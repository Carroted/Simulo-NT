var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/colord/plugins/names.mjs
var require_src = __commonJS((exports, module) => {
  var lineInt = function(l1, l2, precision) {
    precision = precision || 0;
    var i2 = [0, 0];
    var a1, b1, c1, a2, b2, c2, det;
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2 * b1;
    if (!scalar_eq(det, 0, precision)) {
      i2[0] = (b2 * c1 - b1 * c2) / det;
      i2[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i2;
  };
  var lineSegmentsIntersect = function(p1, p2, q1, q2) {
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    var da2 = q2[0] - q1[0];
    var db = q2[1] - q1[1];
    if (da2 * dy - db * dx === 0) {
      return false;
    }
    var s2 = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da2 * dy - db * dx);
    var t2 = (da2 * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da2 * dy);
    return s2 >= 0 && s2 <= 1 && t2 >= 0 && t2 <= 1;
  };
  var triangleArea = function(a2, b2, c2) {
    return (b2[0] - a2[0]) * (c2[1] - a2[1]) - (c2[0] - a2[0]) * (b2[1] - a2[1]);
  };
  var isLeft = function(a2, b2, c2) {
    return triangleArea(a2, b2, c2) > 0;
  };
  var isLeftOn = function(a2, b2, c2) {
    return triangleArea(a2, b2, c2) >= 0;
  };
  var isRight = function(a2, b2, c2) {
    return triangleArea(a2, b2, c2) < 0;
  };
  var isRightOn = function(a2, b2, c2) {
    return triangleArea(a2, b2, c2) <= 0;
  };
  var collinear = function(a2, b2, c2, thresholdAngle) {
    if (!thresholdAngle) {
      return triangleArea(a2, b2, c2) === 0;
    } else {
      var ab4 = tmpPoint1, bc4 = tmpPoint2;
      ab4[0] = b2[0] - a2[0];
      ab4[1] = b2[1] - a2[1];
      bc4[0] = c2[0] - b2[0];
      bc4[1] = c2[1] - b2[1];
      var dot = ab4[0] * bc4[0] + ab4[1] * bc4[1], magA = Math.sqrt(ab4[0] * ab4[0] + ab4[1] * ab4[1]), magB = Math.sqrt(bc4[0] * bc4[0] + bc4[1] * bc4[1]), angle = Math.acos(dot / (magA * magB));
      return angle < thresholdAngle;
    }
  };
  var sqdist = function(a2, b2) {
    var dx = b2[0] - a2[0];
    var dy = b2[1] - a2[1];
    return dx * dx + dy * dy;
  };
  var polygonAt = function(polygon, i2) {
    var s2 = polygon.length;
    return polygon[i2 < 0 ? i2 % s2 + s2 : i2 % s2];
  };
  var polygonClear = function(polygon) {
    polygon.length = 0;
  };
  var polygonAppend = function(polygon, poly, from, to) {
    for (var i2 = from;i2 < to; i2++) {
      polygon.push(poly[i2]);
    }
  };
  var polygonMakeCCW = function(polygon) {
    var br = 0, v3 = polygon;
    for (var i2 = 1;i2 < polygon.length; ++i2) {
      if (v3[i2][1] < v3[br][1] || v3[i2][1] === v3[br][1] && v3[i2][0] > v3[br][0]) {
        br = i2;
      }
    }
    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
      polygonReverse(polygon);
      return true;
    } else {
      return false;
    }
  };
  var polygonReverse = function(polygon) {
    var tmp = [];
    var N2 = polygon.length;
    for (var i2 = 0;i2 !== N2; i2++) {
      tmp.push(polygon.pop());
    }
    for (var i2 = 0;i2 !== N2; i2++) {
      polygon[i2] = tmp[i2];
    }
  };
  var polygonIsReflex = function(polygon, i2) {
    return isRight(polygonAt(polygon, i2 - 1), polygonAt(polygon, i2), polygonAt(polygon, i2 + 1));
  };
  var polygonCanSee = function(polygon, a2, b2) {
    var p2, dist, l1 = tmpLine1, l2 = tmpLine2;
    if (isLeftOn(polygonAt(polygon, a2 + 1), polygonAt(polygon, a2), polygonAt(polygon, b2)) && isRightOn(polygonAt(polygon, a2 - 1), polygonAt(polygon, a2), polygonAt(polygon, b2))) {
      return false;
    }
    dist = sqdist(polygonAt(polygon, a2), polygonAt(polygon, b2));
    for (var i2 = 0;i2 !== polygon.length; ++i2) {
      if ((i2 + 1) % polygon.length === a2 || i2 === a2) {
        continue;
      }
      if (isLeftOn(polygonAt(polygon, a2), polygonAt(polygon, b2), polygonAt(polygon, i2 + 1)) && isRightOn(polygonAt(polygon, a2), polygonAt(polygon, b2), polygonAt(polygon, i2))) {
        l1[0] = polygonAt(polygon, a2);
        l1[1] = polygonAt(polygon, b2);
        l2[0] = polygonAt(polygon, i2);
        l2[1] = polygonAt(polygon, i2 + 1);
        p2 = lineInt(l1, l2);
        if (sqdist(polygonAt(polygon, a2), p2) < dist) {
          return false;
        }
      }
    }
    return true;
  };
  var polygonCanSee2 = function(polygon, a2, b2) {
    for (var i2 = 0;i2 !== polygon.length; ++i2) {
      if (i2 === a2 || i2 === b2 || (i2 + 1) % polygon.length === a2 || (i2 + 1) % polygon.length === b2) {
        continue;
      }
      if (lineSegmentsIntersect(polygonAt(polygon, a2), polygonAt(polygon, b2), polygonAt(polygon, i2), polygonAt(polygon, i2 + 1))) {
        return false;
      }
    }
    return true;
  };
  var polygonCopy = function(polygon, i2, j2, targetPoly) {
    var p2 = targetPoly || [];
    polygonClear(p2);
    if (i2 < j2) {
      for (var k2 = i2;k2 <= j2; k2++) {
        p2.push(polygon[k2]);
      }
    } else {
      for (var k2 = 0;k2 <= j2; k2++) {
        p2.push(polygon[k2]);
      }
      for (var k2 = i2;k2 < polygon.length; k2++) {
        p2.push(polygon[k2]);
      }
    }
    return p2;
  };
  var polygonGetCutEdges = function(polygon) {
    var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];
    var nDiags = Number.MAX_VALUE;
    for (var i2 = 0;i2 < polygon.length; ++i2) {
      if (polygonIsReflex(polygon, i2)) {
        for (var j2 = 0;j2 < polygon.length; ++j2) {
          if (polygonCanSee(polygon, i2, j2)) {
            tmp1 = polygonGetCutEdges(polygonCopy(polygon, i2, j2, tmpPoly));
            tmp2 = polygonGetCutEdges(polygonCopy(polygon, j2, i2, tmpPoly));
            for (var k2 = 0;k2 < tmp2.length; k2++) {
              tmp1.push(tmp2[k2]);
            }
            if (tmp1.length < nDiags) {
              min = tmp1;
              nDiags = tmp1.length;
              min.push([polygonAt(polygon, i2), polygonAt(polygon, j2)]);
            }
          }
        }
      }
    }
    return min;
  };
  var polygonDecomp = function(polygon) {
    var edges = polygonGetCutEdges(polygon);
    if (edges.length > 0) {
      return polygonSlice(polygon, edges);
    } else {
      return [polygon];
    }
  };
  var polygonSlice = function(polygon, cutEdges) {
    if (cutEdges.length === 0) {
      return [polygon];
    }
    if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {
      var polys = [polygon];
      for (var i2 = 0;i2 < cutEdges.length; i2++) {
        var cutEdge = cutEdges[i2];
        for (var j2 = 0;j2 < polys.length; j2++) {
          var poly = polys[j2];
          var result = polygonSlice(poly, cutEdge);
          if (result) {
            polys.splice(j2, 1);
            polys.push(result[0], result[1]);
            break;
          }
        }
      }
      return polys;
    } else {
      var cutEdge = cutEdges;
      var i2 = polygon.indexOf(cutEdge[0]);
      var j2 = polygon.indexOf(cutEdge[1]);
      if (i2 !== -1 && j2 !== -1) {
        return [
          polygonCopy(polygon, i2, j2),
          polygonCopy(polygon, j2, i2)
        ];
      } else {
        return false;
      }
    }
  };
  var polygonIsSimple = function(polygon) {
    var path = polygon, i2;
    for (i2 = 0;i2 < path.length - 1; i2++) {
      for (var j2 = 0;j2 < i2 - 1; j2++) {
        if (lineSegmentsIntersect(path[i2], path[i2 + 1], path[j2], path[j2 + 1])) {
          return false;
        }
      }
    }
    for (i2 = 1;i2 < path.length - 2; i2++) {
      if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i2], path[i2 + 1])) {
        return false;
      }
    }
    return true;
  };
  var getIntersectionPoint = function(p1, p2, q1, q2, delta) {
    delta = delta || 0;
    var a1 = p2[1] - p1[1];
    var b1 = p1[0] - p2[0];
    var c1 = a1 * p1[0] + b1 * p1[1];
    var a2 = q2[1] - q1[1];
    var b2 = q1[0] - q2[0];
    var c2 = a2 * q1[0] + b2 * q1[1];
    var det = a1 * b2 - a2 * b1;
    if (!scalar_eq(det, 0, delta)) {
      return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];
    } else {
      return [0, 0];
    }
  };
  var polygonQuickDecomp = function(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof result !== "undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];
    var upperInt = [0, 0], lowerInt = [0, 0], p2 = [0, 0];
    var upperDist = 0, lowerDist = 0, d2 = 0, closestDist = 0;
    var upperIndex = 0, lowerIndex = 0, closestIndex = 0;
    var lowerPoly = [], upperPoly = [];
    var poly = polygon, v3 = polygon;
    if (v3.length < 3) {
      return result;
    }
    level++;
    if (level > maxlevel) {
      console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
      return result;
    }
    for (var i2 = 0;i2 < polygon.length; ++i2) {
      if (polygonIsReflex(poly, i2)) {
        reflexVertices.push(poly[i2]);
        upperDist = lowerDist = Number.MAX_VALUE;
        for (var j2 = 0;j2 < polygon.length; ++j2) {
          if (isLeft(polygonAt(poly, i2 - 1), polygonAt(poly, i2), polygonAt(poly, j2)) && isRightOn(polygonAt(poly, i2 - 1), polygonAt(poly, i2), polygonAt(poly, j2 - 1))) {
            p2 = getIntersectionPoint(polygonAt(poly, i2 - 1), polygonAt(poly, i2), polygonAt(poly, j2), polygonAt(poly, j2 - 1));
            if (isRight(polygonAt(poly, i2 + 1), polygonAt(poly, i2), p2)) {
              d2 = sqdist(poly[i2], p2);
              if (d2 < lowerDist) {
                lowerDist = d2;
                lowerInt = p2;
                lowerIndex = j2;
              }
            }
          }
          if (isLeft(polygonAt(poly, i2 + 1), polygonAt(poly, i2), polygonAt(poly, j2 + 1)) && isRightOn(polygonAt(poly, i2 + 1), polygonAt(poly, i2), polygonAt(poly, j2))) {
            p2 = getIntersectionPoint(polygonAt(poly, i2 + 1), polygonAt(poly, i2), polygonAt(poly, j2), polygonAt(poly, j2 + 1));
            if (isLeft(polygonAt(poly, i2 - 1), polygonAt(poly, i2), p2)) {
              d2 = sqdist(poly[i2], p2);
              if (d2 < upperDist) {
                upperDist = d2;
                upperInt = p2;
                upperIndex = j2;
              }
            }
          }
        }
        if (lowerIndex === (upperIndex + 1) % polygon.length) {
          p2[0] = (lowerInt[0] + upperInt[0]) / 2;
          p2[1] = (lowerInt[1] + upperInt[1]) / 2;
          steinerPoints.push(p2);
          if (i2 < upperIndex) {
            polygonAppend(lowerPoly, poly, i2, upperIndex + 1);
            lowerPoly.push(p2);
            upperPoly.push(p2);
            if (lowerIndex !== 0) {
              polygonAppend(upperPoly, poly, lowerIndex, poly.length);
            }
            polygonAppend(upperPoly, poly, 0, i2 + 1);
          } else {
            if (i2 !== 0) {
              polygonAppend(lowerPoly, poly, i2, poly.length);
            }
            polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
            lowerPoly.push(p2);
            upperPoly.push(p2);
            polygonAppend(upperPoly, poly, lowerIndex, i2 + 1);
          }
        } else {
          if (lowerIndex > upperIndex) {
            upperIndex += polygon.length;
          }
          closestDist = Number.MAX_VALUE;
          if (upperIndex < lowerIndex) {
            return result;
          }
          for (var j2 = lowerIndex;j2 <= upperIndex; ++j2) {
            if (isLeftOn(polygonAt(poly, i2 - 1), polygonAt(poly, i2), polygonAt(poly, j2)) && isRightOn(polygonAt(poly, i2 + 1), polygonAt(poly, i2), polygonAt(poly, j2))) {
              d2 = sqdist(polygonAt(poly, i2), polygonAt(poly, j2));
              if (d2 < closestDist && polygonCanSee2(poly, i2, j2)) {
                closestDist = d2;
                closestIndex = j2 % polygon.length;
              }
            }
          }
          if (i2 < closestIndex) {
            polygonAppend(lowerPoly, poly, i2, closestIndex + 1);
            if (closestIndex !== 0) {
              polygonAppend(upperPoly, poly, closestIndex, v3.length);
            }
            polygonAppend(upperPoly, poly, 0, i2 + 1);
          } else {
            if (i2 !== 0) {
              polygonAppend(lowerPoly, poly, i2, v3.length);
            }
            polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
            polygonAppend(upperPoly, poly, closestIndex, i2 + 1);
          }
        }
        if (lowerPoly.length < upperPoly.length) {
          polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
          polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
        } else {
          polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
          polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
        }
        return result;
      }
    }
    result.push(polygon);
    return result;
  };
  var polygonRemoveCollinearPoints = function(polygon, precision) {
    var num = 0;
    for (var i2 = polygon.length - 1;polygon.length > 3 && i2 >= 0; --i2) {
      if (collinear(polygonAt(polygon, i2 - 1), polygonAt(polygon, i2), polygonAt(polygon, i2 + 1), precision)) {
        polygon.splice(i2 % polygon.length, 1);
        num++;
      }
    }
    return num;
  };
  var polygonRemoveDuplicatePoints = function(polygon, precision) {
    for (var i2 = polygon.length - 1;i2 >= 1; --i2) {
      var pi = polygon[i2];
      for (var j2 = i2 - 1;j2 >= 0; --j2) {
        if (points_eq(pi, polygon[j2], precision)) {
          polygon.splice(i2, 1);
          continue;
        }
      }
    }
  };
  var scalar_eq = function(a2, b2, precision) {
    precision = precision || 0;
    return Math.abs(a2 - b2) <= precision;
  };
  var points_eq = function(a2, b2, precision) {
    return scalar_eq(a2[0], b2[0], precision) && scalar_eq(a2[1], b2[1], precision);
  };
  module.exports = {
    decomp: polygonDecomp,
    quickDecomp: polygonQuickDecomp,
    isSimple: polygonIsSimple,
    removeCollinearPoints: polygonRemoveCollinearPoints,
    removeDuplicatePoints: polygonRemoveDuplicatePoints,
    makeCCW: polygonMakeCCW
  };
  var tmpPoint1 = [];
  var tmpPoint2 = [];
  var tmpLine1 = [];
  var tmpLine2 = [];
});

// node_modules/colord/plugins/names.m
var require_eventemitter3 = __commonJS((exports, module) => {
  var Events = function() {
  };
  var EE = function(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  };
  var addListener = function(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  };
  var clearEvent = function(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  };
  var EventEmitter2 = function() {
    this._events = new Events;
    this._eventsCount = 0;
  };
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i2 = 0, l3 = handlers.length, ee = new Array(l3);i2 < l3; i2++) {
      ee[i2] = handlers[i2].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i2;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len - 1);i2 < len; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length2 = listeners.length, j2;
      for (i2 = 0;i2 < length2; i2++) {
        if (listeners[i2].once)
          this.removeListener(event, listeners[i2].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i2].fn.call(listeners[i2].context);
            break;
          case 2:
            listeners[i2].fn.call(listeners[i2].context, a1);
            break;
          case 3:
            listeners[i2].fn.call(listeners[i2].context, a1, a2);
            break;
          case 4:
            listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len - 1);j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners[i2].fn.apply(listeners[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events = [], length2 = listeners.length;i2 < length2; i2++) {
        if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
          events.push(listeners[i2]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter2;
  }
});

// node_modules/colord/plugins/names
var require_earcut = __commonJS((exports, module) => {
  var earcut = function(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    var minX, minY, maxX, maxY, x2, y2, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (var i2 = dim;i2 < outerLen; i2 += dim) {
        x2 = data[i2];
        y2 = data[i2 + 1];
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  };
  var linkedList = function(data, start, end, dim, clockwise) {
    var i2, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i2 = start;i2 < end; i2 += dim)
        last = insertNode(i2, data[i2], data[i2 + 1], last);
    } else {
      for (i2 = end - dim;i2 >= start; i2 -= dim)
        last = insertNode(i2, data[i2], data[i2 + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  };
  var filterPoints = function(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    var p2 = start, again;
    do {
      again = false;
      if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
        removeNode(p2);
        p2 = end = p2.prev;
        if (p2 === p2.next)
          break;
        again = true;
      } else {
        p2 = p2.next;
      }
    } while (again || p2 !== end);
    return end;
  };
  var earcutLinked = function(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    var stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  };
  var isEar = function(ear) {
    var a2 = ear.prev, b2 = ear, c2 = ear.next;
    if (area(a2, b2, c2) >= 0)
      return false;
    var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var p2 = c2.next;
    while (p2 !== a2) {
      if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle2(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.next;
    }
    return true;
  };
  var isEarHashed = function(ear, minX, minY, invSize) {
    var a2 = ear.prev, b2 = ear, c2 = ear.next;
    if (area(a2, b2, c2) >= 0)
      return false;
    var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
    var { prevZ: p2, nextZ: n3 } = ear;
    while (p2 && p2.z >= minZ && n3 && n3.z <= maxZ) {
      if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
      if (n3.x >= x0 && n3.x <= x1 && n3.y >= y0 && n3.y <= y1 && n3 !== a2 && n3 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n3.x, n3.y) && area(n3.prev, n3, n3.next) >= 0)
        return false;
      n3 = n3.nextZ;
    }
    while (p2 && p2.z >= minZ) {
      if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
    }
    while (n3 && n3.z <= maxZ) {
      if (n3.x >= x0 && n3.x <= x1 && n3.y >= y0 && n3.y <= y1 && n3 !== a2 && n3 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n3.x, n3.y) && area(n3.prev, n3, n3.next) >= 0)
        return false;
      n3 = n3.nextZ;
    }
    return true;
  };
  var cureLocalIntersections = function(start, triangles, dim) {
    var p2 = start;
    do {
      var a2 = p2.prev, b2 = p2.next.next;
      if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
        triangles.push(a2.i / dim | 0);
        triangles.push(p2.i / dim | 0);
        triangles.push(b2.i / dim | 0);
        removeNode(p2);
        removeNode(p2.next);
        p2 = start = b2;
      }
      p2 = p2.next;
    } while (p2 !== start);
    return filterPoints(p2);
  };
  var splitEarcut = function(start, triangles, dim, minX, minY, invSize) {
    var a2 = start;
    do {
      var b2 = a2.next.next;
      while (b2 !== a2.prev) {
        if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
          var c2 = splitPolygon(a2, b2);
          a2 = filterPoints(a2, a2.next);
          c2 = filterPoints(c2, c2.next);
          earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b2 = b2.next;
      }
      a2 = a2.next;
    } while (a2 !== start);
  };
  var eliminateHoles = function(data, holeIndices, outerNode, dim) {
    var queue = [], i2, len, start, end, list;
    for (i2 = 0, len = holeIndices.length;i2 < len; i2++) {
      start = holeIndices[i2] * dim;
      end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i2 = 0;i2 < queue.length; i2++) {
      outerNode = eliminateHole(queue[i2], outerNode);
    }
    return outerNode;
  };
  var compareX = function(a2, b2) {
    return a2.x - b2.x;
  };
  var eliminateHole = function(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    var bridgeReverse = splitPolygon(bridge, hole);
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  };
  var findHoleBridge = function(hole, outerNode) {
    var p2 = outerNode, hx = hole.x, hy = hole.y, qx = (-Infinity), m2;
    do {
      if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
        var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
        if (x2 <= hx && x2 > qx) {
          qx = x2;
          m2 = p2.x < p2.next.x ? p2 : p2.next;
          if (x2 === hx)
            return m2;
        }
      }
      p2 = p2.next;
    } while (p2 !== outerNode);
    if (!m2)
      return null;
    var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
    p2 = m2;
    do {
      if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle2(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
        tan = Math.abs(hy - p2.y) / (hx - p2.x);
        if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
          m2 = p2;
          tanMin = tan;
        }
      }
      p2 = p2.next;
    } while (p2 !== stop);
    return m2;
  };
  var sectorContainsSector = function(m2, p2) {
    return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
  };
  var indexCurve = function(start, minX, minY, invSize) {
    var p2 = start;
    do {
      if (p2.z === 0)
        p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
      p2.prevZ = p2.prev;
      p2.nextZ = p2.next;
      p2 = p2.next;
    } while (p2 !== start);
    p2.prevZ.nextZ = null;
    p2.prevZ = null;
    sortLinked(p2);
  };
  var sortLinked = function(list) {
    var i2, p2, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
    do {
      p2 = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p2) {
        numMerges++;
        q2 = p2;
        pSize = 0;
        for (i2 = 0;i2 < inSize; i2++) {
          pSize++;
          q2 = q2.nextZ;
          if (!q2)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q2) {
          if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
            e2 = p2;
            p2 = p2.nextZ;
            pSize--;
          } else {
            e2 = q2;
            q2 = q2.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e2;
          else
            list = e2;
          e2.prevZ = tail;
          tail = e2;
        }
        p2 = q2;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  };
  var zOrder = function(x2, y2, minX, minY, invSize) {
    x2 = (x2 - minX) * invSize | 0;
    y2 = (y2 - minY) * invSize | 0;
    x2 = (x2 | x2 << 8) & 16711935;
    x2 = (x2 | x2 << 4) & 252645135;
    x2 = (x2 | x2 << 2) & 858993459;
    x2 = (x2 | x2 << 1) & 1431655765;
    y2 = (y2 | y2 << 8) & 16711935;
    y2 = (y2 | y2 << 4) & 252645135;
    y2 = (y2 | y2 << 2) & 858993459;
    y2 = (y2 | y2 << 1) & 1431655765;
    return x2 | y2 << 1;
  };
  var getLeftmost = function(start) {
    var p2 = start, leftmost = start;
    do {
      if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
        leftmost = p2;
      p2 = p2.next;
    } while (p2 !== start);
    return leftmost;
  };
  var pointInTriangle2 = function(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  };
  var isValidDiagonal = function(a2, b2) {
    return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
  };
  var area = function(p2, q2, r3) {
    return (q2.y - p2.y) * (r3.x - q2.x) - (q2.x - p2.x) * (r3.y - q2.y);
  };
  var equals = function(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  };
  var intersects = function(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  };
  var onSegment = function(p2, q2, r3) {
    return q2.x <= Math.max(p2.x, r3.x) && q2.x >= Math.min(p2.x, r3.x) && q2.y <= Math.max(p2.y, r3.y) && q2.y >= Math.min(p2.y, r3.y);
  };
  var sign = function(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  };
  var intersectsPolygon = function(a2, b2) {
    var p2 = a2;
    do {
      if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
        return true;
      p2 = p2.next;
    } while (p2 !== a2);
    return false;
  };
  var locallyInside = function(a2, b2) {
    return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
  };
  var middleInside = function(a2, b2) {
    var p2 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
    do {
      if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
        inside = !inside;
      p2 = p2.next;
    } while (p2 !== a2);
    return inside;
  };
  var splitPolygon = function(a2, b2) {
    var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
    a2.next = b2;
    b2.prev = a2;
    a22.next = an;
    an.prev = a22;
    b22.next = a22;
    a22.prev = b22;
    bp.next = b22;
    b22.prev = bp;
    return b22;
  };
  var insertNode = function(i2, x2, y2, last) {
    var p2 = new Node(i2, x2, y2);
    if (!last) {
      p2.prev = p2;
      p2.next = p2;
    } else {
      p2.next = last.next;
      p2.prev = last;
      last.next.prev = p2;
      last.next = p2;
    }
    return p2;
  };
  var removeNode = function(p2) {
    p2.next.prev = p2.prev;
    p2.prev.next = p2.next;
    if (p2.prevZ)
      p2.prevZ.nextZ = p2.nextZ;
    if (p2.nextZ)
      p2.nextZ.prevZ = p2.prevZ;
  };
  var Node = function(i2, x2, y2) {
    this.i = i2;
    this.x = x2;
    this.y = y2;
    this.prev = null;
    this.next = null;
    this.z = 0;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  };
  var signedArea = function(data, start, end, dim) {
    var sum2 = 0;
    for (var i2 = start, j2 = end - dim;i2 < end; i2 += dim) {
      sum2 += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
      j2 = i2;
    }
    return sum2;
  };
  module.exports = earcut;
  module.exports.default = earcut;
  earcut.deviation = function(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
      for (var i2 = 0, len = holeIndices.length;i2 < len; i2++) {
        var start = holeIndices[i2] * dim;
        var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
      }
    }
    var trianglesArea = 0;
    for (i2 = 0;i2 < triangles.length; i2 += 3) {
      var a2 = triangles[i2] * dim;
      var b2 = triangles[i2 + 1] * dim;
      var c2 = triangles[i2 + 2] * dim;
      trianglesArea += Math.abs((data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1]));
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
  };
  earcut.flatten = function(data) {
    var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
    for (var i2 = 0;i2 < data.length; i2++) {
      for (var j2 = 0;j2 < data[i2].length; j2++) {
        for (var d2 = 0;d2 < dim; d2++)
          result.vertices.push(data[i2][j2][d2]);
      }
      if (i2 > 0) {
        holeIndex += data[i2 - 1].length;
        result.holes.push(holeIndex);
      }
    }
    return result;
  };
});

// node_modules/colord/plugins/names.mjsistener.mjsgle
var g = function(A) {
  return I[A];
};
var B = function(A) {
  const B2 = g(A);
  return function(A2) {
    A2 < 36 || (I[A2] = C, C = A2);
  }(A), B2;
};
var Q = function(A) {
  C === I.length && I.push(I.length + 1);
  const g2 = C;
  return C = I[g2], I[g2] = A, g2;
};
var E = function(A) {
  return A == null;
};
var o = function() {
  return i.byteLength === 0 && (i = new Float64Array(A.memory.buffer)), i;
};
var G = function() {
  return D.byteLength === 0 && (D = new Int32Array(A.memory.buffer)), D;
};
var h = function(I, g2) {
  return w.decode((a.byteLength === 0 && (a = new Uint8Array(A.memory.buffer)), a).subarray(I, I + g2));
};
var k = function(A, I) {
  if (!(A instanceof I))
    throw new Error(`expected instance of ${I.name}`);
  return A.ptr;
};
var S = function() {
  return K.byteLength === 0 && (K = new Float32Array(A.memory.buffer)), K;
};
var F = function(A) {
  if (N == 1)
    throw new Error("out of js stack");
  return I[--N] = A, N;
};
var y = function(A, I) {
  return S().subarray(A / 4, A / 4 + I);
};
var J = function() {
  return R.byteLength === 0 && (R = new Uint32Array(A.memory.buffer)), R;
};
var s = function(A, I) {
  const g2 = I(4 * A.length);
  return S().set(A, g2 / 4), M = A.length, g2;
};
var U = function(A, I) {
  const g2 = I(4 * A.length);
  return J().set(A, g2 / 4), M = A.length, g2;
};
var q = function(I, g2) {
  try {
    return I.apply(this, g2);
  } catch (I2) {
    A.__wbindgen_exn_store(Q(I2));
  }
};
async function QA(I) {
  I === undefined && (I = new URL("rapier_wasm2d_bg.wasm", "<deleted>"));
  const C = function() {
    const I2 = { wbg: {} };
    return I2.wbg.__wbindgen_object_drop_ref = function(A) {
      B(A);
    }, I2.wbg.__wbindgen_number_new = function(A) {
      return Q(A);
    }, I2.wbg.__wbindgen_number_get = function(A, I3) {
      const C2 = g(I3), B2 = typeof C2 == "number" ? C2 : undefined;
      o()[A / 8 + 1] = E(B2) ? 0 : B2, G()[A / 4 + 0] = !E(B2);
    }, I2.wbg.__wbindgen_boolean_get = function(A) {
      const I3 = g(A);
      return typeof I3 == "boolean" ? I3 ? 1 : 0 : 2;
    }, I2.wbg.__wbindgen_is_function = function(A) {
      return typeof g(A) == "function";
    }, I2.wbg.__wbg_rawraycolliderintersection_new = function(A) {
      return Q(v.__wrap(A));
    }, I2.wbg.__wbg_rawcontactforceevent_new = function(A) {
      return Q(r.__wrap(A));
    }, I2.wbg.__wbg_call_168da88779e35f61 = function() {
      return q(function(A, I3, C2) {
        return Q(g(A).call(g(I3), g(C2)));
      }, arguments);
    }, I2.wbg.__wbg_call_3999bee59e9f7719 = function() {
      return q(function(A, I3, C2, B2) {
        return Q(g(A).call(g(I3), g(C2), g(B2)));
      }, arguments);
    }, I2.wbg.__wbg_call_e1f72c051cdab859 = function() {
      return q(function(A, I3, C2, B2, E2) {
        return Q(g(A).call(g(I3), g(C2), g(B2), g(E2)));
      }, arguments);
    }, I2.wbg.__wbg_bind_10dfe70e95d2a480 = function(A, I3, C2, B2) {
      return Q(g(A).bind(g(I3), g(C2), g(B2)));
    }, I2.wbg.__wbg_buffer_3f3d764d4747d564 = function(A) {
      return Q(g(A).buffer);
    }, I2.wbg.__wbg_newwithbyteoffsetandlength_d9aa266703cb98be = function(A, I3, C2) {
      return Q(new Uint8Array(g(A), I3 >>> 0, C2 >>> 0));
    }, I2.wbg.__wbg_new_8c3f0052272a457a = function(A) {
      return Q(new Uint8Array(g(A)));
    }, I2.wbg.__wbg_set_83db9690f9353e79 = function(A, I3, C2) {
      g(A).set(g(I3), C2 >>> 0);
    }, I2.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(A) {
      return g(A).length;
    }, I2.wbg.__wbg_newwithbyteoffsetandlength_be22e5fcf4f69ab4 = function(A, I3, C2) {
      return Q(new Float32Array(g(A), I3 >>> 0, C2 >>> 0));
    }, I2.wbg.__wbg_set_0e0314cf6675c1b9 = function(A, I3, C2) {
      g(A).set(g(I3), C2 >>> 0);
    }, I2.wbg.__wbg_length_9a2deed95d22668d = function(A) {
      return g(A).length;
    }, I2.wbg.__wbg_newwithlength_a7168e4a1e8f5e12 = function(A) {
      return Q(new Float32Array(A >>> 0));
    }, I2.wbg.__wbindgen_throw = function(A, I3) {
      throw new Error(h(A, I3));
    }, I2.wbg.__wbindgen_memory = function() {
      return Q(A.memory);
    }, I2;
  }();
  (typeof I == "string" || typeof Request == "function" && I instanceof Request || typeof URL == "function" && I instanceof URL) && (I = fetch(I));
  const { instance: w, module: k2 } = await async function(A, I2) {
    if (typeof Response == "function" && A instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming == "function")
        try {
          return await WebAssembly.instantiateStreaming(A, I2);
        } catch (I3) {
          if (A.headers.get("Content-Type") == "application/wasm")
            throw I3;
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", I3);
        }
      const g2 = await A.arrayBuffer();
      return await WebAssembly.instantiate(g2, I2);
    }
    {
      const g2 = await WebAssembly.instantiate(A, I2);
      return g2 instanceof WebAssembly.Instance ? { instance: g2, module: A } : g2;
    }
  }(await I, C);
  return function(I2, g2) {
    return A = I2.exports, QA.__wbindgen_wasm_module = g2, K = new Float32Array, i = new Float64Array, D = new Int32Array, R = new Uint32Array, a = new Uint8Array, A;
  }(w, k2);
}
var cI = function(A, I, g2, C) {
  return new (g2 || (g2 = Promise))(function(B2, Q2) {
    function E2(A2) {
      try {
        o2(C.next(A2));
      } catch (A3) {
        Q2(A3);
      }
    }
    function i(A2) {
      try {
        o2(C.throw(A2));
      } catch (A3) {
        Q2(A3);
      }
    }
    function o2(A2) {
      var I2;
      A2.done ? B2(A2.value) : (I2 = A2.value, I2 instanceof g2 ? I2 : new g2(function(A3) {
        A3(I2);
      })).then(E2, i);
    }
    o2((C = C.apply(A, I || [])).next());
  });
};
var eI = function(A) {
  var I = A.length;
  if (I % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var g2 = A.indexOf("=");
  return g2 === -1 && (g2 = I), [g2, g2 === I ? 0 : 4 - g2 % 4];
};
var nI = function(A, I, g2) {
  for (var C, B2, Q2 = [], E2 = I;E2 < g2; E2 += 3)
    C = (A[E2] << 16 & 16711680) + (A[E2 + 1] << 8 & 65280) + (255 & A[E2 + 2]), Q2.push(LI[(B2 = C) >> 18 & 63] + LI[B2 >> 12 & 63] + LI[B2 >> 6 & 63] + LI[63 & B2]);
  return Q2.join("");
};
var dI = function() {
  return cI(this, undefined, undefined, function* () {
    yield QA(YI.toByteArray("AGFzbQEAAAABuAuUAWACf38AYAR/f39/AGADf39/AGACf38Bf2ABfwF/YAN/f38Bf2ABfwF+YAF/AGAFf39/f38AYAZ/f39/fX8AYAJ/fAF/YAF/AX1gBX9/f31/AGADf3x/AGAFf39/f30AYAABf2AEf39/fQF/YAZ/f39/f30AYAN/f30Bf2AEf39/fwF9YAN/f38BfWADf399AGACf3wBfWADf39/AX5gBH9/f38Bf2ADf3x9AGAGf39/f39/AX9gAn99AGABfQF9YAR/fH9/AGAIf39/f39/fX8Bf2AIf39/f39/f38AYAZ/f39/f38AYAJ/fwF9YAN/f3wAYAV/f39/fwF/YAR/fH1/AGAAAGAIf39/f39/f30AYAF/AXxgB39/f39/f38AYAN+fn8BfmAFf3x/f38AYAN/fH8BfWAGf31/f399AGAFf39/fn8AYAp/f39/f39/f31/AGALf39/f39/f399fX8AYAN/fH8Bf2ABfQF/YAJ9fQF/YAR/fH19AGAPf39/f39/f39/f39/f39/AGAGf39/f35/AGAJf39/f39/f39/AGAJf39/f39/fX9/AX9gCn9/f39/f31/f38AYAN+f38Bf2AEf31/fwF/YAt/f39/f39/f39/fwBgA39+fwF/YAR/fn5/AGAPf39/f399f39/f398f3x/AX9gD39/f39/f39/f39/fH98fwBgA398fAF/YAV/fH99fQBgAn98AXxgAn98AGAFf398fH8BfGABfAF/YAd/f39/f399AGALf39/f39/f399f38AYAx/fX9/f39/f39/f38Bf2AGf39/f39/AX1gCX9/f39/fX9/fwBgCH9/f399f39/AGAPf39/f39/f39/f39/fX1/AGALf39/fX9/fX99fX8AYAd/f39/fX9/AGAJf39/f39/f399AGAEf35/fwF/YBJ/f39/f39/f39/f399f319fX0AYAl/f39/f39/fX8AYAl/f39/f399f38AYAh/f39/fX1/fwBgCX9/f319f39/fwBgC39/f399f39/f39/AGAKf39/f39/f399fwF/YAR/f399AGAKf39/f31/f39/fwBgAn9+AX9gC399f39/f39/fX1/AGAIf39/fn9/f38AYAl/fX9+f359fX8AYAl/fX99f319fX8AYAd/f39/f399AX9gBH9/fn8AYBF/f39/f39/fX9/f39/fH98fwF/YAx/f39/f39/f3x/fH8Bf2APf39/f39/f39/f39/fn9/AGAJf3x/f39/f31/AX9gB39/f319f38AYAZ/f39/fX0AYA1/f39/f39/f398f3x/AGAIf39/f39/fX8AYAp/f39/f39/f39/AX9gB398f3x/fX8Bf2AIf399fX5/f38AYAd/f39/f31/AX9gBn98f39/fQF/YAl/f39/f39+fn4AYA1/f39/f39/f398f3x/AX9gB39/f39/f38Bf2AHf39/f399fwF9YBl/f39/f39/fX99fX19f39/f39/f399f3x/AGAGf39/f399AX9gEH9/f39/fX9/f39/f3x/fH8AYAJ9fQF9YAZ/f39/fX0Bf2AVf39/f319f39/fX1/f399fX9/f39/AXxgBn98f39/fwBgBH98fH0Bf2AEf3x/fwF/YAZ/fH9/fX8Bf2AOf31/f398f39/fX9/f38AYAV/f39/fwF9YAt/f39/f39/f399fwBgEn99f39/f39/f39/f39/f39/fwBgBn98fX99fwBgBX98fX99AGACf34AYAV/fH9/fwF/YAN9fX8Bf2AGf3x/f31/AX1gBX98f399AX9gBn98f319fQBgB398f319fX0AYAR/fX1/AGADfX19AX9gBn9/fX19fQBgA398fwF8YAV/fH19fwBgBH9/fX0AYAV/f3x/fwBgBX9/fX9/AGAEf31/fwBgBX9/fn9/AGAEf35/fwAChQYWA3diZxpfX3diaW5kZ2VuX29iamVjdF9kcm9wX3JlZgAHA3diZxVfX3diaW5kZ2VuX251bWJlcl9uZXcARQN3YmcVX193YmluZGdlbl9udW1iZXJfZ2V0AAADd2JnFl9fd2JpbmRnZW5fYm9vbGVhbl9nZXQABAN3YmcWX193YmluZGdlbl9pc19mdW5jdGlvbgAEA3diZyRfX3diZ19yYXdyYXljb2xsaWRlcmludGVyc2VjdGlvbl9uZXcABAN3YmceX193YmdfcmF3Y29udGFjdGZvcmNlZXZlbnRfbmV3AAQDd2JnG19fd2JnX2NhbGxfMTY4ZGE4ODc3OWUzNWY2MQAFA3diZxtfX3diZ19jYWxsXzM5OTliZWU1OWU5Zjc3MTkAGAN3YmcbX193YmdfY2FsbF9lMWY3MmMwNTFj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AhUDAwMAAwgAAAADAwcAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAwMAAwEBAQEAAQEBAQgDAwICAgMCAAUDAwQDAwMDAwAlJQMDCwUFBQUDAwAIAgsLHAYGBgYGBAMGBgYGBgYGBgYGBgYGBgYDBQsEBAQEBAQEBAsLBAQLBAQLBAQGBgcACCwEBwFwAcsGywYFAwEAEQYJAX8BQYCAwAALB4ZyoAMGbWVtb3J5AgAHdmVyc2lvbgCtCSpfX3diZ19yYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX2ZyZWUA2ggjcmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9uZXcAhwYicmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl91cADSCCVyYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX3NldFVwAJsGJnJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfb2Zmc2V0APcJKXJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfc2V0T2Zmc2V0AK4JLHJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfc2xpZGVFbmFibGVkAPgJL3Jhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfc2V0U2xpZGVFbmFibGVkAMIJMXJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfYXV0b3N0ZXBNYXhIZWlnaHQAlgkwcmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9hdXRvc3RlcE1pbldpZHRoAJcJPXJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfYXV0b3N0ZXBJbmNsdWRlc0R5bmFtaWNCb2RpZXMA2wgvcmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9hdXRvc3RlcEVuYWJsZWQA6QkucmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9lbmFibGVBdXRvc3RlcACNCC9yYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX2Rpc2FibGVBdXRvc3RlcADZCTJyYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX21pblNsb3BlU2xpZGVBbmdsZQD5CTVyYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX3NldE1pblNsb3BlU2xpZGVBbmdsZQDaCTRyYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX3NuYXBUb0dyb3VuZERpc3RhbmNlAJgJMnJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfZW5hYmxlU25hcFRvR3JvdW5kAK8JM3Jhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfZGlzYWJsZVNuYXBUb0dyb3VuZADbCTNyYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX3NuYXBUb0dyb3VuZEVuYWJsZWQA6gk3cmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9jb21wdXRlQ29sbGlkZXJNb3ZlbWVudADaAzByYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX2NvbXB1dGVkTW92ZW1lbnQAuwgwcmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9jb21wdXRlZEdyb3VuZGVkAPoJNXJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfbnVtQ29tcHV0ZWRDb2xsaXNpb25zAPsJMXJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfY29tcHV0ZWRDb2xsaXNpb24A3QYgX193YmdfcmF3Y2hhcmFjdGVyY29sbGlzaW9uX2ZyZWUAjgoZcmF3Y2hhcmFjdGVyY29sbGlzaW9uX25ldwCIBhxyYXdjaGFyYWN0ZXJjb2xsaXNpb25faGFuZGxlAMYHKHJhd2NoYXJhY3RlcmNvbGxpc2lvbl90cmFuc2xhdGlvbkFwcGxpZWQAvAgqcmF3Y2hhcmFjdGVyY29sbGlzaW9uX3RyYW5zbGF0aW9uUmVtYWluaW5nAL0IGXJhd2NoYXJhY3RlcmNvbGxpc2lvbl90b2kA/AkjcmF3Y2hhcmFjdGVyY29sbGlzaW9uX3dvcmxkV2l0bmVzczEAvggjcmF3Y2hhcmFjdGVyY29sbGlzaW9uX3dvcmxkV2l0bmVzczIA2AUicmF3Y2hhcmFjdGVyY29sbGlzaW9uX3dvcmxkTm9ybWFsMQC/CCJyYXdjaGFyYWN0ZXJjb2xsaXNpb25fd29ybGROb3JtYWwyAKQGF19fd2JnX3Jhd2NjZHNvbHZlcl9mcmVlAOoHEHJhd2NjZHNvbHZlcl9uZXcAwAgccmF3aW1wdWxzZWpvaW50c2V0X2pvaW50VHlwZQCeBSNyYXdpbXB1bHNlam9pbnRzZXRfam9pbnRCb2R5SGFuZGxlMQD9BSNyYXdpbXB1bHNlam9pbnRzZXRfam9pbnRCb2R5SGFuZGxlMgD+BR9yYXdpbXB1bHNlam9pbnRzZXRfam9pbnRGcmFtZVgxAJIFH3Jhd2ltcHVsc2Vqb2ludHNldF9qb2ludEZyYW1lWDIAhAUfcmF3aW1wdWxzZWpvaW50c2V0X2pvaW50QW5jaG9yMQDBBR9yYXdpbXB1bHNlam9pbnRzZXRfam9pbnRBbmNob3IyAMIFInJhd2ltcHVsc2Vqb2ludHNldF9qb2ludFNldEFuY2hvcjEA0gUicmF3aW1wdWxzZWpvaW50c2V0X2pvaW50U2V0QW5jaG9yMgDTBSdyYXdpbXB1bHNlam9pbnRzZXRfam9pbnRDb250YWN0c0VuYWJsZWQApQYqcmF3aW1wdWxzZWpvaW50c2V0X2pvaW50U2V0Q29udGFjdHNFbmFibGVkAPsGJXJhd2ltcHVsc2Vqb2ludHNldF9qb2ludExpbWl0c0VuYWJsZWQAtgUhcmF3aW1wdWxzZWpvaW50c2V0X2pvaW50TGltaXRzTWluANkFIXJhd2ltcHVsc2Vqb2ludHNldF9qb2ludExpbWl0c01heADaBSFyYXdpbXB1bHNlam9pbnRzZXRfam9pbnRTZXRMaW1pdHMA9wUrcmF3aW1wdWxzZWpvaW50c2V0X2pvaW50Q29uZmlndXJlTW90b3JNb2RlbAC9BS5yYXdpbXB1bHNlam9pbnRzZXRfam9pbnRDb25maWd1cmVNb3RvclZlbG9jaXR5AIkGLnJhd2ltcHVsc2Vqb2ludHNldF9qb2ludENvbmZpZ3VyZU1vdG9yUG9zaXRpb24AigYmcmF3aW1wdWxzZWpvaW50c2V0X2pvaW50Q29uZmlndXJlTW90b3IAiwYdX193YmdfcmF3aW1wdWxzZWpvaW50c2V0X2ZyZWUA6wcWcmF3aW1wdWxzZWpvaW50c2V0X25ldwDiCB5yYXdpbXB1bHNlam9pbnRzZXRfY3JlYXRlSm9pbnQAvgcZcmF3aW1wdWxzZWpvaW50c2V0X3JlbW92ZQDDBxZyYXdpbXB1bHNlam9pbnRzZXRfbGVuAOMIG3Jhd2ltcHVsc2Vqb2ludHNldF9jb250YWlucwCMByVyYXdpbXB1bHNlam9pbnRzZXRfZm9yRWFjaEpvaW50SGFuZGxlAP0HMnJhd2ltcHVsc2Vqb2ludHNldF9mb3JFYWNoSm9pbnRBdHRhY2hlZFRvUmlnaWRCb2R5APkHI19fd2JnX3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc19mcmVlAI4KHHJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19uZXcA1AUbcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX2R0AJcKHHJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19lcnAA/QkrcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX2FsbG93ZWRMaW5lYXJFcnJvcgD+CS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbWF4VmVsb2NpdHlJdGVyYXRpb25zAP8JNnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19tYXhWZWxvY2l0eUZyaWN0aW9uSXRlcmF0aW9ucwCACjNyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbWF4U3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMAgQomcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX21pbklzbGFuZFNpemUAggoncmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX21heENjZFN1YnN0ZXBzAIMKH3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfZHQA8gkgcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9lcnAA3AkvcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9hbGxvd2VkTGluZWFyRXJyb3IA3QkvcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9wcmVkaWN0aW9uRGlzdGFuY2UA3gkycmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9tYXhWZWxvY2l0eUl0ZXJhdGlvbnMA3wk6cmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9tYXhWZWxvY2l0eUZyaWN0aW9uSXRlcmF0aW9ucwDgCTdyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X21heFN0YWJpbGl6YXRpb25JdGVyYXRpb25zAOEJKnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfbWluSXNsYW5kU2l6ZQDiCStyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X21heENjZFN1YnN0ZXBzAOMJG19fd2JnX3Jhd2lzbGFuZG1hbmFnZXJfZnJlZQDvBBRyYXdpc2xhbmRtYW5hZ2VyX25ldwDVBS1yYXdpc2xhbmRtYW5hZ2VyX2ZvckVhY2hBY3RpdmVSaWdpZEJvZHlIYW5kbGUA/gcaX193YmdfcmF3Z2VuZXJpY2pvaW50X2ZyZWUAjgoZcmF3Z2VuZXJpY2pvaW50X3ByaXNtYXRpYwCSAxVyYXdnZW5lcmljam9pbnRfZml4ZWQAhQMYcmF3Z2VuZXJpY2pvaW50X3Jldm9sdXRlAI4DHnJhd211bHRpYm9keWpvaW50c2V0X2pvaW50VHlwZQDKCCFyYXdtdWx0aWJvZHlqb2ludHNldF9qb2ludEZyYW1lWDEAgAQhcmF3bXVsdGlib2R5am9pbnRzZXRfam9pbnRGcmFtZVgyAPYDIXJhd211bHRpYm9keWpvaW50c2V0X2pvaW50QW5jaG9yMQCgBCFyYXdtdWx0aWJvZHlqb2ludHNldF9qb2ludEFuY2hvcjIAoQQpcmF3bXVsdGlib2R5am9pbnRzZXRfam9pbnRDb250YWN0c0VuYWJsZWQAgQUscmF3bXVsdGlib2R5am9pbnRzZXRfam9pbnRTZXRDb250YWN0c0VuYWJsZWQAtwUncmF3bXVsdGlib2R5am9pbnRzZXRfam9pbnRMaW1pdHNFbmFibGVkAI4II3Jhd211bHRpYm9keWpvaW50c2V0X2pvaW50TGltaXRzTWluAKkEI3Jhd211bHRpYm9keWpvaW50c2V0X2pvaW50TGltaXRzTWF4AKoEH19fd2JnX3Jhd211bHRpYm9keWpvaW50c2V0X2ZyZWUA7AcYcmF3bXVsdGlib2R5am9pbnRzZXRfbmV3AOQIIHJhd211bHRpYm9keWpvaW50c2V0X2NyZWF0ZUpvaW50AL8HG3Jhd211bHRpYm9keWpvaW50c2V0X3JlbW92ZQDHBx1yYXdtdWx0aWJvZHlqb2ludHNldF9jb250YWlucwD0BidyYXdtdWx0aWJvZHlqb2ludHNldF9mb3JFYWNoSm9pbnRIYW5kbGUA/wc0cmF3bXVsdGlib2R5am9pbnRzZXRfZm9yRWFjaEpvaW50QXR0YWNoZWRUb1JpZ2lkQm9keQD6Bx1yYXdyaWdpZGJvZHlzZXRfcmJUcmFuc2xhdGlvbgDDBRpyYXdyaWdpZGJvZHlzZXRfcmJSb3RhdGlvbgCTBRdyYXdyaWdpZGJvZHlzZXRfcmJTbGVlcACeBxxyYXdyaWdpZGJvZHlzZXRfcmJJc1NsZWVwaW5nALwGGnJhd3JpZ2lkYm9keXNldF9yYklzTW92aW5nAL0GIXJhd3JpZ2lkYm9keXNldF9yYk5leHRUcmFuc2xhdGlvbgDIBR5yYXdyaWdpZGJvZHlzZXRfcmJOZXh0Um90YXRpb24AlAUgcmF3cmlnaWRib2R5c2V0X3JiU2V0VHJhbnNsYXRpb24AjQkdcmF3cmlnaWRib2R5c2V0X3JiU2V0Um90YXRpb24AmQkbcmF3cmlnaWRib2R5c2V0X3JiU2V0TGludmVsAMkFG3Jhd3JpZ2lkYm9keXNldF9yYlNldEFuZ3ZlbAD1Bi1yYXdyaWdpZGJvZHlzZXRfcmJTZXROZXh0S2luZW1hdGljVHJhbnNsYXRpb24A3gYqcmF3cmlnaWRib2R5c2V0X3JiU2V0TmV4dEtpbmVtYXRpY1JvdGF0aW9uAN8GNnJhd3JpZ2lkYm9keXNldF9yYlJlY29tcHV0ZU1hc3NQcm9wZXJ0aWVzRnJvbUNvbGxpZGVycwDkBSNyYXdyaWdpZGJvZHlzZXRfcmJTZXRBZGRpdGlvbmFsTWFzcwC1Bi1yYXdyaWdpZGJvZHlzZXRfcmJTZXRBZGRpdGlvbmFsTWFzc1Byb3BlcnRpZXMApQQYcmF3cmlnaWRib2R5c2V0X3JiTGludmVsAMoFGHJhd3JpZ2lkYm9keXNldF9yYkFuZ3ZlbAC+BiJyYXdyaWdpZGJvZHlzZXRfcmJMb2NrVHJhbnNsYXRpb25zAIIJKHJhd3JpZ2lkYm9keXNldF9yYlNldEVuYWJsZWRUcmFuc2xhdGlvbnMA3AgfcmF3cmlnaWRib2R5c2V0X3JiTG9ja1JvdGF0aW9ucwCDCSByYXdyaWdpZGJvZHlzZXRfcmJEb21pbmFuY2VHcm91cACcBiNyYXdyaWdpZGJvZHlzZXRfcmJTZXREb21pbmFuY2VHcm91cACNBxtyYXdyaWdpZGJvZHlzZXRfcmJFbmFibGVDY2QA/AYWcmF3cmlnaWRib2R5c2V0X3JiTWFzcwC/BhlyYXdyaWdpZGJvZHlzZXRfcmJJbnZNYXNzAKYGInJhd3JpZ2lkYm9keXNldF9yYkVmZmVjdGl2ZUludk1hc3MAxAUacmF3cmlnaWRib2R5c2V0X3JiTG9jYWxDb20AxQUacmF3cmlnaWRib2R5c2V0X3JiV29ybGRDb20AxgUpcmF3cmlnaWRib2R5c2V0X3JiSW52UHJpbmNpcGFsSW5lcnRpYVNxcnQApwYicmF3cmlnaWRib2R5c2V0X3JiUHJpbmNpcGFsSW5lcnRpYQCoBi5yYXdyaWdpZGJvZHlzZXRfcmJFZmZlY3RpdmVXb3JsZEludkluZXJ0aWFTcXJ0AKkGKXJhd3JpZ2lkYm9keXNldF9yYkVmZmVjdGl2ZUFuZ3VsYXJJbmVydGlhAKoGGHJhd3JpZ2lkYm9keXNldF9yYldha2VVcACOBx5yYXdyaWdpZGJvZHlzZXRfcmJJc0NjZEVuYWJsZWQAwAYecmF3cmlnaWRib2R5c2V0X3JiTnVtQ29sbGlkZXJzAKAGGnJhd3JpZ2lkYm9keXNldF9yYkNvbGxpZGVyANMIGnJhd3JpZ2lkYm9keXNldF9yYkJvZHlUeXBlAKsGHXJhd3JpZ2lkYm9keXNldF9yYlNldEJvZHlUeXBlAJUGGXJhd3JpZ2lkYm9keXNldF9yYklzRml4ZWQAwQYdcmF3cmlnaWRib2R5c2V0X3JiSXNLaW5lbWF0aWMAwgYbcmF3cmlnaWRib2R5c2V0X3JiSXNEeW5hbWljAMMGH3Jhd3JpZ2lkYm9keXNldF9yYkxpbmVhckRhbXBpbmcArAYgcmF3cmlnaWRib2R5c2V0X3JiQW5ndWxhckRhbXBpbmcArQYicmF3cmlnaWRib2R5c2V0X3JiU2V0TGluZWFyRGFtcGluZwCPByNyYXdyaWdpZGJvZHlzZXRfcmJTZXRBbmd1bGFyRGFtcGluZwD9BhxyYXdyaWdpZGJvZHlzZXRfcmJTZXRFbmFibGVkAP4GG3Jhd3JpZ2lkYm9keXNldF9yYklzRW5hYmxlZADEBh5yYXdyaWdpZGJvZHlzZXRfcmJHcmF2aXR5U2NhbGUAxQYhcmF3cmlnaWRib2R5c2V0X3JiU2V0R3Jhdml0eVNjYWxlAPYGHXJhd3JpZ2lkYm9keXNldF9yYlJlc2V0Rm9yY2VzAP8GHnJhd3JpZ2lkYm9keXNldF9yYlJlc2V0VG9ycXVlcwCABxpyYXdyaWdpZGJvZHlzZXRfcmJBZGRGb3JjZQDLBR5yYXdyaWdpZGJvZHlzZXRfcmJBcHBseUltcHVsc2UAzAUbcmF3cmlnaWRib2R5c2V0X3JiQWRkVG9ycXVlAPcGJHJhd3JpZ2lkYm9keXNldF9yYkFwcGx5VG9ycXVlSW1wdWxzZQD4BiFyYXdyaWdpZGJvZHlzZXRfcmJBZGRGb3JjZUF0UG9pbnQAmAQlcmF3cmlnaWRib2R5c2V0X3JiQXBwbHlJbXB1bHNlQXRQb2ludACZBBpyYXdyaWdpZGJvZHlzZXRfcmJVc2VyRGF0YQCuBh1yYXdyaWdpZGJvZHlzZXRfcmJTZXRVc2VyRGF0YQDgBhpfX3diZ19yYXdyaWdpZGJvZHlzZXRfZnJlZQDfAxNyYXdyaWdpZGJvZHlzZXRfbmV3APEGH3Jhd3JpZ2lkYm9keXNldF9jcmVhdGVSaWdpZEJvZHkAkwMWcmF3cmlnaWRib2R5c2V0X3JlbW92ZQCxAxNyYXdyaWdpZGJvZHlzZXRfbGVuAOUIGHJhd3JpZ2lkYm9keXNldF9jb250YWlucwCQByZyYXdyaWdpZGJvZHlzZXRfZm9yRWFjaFJpZ2lkQm9keUhhbmRsZQCACDlyYXdyaWdpZGJvZHlzZXRfcHJvcGFnYXRlTW9kaWZpZWRCb2R5UG9zaXRpb25zVG9Db2xsaWRlcnMAsQgYX193YmdfcmF3YnJvYWRwaGFzZV9mcmVlAO0HEXJhd2Jyb2FkcGhhc2VfbmV3AMEIHHJhd2NvbGxpZGVyc2V0X2NvVHJhbnNsYXRpb24AzQUZcmF3Y29sbGlkZXJzZXRfY29Sb3RhdGlvbgCVBR9yYXdjb2xsaWRlcnNldF9jb1NldFRyYW5zbGF0aW9uAOEGKHJhd2NvbGxpZGVyc2V0X2NvU2V0VHJhbnNsYXRpb25XcnRQYXJlbnQA4gYccmF3Y29sbGlkZXJzZXRfY29TZXRSb3RhdGlvbgDjBiVyYXdjb2xsaWRlcnNldF9jb1NldFJvdGF0aW9uV3J0UGFyZW50AJEHGXJhd2NvbGxpZGVyc2V0X2NvSXNTZW5zb3IAxgYacmF3Y29sbGlkZXJzZXRfY29TaGFwZVR5cGUAywggcmF3Y29sbGlkZXJzZXRfY29IYWxmc3BhY2VOb3JtYWwArwQccmF3Y29sbGlkZXJzZXRfY29IYWxmRXh0ZW50cwCWBh9yYXdjb2xsaWRlcnNldF9jb1NldEhhbGZFeHRlbnRzAO4HF3Jhd2NvbGxpZGVyc2V0X2NvUmFkaXVzALAHGnJhd2NvbGxpZGVyc2V0X2NvU2V0UmFkaXVzALYJG3Jhd2NvbGxpZGVyc2V0X2NvSGFsZkhlaWdodACxBx5yYXdjb2xsaWRlcnNldF9jb1NldEhhbGZIZWlnaHQAtwkccmF3Y29sbGlkZXJzZXRfY29Sb3VuZFJhZGl1cwCyBx9yYXdjb2xsaWRlcnNldF9jb1NldFJvdW5kUmFkaXVzALgJGXJhd2NvbGxpZGVyc2V0X2NvVmVydGljZXMA0AQYcmF3Y29sbGlkZXJzZXRfY29JbmRpY2VzANEEI3Jhd2NvbGxpZGVyc2V0X2NvSGVpZ2h0ZmllbGRIZWlnaHRzANIEIXJhd2NvbGxpZGVyc2V0X2NvSGVpZ2h0ZmllbGRTY2FsZQCXBhdyYXdjb2xsaWRlcnNldF9jb1BhcmVudACWBRtyYXdjb2xsaWRlcnNldF9jb1NldEVuYWJsZWQAgQcacmF3Y29sbGlkZXJzZXRfY29Jc0VuYWJsZWQAxwYZcmF3Y29sbGlkZXJzZXRfY29GcmljdGlvbgC2BhxyYXdjb2xsaWRlcnNldF9jb1Jlc3RpdHV0aW9uALcGGHJhd2NvbGxpZGVyc2V0X2NvRGVuc2l0eQDIBhVyYXdjb2xsaWRlcnNldF9jb01hc3MAyQYXcmF3Y29sbGlkZXJzZXRfY29Wb2x1bWUAygYgcmF3Y29sbGlkZXJzZXRfY29Db2xsaXNpb25Hcm91cHMA/wUdcmF3Y29sbGlkZXJzZXRfY29Tb2x2ZXJHcm91cHMAgAYccmF3Y29sbGlkZXJzZXRfY29BY3RpdmVIb29rcwDLBiVyYXdjb2xsaWRlcnNldF9jb0FjdGl2ZUNvbGxpc2lvblR5cGVzAK8GHXJhd2NvbGxpZGVyc2V0X2NvQWN0aXZlRXZlbnRzAMwGK3Jhd2NvbGxpZGVyc2V0X2NvQ29udGFjdEZvcmNlRXZlbnRUaHJlc2hvbGQAzQYecmF3Y29sbGlkZXJzZXRfY29Db250YWluc1BvaW50AKMEGnJhd2NvbGxpZGVyc2V0X2NvQ2FzdFNoYXBlAOQBHXJhd2NvbGxpZGVyc2V0X2NvQ2FzdENvbGxpZGVyAIgCIHJhd2NvbGxpZGVyc2V0X2NvSW50ZXJzZWN0c1NoYXBlANgEHXJhd2NvbGxpZGVyc2V0X2NvQ29udGFjdFNoYXBlALkCIHJhd2NvbGxpZGVyc2V0X2NvQ29udGFjdENvbGxpZGVyALUDHXJhd2NvbGxpZGVyc2V0X2NvUHJvamVjdFBvaW50ALYDHnJhd2NvbGxpZGVyc2V0X2NvSW50ZXJzZWN0c1JheQDsBRhyYXdjb2xsaWRlcnNldF9jb0Nhc3RSYXkA2wUkcmF3Y29sbGlkZXJzZXRfY29DYXN0UmF5QW5kR2V0Tm9ybWFsAMsDGnJhd2NvbGxpZGVyc2V0X2NvU2V0U2Vuc29yAIIHH3Jhd2NvbGxpZGVyc2V0X2NvU2V0UmVzdGl0dXRpb24AkgcccmF3Y29sbGlkZXJzZXRfY29TZXRGcmljdGlvbgCTByRyYXdjb2xsaWRlcnNldF9jb0ZyaWN0aW9uQ29tYmluZVJ1bGUAsAYncmF3Y29sbGlkZXJzZXRfY29TZXRGcmljdGlvbkNvbWJpbmVSdWxlAOYGJ3Jhd2NvbGxpZGVyc2V0X2NvUmVzdGl0dXRpb25Db21iaW5lUnVsZQCxBipyYXdjb2xsaWRlcnNldF9jb1NldFJlc3RpdHV0aW9uQ29tYmluZVJ1bGUA5wYjcmF3Y29sbGlkZXJzZXRfY29TZXRDb2xsaXNpb25Hcm91cHMAkAYgcmF3Y29sbGlkZXJzZXRfY29TZXRTb2x2ZXJHcm91cHMAkQYfcmF3Y29sbGlkZXJzZXRfY29TZXRBY3RpdmVIb29rcwDoBiByYXdjb2xsaWRlcnNldF9jb1NldEFjdGl2ZUV2ZW50cwDpBihyYXdjb2xsaWRlcnNldF9jb1NldEFjdGl2ZUNvbGxpc2lvblR5cGVzAOoGGXJhd2NvbGxpZGVyc2V0X2NvU2V0U2hhcGUA2QQucmF3Y29sbGlkZXJzZXRfY29TZXRDb250YWN0Rm9yY2VFdmVudFRocmVzaG9sZACUBxtyYXdjb2xsaWRlcnNldF9jb1NldERlbnNpdHkAlQcYcmF3Y29sbGlkZXJzZXRfY29TZXRNYXNzAJYHInJhd2NvbGxpZGVyc2V0X2NvU2V0TWFzc1Byb3BlcnRpZXMApgQZX193YmdfcmF3Y29sbGlkZXJzZXRfZnJlZQCsAxJyYXdjb2xsaWRlcnNldF9uZXcA9gUScmF3Y29sbGlkZXJzZXRfbGVuAOYIF3Jhd2NvbGxpZGVyc2V0X2NvbnRhaW5zAJcHHXJhd2NvbGxpZGVyc2V0X2NyZWF0ZUNvbGxpZGVyAPkCFXJhd2NvbGxpZGVyc2V0X3JlbW92ZQCBBCRyYXdjb2xsaWRlcnNldF9mb3JFYWNoQ29sbGlkZXJIYW5kbGUAgQgaX193YmdfcmF3c2hhcGVjb250YWN0X2ZyZWUAjgoZX193YmdfcmF3bmFycm93cGhhc2VfZnJlZQDvBxJyYXduYXJyb3dwaGFzZV9uZXcAwggccmF3bmFycm93cGhhc2VfY29udGFjdHNfd2l0aADnCBtyYXduYXJyb3dwaGFzZV9jb250YWN0X3BhaXIA8AQhcmF3bmFycm93cGhhc2VfaW50ZXJzZWN0aW9uc193aXRoAOgIIHJhd25hcnJvd3BoYXNlX2ludGVyc2VjdGlvbl9wYWlyAIEGHV9fd2JnX3Jhd2NvbnRhY3RtYW5pZm9sZF9mcmVlAI4KGHJhd2NvbnRhY3RwYWlyX2NvbGxpZGVyMQDXBxhyYXdjb250YWN0cGFpcl9jb2xsaWRlcjIAyAcicmF3Y29udGFjdHBhaXJfbnVtQ29udGFjdE1hbmlmb2xkcwCECR5yYXdjb250YWN0cGFpcl9jb250YWN0TWFuaWZvbGQAoQYZcmF3Y29udGFjdG1hbmlmb2xkX25vcm1hbACJCBtyYXdjb250YWN0bWFuaWZvbGRfbG9jYWxfbjEAiggbcmF3Y29udGFjdG1hbmlmb2xkX2xvY2FsX24yAIsIHHJhd2NvbnRhY3RtYW5pZm9sZF9zdWJzaGFwZTEAmgkccmF3Y29udGFjdG1hbmlmb2xkX3N1YnNoYXBlMgCbCR9yYXdjb250YWN0bWFuaWZvbGRfbnVtX2NvbnRhY3RzAIUJI3Jhd2NvbnRhY3RtYW5pZm9sZF9jb250YWN0X2xvY2FsX3AxANMGI3Jhd2NvbnRhY3RtYW5pZm9sZF9jb250YWN0X2xvY2FsX3AyANQGH3Jhd2NvbnRhY3RtYW5pZm9sZF9jb250YWN0X2Rpc3QAgggfcmF3Y29udGFjdG1hbmlmb2xkX2NvbnRhY3RfZmlkMQCDCB9yYXdjb250YWN0bWFuaWZvbGRfY29udGFjdF9maWQyAIQIInJhd2NvbnRhY3RtYW5pZm9sZF9jb250YWN0X2ltcHVsc2UAhQgqcmF3Y29udGFjdG1hbmlmb2xkX2NvbnRhY3RfdGFuZ2VudF9pbXB1bHNlAIYIJnJhd2NvbnRhY3RtYW5pZm9sZF9udW1fc29sdmVyX2NvbnRhY3RzAIYJJ3Jhd2NvbnRhY3RtYW5pZm9sZF9zb2x2ZXJfY29udGFjdF9wb2ludADOBiZyYXdjb250YWN0bWFuaWZvbGRfc29sdmVyX2NvbnRhY3RfZGlzdADcBypyYXdjb250YWN0bWFuaWZvbGRfc29sdmVyX2NvbnRhY3RfZnJpY3Rpb24AzgctcmF3Y29udGFjdG1hbmlmb2xkX3NvbHZlcl9jb250YWN0X3Jlc3RpdHV0aW9uAM8HMnJhd2NvbnRhY3RtYW5pZm9sZF9zb2x2ZXJfY29udGFjdF90YW5nZW50X3ZlbG9jaXR5ALgGHV9fd2JnX3Jhd3BvaW50cHJvamVjdGlvbl9mcmVlAI4KG3Jhd3BvaW50cHJvamVjdGlvbl9pc0luc2lkZQCECiVfX3diZ19yYXdwb2ludGNvbGxpZGVycHJvamVjdGlvbl9mcmVlAI4KI3Jhd3BvaW50Y29sbGlkZXJwcm9qZWN0aW9uX2lzSW5zaWRlAIUKJnJhd3BvaW50Y29sbGlkZXJwcm9qZWN0aW9uX2ZlYXR1cmVUeXBlAKYJJHJhd3BvaW50Y29sbGlkZXJwcm9qZWN0aW9uX2ZlYXR1cmVJZACcCR1fX3diZ19yYXdyYXlpbnRlcnNlY3Rpb25fZnJlZQCOChZyYXdyYXlpbnRlcnNlY3Rpb25fdG9pAIYKIXJhd3JheWNvbGxpZGVyaW50ZXJzZWN0aW9uX25vcm1hbADDCCZyYXdyYXljb2xsaWRlcmludGVyc2VjdGlvbl9mZWF0dXJlVHlwZQCnCSRyYXdyYXljb2xsaWRlcmludGVyc2VjdGlvbl9mZWF0dXJlSWQAnQkTX193YmdfcmF3c2hhcGVfZnJlZQCyCA9yYXdzaGFwZV9jdWJvaWQAmggUcmF3c2hhcGVfcm91bmRDdWJvaWQAkggNcmF3c2hhcGVfYmFsbAChCBJyYXdzaGFwZV9oYWxmc3BhY2UA+wQQcmF3c2hhcGVfY2Fwc3VsZQC5BhFyYXdzaGFwZV9wb2x5bGluZQDyBhByYXdzaGFwZV90cmltZXNoAPMGFHJhd3NoYXBlX2hlaWdodGZpZWxkANYFEHJhd3NoYXBlX3NlZ21lbnQA4wQRcmF3c2hhcGVfdHJpYW5nbGUA6QMWcmF3c2hhcGVfcm91bmRUcmlhbmdsZQDlAxNyYXdzaGFwZV9jb252ZXhIdWxsAJgHGHJhd3NoYXBlX3JvdW5kQ29udmV4SHVsbACFBxdyYXdzaGFwZV9jb252ZXhQb2x5bGluZQCZBxxyYXdzaGFwZV9yb3VuZENvbnZleFBvbHlsaW5lAIYHEnJhd3NoYXBlX2Nhc3RTaGFwZQCPARhyYXdzaGFwZV9pbnRlcnNlY3RzU2hhcGUA0wIVcmF3c2hhcGVfY29udGFjdFNoYXBlALYBFnJhd3NoYXBlX2NvbnRhaW5zUG9pbnQA5gMVcmF3c2hhcGVfcHJvamVjdFBvaW50AJQDFnJhd3NoYXBlX2ludGVyc2VjdHNSYXkA+wIQcmF3c2hhcGVfY2FzdFJheQDkAhxyYXdzaGFwZV9jYXN0UmF5QW5kR2V0Tm9ybWFsALECHl9fd2JnX3Jhd3NoYXBlY29sbGlkZXJ0b2lfZnJlZQCOChdyYXdzaGFwZWNvbGxpZGVydG9pX3RvaQCHChZfX3diZ19yYXdyb3RhdGlvbl9mcmVlAI4KFHJhd3JvdGF0aW9uX2lkZW50aXR5AI8KFXJhd3JvdGF0aW9uX2Zyb21BbmdsZQCiCA5yYXdyb3RhdGlvbl9pbQCIChFyYXdyb3RhdGlvbl9hbmdsZQC3CA5yYXd2ZWN0b3JfemVybwCQCg1yYXd2ZWN0b3JfbmV3ALkJD3Jhd3ZlY3Rvcl9zZXRfeQDkCQxyYXd2ZWN0b3JfeHkAhwgMcmF3dmVjdG9yX3l4AIgIIV9fd2JnX3Jhd2RlYnVncmVuZGVycGlwZWxpbmVfZnJlZQD9AhpyYXdkZWJ1Z3JlbmRlcnBpcGVsaW5lX25ldwCyBh9yYXdkZWJ1Z3JlbmRlcnBpcGVsaW5lX3ZlcnRpY2VzAKkHHXJhd2RlYnVncmVuZGVycGlwZWxpbmVfY29sb3JzAKoHHXJhd2RlYnVncmVuZGVycGlwZWxpbmVfcmVuZGVyAMADGF9fd2JnX3Jhd2V2ZW50cXVldWVfZnJlZQBcH19fd2JnX3Jhd2NvbnRhY3Rmb3JjZWV2ZW50X2ZyZWUAjgoecmF3Y29udGFjdGZvcmNlZXZlbnRfY29sbGlkZXIxANgHHnJhd2NvbnRhY3Rmb3JjZWV2ZW50X2NvbGxpZGVyMgDJByByYXdjb250YWN0Zm9yY2VldmVudF90b3RhbF9mb3JjZQDECCpyYXdjb250YWN0Zm9yY2VldmVudF90b3RhbF9mb3JjZV9tYWduaXR1ZGUAiQoocmF3Y29udGFjdGZvcmNlZXZlbnRfbWF4X2ZvcmNlX21hZ25pdHVkZQCKChFyYXdldmVudHF1ZXVlX25ldwDVBiJyYXdldmVudHF1ZXVlX2RyYWluQ29sbGlzaW9uRXZlbnRzALMIJXJhd2V2ZW50cXVldWVfZHJhaW5Db250YWN0Rm9yY2VFdmVudHMAtAgTcmF3ZXZlbnRxdWV1ZV9jbGVhcgDPBh1fX3diZ19yYXdwaHlzaWNzcGlwZWxpbmVfZnJlZQCNARZyYXdwaHlzaWNzcGlwZWxpbmVfbmV3APAHF3Jhd3BoeXNpY3NwaXBlbGluZV9zdGVwANECIXJhd3BoeXNpY3NwaXBlbGluZV9zdGVwV2l0aEV2ZW50cwC/AhtfX3diZ19yYXdxdWVyeXBpcGVsaW5lX2ZyZWUA6gcUcmF3cXVlcnlwaXBlbGluZV9uZXcAxQgXcmF3cXVlcnlwaXBlbGluZV91cGRhdGUAswYYcmF3cXVlcnlwaXBlbGluZV9jYXN0UmF5AMECJHJhd3F1ZXJ5cGlwZWxpbmVfY2FzdFJheUFuZEdldE5vcm1hbACoAiVyYXdxdWVyeXBpcGVsaW5lX2ludGVyc2VjdGlvbnNXaXRoUmF5AIoDJnJhd3F1ZXJ5cGlwZWxpbmVfaW50ZXJzZWN0aW9uV2l0aFNoYXBlANcCHXJhd3F1ZXJ5cGlwZWxpbmVfcHJvamVjdFBvaW50ANUCKnJhd3F1ZXJ5cGlwZWxpbmVfcHJvamVjdFBvaW50QW5kR2V0RmVhdHVyZQDdASdyYXdxdWVyeXBpcGVsaW5lX2ludGVyc2VjdGlvbnNXaXRoUG9pbnQA/wEacmF3cXVlcnlwaXBlbGluZV9jYXN0U2hhcGUAwwEncmF3cXVlcnlwaXBlbGluZV9pbnRlcnNlY3Rpb25zV2l0aFNoYXBlAO4CMnJhd3F1ZXJ5cGlwZWxpbmVfY29sbGlkZXJzV2l0aEFhYmJJbnRlcnNlY3RpbmdBYWJiAJ8FH19fd2JnX3Jhd2Rlc2VyaWFsaXplZHdvcmxkX2ZyZWUAiQQgcmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZUdyYXZpdHkAswcucmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZUludGVncmF0aW9uUGFyYW1ldGVycwDSAiZyYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlSXNsYW5kTWFuYWdlcgDaAiNyYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlQnJvYWRQaGFzZQDXBSRyYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlTmFycm93UGhhc2UA6gIfcmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZUJvZGllcwDHAyJyYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlQ29sbGlkZXJzAKIDJnJhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VJbXB1bHNlSm9pbnRzAL0CKHJhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VNdWx0aWJvZHlKb2ludHMAvgIlcmF3c2VyaWFsaXphdGlvbnBpcGVsaW5lX3NlcmlhbGl6ZUFsbACGAidyYXdzZXJpYWxpemF0aW9ucGlwZWxpbmVfZGVzZXJpYWxpemVBbGwAvgUZX193YmdfcmF3Y29udGFjdHBhaXJfZnJlZQCOCiVfX3diZ19yYXdyYXljb2xsaWRlcmludGVyc2VjdGlvbl9mcmVlAI4KHF9fd2JnX3Jhd3JheWNvbGxpZGVydG9pX2ZyZWUAjgoUX193YmdfcmF3dmVjdG9yX2ZyZWUAjgoWX193YmdfcmF3c2hhcGV0b2lfZnJlZQCOCjVyYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX3NldE1heFNsb3BlQ2xpbWJBbmdsZQDdCQ9yYXd2ZWN0b3Jfc2V0X3gA8gkccmF3Y29sbGlkZXJzZXRfaXNIYW5kbGVWYWxpZACXBx5yYXdyYXlpbnRlcnNlY3Rpb25fZmVhdHVyZVR5cGUApgkccmF3cmF5aW50ZXJzZWN0aW9uX2ZlYXR1cmVJZACcCRZyYXdzaGFwZWNvbnRhY3RfcG9pbnQxANIIF3Jhd3NoYXBlY29udGFjdF9ub3JtYWwyALwIGHJhd3BvaW50cHJvamVjdGlvbl9wb2ludADSCBdyYXdzaGFwZWNvbnRhY3Rfbm9ybWFsMQDECBlyYXdyYXlpbnRlcnNlY3Rpb25fbm9ybWFsANIIFnJhd3NoYXBlY29udGFjdF9wb2ludDIAwwgUcmF3c2hhcGV0b2lfd2l0bmVzczEA0ggUcmF3c2hhcGV0b2lfd2l0bmVzczIAwwgTcmF3c2hhcGV0b2lfbm9ybWFsMQDECBNyYXdzaGFwZXRvaV9ub3JtYWwyALwIHHJhd3NoYXBlY29sbGlkZXJ0b2lfd2l0bmVzczEAwwgccmF3c2hhcGVjb2xsaWRlcnRvaV93aXRuZXNzMgDECBtyYXdzaGFwZWNvbGxpZGVydG9pX25vcm1hbDEAvAgbcmF3c2hhcGVjb2xsaWRlcnRvaV9ub3JtYWwyAL0IIHJhd3BvaW50Y29sbGlkZXJwcm9qZWN0aW9uX3BvaW50AMQIKHJhd2NvbnRhY3Rmb3JjZWV2ZW50X21heF9mb3JjZV9kaXJlY3Rpb24AvAgccmF3c2VyaWFsaXphdGlvbnBpcGVsaW5lX25ldwCcCjJyYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX21heFNsb3BlQ2xpbWJBbmdsZQD+CRhyYXdzaGFwZWNvbnRhY3RfZGlzdGFuY2UAiQoecmF3cmF5Y29sbGlkZXJpbnRlcnNlY3Rpb25fdG9pAP4JFXJhd3JheWNvbGxpZGVydG9pX3RvaQD9CQ9yYXdzaGFwZXRvaV90b2kAiQoOcmF3cm90YXRpb25fcmUAlwoLcmF3dmVjdG9yX3gAlwoLcmF3dmVjdG9yX3kAiAorcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3ByZWRpY3Rpb25EaXN0YW5jZQCJCilyYXdyYXljb2xsaWRlcmludGVyc2VjdGlvbl9jb2xsaWRlckhhbmRsZQDYByByYXdyYXljb2xsaWRlcnRvaV9jb2xsaWRlckhhbmRsZQDYByJyYXdzaGFwZWNvbGxpZGVydG9pX2NvbGxpZGVySGFuZGxlANgHKXJhd3BvaW50Y29sbGlkZXJwcm9qZWN0aW9uX2NvbGxpZGVySGFuZGxlANgHI19fd2JnX3Jhd3NlcmlhbGl6YXRpb25waXBlbGluZV9mcmVlAJEKH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAnwsPX193YmluZGdlbl9mcmVlAMAKEV9fd2JpbmRnZW5fbWFsbG9jAL0JFF9fd2JpbmRnZW5fZXhuX3N0b3JlANEKCf8MAQBBAQvKBpkLygqBAeAI3wjhCN8I3wjkC6ILrwuwC4cLmQihC78J0QmpCKcKugu4C7kLowr9CIQD+AfHCtkIzwroB6QLzwmIB58ErAmfBs0H6AnxBZ0FiATlBswKzArMCswKjAnlAcEJ1gTGA4AF5QeGBMcImgSKB7QK0wvpCtgL3wvRC/EKsQu8CpEI3QXcBpcE0QiqBagHqwnwBZAFvwPSBs0KzQrNCs0KiwmoAcAJ1wTFA/8EwAWoBaAJvgOLB8UK1AvoCvIKvQr9BN8FkQX8AtYH6QGbA7oI9ASkB/AG0QbOCs4KzgrOCukHhgaMCPUD7QKMBPQJ5gnWCbQGiQfZB9EL6wqyCu8KuwqoBN4FtwugC6MLswu9C+UL5gvnC6UJ7gHWAuULnwEyLNAJ4gSdC58K+AWdCp8KmgqoCqQKnQqdCqAKngqhCuQLzwnUCukI6wjqCOkI6QjhB+wJ7QnpCOkI8wmjCdAI5AtYQV9gXtABJha/CdQJqwipCrsLugvSCagJygfPCc8JpAvTCYgHnwSsCZ8GzQfoCfEFnQWIBOUG0wrTCtMK0wqMCeUBwQnWBMYDgAWKB7EL3QWlB9cDugHBCtAHiwrrBqAF0Ab5BtIK0grSCtIKjgmpAcMJ2gTIA4IF+ga3B8YIpASaB9kD0gvqCrUL8Aqz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IAgqAkAhHSAIKAJQIQwgCCgCTCELA0AgBCgCHCECAn8gCEEwaiAKDQAaIAEgAiALRw0AGiABIAQoAiAgDEcNABogBCAGOAIUIAQgHTgCECABCyEAIAlBJE8EQCAAQTRqIQUDQAJAIAIgBSIAQRhrKAIARw0AIAQoAiAgAEEUaygCAEcNACAEIABBJGspAgA3AhALAkAgAiAAQQxqKAIARw0AIAQoAiAgAEEQaigCAEcNACAEIAApAgA3AhALIABByABqIQUgAEEUaiADRw0ACwsgByAEQSRqIgRHDQALDAELIANFDQELIAhBADYCeAtBACEJCyAIQbADaiQAIAkPC0HYw8AAQSsgCEGgAmpBlPPAAEGI9MAAENsGAAu0TgMpfwJ+AX0jAEGQA2siAiQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQCABKAIEIgZBBE8EQCABIAZBBGsiBzYCBCABIAEoAgAiA0EEajYCACADKAAAIggODwMEBQYHCAkKCwwNDg8QEQELIAJCgcoANwPoASACQegBahDrCQwBCyACQQE6AOgBIAIgCK03A/ABIAJB6AFqQeiGwABBtIHAABCEBwshASAAQQ82AgAgACABNgIEDDMLIAdBBE8EQCABIAZBCGs2AgQgASADQQhqNgIAIAAgAygABDYCBCAAQQA2AgAMMwsgAkEAOgDrASACQSU7AOkBIAJBADYC7AEgAkEBOgDoASACQegBahDrCSEBIABBDzYCACAAIAE2AgQMMgsgAkHoAWogARCBAyACKALoAUUEQCAAIAIpAuwBNwIEIABBATYCAAwyCyACKALsASEBIABBDzYCACAAIAE2AgQMMQsgAkHoAWogARCBAwJ/IAIoAugBBEAgAigC7AEMAQsgAkHwAWoiBCgCACEDIAIoAuwBIQYgAkHoAWogARCBAyACKALoAQRAIAIoAuwBDAELIAEoAgQiBUEDSw0NIAJBADoA6wEgAkElOwDpASACQQA2AuwBIAJBAToA6AEgAkHoAWoQ6wkLIQEgAEEPNgIAIAAgATYCBAwwCyACQegBaiABEIEDIAIoAugB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///7////v/8ANwIAIAhBgAFqQv////sHNwIAIAhB+ABqQoCAgIDw//+/fzcCACAIQfAAakL////7////v/8ANwIAIAhB6ABqQgA3AgAgCEHgAGpCgICA/AM3AgAgCEHYAGogbTcCACAIIHE3AlAgCEGYAWpCADcCACAIQaABakEANgIAIAhBrAFqQQA6AAAgCEGkAWpC////+wc3AgAgCEHoAWoiHi0AACEnIAhBrQFqICIpA4gBNwAAIAhBtQFqICUpAwA3AAAgCEG8AWogGCgAADYAACAIQcgBakEAOgAAIAhBwAFqQv////sHNwIAIAhB2AFqIB0oAAA2AAAgCEHRAWogHCkDADcAACAIQckBaiAiKQNwNwAAIAhB8AFqQYCAgPwDNgIAIAhB7AFqQYACOwEAIB5BBzYCACAIQeQBakEAOgAAIAhB3AFqQv////sHNwIAIAhB/AFqQgA3AgAgCEH0AWpCADcCACAoKAIARQ0CIBQoAgBBADYCPCARIBEoApABIghBAyAnaWsiGGs2ApABAkAgCCAYRgRAIBEoAgAEQCARQQRqKAIAEIcBCyARQgA3AgggEUKAgICAwAA3AgAgESgCEARAIBFBFGooAgAQhwELIBFCgICAgMAANwIQIBFBGGpCADcCACARKAIgBEAgEUEkaigCABCHAQsgEUKAgICAwAA3AiAgEUEoakIANwIADAELIBIoAgAiCCAYTQ0TICIgGEECdCISIBFBBGoiJSgCAGo2AqABICIgCDYCqAEgIkEAIAggGGsiHSAIIB1JGzYCpAEgIkEwaiAiQaABahChAiARKAIABEAgJSgCABCHAQsgESAiKQMwNwIAIBFBCGogDykDADcCACAZKAIAIgggGE0NEyAiIBFBFGoiGSgCACASajYCoAEgIiAINgKoASAiQQAgCCAYayIlIAggJUkbNgKkASAiQTBqICJBoAFqEKECIBFBEGoiCCgCAARAIBkoAgAQhwELIAggIikDMDcCACAIQQhqIA8pAwA3AgAgICgCACIIIBhNDRMgIiASIBFBJGoiGSgCAGo2AqABICIgCDYCqAEgIkEAIAggGGsiEiAIIBJJGzYCpAEgIkEwaiAiQaABahChAiARQSBqIggoAgAEQCAZKAIAEIcBCyAIICIpAzA3AgAgCEEIaiAPKQMANwIACyAoKAIAIghFDQEgCEEBRg0JIBQoAgAhEgJ/IAhBhAJsIhlBiARrIiBBhAJuQQFqQQdxIghFBEAgEiIPQYQCagwBCyAIQYQCbCEIIBIhDwNAIA9BwAJqIiUgJSgCACAYazYCACAPQYQCaiEPIAhBhAJrIggNAAsgD0GEAmoLIQggIEGcDkkNCSASIBlqIRIDQCAPQcACaiIPIA8oAgAgGGs2AgAgCEHAAmoiDyAPKAIAIBhrNgIAIAhBxARqIg8gDygCACAYazYCACAIQcgGaiIPIA8oAgAgGGs2AgAgCEHMCGoiDyAPKAIAIBhrNgIAIAhB0ApqIg8gDygCACAYazYCACAIQdQMaiIPIA8oAgAgGGs2AgAgCEHYDmoiDyAPKAIAIBhrNgIAIAhBnA5qIQ8gEiAIQaAQaiIIRw0ACwwJCyAAIAJBIGoqAgAgAyAEIAUgBiAHIDkgCSAiKAIUIiggIigCGCIQICIoAiQiTCAiKAIoIAsgDCANIA5BARCSBCAiQQA2AhgCQCAQRQ0AIBBBAWtB/////wFxIRggB0EwaigCACEIIAdBLGooAgAhEiAoIQ8CQCAQQQFxRQ0AIChBCGohDyAoKAIAIhEgCE8NACASIBFBkAFsakEAIAggEUsbIhEoAgBBAUcNACARKAIEIChBBGooAgBHDQAgEUE4akEANgIACyAYRQ0AICggEEEDdGohEQNAAkAgDygCACIQIAhPDQAgEiAQQZABbGpBACAIIBBLGyIQKAIAQQFHDQAgECgCBCAPQQRqKAIARw0AIBBBOGpBADYCAAsCQCAPQQhqKAIAIhAgCE8NACASIBBBkAFsakEAIAggEEsbIhAoAgBBAUcNACAQKAIEIA9BDGooAgBHDQAgEEE4akEANgIACyARIA9BEGoiD0cNAAsLAkAgIUUNACAhQQFrQf////8BcSERIAZBJGooAgAhCCAGQSBqKAIAIRAgQiEPAkAgIUEBcUUNACBCQQhqIQ8gQigCACISIAhPDQAgECASQegBbGpBACAIIBJLGyISKAIAQQFHDQAgEigCBCBCQQRqKAIARw0AIBJBsAFqQQA2AgALIBFFDQAgQiAhQQN0aiERA0ACQCAPKAIAIhIgCE8NACAQIBJB6AFsakEAIAggEksbIhIoAgBBAUcNACASKAIEIA9BBGooAgBHDQAgEkGwAWpBADYCAAsCQCAPQQhqKAIAIhIgCE8NACAQIBJB6AFsakEAIAggEksbIhIoAgBBAUcNACASKAIEIA9BDGooAgBHDQAgEkGwAWpBADYCAAsgESAPQRBqIg9HDQALCyACKgIAIVwgIkEANgIoICJBMGoiCEEwaiACQTBqKQIANwMAIAhBIGoiDyACQSBqKQIANwMAIAhBOGogAkE4aigCADYCACAIQShqIAJBKGopAgA3AwAgCEEYaiACQRhqKQIANwMAIAhBEGogAkEQaikCADcDACAIQQhqIAJBCGopAgA3AwAgIiACKQIANwMwICIoAmQiRUEARyFNIEVBASBFGyECIAEpAgAhcSAPKgIAIWsgIioCNCFsIANBFGohSCAGQSRqIUYgA0EMaiFJIAdBLGohSgNAAkAgTSACQQFHcUUEQCAiIFw4AjBBACECIFwhWEMAAAAAIVwMAQsCfwJAIANBDGooAgAiAUUEQEEAIREMAQsgA0EIaigCACISIAFBA3RqIQ8gBkEkaigCACEIIAZBIGooAgAhEEEAIREDQCASKAIAIgEgCE8NGSAQIAFB6AFsakEAIAEgCEkbIgEoAgBBAUcNGSABKAIEIBJBBGooAgBHDRkgAUHJAWotAAAEQCABQcABaioCACFYIAFByAFqIAFBlAFqKQIAIm2nviBclCABQfwAaikCACJup76SIk4gTpQgbUIgiKe+IFyUIG5CIIinvpIiTiBOlJJDAAAAAJIQdiABQcQBaioCACABQYQBaioCACABQaQBaioCACBclJKLlJIgWEMAACBBlV4iAToAACABIBFyIRELIA8gEkEIaiISRw0ACwsCQCARQQFxRQ0AICJBCGohLkEAIREjAEGwAmsiEyQAIAogBiAHQQIgXBA1IBNBADYCKCATQoCAgIDAADcDICATQZj0wAA2AhwgE0EANgIYIBNCADcDECATIFw4AiwCQCADQQxqKAIAIgEEQCADQQhqKAIAIhwgAUEDdGohLyAGQSBqITIgBkEkaiEqIAdBLGohMCAHQTBqIS0gCkEYaiErIApBOGohKSAKQTxqIUMDQAJAAkAgKigCACIIIBwoAgAiAU0NACAyKAIAIAFB6AFsakEAIAEgCEkbIgEoAgBBAUcNACABKAIEIBwoAgRGDQELQZSPwQBBE0H4lMEAEJoLAAsCQCABQcgBai0AAEUNACABQegA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IA8gASAPRhsiD0EANgIAIA8gCEEBayISQQBHQQJ0agshECAIQQFGDQADQCAPIBFqIhQgECABIBBGIhgbIghBADYCACAIIBJBAUdBAnRqIhMgECARaiABIBgbIgFGIQggFCAPIBgbIg8gEWoiECATIAgbIhhBADYCACARIBNqIAEgCBshASAQIA8gCBshDyAYIBJBAkdBAnRqIRAgEkECayISDQALCyAWQdABaigCACIBIBZB1AFqKAIAbCIIRQ0BIBZByAFqKAIAIg8gAUECdCIRaiEBAn8gCEEBcUUEQCAIIRIgDwwBCyABIA8gASAPRhsiD0EANgIAIA8gCEEBayISQQBHQQJ0agshECAIQQFGDQEDQCAPIBFqIhQgECABIBBGIhgbIghBADYCACAIIBJBAUdBAnRqIhMgECARaiABIBgbIgFGIQggFCAPIBgbIg8gEWoiECATIAgbIhhBADYCACARIBNqIAEgCBshASAQIA8gCBshDyAYIBJBAkdBAnRqIRAgEkECayISDQALDAELAkAgDyAPbCISRQRAQQQhEAwBCyASQf////8BSw0CIBJBAnQiCEEASA0CIBJBgICAgAJJQQJ0IQEgCAR/IAggARDQCgUgAQsiEEUNFyAQQQAgCBCtCxoLIBYoArABBEAgFkG0AWooAgAQhwELIBYgEjYCsAEgMiAPNgIAICwgDzYCACAWQbgBaiASNgIAIBZBtAFqIBA2AgACQCAWKAKQASIPIA9sIghFBEBBBCEQDAELIAhB/////wFLDQIgCEECdCISQQBIDQIgCEGAgICAAklBAnQhASASBH8gEiABENAKBSABCyIQRQ0PIBBBACASEK0LGgsgFigCxAEEQCAWQcgBaigCABCHAQsgFiAINgLEASAWQdQBaiAPNgIAIBZB0AFqIA82AgAgFkHMAWogCDYCACAWQcgBaiAQNgIACwJAIBZB/AFqIhsoAgAiGiAlKAIAIhNGDQACQCAWKAKQASISQQF0IhBFBEBBBCEYDAELIBBB/////wFLDQIgEkEDdCIIQQBIDQIgEEGAgICAAklBAnQhASAIBH8gCCABENAKBSABCyIYRQ0XIBhBACAIEK0LGiAbKAIAIRoLAkACQAJAIBMgGk0EQCAbIBM2AgAgEyAaRwRAIBpBBHQgE0EEdCIBayEPIBZB+AFqKAIAIAFq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IVICQCAmKAIQIgFBQGsoAgAiEiAIKAIAIh5NDQAgAUE8aigCACIIIB5BDGxqIhEoAgAgHEcNACASIBRNDQAgCCAUQQxsaiITKAIAIB1HDQAgAUEQaigCACISIBFBBGooAgAiCE0NACATKAIEIRMgAUEYaigCACERAkAgAUEMaigCACAIQQR0akEAIAggEkkbIh8oAggiCCABQRxqKAIAIgFJBEADQCARIAhBOGxqIidBDGooAgAgE0YNAiABICcoAgAiCEsNAAsLIAEgH0EMaigCACIITQ0BA0AgESAIQThsaiIfKAIIIBNGDQEgASAfKAIEIghLDQALDAELIAEgCE0NACARIAhBOGxqIgFBCGooAgAgEk8NACABQQxqKAIAIBJPDQAgAUEwaigCACIIRQ0AIAFBLGooAgAiEiAIQcQBbGohNkEAIRMDQCASIhFBxAFqIRICQCARQZABaigCACIIRQ0AIBFByABqIiciASEfIAhBJGwiN0EkayI6QSRuQQFqQQNxIggEQCAIQSRsIR9BACEIICchAQNAIAggEWoiPUHIAGogASA9QeAAaioCACABKgIYXRshASAfIAhBJGoiCEcNAAsgCCARakHIAGohHwsgOkHsAE8EQCAnIDdqIScgH0GEAWohCANAIAhBGGsgCEE8ayAIQeAAayAIQYQBayABIAhB7ABrKgIAIAEqAhhdGyIBIAhByABrKgIAIAEqAhhdGyIBIAhBJGsqAgAgASoCGF0bIgEgCCoCACABKgIYXRshASAIQQxqIR8gCEGQAWohCCAfICdHDQALCyABRQ0AIBNFBEAgESETIAEhGAwBCyAYIAEgGCoCGCABKgIYXyIBGyEYIBMgESABGyETCyASIDZHDQALIBNFDQAgGEEYaioCACFSCyAmKAIYIgFBxABqKAIAIggoAghBB2pBeHEhEiABKAJAIRFBACEBIBYEQCAWKgIAIU5BASEBCyAVQZgDaiARIBJqIAggHiAcIBQgHSAgICRBCGogECAaIAEgTiAlBH8gJSoCACFPQQEFQQALIE8gJigCHCoCACAmKAIgKgIAIFIQZSAVKAKwA0ECRg0AICYoAiQiEEEIaiITKAIAIgghASAQKAIAIAhGBEAgECAIEMoEIBMoAgAhAQsgEEEEaigCACISIAFBNGxqIhAgFSkDmAM3AgAgEEEwaiAV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QgAhWSAjQQhqQgA3AAAgI0IANwAAIBlCADcAACAZQQhqQgA3AAAgKSAEQcAFaiICQQhqKQAANwMAICggAkEPaigAADYAACArIARBqAVqIgJBCGopAAA3AwAgKiACQQ9qKAAANgAAIAQgBCkAwAU3A+gEIAQgBCkAqAU3A9AEQQAhEyAmQQA2AgAgJ0IANwMAIARCADcDgAUgLEEANgIAIARCADcDwARBByEDQ///f/8hY0P//39/IW5DAAAAACFpQwAAgD8hakEBIR1BACEeQwAAAAAhbUEAIR9D//9/fyFsQwAAAAAha0EAIRggbyFnIGghZiBYIVdDAACAPyFlQwAAAAAhZEP//39/IWJBACECQwAAAAAhYUP//3//IWBD//9/fyFfQwAAAAAhXkP//3//IV1D//9/fyFcQ///f38hW0MAAAAAIVoMBQsgFSAQQeifwQAQowcACyAFIBBB+J/BABCjBwALIAUgEEHYn8EAEKMHAAsgECAQQYigwQAQowcACyABIAxBmKDBABCjBwALIAEgASgCkAEgA0H/AXFpa0EDajYCkAEgESgCCCIIIBEoAgBGBEAgESAIEMQEIBEoAgghCAsgESgCBCAIQYQCbGoiASBYNwIIIAEgaDgCBCABIG84AgAgASAEKQOwAjcCECABIBU2AkAgASAEKQOYBTcCRCABQRhqIE4pAwA3AgAgAUEgaiBPKQMANwIAIAFBKGogUCkDADcCACABQTBqIFEpAwA3AgAgAUE4aiBSKQMANwIAIAFBzABqIFMoAgA2AgAgASBcOAKMASABIF04AogBIAEgXjgChAEgASBfOAKAASABIGA4AnwgASBhOAJ4IAEgYjgCdCABIGM4AnAgASBZNwJoIAEgZDgCZCABIGU4AmAgASBXNwJYIAEgZjgCVCABIGc4AlAgASAEKQOABTcCkAEgAUGYAWogJykDADcCACABQaABaiAmKAIANgIAIAEgAjoArAEgASBaOAKoASABIFs4AqQBIAEgHzoAyAEgASBtOALEASABIG44AsABIAEgBCkD6AQ3AK0BIAFBtQFqICkpAwA3AAAgAUG8AWogKCgAADYAACABIAQpA9AENwDJASABQdEBaiArKQMANwAAIAFB2AFqICooAAA2AAAgASAYOgDkASABIGs4AuABIAEgbDgC3AEgAUHnAWogVC0A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QQRyIQUCQCALKALsASIMKAI4IhBBMGooAgAiEiADKAIAIg9NDQAgEEEsaigCACAPQZABbGpBACAPIBJJGyIDKAIAQQFHDQAgAygCBCATRw0AIAsoAtwBIRIgCygC2AEhGCALKALoASEQIAsoAtQBIRkgCygC0AEhGiAMIAwoAjQiDEEgaigCACAMQSRqKAIAIA8gEyADQQhqIgwQnwJFDQAgC0EIaiIFIANBKGoiFCgCBCIVNgIEIAUgFCgCACAVKAIIQQdqQXhxajYCACALKAIMIRQgCygCCCEVIAsgDCoCACIIIAsoAuQBIgVBBGoqAgAiJZQgA0EMaioCACIkIAUqAgAiJpSTOAKsByALIAggJpQgJCAllJI4AqgHIAsgCCAFQQhqKgIAIANBEGoqAgCTIiWUICQgBUEMaioCACADQRRqKgIAkyImlJK8rSAIICaUICQgJZSTvK1CIIaENwOwByALIAggEEEEaioCACIllCAkIBAqAgAiJpSTOAK8ByALIAggJpQgJCAllJI4ArgHIAtBwAdqIBogC0GoB2ogC0G4B2ogFSAUIBggEiALKgLgASALLQDwASAZKAIgES4AAkACQCALLQDkByIQQQVHBEAgC0GAB2oiA0EgaiISIAtBwAdqIgVBIGoiGCgCADYCACADQRhqIhkgBUEYaiIaKQMANwMAIANBEGoiFCAFQRBqIhUpAwA3AwAgA0EIaiIDIAVBCGoiBSkDADcDACALQf4GaiIiIBdBAmoiIy0AADoAACALIAspA8AHNwOAByALIBcvAAA7AfwGIBBBBEcNAQsgC0EEOgD0BgwBCyAXIAsvAfwGOwAAIBggEigCADYCACAaIBkpAwA3AwAgFSAUKQMANwMAIAUgAykDADcDACAjICItAAA6AAAgCyALKQOABzcDwAcgCyAQOgDkByALQdAGaiIFIAtBwAdqIgMqAiA4AiAgBSADLQAkOgAkIAUgAykCGDcCGCAFIAMpAgg3AgggBSADKgIEIiUgDCoCACIIlCADKgIAIiYgDEEEaioCACIklJIgDEEMaioCAJI4AgQgBSAMQQhqKgIAICYgCJQgJSAklJOSOAIAIAUgCCADKgIQIiWUICQgA0EUaioCACImlJO8rSAkICWUIAggJpSSvK1CIIaENwIQCyALQcAHaiIDQQhqIAtB0AZqIgVBCGopAwA3AwAgA0EQaiAFQRBqKQMANwMAIANBGGogBUEYaikDADcDACALIAspA9AGNwPAByALKgLwBiEkIAsoAvQGIQULIAVB/wFxQQRGDQAgC0GQBWogB2oiAyAPNgIAIAQgJCAnXToAACALQfgEaiAKaiAkOAIAIANBBGogEzYCACADQQhqIAspA8AHNwIAIANBEGogC0HAB2oiDEEIaikDADcCACADQRhqIAxBEGopAwA3AgAgA0EgaiAMQRhqKQMANwIAIANBLGogBTYCACADQShqICQ4AgALIAdBMGohByAEQQFqIQQgCkEEaiEKIENCBFINAAsgC0HgA2oiBEEQaiALQZAFaiIDQRBqKQMANwMAIARBGGogA0EYaikDADcDACAEQSBqIANBIGopAwA3AwAgBEEoaiADQShqKAIANgIAIAsgCykDkAU3A+ADIAsgA0EIaikDADcD6AMgCyoChAUhJiALKgKABSEIIAsqAvwEISUgCyoC+AQhJCALKAKMBSEKIAtBsANqIgNBCGogDkEIaikAADcDACADQRBqIA5BEGopAAA3AwAgA0EYaiAOQRhqKQAANwMAIANBIGogDkEgaikAADcDACADQSdqIA5BJ2opAAA3AAAgC0GAA2oiA0EIaiANQQhqKQAANwMAIANBEGogDUEQaikAADcDACADQRhqIA1BGGopAAA3AwAgA0EgaiANQSBqKQAANwMAIANBJ2ogDUEnaikAADcAACALIA4pAAA3A7ADIAsgDSkAADcDgAMgCy0AvAUhByALLQDsBSEEIAtB0AJqIgNBCGogCUEIaikAADcDACADQRBqIAlBEGopAAA3AwAgA0EYaiAJQRhqKQAANwMAIANBIGogCUEgaikAADcDACADQSdqIAlBJ2opAAA3AAAgC0HOAmogFkECai0AADoAACALIAkpAAA3A9ACIAsgFi8AADsBzAIgCkH/AXFBAkcEQCALLQCcBiEPIAstAMwGDAMLIAdB/wFxQQRGDQMgC0GbBWogCykD6AM3AAAgC0G7BWogC0GIBGooAgA2AAAgC0GzBWogC0HgA2oiAUEgaikDADcAACALQasFaiABQRhqKQMANwAAIAtBowVqIAFBEGopAwA3AAAgC0HCB2ogCy0AsgM6AAAgCyALKQPgAzcAkwUgC0GQBGoiAUEIaiALQZAFaiICQQhqKQAANwMAIAFBJ2ogAkEnaikAADcAACABQSBqIAJBIGopAAA3AwAgAUEYaiACQRhqKQAANwMAIAFBEGogAkEQaikAADcDACALIAsvAbADOwHAByALIAspAJAFNwOQBCAHIQIMBQsgAyAFQaTawAAQowcACyAKQf8BcUECRg0BQQQhB0EEIQRBBCEPQQQLIQwgBkHYAGohEyAOIAspA7ADNwAAIAtBkAVqIgNBCGogCykD6AM3AwAgA0EoaiALQeADaiIFQShqKAIANgIAIANBIGogBUEgaikDADcDACADQRhqIAVBGGopAwA3AwAgA0EQaiAFQRBqKQMANwMAIA5BCGogC0GwA2oiA0EIaikDADcAACAOQRBqIANBEGopAwA3AAAgDkEYaiADQRhqKQMANwAAIA5BIGogA0EgaikDADcAACAOQSdqIANBJ2opAAA3AAAgCyALKQPgAzcDkAUgCyAHOgC8BSANIAspA4ADNwAAIA1BCGogC0GAA2oiA0EIaikDADcAACANQRBqIANBEGopAwA3AAAgDUEYaiADQRhqKQMANwAAIA1BIGogA0EgaikDADcAACANQSdqIANBJ2opAAA3AAAgCSALKQPQAjcAACAJQQhqIAtB0AJqIgNBCGopAwA3AAAgCUEQaiADQRBqKQMANwAAIAlBGGogA0EYaikDADcAACAJQSBqIANBIGopAwA3AAAgCUEnaiADQSdqKQAANwAAIAsgBDoA7AUgCyAPOgCcBiAWIAsvAcwCOwAAIBZBAmogC0HOAmotAAA6AAAgCyAMOgDMBiALICY4AswHIAsgCDgCyAcgCyAlOALEByALICQ4AsAHIApBFXZBCHEgCkEOdkEEcSAKQQd2QQJxIApBAXFycnKtIUUgAUEYaigCACEFIAFBPGooAgAhDEIAIUMDQCBDIkRCAXwhQwJAIEUgRIinQQFxRQ0AIESnIQMgEy0AAEEBcQRAIANBAnQiByALQcAHamoqAgAiCCAnXUUNASALQZAFaiADQTBsaiIELQAsIgNBBEYNASAMIAYgB2pBQGsoAgBNDQEgESAEKQAANwAAIBFBKGogBEEoaigAADYAACARQSBqIARBIGopAAA3AAAgEUEYaiAEQRhqKQAANwAAIBFBEGogBEEQaikAADcAACARQQhqIARBCGopAAA3AAAgC0GOAmogBEEv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CARAA0AgASABNQIAQgV+IB98Ih8+AgAgAUEEaiEBIB9CIIghHyAIQQFrIggNAAsLIB+nIgFFDQAgDkEnSw0BIAZBsAFqIA5BAnRqIAE2AgAgDkEBaiEOCyAGIA42AtACIAYoAqgBIgEgDiABIA5LGyIBQSlPDQUgAUECdCEBAkADQCABBEBBfyABQQRrIgEgBkGwAWpqKAIAIgkgASAGQQhqaigCACIHRyAHIAlJGyIIRQ0BDAILC0F/QQAgARshCAsCQAJAIAhB/wFxDgIAAQULIAVFDQQgCkEBayIBIANPDQIgASACai0AAEEBcUUNBAsgAyAKSQ0CQQAhASACIQgCQANAIAEgCkYNASABQQFqIQEgCiAIQQFrIghqIgUtAABBOUYNAAsgBSAFLQAAQQFqOgAAIAogCiABa0EBak0NBCAFQQFqQTAgAUEBaxCtCxoMBAsCf0ExIApFDQAaIAJBMToAAEEwIApBAUYNABogAkEBakEwIApBAWsQrQsaQTALIQEgEkEQdEGAgARqQRB1IhIgBEEQdEEQdUwNAyADIApNDQMgAiAKaiABOgAAIApBAWohCgwDCyAOQShByLLDABCjBwALIAEgA0GoisMAEKMHAAsgCiADQbiKwwAQlwsACyADIApPDQAgCiADQciKwwAQlwsACyAAIBI7AQggACAKNgIEIAAgAjYCACAGQdAGaiQADwsgAUEoQciywwAQlwsACyAFQShByLLDABCXCwALQdiywwBBGkHIssMAEMkIAAvZJwMIfwJ9AX4jAEEQayIJJAAgCUEIaiAAKAIAIAAoAgQiACgCCEEHakF4cWogACgCmAERAAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAkoAghBAWsODgECAwQFBgcICQoLDA0OAAsgCSgCDCEDIAEoAgAiASgCCCECIAEoAgAgAmtBA00EQCABIAJBBBDuBCABKAIIIQILQQAhACABKAIEIAJqQQA2AAAgASACQQRqIgI2AgggAyoCACEKIAEoAgAgAmtBA00EQCABIAJBBBDuBCABKAIIIQILIAEgAkEEajYCCCABKAIEIAJqIAo4AAAMDwsgCSgCDCEAIAEoAgAiAygCCCECIAMoAgAgAmtBA00EQCADIAJBBBDuBCADKAIIIQILIAMgAkEEajYCCCADKAIE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BBDuBCAAKAIIIQILIAAgAkEEajYCCCAAKAIEIAJqQQ02AAAgAyABEIcDIgANAiADKgIYIQogASgCACIAKAIIIQEgACgCACABa0EDTQRAIAAgAUEEEO4EIAAoAgghAQsgACABQQRqNgIIIAAoAgQgAWogCjgAAAwBCyAJKAIMIQAgASgCACIDKAIIIQEgAygCACABa0EDTQRAIAMgAUEEEO4EIAMoAgghAQsgAygCBCABakEONgAAIAMgAUEEaiIBNgIIIAMoAgAgAWtBA00EQCADIAFBBBDuBCADKAIIIQELIAMgAUEEajYCCCADKAIEIAFqIAA2AAALQQAhAAsgCUEQaiQAIAALlCUDIH8mfQR+IwBB4AVrIgokACAKQfACaiAGIAIgBygCiAERAgAgCkHcAGogCioC9AIgCkH8AmoqAgCSQwAAAL+UIio4AgAgCkHYAGogKjgCACAKQdQAaiAqOAIAIApB0ABqICo4AgAgCkHMAGogCioC8AIgCioC+AKSQwAAAL+UIiw4AgAgCkHIAGogLDgCACAKQcQAaiAsOAIAIApB7ABqIAopA/gCIlGnviAKKQPwAiJQp76TQwAAAD+UIis4AgAgCkHoAGogKzgCACAKQeQAaiArOAIAIApB/ABqIFFCIIinviBQQiCIp76TQwAAAD+UIio4AgAgCkH4AGogKjgCACAKQfQAaiAqOAIAIApB8ABqICo4AgAgCiAsOAJAIAogKzgCYCADKQIAIVAgCkEYakIANwMAIApBEGpCADcDACAKQYQBaiAFNgIAIApBjAFqIAc2AgAgCkIANwMIIApCADcDACAKIFCnIgc2AiAgCiAHNgIkIAogBzYCKCAKIAc2AiwgCiBQQiCIpyIHNgIwIAogBzYCNCAKIAc2AjggCiAHNgI8IAogATYClAEgCiACNgKYASAKIAM2ApwBIAogBDYCgAEgCiAGNgKIASAKIAg4ApABIAogCToAoAECQAJAIAQgBSgCEBEEACIPQRhqKAIAIg0EQCAKQQA2AsABIApCgICAgMAANwO4ASAKQbgBaiICQQAQvwQgCigCvAEgCigCwAEiAUEDdGpCgICAgPD///9+NwIAIAogAUEBajYCwAEgCkHgAWogAhCAAgJAAkAgCigC4AFBAUcEQEEEIQEMAQsgCkGgAWohECAKQZABaiERIApBmAFq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KgIAIhggA0EMaioCACIelJI4AgQgCCAYICOUIBkgHpSTOAIAIAggA0EQaioCACAfICOUICAgHpSTkrytICAgI5QgHyAelJIgA0EUaioCAJK8rUIghoQ3AwggCCAcIA0qAggiGZQgHSANQQxqKgIAIhiUkjgCFCAIIB0gGZQgHCAYlJM4AhAgCCANQRBqKgIAIBogGZQgGyAYlJOSvK0gGyAZlCAaIBiUkiANQRRqKgIAkrytQiCGhDcDGCAIQX82AkAgCCADQZABaioCADgCOCAIIANBiAFqKQMANwMgIAggA0H0AGoqAgA4AjwgCCADQegAaikDADcDKCAIIANB4ABqKQMANwMwIAggDUGQAWoqAgA4AmAgCCANQYgBaikDADcDSCAIIA1B9ABqKgIAOAJkIAggDUHoAGopAwA3A1AgCCANQTBqKAIANgJoIAggDUHgAGopAwA3A1gCQAJAIARBIGooAgAgDk0NACAEQRxqKAIAIg0gDkEUbGooAgAgCUcNACANIA5BFGxqIgwoAgQiCSAEQcgAaigCACIDTw0FIARBxABqKAIAIAlBlAJsaiILQQAgAyAJSxsiAy0AjAJBAkYNBSADKAKQAiAMQQhqKAIARw0FIAsoApABIgNFDQcgDSAOQRRsakEQaigCACESIAUoAgAgA0EGbGoiAyAGQQxqKAIASw0BDAYLIAhBuAFqQgA3AwAgCEGgAWoiA0EQakIANwMAIAhBqAFqQgA3AwAgA0EwakIANwMAIAhB2AFqQgA3AwAgCEHgAWpCADcDACAIQegBakIANwMAIAhB8AFqQgA3AwAgCEH4AWpCADcDACADQeAAakEANgIAIAhBjAJqQgA3AgAgCEGEAmpCfzcCACADQfQAakIANwIAIAhBnAJqQgA3AgAgCEGkAmpCADcCACAIQawCakIANwIAIAhBtAJqQgA3AgAgCEG8AmpCADcCACAIQcQCakEANgIAIAhCADcDoAEgCEIANwPIASAIQn83A8ABIAhB0AJqQgA3AwAgCEHIAmpCfzcDACAIQdgCakIANwMAIAhB4AJqQgA3AwAgCEHoAmpCADcDACAIQfACakIANwMAIAhB+AJqQgA3AwAgCEGAA2pCADcDACAIQYgDakEANgIAIAhBjANqQn83AgAgCEGUA2pCADcCACAIQZwDakIANwIAIAhBpANqQgA3AgAgCEGsA2pCADcCACAIQbQDakIANwIAIAhBvANqQgA3AgAgCEHEA2pCADcCACAIQcwDakEANgIAIAhBkARqQQA2AgAgCEHQA2pCfzcDACAIQYgEakIANwMAIAhBgARqQgA3AwAgCEH4A2pCADcDACAIQfADakIANwMAIAhB6ANqQgA3AwAgCEHgA2pCADcDACAIQdgDakIANwMAIAhB1ARqQQA2AgAgCEGUBGpCfzcCACAIQcwEakIANwIAIAhBxARqQgA3AgAgCEG8BGpCADcCACAIQbQEakIANwIAIAhBrARqQgA3AgAgCEGkBGpCADcCACAIQZwEakIANwIAIAhB2ARqQn83AwAgCEGYBWpBADYCACAIQZAFakIANwMAIAhBiAVqQgA3AwAgCEGABWpCADcDACAIQfgEakIANwMAIAhB8ARqQgA3AwAgCEHoBGpCADcDACAIQeAEakIANwMAIAhBnAVqQn83AgAgCEHcBWpBADYCACAIQdQFakIANwIAIAhBzAVqQgA3AgAgCEHEBWpCADcCACAIQbwFakIANwIAIAhBtAVqQgA3AgAgCEGsBWpCADcCACAIQaQFakIANwIAIAhB4AVqQn83AwAgCEGgBmpBADYCACAIQZgGakIANwMAIAhBkAZqQgA3AwAgCEGIBmpCADcDACAIQYAGakIANwMAIAhB+AVqQgA3AwAgCEHwBWpCADcDACAIQegFakIANwMAIAhBpAZqQn83AgAgCEHkBmpBADYCACAIQdwGakIANwIAIAhB1AZqQgA3AgAgCEHMBmpCADcCACAIQcQGakIANwIAIAhBvAZqQgA3AgAgCEG0BmpCADcCACAIQawGakIANwIAIAhB6AZqQn83AwAgCEGoB2pBADYCACAIQaAHakIANwMAIAhBmAdqQgA3AwAgCEGQB2pCADcDACAIQYgHakIANwMAIAhBgAdqQgA3AwAgCEH4BmpCADcDACAIQfAGakIANwMAIAhBrAdqQn83AgAgCEHMB2pBADYCACAIQcQHakIANwIAIAhBvAdqQgA3AgAgCEG0B2pCADcCACAIQSBqIRMgCEHIAGohDyADIQQjAEHQAGsiCyQAIAItAJoBIQMgCEEQaiIMKQIIIjJCIIinviIaIAgpAggiMUIgiKe+kyEpIAItAJgBIhRBf3MhBiAyp74iGyAx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j8EAQRNB3LrBABCaCwALIAhBxAFqQgA3AgAgCEHMAWpCADcCACAIQdQBakEANgIAIAhB9AFqQgA3AgAgCEHwAWpBfzYCACAIQegBakL/////DzcDACAIQeABakIANwMAIAhB/AFqQgA3AgAgCEGEAmpCADcCACAIQYwCakEANgIAIAhBoAJqQv////8PNwMAIAhBmAJqQgA3AwAgCEGoAmpBfzYCACAIQgA3ArwBIAhBfzYCuAEgCEL/////DzcDsAEgCEIANwOoASAIQv////v///+//wA3A6ABIAhC////+////7//ADcD2AEgCEL////7////v/8ANwOQAiAIQcQCakEANgIAIAhBvAJqQgA3AgAgCEG0AmpCADcCACAIQawCakIANwIAIAhB4AJqQX82AgAgCEHQAmpCADcDACAIQdgCakL/////DzcDACAIQeQCakIANwIAIAhB7AJqQgA3AgAgCEH0AmpCADcCACAIQfwCakEANgIAIAhBmANqQX82AgAgCEGIA2pCADcDACAIQZADakL/////DzcDACAIQZwDakIANwIAIAhBpANqQgA3AgAgCEGsA2pCADcCACAIQbQDakEANgIAIAhC////+////7//ADcDyAIgCEL////7////v/8ANwOAAyAIQdADakF/NgIAIAhByANqQv////8PNwMAIAhBwANqQgA3AwAgCEHsA2pBADYCACAIQeQDakIANwIAIAhB3ANqQgA3AgAgCEHUA2pCADcCACAIQYAEakL/////DzcDACAIQfgDakIANwMAIAhBiARqQX82AgAgCEGkBGpBADYCACAIQZwEakIANwIAIAhBlARqQgA3AgAgCEGMBGpCADcCACAIQbgEakL/////DzcDACAIQbAEakIANwMAIAhBwARqQX82AgAgCEL////7////v/8ANwO4AyAIQv////v///+//wA3A/ADIAhC////+////7//ADcDqAQgCEHcBGpBADYCACAIQdQEakIANwIAIAhBzARqQgA3AgAgCEHEBGpCADcCACAIQfgEakF/NgIAIAhB8ARqQv////8PNwMAIAhB6ARqQgA3AwAgCEL////7////v/8ANwPgBCAIQZQFakEANgIAIAhBjAVqQgA3AgAgCEGEBWpCADcCACAIQfwEakIANwIAIAhBsAVqQX82AgAgCEGoBWpC/////w83AwAgCEGgBWpCADcDACAIQv////v///+//wA3A5gFIAhBzAVqQQA2AgAgCEHEBWpCADcCACAIQbwFakIANwIAIAhBtAVqQgA3AgAgCEHoBWpBfzYCACAIQeAFakL/////DzcDACAIQdgFakIANwMAIAhC////+////7//ADcD0AUgCEGEBmpBADYCACAIQfwFakIANwIAIAhB9AVqQgA3AgAgCEHsBWpCADcCACAIQaAGakF/NgIAIAhBmAZqQv////8PNwMAIAhBkAZqQgA3AwAgCEL////7////v/8ANwOIBiAIQbwGakEANgIAIAhBtAZqQgA3AgAgCEGsBmpCADcCACAIQaQGakIANwIAIAEhAyAIQSBqIQ4gCEHIAGohCSAIQaABaiEQIwBBkAFrIgokACAIQRBqIgEpAggiMkIgiKe+IhogCCkCCCIxQiCIp76TISMgMqe+IhsgMae+kyEeIAgqAgQhIiAIKgIAISEgGyEZIBohGCACLQCYASIXQQFxIhUEQCAaICIgISAelCAiICOUkiIZlJMhGCAbICEgGZSTIRkLIAItAJoBIQwgCSkCECEyIA4pAhAhMSAXQQJxIg0EQCAYICEgISAjlCAiIB6UkyIclJMhGCAiIByUIBmSIRkLIAItAJkBIRYgCkHkAGogASoCACIgOAIAIApB3ABqIAFBBGoqAgAiHzgCACAKQeAAaiAfjDgCACAKICI4AkwgCkGEAWogISAflCAiICCUkyIdOAIAIApB9ABqICEgGyAyp76TIhyUICIgGiAyQiCIp76TIhuUkjgCACAKQewAaiAhIBkgMae+kyIZlCAiIBggMUIgiKe+kyIYlJI4AgAgCiAhOAJUIAogITgCSCAKICA4AlggCiAijDgCUCAKIB68rSAjvK1CIIaENwN4IAogISAglCAiIB+UkiIaOAKAASAKIBogGpI4AogBIAogIiAclCAhIBuUkyIjOAJwIAogIiAZlCAhIBiUkyIcOAJoIAlBGGoqAgAhLCAOKgIYIScgBkEMaigCACERIAZBBGooAgAhDyALKAKUASETIAsoApABIRQgACoCACIkICSUIS1BACEBIAxBEHEEQCACQfwAaioCACEaIAJBgAFqKgIAIRsgAkGMAWoqAgAhGSACQZQBai0AACEEIAJBhAFqKgIAIS8gAkGI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NwO4ASAIQv////v///+//wA3A7ABIAhC////+////7//ADcD+AEgCEHIAmpCADcDACAIQdACakIANwMAIAhB2AJqQgA3AwAgCEHgAmpCADcDACAIQegCakIANwMAIAhB8AJqQgA3AwAgCEH4AmpCADcDACAIQf4CakIANwEAIAhBkANqQgA3AwAgCEGYA2pCADcDACAIQaADakIANwMAIAhBqANqQgA3AwAgCEGwA2pCADcDACAIQbgDakIANwMAIAhBwANqQgA3AwAgCEHGA2pCADcBACAIQv////v///+//wA3A8ACIAhC////+////7//ADcDiAMgCEGOBGpCADcBACAIQYgEakIANwMAIAhBgARqQgA3AwAgCEH4A2pCADcDACAIQfADakIANwMAIAhB6ANqQgA3AwAgCEHgA2pCADcDACAIQdgDakIANwMAIAhB1gRqQgA3AQAgCEHQBGpCADcDACAIQcgEakIANwMAIAhBwARqQgA3AwAgCEG4BGpCADcDACAIQbAEakIANwMAIAhBqARqQgA3AwAgCEGgBGpCADcDACAIQv////v///+//wA3A9ADIAhC////+////7//ADcDmAQgCEL////7////v/8ANwPgBCAIQZ4FakIANwEAIAhBmAVqQgA3AwAgCEGQBWpCADcDACAIQYgFakIANwMAIAhBgAVqQgA3AwAgCEH4BGpCADcDACAIQfAEakIANwMAIAhB6ARqQgA3AwAgCEL////7////v/8ANwOoBSAIQeYFakIANwEAIAhB4AVqQgA3AwAgCEHYBWpCADcDACAIQdAFakIANwMAIAhByAVqQgA3AwAgCEHABWpCADcDACAIQbgFakIANwMAIAhBsAVqQgA3AwAgCEL////7////v/8ANwPwBSAIQa4GakIANwEAIAhBqAZqQgA3AwAgCEGgBmpCADcDACAIQZgGakIANwMAIAhBkAZqQgA3AwAgCEGIBmpCADcDACAIQYAGakIANwMAIAhB+AVqQgA3AwAgCEL////7////v/8ANwO4BiAIQfYGakIANwEAIAhB8AZqQgA3AwAgCEHoBmpCADcDACAIQeAGakIANwMAIAhB2AZqQgA3AwAgCEHQBmpCADcDACAIQcgGakIANwMAIAhBwAZqQgA3AwAgCEL////7////v/8ANwOAByAIQb4H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aiADQRBqKQAANwMAIAFBGGogA0EYaikAADcDACABQSBqIANBIGopAAA3AwAgAUEnaiADQSdqKAAANgAAIAsgCy8BnAI7AZAFIAsgCykA6AI3A9AFIAIhAQsgCygCOEUNASALKAI8EIcBDAELIAtB0AVqIgJBCGogC0HIAGoiA0EIaikDADcDACACQRBqIANBEGopAwA3AwAgAkEYaiADQRhqKQMANwMAIAJBIGogA0EgaikDADcDACACQSdqIANBJ2ooAAA2AAAgC0GSBWogC0HGAGotAAA6AAAgCyALKQNINwPQBSALIAsvAUQ7AZAFIAsoAjhFDQAgCygCPBCHAQsgAUH/AXFBBEcNAQsgAEEEOgAkDAELIAtB6AJqIgJBCGogC0HQBWoiA0EIaikDADcDACACQRBqIANBEGopAwA3AwAgAkEYaiADQRhqKQMANwMAIAJBIGogA0EgaikDADcDACACQSdqIgIgA0EnaigAADYAACAAIAsvAZAFOwAlIABBJ2ogC0GSBWotAAA6AAAgCyALKQPQBTcD6AIgACALKQDvAjcAACAAQQhqIAtB9wJqKQAANwAAIABBEGogC0H/AmopAAA3AAAgAEEYaiALQYcDaikAADcAACAAQSBqIAIoAAA2AAAgACABOgAkCyALQZAGaiQAC98gAxx/A34OfSMAQeACayIKJAAgCiAJOgAWIAogBjgCECMAQRBrIg0kAAJAAkACQAJAIAgoAgAiDkUNACANQQhqIA4gCEEEaigCACgCGBEAACANKAIIIgkgDSgCDEEMaigCABEGACEmIAlFDQAgJkL74OCRo76q39UAUQ0BC0EgQQQQ0AoiCUUNASAJQQA6ABwgCUEANgIYIAlCgICAgMAANwIQIAlB6PXBADYCDCAJQQA2AgggCUIANwIAAkAgDkUNACAOIAgoAgQiDCgCABEHACAMQQRqKAIARQ0AIAxBCGooAgAaIA4QhwELIAhBnJLCADYCBCAIIAk2AgALIA1BEGokAAwBC0EgQQRBwMPDACgCACIAQaQGIAAbEQAAAAsCQAJAAkACQCAIKAIAIgkEQCAKQQhqIAkgCCgCBCgCHBEAACAKKAIIIg4gCigCDEEMaigCABEGACEmAkAgDkUNACAmQvvg4JGjvqrf1QBSDQAgDiAOLQAcQQFzIgg6ABwgCiAIOgAXIAQg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IAghByAJIQYgAioCGCAeXUUNAANAAkAgBkEIaiAGQRRqKAIANgIAIAYiAiAGQQxqIgYpAgA3AgAgB0EBayIHRQ0AIAJBGGoqAgAgHl0NAQsLIAJBDGohCgsgCiAgNwIEIAogHjgCAAsgCEEBaiEIIAlBDGshCSADDQALCyAAQRxqKAIAIgkgAEEQaiINKAIAIghqIQwCQCAIIAxPBEAgDCEGDAELIAkgACgCCCAIIgZrSwRAIABBCGogCCAJELQEIABBEGooAgAhBgsgAEEMaigCACAGQQN0aiEDIAlBAk8EQCAJQQFrIgdBB3EhAiAJQQJrQQdPBEAgB0F4cSEHA0AgA0L////79/////8ANwIAIANBOGpC////+/f/////ADcCACADQTBqQv////v3/////wA3AgAgA0EoakL////79/////8ANwIAIANBIGpC////+/f/////ADcCACADQRhqQv////v3/////wA3AgAgA0EQakL////79/////8ANwIAIANBCGpC////+/f/////ADcCACADQUBrIQMgB0EIayIHDQALCyACBEADQCADQv////v3/////wA3AgAgA0EIaiEDIAJBAWsiAg0ACwsgBiAJakEBayEGCyAJBEAgA0L////79/////8ANwIAIAZBAWohBgsgAEEcaigCACEJCyANIAY2AgAgCQRAIAhBAmshBiAMQQJrIQMgAEEYaigCACINIAlBDGxqIQ8gAEEQaiEIAkACQANAAkACQCAIKAIAIgkgBksEQCAPQQxrIQ8gBkEDdCECIANBA3QhBwNAIABBDGooAgAiDCACaiIKKgIAIh4gDyoCACIfXw0CIAMgCU8NAyAHIAxqIgxBBGogCkEEaigCADYCACAMIB44AgAgAkEIayECIAdBCGshByADQQFrIQMgBkEBayIGIAgoAgAiCUkNAAsLIAYgCUH018EAEKMHAAsgAyAJTw0CIAcgDGoiAkEEaiAPQQRqKAIANgIAIAIgHzgCACAPQQhqIAM2AgAgA0EBayEDIA0gD0cNAQwDCwsgAyAJQZTYwQAQowcACyADIAlBhNjBABCjBwALIABBEGooAgAhBgsgBkEBayEMAkAgBgRAIAVFDQIgAEEMaigCACENIABBHGoiAigCACEDIAJBADYCACADQQxsIQMgAEEYaigCACEKIARBDGoo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IhIgDSgCBEcNBCAKQdAAaioCACEfIApB1ABqKgIAISAgCCkCCCEoIAgqAgQhISAIKgIAISIgAUE0aiAeIBwgDUHQAGoqAgAiJJQgHSANQdQAaioCACIllJKSIB4gHCAQKgIAIh6UIB0gDyoCACImlJKSIieTOAIAIAFBMGogIyAdICSUIBwgJZSTkiAjIB0gHpQgHCAmlJOSIhyTOAIAIAFBLGogJyAhIB+UICIgIJSSIChCIIinvpKTOAIAIAFBKGogHCAiIB+UICEgIJSTICinvpKTOAIAIAMoAgBBAUcNBSADKAIEIBJHDQUgASkCACEoIANBIGogESkCADcCACADQRhqICg3AgAgA0HhAWotAAANBiAFQQFqIQUgAkUNCSAEQQhqIANB0ABqIgggARC1CCADQeAAaiAEKQMINwIAIANB7ABqIANB2ABqKAIAIgo2AgAgA0HoAGogCjYCACADQfQAaiAIKgIMOAIAIANB+ABqLQAAIghBAXENBwwICyAJIAlB8KvBABCjBwALIARBFGpBATYCACAEQRxqQQA2AgAgBEGwrMEANgIQIARB9L7AADYCGCAEQQA2AgggBEEIakG4rMEAELwJAAsgBEEUakEBNgIAIARBHGpBADYCACAEQeCswQA2AhAgBEH0vsAANgIYIARBADYCCCAEQQhqQeiswQAQvAkAC0GUj8EAQRNBsKfBABCaCwALQZSPwQBBE0HAp8EAEJoLAAtBlI/BAEETQZDRwQAQmgsACyAEQQA2AhwgBEH0vsAANgIYIARBATYCFCAEQZSowQA2AhAgBEEANgIIIwBBIGsiACQAIABBoMDAADYCBCAAIANB4QFqNgIAIABBCGoiAUEQaiAEQQhqIgJBEGopAgA3AwAgAUEIaiACQQhqKQIANwMAIAAgAikCADcDCEEAIABBtM7AACAAQQRqQbTOwAAgAUGcqMEAELsCAAsgA0EANgJoCyAIQQJxBEAgA0EANgJsCyAIQSBxRQ0AIANBADYCdAsgAUGEAmohASAFIAlHDQALIABBoAFqKAIAIgpFDQELIAAoApABIgJBDGwhDCACQQNsIg1BgICAgAJJQQJ0IQYgAEGoAWooAgAhDyAAQawBaigCACEQIABBnAFqKAIAIRIgBEEoaiEWIARBCGoiAEEYaiEXIABBEGohGCAAQQhqIRkgDUH/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AEEBcSIAOgCAAgJAIABFBEBBACEIQdTDwwAoAgBB/////wdxBEBBxMfDACgCAEVFIQgLIActAAENASAGQegAaiAHQRxqELICAkACQAJAIAYoAnAiAARAIAYgBigCbCIENgJgIAhFBEACQEHUw8MAKAIAQf////8HcUUNAEHEx8MAKAIARQ0AIAdBAToAAQsgBigCYCEECyAHQQA6AAAgBA0BQeTBwABBK0HUyMAAEMkIAAsgB0E0ai0AAA0BIAYgCDoAlAEgBiAHNgKQASAGIBQ4AowBIAYgBTgCiAEgBiAYNwOAASAGIAE4AnwgBiATOAJ4IAYgCzYCdCAGIAw2AnAgBiANNgJsIAYgDjYCaCAGIAZBFGo2AqABIAYgBkEYajYCnAEgBiAGQSxqNgKYAQJAQaS9wwAoAgANABCDByECQai9wwAoAgAhAEGovcMAIAI2AgBBpL3DACgCACECQaS9wwBBATYCACACRQ0AIABFDQAgACAAKAIAIgJBAWs2AgAgAkEBRw0AIAAQqAgLQai9wwAoAgAhAEGovcMAQQA2AgACQCAARQRAIAYQgwciADYCgAIgBkHQAWogBkHoAGogBkGAAmoQaiAAIAAoAgAiAEEBazYCACAAQQFHDQEgBigCgAIQqAgMAQsgAEEQakIANwIAIAYgADYCqAEgBkGAAmogBkHoAGogBkGoAWoQakGovcMAKAIAIQJBqL3DACAANgIAAkAgAkUNACACIAIoAgAiAEEBazYCACAAQQFHDQAgAhCoCAsgBkHQAWoiAEEoaiAGQYACaiICQShqKAIANgIAIABBIGogAkEgaikDADcDACAAQRhqIAJBGGopAwA3AwAgAEEQaiACQRBqKQMANwMAIABBCGogAkEIaikDADcDACAGIAYpA4ACNwPQAQsgBkGwAWoiAiAGQdABaiIAQQxqKQIANwMAIAZBuAFqIgMgAEEUaikCADcDACAGQcABaiIEIABBHGopAgA3AwAgBkHIAWoiCCAAQSRqKQIANwMAIAYgBikC1AE3A6gBAkAgBigC0AEiB0EDRwRAIAZBgAJqIgBBDGogAikDADcCACAAQRRqIAMpAwA3AgAgAEEcaiAEKQMANwIAIABBJGogCCkDADcCACAGIAc2AoACIAYgBikDqAE3AoQCDAELIAYQgwciADYC0AEgBkGAAmogBkHo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BEE8aigCACESIARBFGooAgAhGwNAIAwgBUEBayIFNgLIAQJAAkAgCSAFQQJ0aigCACIAIA9JBEAgGyAAQeAAbGoiBC0AWEEBcUUNASAEQcQAaigCACEAIARByABqKAIAIQIgBEHMAGooAgAhAyAEKAJAIQYgDEHQAWogBCAMQfAAahDhAiAMIBEgBkEEdGpBACAGIBJJGyIGQQhqQQAgBhs2AuABIAwgESADQQR0akEAIAMgEkkbIgNBCGpBACADGzYC7AEgDCARIAJBBHRqQQAgAiASSRsiAkEIakEAIAIbNgLoASAMIBEgAEEEdGpBACAAIBJJGyIAQQhqQQAgABs2AuQBIAwtANMBIhZBA3RBCHEgDC0A0gEiF0ECdEEEcSAMLQDRASIYQQF0QQJxIAwtANABIhVBAXFycnKtIS1CACErA0ACQCAtICuIQgGDUA0AIAxB4AFqICunQQJ0aigCACICRQ0AIAwoArABIgMoAggiBkEwaigCACIHIAIoAgAiAE0NACAGQSxqKAIAIABBkAFsakEAIAAgB0kbIgYoAgBBAUcNACACQQRqKAIAIgIgBigCBEcNACADKAIMIAMoAhAiB0EgaiILKAIAIAdBJGoiEygCACAAIAIgBkEIaiINEJ8CRQ0AIAMoAhQiCkEIaiICKAIAIQAgAkEANgIAIApBBGohCCAABEAgAEHEAWwhByAIKAIAQZABaiEAA0AgACgCAARAIABBADYCAAsgAEHwAGsoAgAEQCAAQewAaygCABCHAQsgAEHEAWohACAHQcQBayIHDQALCyAMIAMoAhgiFCgCACIAKgIAIgEgBkEMaiIcKgIAIiSUIABBBGoqAgAiIiANKgIAIiOUkzgC9AEgDCABICOUICIgJJSSOALwASAMIAEgBkEQaioCACAAQQhqKgIAkyIklCAiIAZBFGoiHSoCACAAQQxqKgIAkyIjlJK8rSABICOUICIgJJSTvK1CIIaENwP4ASADKAIcIQAgAygCACEHIAMoAgQhDSAMIAZBKGoiDigCBCIQNgIEIAwgDigCACAQKAIIQQdqQXhxajYCACADKAIgIh4qAgAhASAMKAIEIQ4gDCgCACEQIAxBADYCgAIgACAMQfABaiAHIA0gECAOIAEgCiAMQYACahAmGgJAIAwoAoACIgBFDQAgACAMKAKEAigCABEHACAM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IAFFDQEgASAINgIAIAEgBSkDEDcCBCABQQE6ABggAUEMaiAFQRhqKQMANwIAIAFBFGogBUEgaigCADYCAAwCCyAGQTRqLQAADQIgBUGMAWogBUEYaikDADcCACAFQZQBaiAFQSBqKAIANgIAIAUgCDYCgAEgBSAAOgB8IAUgBjYCeCAFIAUpAxA3AoQBIAUgBUEkajYCoAEgBSAFQShqNgKcASAFIAVBPGo2ApgBAkBBpL3DACgCAA0AEIMHIQFBqL3DACgCACEAQai9wwAgATYCAEGkvcMAKAIAIQFBpL3DAEEBNgIAIAFFDQAgAEUNACAAIAAoAgAiAUEBazYCACABQQFHDQAgABCoCAtBqL3DACgCACEAQai9wwBBADYCAAJAIABFBEAgBRCDByIANgLgASAFQcABaiAFQfgAaiAFQeABahBtIAAgACgCACIAQQFrNgIAIABBAUcNASAFKALgARCoCAwBCyAAQRBqQgA3AgAgBSAANgKoASAFQeABaiAFQfgAaiAFQagBahBtQai9wwAoAgAhAUGovcMAIAA2AgACQCABRQ0AIAEgASgCACIAQQFrNgIAIABBAUcNACABEKgICyAFQcABaiIAQRhqIAVB4AFqIgFBGGooAgA2AgAgAEEQaiABQRBqKQMANwMAIABBCGogAUEIaikDADcDACAFIAUpA+ABNwPAAQsgBUGwAWoiACAFQcABaiIBQQxqKQIANwMAIAVBuAFqIgIgAUEUaikCADcDACAFIAUpAsQBNwOoAQJAIAUoAsABIgFBA0cEQCAFQeABaiIDQQxqIAApAwA3AgAgA0EUaiACKQMANwIAIAUgATYC4AEgBSAFKQOoATcC5AEMAQsgBRCDByIANgLAASAFQeABaiAFQfgAaiAFQcABahBtIAAgACgCACIAQQFrNgIAIABBAUcNACAFKALAARCoCAsgBSgCgAFBAkYNAyAFKAJ4IQACQCAFLQB8DQBB1MPDACgCAEH/////B3FFDQBBxMfDACgCAEUNACAAQQE6AAELIABBADoAAAwDCyAIQQJHDQULIAIgAigCACIAQQFrNgIAIAVBAjYC4AEgAEEBRw0BIAIQqAgMAQsgBUHwAWogBUEYaikDADcDACAFQfgBaiAFQSBqKAIANgIAIAUgCDYC5AEgBSAFKQMQNwPoASAFQQE2AuABAkAg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YCAJQf///z9LDQIgCUEEdCIHQQBIDQIgCUGAgIDAAElBAnQhCCAHBH8gByAIENAKBSAICyIGRQ0GIAUgBjYCdCAFIAk2AnACQCAJQQJJDQAgCUEBayIIQQdxIQcgCUECa0EHTwRAIAhBeHEhCANAIAZC////+////79/NwIIIAZC////+/f//7//ADcCACAGQfgAakL////7////v383AgAgBkHwAGpC////+/f//7//ADcCACAGQegAakL////7////v383AgAgBkHgAGpC////+/f//7//ADcCACAGQdgAakL////7////v383AgAgBkHQAGpC////+/f//7//ADcCACAGQcgAakL////7////v383AgAgBkFAa0L////79///v/8ANwIAIAZBOGpC////+////79/NwIAIAZBMGpC////+/f//7//ADcCACAGQShqQv////v///+/fzcCACAGQSBqQv////v3//+//wA3AgAgBkEYakL////7////v383AgAgBkEQakL////79///v/8ANwIAIAZBgAFqIQYgCEEIayIIDQALCyAHRQ0AA0AgBkL////7////v383AgggBkL////79///v/8ANwIAIAZBEGohBiAHQQFrIgcNAAsLIAZC////+////79/NwIIIAZC////+/f//7//ADcCACAFIAk2AnggAkEkaigCACEHIAVB0ABqIgZBADoABCAGQX82AgAgB0UEQEEEIQhBACEHDAELIAdB////P0sNAiAHQQR0IgtBAEgNAiAFLQBUIQkgBSgCUCEKIAdBgICAwABJQQJ0IQYgCwR/IAsgBhDQCgUgBgsiCEUNASAIIQYCQCAHQQJJDQAgB0EBayIMQQNxIQsgB0ECa0EDTwRAIAxBfHEhDANAIAZCfzcCCCAGIAk6AAQgBiAKNgIAIAZBOGpCfzcCACAGQTRqIAk6AAAgBkEwaiAKNgIAIAZBKGpCfzcCACAGQSRqIAk6AAAgBkEgaiAKNgIAIAZBGGpCfzcCACAGQRRqIAk6AAAgBkEQaiAKNgIAIAZBQGshBiAMQQRrIgwNAAsLIAtFDQADQCAGQn83AgggBiAJOgAEIAYgCjYCACAGQRBqIQYgC0EBayILDQALCyAGQn83AgggBiAJOgAEIAYgCjYCAAsgAEE0aiIGKAIABEAgAEE4aigCABCH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IQYgBSgCECEIIABBGGoiAygCACIHIAAoAhBGBEAgAEEQaiAHEMUEIAMoAgAhBwsgAEEUaiIJKAIAIAdB4ABsaiIBIAUpA4ABNwMAIAFBOGogBUGAAWoiAkE4aikDADcDACABQTBqIAJBMGopAwA3AwAgAUEoaiACQShqKQMANwMAIAFBIGogAkEgaikDADcDACABQRhqIAJBGGopAwA3AwAgAUEQaiACQRBqKQMANwMAIAFBCGogBSkDiAE3AwAgAUEAOgBYIAEgBjoAVCABIAg2AlAgAUJ/NwNIIAFCgYCAgHA3A0AgAyAHQQFqNgIAIAVBCGoiAUEAOgAEIAFBADYCACAFQZACaiIBIAAgBUHfAGogBSgCZCAFKAJoIAVB8ABqIAUoAgggBS0ADCAdEFAgBUHIAWogBUGcAmopAgAiITcDACAFIAUpApQCIiI3A8ABIABBCGogITcCACAAICI3AgAgAUEIaiAhNwMAIAFBOGpC////+////79/NwMAIAFBKGpC////+////79/NwMAIAFBGGpC////+////79/NwMAIAUgIjcDkAIgBUL////79///v/8ANwPAAiAFQv////v3//+//wA3A7ACIAVC////+/f//7//ADcDoAIgBUHQAWogARDxBCADKAIABEAgCSgCACIAIAUpA9ABNwMAIABBOGogBUHQAWoiAUE4aikDADcDACAAQTBqIAFBMGopAwA3AwAgAEEoaiABQShqKQMANwMAIABBIGogAUEgaikDADcDACAAQRhqIAFBGGopAwA3AwAgAEEQaiABQRBqKQMANwMAIABBCGogBSkD2AE3AwAgBSgCcARAIAUoAnQQhwELIAUoAmAEQCAFKAJkEIcBCyAFQdACaiQADwtBAEEAQdDUwAAQowcACyAHIAhBwMPDACgCACIAQaQGIAAbEQAAAAuoGAMYfw99An4jAEGQAWsiBiQAIAZBIGogBCABIAUoAogBEQIAIAYpAyAhLiAGKQMoIS0gBkEsaioCACEoIAYqAiQhHyAGKgIoIR4gBioCICEgAkAgAiADKAIQEQQAIhBBGGooAgAiDwRAIAZBADYCCCAGQoCAgIDAADcDACAGQQAQvwQgBigCBCAGKAIIIgdBA3RqQoCAgIDw////fjcCACAGIAdBAWo2AgggBkEQaiAGEIACAkAgBigCEEEB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BygCAARAIAdBADYCAAsgB0HwAGsoAgAEQCAHQewAaygCABCHAQsgB0HEAWohByANQcQBayINDQALCyAfBEAgGhCHAQsgC0GQAmokAA8LQeD1wABBxQBBiPfAABDJCAALkxkDDH8ZfQl+IwBB4ABrIgokACAAAn4CQAJAAkACQAJAAkACQAJAIARBBU8EQCAEQQJ0IQ1DAACAPyAEs5UhFiAFQQRqKAIAIQwgBUEIaigCACEIA0AgAyALaigCACIJIAhPDQYgFCAWIAwgCUEEdGoiCSoCACAJKgIIkkMAAAA/lJSSIRQgFSAWIAlBBGoqAgAgCUEMaioCAJJDAAAAP5SUkiEVIA0gC0EEaiILRw0ACyABQRhqIg0oAgAiCyEJIAFBEGoiCCgCACALRgRAIAggCxDFBCANKAIAIQkLIAFBFGoiDCgCACAJQeAAbGoiCEIANwNAIAhByABqQgA3AwAgCEL////7////v383AzggCEL////7////v383AzAgCEL////7////v383AyggCEL////7////v383AyAgCEL////79///v/8ANwMYIAhC////+/f//7//ADcDECAIQv////v3//+//wA3AwggCEL////79///v/8ANwMAIAggBjYCUCAIQQA6AFggCCAHOgBUIA0gCUEBajYCACAFQQRqKAIAIQYgBUEIaigCACEHIAItAAAhCSAKIBS8rSAVvK1CIIaENwMwIApByABqIgggAyAEIAYgByAKQTBqIgNBACAJEM8CIApB1ABqIgQoAgAhDiAKKAJQIQ8gCCAKKAJIIAooAkwgBiAHIANBASAJEM8CIAQoAgAhECAKKAJQIREgCigCTCESIAooAkghEyAIIA8gDiAGIAcgA0EBIAkQzwIgBCgCACEEIAooAlAhBiAKKAJMIQcgCigCSCEJIAogASACIBMgEiAFIAtBABA4IApBGGogASACIBEgECAFIAtBARA4IAMgASACIAkgByAFIAtBAhA4IAggASACIAYgBCAFIAtBAxA4IA0oAgAiAiALTQ0CIAopAlQhLSAKKQJMIS8gCigCSCEDIAopAjwhLiAKKQI0ITAgCigCMCEEIAopAiQhMSAKKQIcITIgCigCGCEFIAopAgwhMyAKKQIEITQgDCgCACALQeAAbGoiAiAKKAIANgJAIAJBzABqIAM2AgAgAkHIAGogBDYCACACQcQAaiAFNgIAIAFBGGoiAygCACICIAtNDQMgC0HgAGwiBCABQRRqIgUoAgBqIgIgLUIgiD4CPCACIC5CIIg+AjggAiAxQiCIPgI0IAIgM0IgiD4CMCACIC0+AiwgAiAuPgIoIAIgMT4CJCACIDM+AiAgAiAvQiCIPgIcIAIgMEIgiD4CGCACIDJCIIg+AhQgAiA0QiCIPgIQIAIgLz4CDCACIDA+AgggAiAyPgIEIAIgND4CACADKAIAIgIgC00NBCAFKAIAIARqIgJBJGoiAyoCACEVIAIqAgQhFCACQShqIgQqAgAhFiACKgIIIRkgAkEsaiIFKgIAIRcgAioCDCEgIAJBMGoiBioCACEaIAIqAhAhGyACQTRqIgcqAgAhHCACKgIUISEgAkE4aiIJKgIAIR0gAioCGCEeIAJBPGoiCCoCACEYIAIqAhwhIiACKgIgIh9DAAAAAJQgAioCACIkQwAAAACUkyEjIAIgHyAjkjgCICACICQgI5M4AgAgCCAYIBhDAAAAAJQgIkMAAAAAlJMiGJI4AgAgCSAdIB1DAAAAAJQgHkMAAAAAlJMiHZI4AgAgByAcIBxDAAAAAJQgIUMAAAAAlJMiHJI4AgAgBiAaIBpDAAAAAJQgG0MAAAAAlJMiGpI4AgAgBSAXIBdDAAAAAJQgIEMAAAAAlJMiF5I4AgAgBCAWIBZDAAAAAJQgGUMAAAAAlJMiFpI4AgAgAyAVIBVDAAAAAJQgFEMAAAAAlJMiFZI4AgAgAiAiIBiTOAIcIAIgHiAdkzgCGCACICEgHJM4AhQgAiAbIBqTOAIQIAIgICAXkzgCDCACIBkgFpM4AgggAiAUIBWTOAIEIAFBGGooAgAiAiALSw0BIAsgAkHohMIAEKMHAAsgAUEYaigCACELQv////v3//+//wAhLUL////7////v38hL0F/IQIgBEUEQEF/IQlBfyENQX8hCEL////7////v38hLkL////79///v/8AITBC////+////79/ITFC////+/f//7//ACEyQv////v///+/fyEzQv////v3//+//wAhNAwICyADKAIAIgkgBUEIaigCACIMTw0GIAFBPGooAgAiDCAJTQ0FIAVBBGooAgAgCUEEdGoiCCkCCCEzIAgpAgAhNCABQThqKAIAIAlBDGxqIghBADoABCAIIAs2AgAgBEEBRgRAQX8hDUF/IQhC////+////79/IS5C////+/f//7//ACEwQv////v///+/fyExQv////v3//+//wAhMgwICyADKAIEIg0gBUEIaigCACIMTwRAIA0hCQwHCyANIAFBPGooAgAiDE8EQCANIQkMBgsgBUEEaigCACANQQR0aiIIKQIIITEgCCkCACEyIAFBOGooAgAgDUEMbGoiCEEBOgAEIAggCzYCACAEQQJGBEBBfyEIQv////v///+/fyEuQv////v3//+//wAhMAwICyADKAIIIgggBUEIaigCACIMTwRAIAghCQwHCyAIIAFBPGooAgAiDE8EQCAIIQkMBgsgBUEEaigCACAIQQR0aiIMKQIIIS4gDCkCACEwIAFBOGooAgAgCEEMbGoiDEECOgAEIAwgCzYCACAEQQNGDQcgAygCDCICIAVBCGooAgAiDE8EQCACIQkMBwsgAiABQTxqKAIAIgxPBEAgAiEJDAYLIAVBBGooAgAgAkEEdGoiAykCACEtIAMpAgghLyABQThqKAIAIAJBDGxqIgNBAzoABCADIAs2AgAMBwsgAUEUaigCACALQeAAbGoiAUEwaioCACEVIAFBIGoqAgAiFCABQSRqKgIAIhYgFCAWYBsiFCABQShqKgIAIhYgFCAWYBsiFCABQSxqKgIAIhYgFCAWYBu8rSAVIAFBNGoqAgAiFCAUIBVfGyIVIAFBOGoqAgAiFCAUIBVfGyIVIAFBPGoqAgAiFCAUIBVfG7ytQiCGhCEtIAEqAgAiFSABKgIEIhQgFCAVYBsiFSABKgIIIhQgFCAVYBsiFSABKgIMIhQgFCAVYBu8rSABQRBqKgIAIhUgAUEUaioCACIUIBQgFWAbIhUgAUEYaioCACIUIBQgFWAbIhUgAUEcaioCACIUIBQgFWAbvK1CIIaEDAcLIAsgAkG4hMIAEKMHAAsgCyACQciEwgAQowcACyALIAJB2ITCABCjBwALIAkgCEGohMIAEKMHAAsgCSAMQZiEwgAQowcACyAJIAxBiITCABCjBwALIDNCIIinviIVQwAAAACUIDRCIIinviIcQwAAAACUkyIhIBWSIhUgMUIgiKe+IhRDAAAAAJQgMkIgiKe+Ih1DAAAAAJSTIh4gFJIiFCAUIBVfGyIZIC5CIIinviIWQwAAAACUIDBC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ACACQThqIgogDSgCADYCACACIAIpA5gBNwNQIAIgAikDgAE3A0AgAiACKQOIATcDSCACIAIpA3A3AzAgAiACKQNgNwMgIAIgAikDaDcDKCADLQAVIQ0gCyAFKAIANgIAIAwgCigCADYCACACIAIpA1A3A9ABIAIgAikDQDcDkAIgAiACKQNINwOYAiACIAIpAzA3A7ABIAIgAikDIDcD8AEgAiACKQMoNwP4ASACQeIAaiIFIAJBH2otAAA6AAAgAiACLwAdOwFgIAIgAkEZaigAADYAgwEgAiACKAAWNgKAASACKAIIIA9GBEAgAkEIaiAPEMUEIAIoAhAhDyACKAIMIQkLIAkgD0HgAGxqIgMgATYCACADIAIpA9ABNwIEIANBDGogCygCADYCACADIAIpA5ACNwMQIAIpA5gCIRsgAyAHNgIgIANBGGogGzcDACADIAIpA7ABNwIkIANBLGogDCgCADYCACACKQP4ASEbIAIpA/ABIRwgAyAONgJAIAMgEjYCRCADIBM2AkggAyAUNgJMIAMgFTYCUCADIBY6AFQgAyAcNwMwIANBOGogGzcDACADQdcAaiAFLQAAOgAAIAMgAi8BYDsAVSADIA06AFggAyACKAKAATYAWSADQdwAaiACKACDATYAACACIA9BAWoiDzYCECAADQALIAIoAgwhCSACKAIIIQcLIAlFBEAgByEBDAoLIAJBkAJqIAIQlAIgAigCkAINAyACQZgCaigCACIKRQRAQQJBqIzAAEG0gcAAELsGIQEMCAsgAkGcAmooAgAhCyACKAKUAiEMIAJBkAJqIAIQlAICQCACKAKQAkUEQCACQZgCaigCACIQRQRAQQNBqIzAAEG0gcAAELsGIQEMCQsgAigClAIhESACKAIABEAgAigCBCIEKAIEIgBBB00EQCACQoHKADcDkAIgAkGQAmoQ6wkhAQwJCyACQZwCaigCACENIAQgAEEIayIINgIEIAQgBCgCACIAQQhqNgIAIAJB8AFqIAApAAAQpwQgAigC9AEhASACKALwAQ0IAkAgAUGAICABQYAgSRsiAEUEQEEEIQMMAQsgAEEMbCIFQQQQ0AoiA0UNCAtBACEFIAJBADYCmAIgAiADNgKUAiACIAA2ApACIAEEQANAAkACfyAIQQNNBEAgAkKBygA3A/ABIAJB8AFqEOsJDAEL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NwIAIABBJGogHTYCACAAQSBqIA02AgAgAEEcaiANNgIAIABBGGogIjYCACAAQRBqICwoAgA2AgAgAEEIaiABQQhqKQIANwIAC7gVAxZ/An0GfiMAQYACayICJAACQCABKAIAIgNFBEAgAEECOgBcDAELIAEgA0EBazYCAAJAIAEoAgQiASgCBCIFQQNNBEAgAkEAOgDbASACQSU7ANkBIAJBADYC3AEgAkEBOgDYASACQdgBahDrCSEBDAELIAEgBUEEayIENgIEIAEgASgCACIDQQRqNgIAIARBA00EQCACQQA6ANsBIAJBJTsA2QEgAkEANgLcASACQQE6ANgBIAJB2AFqEOsJIQEMAQsgAygAACEKIAEgBUEIazYCBCABIANBCGo2AgAgAyoABCEYIAJB2AFqIAEQgQMgAigC2AEEQCACKALcASEBDAELIAEoAgQiBUEDTQRAIAJBADoA2wEgAkElOwDZASACQQA2AtwBIAJBAToA2AEgAkHYAWoQ6wkhAQwBCyACQeABaigCACELIAIoAtwBIQwgASAFQQRrIgQ2AgQgASABKAIAIgNBBGo2AgAgBEEDTQRAIAJBADoA2wEgAkElOwDZASACQQA2AtwBIAJBAToA2AEgAkHYAWoQ6wkhAQwBCyADKAAAIQ0gASAFQQhrNgIEIAEgA0EIajYCACADKgAEIRkgAkHYAWogARCBAyACKALYAQRAIAIoAtwBIQEMAQsgASgCBCIFRQRAIAJCgcoANwPYASACQdgBahDrCSEBDAELIAJB4AFqKAIAIQ4gAigC3AEhDyABIAVBAWsiBDYCBCABIAEoAgAiA0EBajYCACAERQRAIAJCgcoANwPYASACQdgBahDrCSEBDAELIAMtAAAhECABIAVBAmsiBDYCBCABIANBAmo2AgAgBEUEQCACQoHKADcD2AEgAkHYAWoQ6wkhAQwBCyADLQABIREgASAFQQNrIgQ2AgQgASADQQNqNgIAIARFBEAgAkKBygA3A9gBIAJB2AFqEOsJIQEMAQsgAy0AAiESIAEgBUEEayIENgIEIAEgA0EEajYCACAEQQNNBEAgAkEAOgDbASACQSU7ANkBIAJBADYC3AEgAkEBOgDYASACQdgBahDrCSEBDAELIAMtAAMhEyABIAVBCGsiBDYCBCABIANBCGo2AgAgBEEDTQRAIAJB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BgsgAigCmAEhAQwECyACKAK4ASEBDAMLIAJCgcoANwPYASACQdgBahDrCSEBDAILQRBBBEHAw8MAKAIAIgBBpAYgABsRAAAACyACQoHKADcD2AEgAkHYAWoQ6wkhAQsgAEEDOgBcIAAgATYCAAsgAkGAAmokAAuWFAMkfwR9A34jAEGQA2siAyQAIAMgAjYCJCADIAE2AiAgA0EAOgAoIAMgAikCACIrpyIGNgIMIAMgBjYCCCADIAY2AgQgAyAGNgIAIAMgK0IgiKciBjYCHCADIAY2AhggAyAGNgIUIAMgBjYCEAJAIAFBGGooAgAiFgRAIANBADYCOCADQoCAgIDAADcDMCADQTBqIgVBABC/BEEDIQYgAygCNCADKAI4IgRBA3RqQoCAgIDw////fjcCACADIARBAWo2AjggA0HQAGogBRCAAgJAAkAgAygCUEEBRw0AIAFBOGooAgAhEiABQTxqKAIAIREgAUEUaigCACEfIANB0wJqIRsgA0HwAWoiBkHEAGohDiADQZwCaiEPIAZBFGohEyADQfkCaiEcQ///f38hKCADQegAaiEXIANB1wJqISAgAUHIAGohISABQdAAaiEiIAFB1ABqISNBAyEGA0AgKCADKgJYjF8NASADKAJUIgQgFkkEQCAfIARB4ABsaiIJLQBYQQFxIgUEQCASIAkoAkAiBEEMbGpBACAEIBFJGyIEQQhqQQAgBBshJCASIAlBzABqKAIAIgRBDGxqQQAgBCARSRsiBEEIakEAIAQbISUgEiAJQcgAaigCACIEQQxsakEAIAQgEUkbIgRBCGpBACAEGyEmIBIgCUHEAGooAgAiBEEMbGpBACAEIBFJGyIEQQhqQQAgBBshHQsgA0HAAWogCSADEPUBIAMqAsABIChdrSErIAMqAswBISogAyoCyAEhKSADKgLEASEnAn8gBQRAIAMgJTYC3AEgAyAmNgLYASADIB02AtQBIAMgJDYC0AFCACEsIANB6AFqIhhCADcDACADQgA3A+ABIANBAzYCyAIgA0EDNgKwAiADQQM2ApgCIANBAzYCgAIgJyAoXa1CAYYgK4QgKCApXq1CAoaEICggKl6tQgOGhCEtICEoAgAhECABQcQAaigCACEZICIoAgAhCiAjKAIAIRRBACEMQQAhBQNAAkAgLSAsiEIBg1ANACADQdABaiAM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//v3//+//wA3AgAgAUHYAGpC////+////79/NwIAIAFB0ABqQv////v3//+//wA3AgAgAUHIAGpC////+////79/NwIAIAFBQGtC////+/f//7//ADcCACABQThqQv////v///+/fzcCACABQTBqQv////v3//+//wA3AgAgAUEoakL////7////v383AgAgAUEgakL////79///v/8ANwIAIAFBGGpC////+////79/NwIAIAFBEGpC////+/f//7//ADcCACABQYABaiEBIAJBCGsiAg0ACyABQRBrIQILIAQEQANAIAFC////+////79/NwIIIAFC////+/f//7//ADcCACABQRBqIQEgBEEBayIEDQALIAFBEGshAgsgAUL////79///v/8ANwIAIAJBGGpC////+////79/NwIAIAMgBTYCICAHQfn///8HTw0FIAdBBBDQCiIJRQ0BIAhBA3EhBCAJIQEgDEEDTwRAIAhBfHEhAgNAIAFCfzcCCCABQQA6AAQgAUF/NgIAIAFBLGpBfzYCACABQShqQQA6AAAgAUEgakJ/NwIAIAFBHGpBADoAACABQRRqQn83AgAgAUEQakEAOgAAIAFBMGohASACQQRrIgINAAsLIARFDQYDQCABQX82AgggAUEAOgAEIAFBfzYCACABQQxqIQEgBEEBayIEDQALDAYLIAFC////+////79/NwIIIAFC////+/f//7//ADcCACADIAU2AiAgB0EEENAKIgkiAQ0FCyAHQQRBwMPDACgCACIAQaQGIAAbEQAAAAsgAkEEQcDDwwAoAgAiAEGkBiAAGxEAAAALIAQgAkHAw8MAKAIAIgBBpAYgABsRAAAACyADQQA2AhAgA0KAgICAwAA3AwggA0EANgIgIANCgICAgMAANwMYQQQhBkEEIQkMAgsQigkACyABQX82AgggAUEAOgAEIAFBfzYCAAsgACgCNARAIABBOGooAgAQhwELIAAgBTYCNCAAQTxqIgwgBTYCACAAQThqIg0gCTYCAAJAAkACQCAFBH8gByAKaiEPIABByABqIRAgAEHEAGohESAAQTRqIRJBACEJQQAhBANAAkACQAJAIAooAgAiASAQKAIAIgJJBEAgCigCBCIIIAJPDQEgCigCCCIGIAJPDQIgBEEBaiEHIBEoAgAiAiAGQQN0aikCACIap74hFSACIAhBA3RqKQIAIhunviIUIAIgAUEDdGopAgAiHKe+IhZeIQIgFSAVIBQgFCAWIAIbIBYgFlwbIhcgFSAXXhsgFyAXXBshGCAWIBYgFCACGyAUIBRcGyIUIBQgFSAUIBVdGyAVIBVcGyEZIBtCIIinviIUIBxCIIinviIWXiECIBpCIIinviIVIBUgFCAUIBYgAhsgFiAWXBsiFyAVIBdeGyAXIBdcGyEXIBYgFiAUIAIbIBQgFFwbIhQgFCAVIBQgFV0bIBUgFVwbIRUgBCAFSQ0DIAAoAjQgBSICayAHIAJrIghJBEAgEiAFIAgQtQQgDCgCACECCyANKAIAIAJBDGxqIQEgCEECTwRAIAQgBWsiBkEDcSELIAQgBUF/c2pBA08EQCAGQXxxIQYDQCABQn83AgggAUEAOgAEIAFBfzYCACABQSxqQX82AgAgAUEoakEAOgAAIAFBIGpCfzcCACABQRxqQQA6AAAgAUEUakJ/NwIAIAFBEGpBADoAACABQTBqIQEgBkEEayIGDQALCyALBEAgDiAFa0EDcSEGA0AgAUF/NgIIIAFBADoABCABQX82AgAgAUEMaiEBIAZBAWsiBg0ACwsgAiAIakEBayECCyAFIAdHBEAgAUF/NgIIIAFBADoABCABQX82AgAgAkEBaiECCyAMIAIiBTYCACADAn8gByADKAIgIgggBEsNABogByAIIgJrIQsgCyADKAIYIAJrSwRAIANBGGogCCALELkEIAMoAiAhAgsgAygCHCACQQR0aiEBIAtBAk8EQCAEIAhrIgZBB3EhEyAEIAhBf3NqQQdPBEAgBkF4cSEGA0AgAUL////7////v383AgggAUL////79///v/8ANwIAIAFB+ABqQv////v///+/fzcCACABQfAAakL////79///v/8ANwIAIAFB6ABqQv////v///+/fzcCACABQeAAakL////79///v/8ANwIAIAFB2ABqQv////v///+/fzcCACABQdAAakL////79///v/8ANwIAIAFByABqQv////v///+/fzcCACABQUBrQv////v3//+//wA3AgAgAUE4akL////7////v383AgAgAUEwakL////79///v/8ANwIAIAFBKGpC////+////79/NwIAIAFBIGpC////+/f//7//ADcCACABQRhqQv////v///+/fzcCACABQRBqQv////v3//+//wA3AgAgAUGAAWohASAGQQhrIgYNAAsLIBMEQCAJIAhrQQdxIQYDQCABQv////v///+/fzcCCCABQv////v3//+//wA3AgAgAUEQaiEBIAZBAWsiBg0ACwsgAiALakEBayECCyACIAcgCEYNABogAUL////7////v383AgggAUL////79///v/8ANwIAIAJBAWoLNgIgDAMLIAEgAkGE0MIAEKMHAAsgCCACQZTQwgAQowcACyAGIAJBpNDCABCjBwALIAQgBU8NAiANKAIAIARBDGxqIAQ2AgggAygCICICIARNDQMgCkEMaiEKIAMoAhwgBEEEdGoiAiAXOAIMIAIgGDgCCCACIBU4AgQgAiAZOAIAIAMoAhAiASADKAIIRgRAIANBCGogARC9BCADKAIQIQELIAMoAgwiBiABQQJ0aiAENgIAIAMgAUEBajYCECAJQQFqIQkgDkEBaiEOIAchBCAKIA9HDQALIABBGGooAgAFQQALIQEgASAAQRBqIgIoAgBGBEAgAiABEMUEIABBGGooAgAhAQsgAEEYaiIFIAFBAWo2AgAgAEEUaiIHKAIAIAFB4ABsaiICQn83AkQgAkEBNgJAIAJC////+////79/NwM4IAJC////+////79/NwMwIAJC////+////79/NwMoIAJC////+////79/NwMgIAJC////+/f//7//ADcDGCACQv////v3//+//wA3AxAgAkL////79///v/8ANwMIIAJC////+/f//7//ADcDACACQQA6AFQgAkEAOgBYIAJBzABqQn83AgAgA0EoaiAAIANBB2ogBiADKAIQIANBGGpBAEEAEDggAykCLCEaIAAgA0E0aikCACIbNwIIIAAgGjcCACAFKAIARQ0CIAcoAgAiACAaPgIAIABB////ezYCPCAAQv////v///+/fzcCNCAAIBtCIIg+AjAgAEH///97NgIsIABC////+////79/NwIkIAAgGz4CICAAQf////sHNgIcIABC////+/f//7//ADcCFCAAIBpCIIg+AhAgAEH////7BzYCDCAAQv////v3//+//wA3AgQgAygCGARAIAMoAhwQhwELIAMoAggEQCAGEIcBCyADQUBrJAAPCyAEIAVB6IPCABCjBwALIAQgAkH4g8IA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oAIgESgCACICIA1NDQIgCSgC+AIhBCAJKAKQAyEDIAkoAkAhAiAVKAIAIA1B4ABsaiIKIAkoAuACNgJAIApBzABqIAI2AgAgCkHIAGogAzYCACAKQcQAaiAENgIAIAlBQGsiAkEIaiALKQMANwMAIAJBGGogBykDADcDACACQShqIAYpAwA3AwAgCSAJKQPQAjcDQCAJIAkpA8ACNwNQIAkgCSkDsAI3A2AgAkE4aiAFKQMANwMAIAkgCSkDoAI3A3AgCUGQA2ogAhDxBCABQRhqIgUoAgAiAiANTQ0DIA1B4ABsIgMgAUEUaiIEKAIAaiIGIAkpA5ADNwMAIAZBOGogCUGQA2oiAkE4aikDADcDACAGQTBqIAJBMGopAwA3AwAgBkEoaiACQShqKQMANwMAIAZBIGogAkEgaikDADcDACAGQRhqIAJBGGopAwA3AwAgBkEQaiACQRBqKQMANwMAIAZBCGogCSkDmAM3AwAgBSgCACICIA1NDQQgBCgCACECIAkgCDgCTCAJIAg4AkggCSAIOAJEIAkgCDgCQCACIANqIAlBQGsQlQIgAUEYaigCACICIA1LDQEgDSACQcDUwAAQowcACyABQRhqKAIAIQ8gBEUEQEL////79///v/8AIRhC////+////79/IRlBfyELQX8hEEF/IQJBfyEOQv////v///+/fyEWQv////v3//+//wAhF0L////7////v38hGkL////79///v/8AIRtC////+////79/IRxC////+/f//7//ACEdIA8MCQsgAygCACILIAVBCGooAgAiDE8NBiALQQR0Ig4gBUEEaigCAGoiAikCCCEcIAIpAgAhHSAJQRhqIgJBADoABCACIA82AgAgAUE8aigCACIMIAtNDQUgCSgCGCEKIAFBOGooAgAgDmoiAiAJLQAcOgAEIAIgCjYCAEL////79///v/8AIRhC////+////79/IRlBfyEOIARBAUYEQEF/IRBBfyECQv////v///+/fyEWQv////v3//+//wAhF0L////7////v38hGkL////79///v/8AIRsMCAsgBUEIaigCACIMIAMoAgQiEE0EQCAQIQsMBwsgBUEEaigCACAQQQR0aiICKQIIIRogAikCACEbIAlBEGoiAkEBOgAEIAIgDzYCACABQTxqKAIAIgwgAygCBCIC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ahDfAgJAAkACQAJAAkACQAJAAkACQCAJKAIARQRAIAlBEGooAgBBBGsoAgAiACAJQQxqKAIAIgJBGGooAgAiA08NASACQRRqKAIAIABBBHRqKAIMIQgMCAsgACoCACIXIAGnspQhGCAXIBiSIRkgFyAXIAFCIIinspQiF5IhGiAJQRBqKAIAIQUgCUEMaigCACENIAkpAgQhGwJAAkAgAygCCCIERQ0AIAMgBEEBayIENgIIIAMoAgQgBEECdGooAgAiA0UNACADQRBqQQA2AgAgA0EcakEANgIAIANBCGohCiADKAIIIgdFBEAgCkEAEL8EIAMoAgghByADKAIQIQgLIAMgCEEBaiIENgIQIANBDGooAgAiBiAIQQN0akL///97NwIAIAQgB0YEQCAKIAcQvwQgAygCDCEGIAMoAhAhBAsgAyAZOAIEIAMgGDgCACADIARBAWo2AhBBACEIIANBPGpBADYCACADQTBqQQA2AgAgBiAEQQN0akL////79/////8ANwIAIANBKGoiCigCACIHRQRAIApBABC/BCADKAIoIQcgAygCMCEICyADIAhBAWoiBDYCMCADQSxqKAIAIgYgCEEDdGpC////ezcCACAEIAdGBEAgCiAHEL8EIAMoAiwhBiADKAIwIQQLIANBADoAcCADIBc4AiAgAyAEQQFqNgIwIANBJGogGjgCACAGIARBA3RqQv////v3/////wA3AgAgA0HEAGooAgAEQCADQcgAaigCABCHAQsgA0EAOgBxIANBfzYCUCADQgA3AkAgA0HsAGpBADYCACADQcgAakIENwIAIAMoAlQNAyADQeAAaigCAEUNAUHg4cEAQSpBjOLBABDJCAALAkAgGCAZXwRAQRBBBBDQCiIIDQEMCwtB6NTBAEEoQZDWwQAQyQgACyAIQv////v3/////wA3AgggCEL///97NwIAAkAgFyAaXwRAQRBBBBDQCiIEDQEMCwtB6NTBAEEoQZDWwQAQyQgACyAEQv////v3/////wA3AgggBEL///97NwIAQfQAQQQQ0AoiA0UNAyADQQA7AXAgA0IENwJoIANCADcCYCADQoCAgIDAADcCWCADQv////8PNwJQIANCBDcCSCADQgA3AkAgA0IENwI4IANCAjcCMCADIAQ2AiwgA0ECNgIoIAMgGjgCJCADIBc4AiAg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IgBBCGogCEEIaikDADcDACACIAIpAzA3A5ACIBAgABCEBiACQewBaiAdOAIAIAJB6AFqIB04AgAgAkHkAWogHTgCACACIB04AuABIAIgAkH8AGo2AvABIAJBADYCiAIgAkKAgICAwAA3A4ACAkAgBUEYaigCACIHRQ0AIAJBgAJqQQAQvQQgAigChAIiBiACKAKIAiIAQQJ0akEANgIAIABBAWoiA0UNACAFQThqKAIAIQggBUE8aigCACEKIAVBFGooAgAhESACQeABaiISQQhqIRMgAkGgAmohFQNAIAIgA0EBayIDNgKIAgJAIAYgA0ECdGooAgAiACAHSQRAIBEgAEHgAGxqIgUtAFhBAXEiAARAIAggBSgCQCIBQQR0akEAIAEgCkkbIgFBCGpBACABGyEWIAggBUHMAGooAgAiAUEEdGpBACABIApJGyIBQQhqQQAgARshCyAIIAVByABqKAIAIgFBBHRqQQAgASAKSRsiAUEIakEAIAEbIRcgCCAFQcQAaigCACIBQQR0akEAIAEgCkkbIgFBCGpBACABGyEUCyACIBMpAwA3A7gCIAIgEikDADcDsAIgAkGQAmogBSACQaABaiACQbACahCdASACLQCQAiEMIAItAJECIQ0gAi0AkgIhDiACLQCTAiEPIAAEQCACIAs2ArwCIAIgFzYCuAIgAiAUNgK0AiACIBY2ArACIA9BA3RBCHEgDkECdEEEcSANQQF0QQJxIAxBAXFycnKtIRxCACEbIAJBsAJqIQADQAJAIBwgG4hCAYNQDQAgACgCACIERQ0AIAIoAvABKAIAIgEoAgAgBCgCACIJIARBBGooAgAiEBCkCCIERQ0AIAEoAgQgASgCCCAJIBAgBBDGAkUNACACQRBqIhggBEEgaiIZKAIEIho2AgQgGCAZKAIAIBooAghBB2pBeHFqNgIAIAJBkAJqIAIoAhAgBCABKAIMIAEoAhAqAgAgASgCFC0AACACKAIUKAIcEQkAIAIoApgCQQNGDQAgASgCGCgCACgCACEEIAJBITYCyAICQAJAQSBBBBDQCiIBBEAgASAQNgIIIAEgCTYCBCABQQA2AgAgASACKQOQAjcCDCABQRRqIAJBmAJqKQMANwIAIAFBHGogFSgCADYCACACIAEQBTYCzAIgAkEIaiAEIAJByAJqIAJBzAJqEMwIIAIo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AgALIAdBQGskAAwECyAAQQU6ACQMAwsgCygCFCEPIwBBwAFrIgEkACABQeAAakECNgIAIAFCgICAgBA3A1ggAUEAQdgAEK0LIQogAykCACEiQwAAoDUQdiEZAkACQCAip74iHSAdlCAiQiCIp74iHiAelJJDAAAAAJIQdiIfQwAAAABbDQACQCAfQwAAgH9bDQAgH0MAAID/Ww0AIB+LIhJDAAAANF8NASASIBJDAAAANJRfDQELIAogHiAflSIYjDgCdCAKIB0gH5UiF4w4AnAgCikDcCElIApBiAFqIA4gCkHwAGogDUEMaigCACIFEQIAIAogCikDcCIip0GAgICAeHM2ApgBIAogIkIgiKdBgICAgHhzNgKcASAKQZABaiAMIAIgCkGYAWogDygCFCIEEQEAIApBEGogCikDiAEiIjcDACAKQRhqIAooApABIgOtIAooApQBIgGtQiCGhDcDACAKQgA3AmQgCiAip74gA76TvK0gIkIgiKe+IAG+k7ytQiCGhDcDCCAKQfgAaiAKEKwBQZDOACEHIAopA3ghI0P//39/IRICQAJAAkACQANAICOnviIUIBSUICNCIIinviIWIBaUkkMAAAAAkiITQwAAyCteRQ0BIAogFowgExB2IhOVIhs4AoQBIAogFIwgE5UiHDgCgAECfiASIBNfIgZFBEAgCkGIAWogDiAKQYABaiAFEQIAIAogCikDgAEiIqdBgICAgHhzNgKYASAKICJCIIinQYCAgIB4czYCnAEgCkGQAWogDCACIApBmAFqIAQRAQAgCikDiAEiJKe+IAooApABIgO+k7ytICRCIIinviAKKAKUASIBvpO8rUIghoQhIyAKKgKEASEbIAoqAoABIRwgA60gAa1CIIaEDAELIBVDAAAAAF4NAiAhIBSSvK0gICAWkrytQiCGhCIkISNCAAshIiAjp74hFiAjQiCIp74hFAJAAkACQCAYIBuUIBcgHJSSIhpDAAAAAFsNAAJAIBpDAACAf1sNACAaQwAAgP9bDQAgGosiEkMAAAA0Xw0BIBIgEkMAAAA0lF8NAQsgHCAWICGTlCAbIBQgIJOUkiAalSISQwAAAABgDQELIBpDAACgNV4NByAGRQ0BDAcLAkAgGkMAAAAAXUUNACASQwAAAABeRQ0AIBUgEpIiFSAflUP//39/Xg0HIAopA4AB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CyAZlCEfQwAAAAAhGSAKBH0gCkH8AGoqAgAFQwAAAAALIBiUIRogHSAbkyIYIBiUIB4gHJMiGCAYlJJDAAAAAJIQdiAfiyAJBH0gCUG8AWoqAgAFQwAAAAALlJIhGCAaiyEaIAoEQCAKQbwBaioCACEZC0MAAAAAQwAAAAAgESARQwAAAABdGyARIBFcGyAHKAIgIAdBJGooAgAiEygCCEEHakF4cWogEygCnAERCwAgCCgCICAIQSRqKAIAIhMoAghBB2pBeHFqIBMoApwBEQsAkpIhESAYIBogGZSSIRhBASEUIActAIABIAgtAIABckUEQCAIQdQAaigCACAHQdAAaigCAHFFIAdB1ABqKAIAIAhB0ABqKAIAcUVyIRQLIBAgD5MgGJQgEV0NASASQRhqIhNCADcCBCATQYCAgPwDNgIAIBNBDGpCADcCACATQRRqQgA3AgAgE0EcakIANwIAIAlFDQIgCUHAAWotAAANAyASQcABaiAJQRhqKQIANwMAIBIgCSkCEDcDuAEgEkHgAWogEkG4AWoQugkMBAsgAEECNgIYDAYLIABBAjYCGAwFCyASQUBrIglBIGogEkEYaiITQSBqKAIANgIAIAlBGGogE0EYaikDADcDACAJQRBqIBNBEGopAwA3AwAgCUEIaiATQQhqKQMANwMAIBIgEikDGDcDQAwCCyASQbgBaiITQQhqIAlBCGopAgA3AwAgEiAJKQIANwO4ASASIAkpA0g3A2ggEiAJKQJ0NwOQASASQeABaiATIBJB6ABqIBJBkAFqIAlB/ABqKgIAEMUJCyASQUBrIglBIGogEkHgAWoiE0EgaigCADYCACAJQRhqIBNBGGopAwA3AwAgCUEQaiATQRBqKQMANwMAIAlBCGogE0EIaikDADcDACASIBIpA+ABNwNACwJAAkACQCAKBEAgCkHAAWotAAANASASQcABaiAKQRhqKQIANwMAIBIgCikCEDcDuAEgEkHgAWogEkG4AWoQugkMAgsgEkHoAGoiCUEgaiASQRhqIgpBIGooAgA2AgAgCUEYaiAKQRhqKQMANwMAIAlBEGogCkEQaikDADcDACAJQQhqIApBCGopAwA3AwAgEiASKQMYNwNoDAILIBJBuAFqIglBCGogCkEIaikCADcDACASIAopAgA3A7gBIBIgCikDSDcDiAIgEiAK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B3FFDQBBxMfDACgCAEUNACACQQE6AAELIAJBADoAACADKAIAIQEgA0EANgIAIAFFDQUgACADKQIkNwIkIAAgAykCHDcCHCAAIAMpAhQ3AhQgACADKQIMNwIMIAAgAykCBDcCBCAAQQE2AgAMAQsgAy0ALEUEQEEAIQEDQCABIAFBAWogAUEKSyABQQdPcRshASADLQAsRQ0ACwsgAEECNgIACyADQdAAaiQADwsgBCAGQcjDwAAQogcACyADIAc6ADwgAyACNgI4QdjDwABBKyADQThqQcjHwABB5MjAABDbBgALQeTBwABBK0HkyMAAEMkIAAtB5MHAAEErQfTIwAAQyQgACyAEIAZByMPAABCiBwALIAMgBzoAPCADIAI2AjhB2MPAAEErIANBOGpByMfAAEGEycAAENsGAAtB5MHAAEErQYTJwAAQyQgAC0HkwcAAQStBlMnAABDJCAALIANBADYCTCADQfS+wAA2AkggA0EBNgJEIANBzMvAADYCQCADQQA2AjggA0E3aiADQThqEN0HAAvnDAMMfwF9An4jAEHAAWsiCCQAIAggBzgCDCAIQRBqIAUgAiAGKAKIARECACAHQwAAAABgBEAgCCkDECEVIAgpAxghFiAAQQA2AgAgCEEcaiAGNgIAIAggAjYCJCAIIAE2AiAgCCADNgIQIAggADYCLCAIIAU2AhggCCAIQQxqNgIoIAggBDYCFCAIIBZCIIinviAHkiIUOAJsIAggFDgCaCAIIBQ4AmQgCCAUOAJgIAggFqe+IAeSIhQ4AlwgCCAUOAJYIAggFDgCVCAIIBQ4AlAgCCAVQiCIp74gB5MiFDgCTCAIIBQ4AkggCCAUOAJEIAggFDgCQCAIIBWnviAHkyIHOAI8IAggBzgCOCAIIAc4AjQgCCAHOAIwIAggCEEQajYCcCADIAQoAhARBAAhACAIQQA2AogBIAhCgICAgMAANwOAAQJAIABBGGooAgAiBEUNACAIQYABakEAEL0EIAgoAoQBIgMgCCgCiAEiAUECdGpBADYCACABQQFqIgZFDQAgAEE4aigCACEMIABBPGooAgAhDSAAQRRqKAIAIREDQCAIIAZBAWsiBjYCiAECQAJAIAMgBkECdGooAgAiACAESQRAIBEgAEHgAGxqIgItAFhBAXEEQCACQcQAaigCACEJIAJByABqKAIA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ECABIAJBGGoQ9wcMEQsgAiAAKQMINwMIIAJBJGpBAjYCACACQSxqQQE2AgAgAkGU8cIANgIgIAJBADYCGCACQZcBNgIUIAIgAkEQajYCKCACIAJBCGo2AhAgASACQRhqEPcHDBALIAIgACkDCDcDCCACQSRqQQI2AgAgAkEsakEBNgIAIAJBlPHCADYCICACQQA2AhggAkGgBjYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD3BwwPCyACIAArAwg5AwggAkEkakECNgIAIAJBLGpBATYCACACQfjwwgA2AiAgAkEANgIYIAJBoQY2AhQgAiACQRBqNgIoIAIgAkEIajYCECABIAJBGGoQ9wcMDgsgAiAAKAIENgIIIAJBJGpBAjYCACACQSxqQQE2AgAgAkHY8MIANgIgIAJBADYCGCACQaIGNgIUIAIgAkEQajYCKCACIAJBCGo2AhAgASACQRhqEPcHDA0LIAIgACkCBDcDCCACQSRqQQE2AgAgAkEsakEBNgIAIAJBxPDCADYCICACQQA2AhggAkGjBjYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD3BwwMCyACQSRqQQE2AgAgAkEsakEANgIAIAJBtPDCADYCICACQejuwgA2AiggAkEANgIYIAEgAkEYahD3BwwLCyACQSRqQQE2AgAgAkEsakEANgIAIAJBrPDCADYCICACQejuwgA2AiggAkEANgIYIAEgAkEYahD3BwwKCyACQSRqQQE2AgAgAkEsakEANgIAIAJBmPDCADYCICACQejuwgA2AiggAkEANgIYIAEgAkEYahD3BwwJCyACQSRqQQE2AgAgAkEsakEANgIAIAJBhPDCADYCICACQejuwgA2AiggAkEANgIYIAEgAkEYahD3BwwICyACQSRqQQE2AgAgAkEsakEANgIAIAJB7O/CADYCICACQejuwgA2AiggAkEANgIYIAEgAkEYahD3BwwHCyACQSRqQQE2AgAgAkEsakEANgIAIAJB3O/CADYCICACQejuwgA2AiggAkEANgIYIAEgAkEYahD3BwwGCyACQSRqQQE2AgAgAkEsakEANgIAIAJB0O/CADYCICACQejuwgA2AiggAkEANgIYIAEgAkEYahD3BwwFCyACQSRqQQE2AgAgAkEsakEANgIAIAJBxO/CADYCICACQejuwgA2AiggAkEANgIYIAEgAkEYahD3BwwECyACQSRqQQE2AgAgAkEsakEANgIAIAJBsO/CADYCICACQejuwgA2AiggAkEANgIYIAEgAkEYahD3BwwDCyACQSRqQQE2AgAgAkEsakEANgIAIAJBmO/CADYCICACQejuwgA2AiggAkEANgIYIAEgAkEYahD3BwwCCyACQSRqQQE2AgAgAkEsakEANgIAIAJBgO/CADYCICACQejuwgA2AiggAkEANgIYIAEgAkEYahD3BwwBCyABKAIAIAAoAgQgAEEIaigCACABKAIEKAIMEQUACyEAIAJBMGokACAAC98HAxR9An4DfyABQRBqIRogAUEIaiEbIAIoAgBB/////wdxIRwgAkEEaigCAEH/////B3EhAiADQQxqKgIAIREgA0EIaioCACESIANBBGoqAgAhByABQRRqKgIAIRYgAUEMaioCACEOIAEpAhAiGEIgiKe+IQogASkCACIZQiCIp74hDSADKgIAIQggASoCECEXIAEqAgghEyAYp74hDyAZp74hEAJ9Q///f/8gASkCCCIYp74iFCABKgIAkyIEIASUIBhCIIinviIVIAFBBGoqAgCTIgUgBZSSQwAAAACSIgZDAACAKF5FDQAaIAUgBhB2IgmVIgUgD5QgBIwgCZUiBCAKlJIhCQJ/IAUgEJQgBCANlJIiCyAFIBSUIAQgFZSSIgxeRQRAIBogCSAMXUUNARogGwwBCyABIBogCSALXRsLIQNDAAAAACELQwAAAAAhDEP//3//IAUgEiAIIAcgBIyUIAggBZSTvEGAgICAeHEgHHK+IgaUIAcgByAFlCAIIASUk7xBgICAgHhxIAJyviIJlJOSIAMpAgAiGKe+k5QgBCARIAggCZQgByAGlJKSIBhCIIinvpOUkiIGQ///f/9eRQ0AGiAEIQsgBSEMIAYLIQkCQCAPIBOTIgQgBJQgCiAOkyIFIAWUkkMAAAAAkiIGQwAAgCheRQ0AIAUgBhB2IgaVIgUgD5QgBIwgBpUiBCAKlJIhBgJ/IAUgEJQgBCANlJIiDiAFIBSUIAQgFZSSIhNeRQRAIBogBiATXUUNARogGwwBCyABIBogBiAOXRsLIQMgBSASIAggByAEjJQgCCAFlJO8QYCAgIB4cSAccr4iBpQgByAHIAWUIAggBJSTvEGAgICAeHEgAnK+Ig6Uk5IgAykCACIYp76TlCAEIBEgCCAOlCAHIAaUkpIgGEIgiKe+k5SSIgYgCV5FDQAgBCELIAUhDCAGIQkLAkAgECAXkyIEIASUIA0gFpMiBSAFlJJDAAAAAJIiBkMAAIAoXkUNACAFIAYQdiIGlSIFIA+UIASMIAaVIgQgCpSSIQYCQCAFIBCUIAQgDZSSIgogBSAUlCAEIBWUkiINXkUEQCAGIA1dRQ0BIBshGgwBCyABIBogBiAKXRshGgsgBSASIAggByAEjJQgCCAFlJO8QYCAgIB4cSAccr4iBpQgByAHIAWUIAggBJSTvEGAgICAeHEgAnK+IgqUk5IgGikCACIYp76TlCAEIBEgCCAKlCAHIAaUkpIgGEIgiKe+k5SSIgYgCV5FDQAgBCELIAUhDCAGIQkLIAAgDDgCBCAAIAk4AgAgAEEIaiALOAIAC4wKAQV/IwBB4ABrIgQkACAEQQA2AkggBEIANwNAIARCgICAgMAANwM4IABBQGsgBEE4aiIDEEUgBEEANgJIIARCADcDQCAEQoCAgIDAADcDOCAAQegAaiADEEUgAEGgAWpBADYCACAAQoCAgIDAADcCmAEgAEG0AWpBBDYCACAAQawBaiIGQgA3AgAgAEKAgICAwAA3AqQBIABBKGpCADcCACAAQoCAgIDAADcCICAAQRhqQgA3AgAgAEKAgICAwAA3AhAgAEIANwIIIABCgICAgMAANwIAIABBuAFqQgA3AgAgAEHAAWpCADcCACAAQcgBakEENgIAIABCADcCkAEgAEHUAWpCADcCACAAQcwBakIANwIAIABB3AFqQgQ3AgAgAEHkAWpCADcCACAAQewBakIENwIAIABCgICAgMAANwL0ASAAQfwBakIANwIAIABBhAJqQgQ3AgAgAEEBOgCMAiAAQThqQgA3AgAgAEKAgICAwAA3AjAgA0ELakIANwAAIARBzQBqIgVBC2pCADcAACAEQgA3ADsgBEEgaiIHQQhqIANBCGopAAA3AwAgB0EPaiADQQ9qKAAANgAAIARCADcAUCAEQQhqIgNBCGogBUEIaikAADcDACADQQ9qIAVBD2ooAAA2AAAgBCAEKQA4NwMgIAQgBCkATTcDCCAAQQMQxQEgAEEQakEDEMUBIABBIGpBAxDFASAGKAIAIgMgACgCpAFGBEAgAEGkAWogA0EBELkEIAAoAqwBIQMLIAAgA0EBajYCrAEgACgCqAEgA0EEdGoiA0IANwIIIANCgICAgMAANwIAIAAgACgCkAFBA2oiBjYCkAECQCAAKAIcQQJLBEAgACgCFEEIakHNmbPuAzYCACAAKAKgASIFIAAoApgBRgRAIABBmAFqIAUQxAQgACgCkAEhBiAAKAKgASEFCyAAKAKcASAFQYQCbGoiA0IANwIoIAMgAjYCJCADIAE2AiAgA0IANwIYIANCgICA/AM3AhAgA0IANwIIIANCgICA/AM3AgAgA0KAgID8AzcCUCADQTBqQgA3AgAgA0E4akIANwIAIANBQGtCADcCACADQcgAakIANwIAIANBiAFqQv////v///+//wA3AgAgA0GAAWpC////+wc3AgAgA0H4AGpCgICAgPD//79/NwIAIANB8ABqQv////v///+//wA3AgAgA0HoAGpCADcCACADQeAAakKAgID8AzcCACADQdgAakIANwIAIANBoAFqQQA2AgAgA0GYAWpCADcCACADQZABakIANwIAIANBpAFqQv////sHNwIAIANBrAFqQQA6AAAgA0HAAWpC////+wc3AgAgA0HIAWpBADoAACADQa0BaiAEKQMgNwAAIANBtQFqIARBIGoiAUEIaikDADcAACADQbwBaiABQQ9qKAAANgAAIANByQFqIAQpAwg3AAAgA0HRAWogBEEIaiIBQQhqKQMANwAAIANB2AFqIAFBD2ooAAA2AAAgA0H0AWpCADcCACADQfwBakIANwIAIANB8AFqQYCAgPwDNgIAIANB7AFqQYACOwEAIANB6AFqQQA2AgAgA0HkAWpBADoAACADQdwBakL////7BzcCACAAIAVBAWoiATYCoAEgAEHYAWogASAGEO8CIAAoAqABRQ0BIARB4ABqJAAPC0G498AAQR1BwPjAABCSCgALQQBBAEHYoMEAEKMHAAvxBwEIfwJAAkAgAEEDakF8cSICIABrIgUgAUsNACAFQQRLDQAgASAFayIHQQRJDQAgB0EDcSEIQQAhAQJAIAAgAkYNACAFQQNxIQMCQCACIABBf3NqQQNJBEAgACECDAELIAVBfHEhBiAAIQIDQCABIAIsAABBv39KaiACLAABQb9/SmogAiwAAkG/f0pqIAIsAANBv39KaiEBIAJB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IAJBA0YNAiAAQQA2AgwgAkEERg0CIABBADYCECACQQVGDQIgAEEANgIUIAJBBkYNAiAAQQA2AhggAkEHRg0CIABBADYCHCACQQhGDQIgAEEANgIgIAJBCUYNAiAAQQA2AiQgAkEKRg0CIABBADYCKCACQQtGDQIgAEEANgIsIAJBDEYNAiAAQQA2AjAgAkENRg0CIABBADYCNCACQQ5GDQIgAEEANgI4IAJBD0YNAiAAQQA2AjwgAkEQRg0CIABBADYCQCACQRFGDQIgAEEANgJEIAJBEkYNAiAAQQA2AkggAkETRg0CIABBADYCTCACQRRGDQIgAEEANgJQIAJBFUYNAiAAQQA2AlQgAkEWRg0CIABBADYCWCACQRdGDQIgAEEANgJcIAJBGEYNAiAAQQA2AmAgAkEZRg0CIABBADYCZCACQRpGDQIgAEEANgJoIAJBG0YNAiAAQQA2AmwgAkEcRg0CIABBADYCcCACQR1GDQIgAEEANgJ0IAJBHkYNAiAAQQA2AnggAkEfRg0CIABBADYCfCACQSBGDQIgAEEANgKAASACQSFGDQIgAEEANgKEASACQSJGDQIgAEEANgKIASACQSNGDQIgAEEANgKMASACQSRGDQIgAEEANgKQASACQSVGDQIgAEEANgKUASACQSZGDQIgAEEANgKYASACQSdGDQIgAEEANgKcASACQShGDQJBKEEoQciywwAQowcACyADQShByLLDABCjBwALQfKywwBBHUHIssMAEMkIAAsgACgCoAEgBWohAiABQR9xIgdFBEAgACACNgKgASAADwsCQCACQQFrIgNBJ00EQCACIQQgACADQQJ0aigCACIGQQAgAWsiAXYiA0UNASACQSdNBEAgACACQQJ0aiADNgIAIAJBAWohBAwCCyACQShByLLDABCjBwALIANBKEHIssMAEKMHAAsCQCACIAVBAWoiCEsEQCABQR9xIQEgAkECdCAAakEIayEDA0AgAkECa0EoTw0CIAYgB3QhCSADQQRqIAkgAygCACIGIAF2cjYCACADQQRrIQMgCCACQQFrIgJJDQALCyAAIAVBAnRqIgEgASgCACAHdDYCACAAIAQ2AqABIAAPC0F/QShByLLDABCjBwALkwYBD38CQCAABEAgACgCAEUNARCnCwALEKYLAAsgACgCnAQhBCAAKAKYBCED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OgAEIAQgCjYCACAEQThqQn83AgAgBEE0aiAJOgAAIARBMGogCjYCACAEQShqQn83AgAgBEEkaiAJOgAAIARBIGogCjYCACAEQRhqQn83AgAgBEEUaiAJOgAAIARBEGogCjYCACAEQUBrIQQgBkEEayIGDQALCyAOBEADQCAEQn83AgggBCAJOgAEIAQgCjYCACAEQRBqIQQgDkEBayIODQALCyAHIA1qQQFrIQcLIAggC0YNACAEQn83AgggBCAJOgAEIAQgCjYCACAHQQFqIQcLIAUgBzYCCAJAIAAoAgQiCSgCCCIIIAtPDQAgCCEGIAsgCGsiCiAJKAIAIAhrSwRAIAkgCCAKELkEIAkoAgghBgsgCSgCBCAGQQR0aiEEIApBAk8EQCABIAhrIgdBB3EhBSAIQX9zIAFqQQdPBEAgB0F4cSEHA0AgBEL////7////v383AgggBEL////79///v/8ANwIAIARB+ABqQv////v///+/fzcCACAEQfAAakL////79///v/8ANwIAIARB6ABqQv////v///+/fzcCACAEQeAAakL////79///v/8ANwIAIARB2ABqQv////v///+/fzcCACAEQdAAakL////79///v/8ANwIAIARByABqQv////v///+/fzcCACAEQUBrQv////v3//+//wA3AgAgBEE4akL////7////v383AgAgBEEwakL////79///v/8ANwIAIARBKGpC////+////79/NwIAIARBIGpC////+/f//7//ADcCACAEQRhqQv////v///+/fzcCACAEQRBqQv////v3//+//wA3AgAgBEGAAWohBCAHQQhrIgcNAAsLIAUEQANAIARC////+////79/NwIIIARC////+/f//7//ADcCACAEQRBqIQQgBUEBayIFDQALCyAGIApqQQFrIQYLIAggC0YEQCAGIQsMAQsgBEL////7////v383AgggBEL////79///v/8ANwIAIAZBAWohCwsgCSALNgIIIAAoAgAhBQsCQCAFQQhqKAIAIgYgAUsEQCABQQR0IgYgBUEEaigCAGoiByABNgIIIAdBDGogAjYCACAAKAIEIgJBCGooAgAiByABTQ0BIAJBBGooAgAgBmoiAiADKQIANwIAIAJBCGogA0EIaikCADcCACAAKAIIIgAoAggiBSAA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QCAEIAUQdiIElbytIAaMIASVvK1CIIaEIQ4LIABCADcCECAAIA43AgggACAPNwIAIABBGGpCADcCACAAIAFFOgAgIABBADoAJA8LIAogAkHklsIAEKMHAAsgCyACQfSWwgAQowcACyADIAJBhJfCABCjBwALIAogAkGUl8IAEKMHAAsgAyACQYSXwgAQowcACyAKIAJBlJfCABCjBwALygUBCH8jAEHgAGsiAyQAIAEtABwhCCADQUBrIAEQywICQAJAAkACQCADKAJEIAMoAkhqIgRFBEBBBCEGDAELIARB5syZM0sNASAEQRRsIgVBAEgNASAEQefMmTNJQQJ0IQIgBQR/IAUgAhDQCgUgAgsiBkUNAgtBACEFIANBADYCWCADIAY2AlQgAyAENgJQAkAgAUEYaigCACIHRQ0AIAFBFGooAgAhAiAEIAdJBEAgA0HQAGpBACAHELYEIAMoAlghBSADKAJUIQYLIAdBFGxBFGsiBEEUbkEBcQR/IAIFIAYgBUEUbGoiASACKAIQNgIQIAEgAkEMai0AADoADCABIAJBCGooAgA2AgggASACKQIANwIAIAVBAWohBSACQRRqCyEBIARBFEkNACACIAdBFGxqIQcgBiAFQRRsaiEJQQAhBgNAIAYgCWoiAiABIAZqIgQpAgA3AgAgAkEQaiAEQRBqKAIANgIAIAJBDGogBEEMai0AADoAACACQQhqIARBCGooAgA2AgAgAkEUaiAEQRRqKQIANwIAIAJBJGogBEEkaigCADYCACACQSBqIARBIGotAAA6AAAgAkEcaiAEQRxqKAIANgIAIAVBAmohBSABIAZBKGoiBmogB0cNAAsLIANBEGoiBiADKQNQNwMAIANBGGoiAiAFNgIAIANBCGoiBSADQcgAaikDADcDACADIAMpA0A3AwBBIEEEENAKIgFFDQIgASADKQMANwIAIAEgCDoAHCABIAMvAEA7AB0gAUEYaiACKAIANgIAIAFBEGogBikDADcCACABQQhqIAUpAwA3AgAgAUEfaiADQcIAai0AADoAACAAQaiRwgA2AgQgACABNgIAIANB4ABqJAAPCxCKCQALIAUgAkHAw8MAKAIAIgBBpAYgABsRAAAAC0EgQQRBwMPDACgCACIAQaQGIAAbEQAAAAvKBQEIfyMAQeAAayIDJAAgAS0AHCEIIANB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AwA3AgAgAUEfaiACQcIAai0AADoAACAAQdyRwgA2AgQgACABNgIAIAJB4ABqJAAPCxCKCQALIAQgA0HAw8MAKAIAIgBBpAYgABsRAAAAC0EgQQRBwMPDACgCACIAQaQGIAAbEQAAAAufBQEIfyMAQeAAayICJAAgAS0AHCEIIAJBQGsgARDLAgJAAkACQAJAIAIoAkQgAigCSGoiBUUEQEEEIQYMAQsgBUH///8/Sw0BIAVBBHQiBEEASA0BIAVBgICAwABJQQJ0IQMgBAR/IAQgAxDQCgUgAwsiBkUNAgtBACEEIAJBADYCWCACIAY2AlQgAiAFNgJQAkAgAUEYaigCACIHRQ0AIAFBFGooAgAhAyAFIAdJBEAgAkHQAGpBACAHELkEIAIoAlghBCACKAJUIQYLIAdBAWtB/////wBxIQUgB0EBcQR/IAYgBEEEdGoiASADKQIINwIIIAEgA0EEai0AADoABCABIAMoAgA2AgAgBEEBaiEEIANBEGoFIAMLIQEgBUUNACADIAdBBHRqIQcgBiAEQQR0aiEJQQAhBgNAIAYgCWoiAyABIAZqIgUoAgA2AgAgA0EIaiAFQQhqKQIANwIAIANBBGogBUEEai0AADoAACADQRhqIAVBGGopAgA3AgAgA0EUaiAFQRRqLQAAOgAAIANBEGogBUEQaigCADYCACAEQQJqIQQgASAGQSBqIgZqIAdHDQALCyACQRBqIgYgAikDUDcDACACQRhqIgMgBDYCACACQQhqIgQgAkHIAGopAwA3AwAgAiACKQNANwMAQSBBBBDQCiIBRQ0CIAEgAikDADcCACABIAg6ABwgASACLwBAOwAdIAFBGGogAygCADYCACABQRBqIAYpAwA3AgAgAUEIaiAEKQMANwIAIAFBH2ogAkHCAGotAAA6AAAgAEHcksIANgIEIAAgATYCACACQeAAaiQADwsQigkACyAEIANBwMPDACgCACIAQaQGIAAbEQAAAAtBIEEEQcDDwwAoAgAiAEGkBiAAGxEAAAALqgUCE38DfiMAQYABayIDJAAgAyABQcgAahC6AiABQZABaiICKAIABEAgAkEANgIACyABKAKYASEHIAEoApQBIQggASkCCCEVIAEpAgAhFiADQdAAaiICQRBqIgkgAUGsAWooAgA2AgAgAkEIaiIKIAFBpAFqKQIANwMA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////P3FBAWohByACKAIIIQADQCAAQQRqKAIAIgEEQCADKAIIIAAoAgAgASADKAIMKAIMEQUADQMLIAMgBSAKaiIEQRxqLQAAOgAoIAMgBEEUaikCADcDICAEQRBqKAIAIQYgAigCECEIQQAhCUEAIQECQAJAAkAgBEEMaigCAEEBaw4CAAIBCyAIIAZBA3RqIgxBBGooAgBBvAZHDQEgDCgCACgCACEGC0EBIQELIAMgBjYCFCADIAE2AhAgBEEIaigCACEBAkACQAJAIARBBGooAgBBAWsOAgACAQsgCCABQQN0aiIGQQRqKAIAQbwGRw0BIAYoAgAoAgAhAQtBASEJCyADIAE2AhwgAyAJNgIYIAggBCgCAEEDdGoiASgCACADQQhqIAEoAgQRAwANAiAAQQhqIQAgCyAFQSBqIgVHDQALCyACQQxqKAIAIAdLBEAgAygCCCACKAIIIAdBA3RqIgAoAgAgACgCBCADKAIMKAIMEQUADQELQQAMAQtBAQshASADQTBqJAAgAQuJBQIGfwF+IwBBQGoiAiQAAn8gASgCACIDRQRAIABBCGpBADYCAEEADAELIAEgA0EBazYCACACIAEoAgQ2AhQgAkEDNgIQIAJBKGogAkEQahCNAgJAAkACQAJAAkACQCACKAIoRQRAIAJBMGooAgAiA0UEQEEAIAJBoILAABC7BiEBDAcLIAIoAiwhBAJAIAIoAhAiBgRAIAIoAhQiASgCBCIHQQhJDQQgAkE0aigCACEFIAEgB0EIazYCBCABIAEoAgAiAUEIajYCACABKQAAIghCgICAgBBUDQEgAkEBOgAoIAIgCDcDMCACQShqIAJB7IDAABCEByEBDAcLQQEgAkGggsAAELsGIQEMBgsgBkEBRw0BQQIgAkGggsAAELsGIQEMBQsgAigCLCEBDAULIAinIgEgBUYNAiACQRxqQQE2AgAgAiABNgIgIAJBATYCFCACIAU2AiQgAiACQSRqNgIYIAIgAkEgajYCECACQQI2AjwgAkECNgI0IAJB0LHAADYCMCACQQA2AiggAiACQRBqIgE2AjggAiACQShqEIoCIAEgAhDaByACQTNqIAFBCGooAgA2AAAgAiACKQMQNwArQRBBBBDQCiIBRQ0BIAFBCDoAACABIAIpACg3AAEgAUEIaiACQS9qKQAANwAAIAIoAgAE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EGpBAkEDIAZDAAAAAFsbNgIADAELIAAgAykDIDcCACAAQQI2AgwgAEEIaiADQShqKAIANgIACyADQUBrJAAL9gQBDH8jAEGAAWsiAiQAIAJBQGsgARDYASABQcQAaigCACEHQQQhCUEEIQQCQAJAAkACQCABQcgAaigCACIIBEAgCEH/////AEsNAiAIQQN0IgVBAEgNAiAIQYCAgIABSUECdCEDIAUEfyAFIAMQ0AoFIAMLIgRFDQELIAQgByAFEK4LIQUgAUHQAGooAgAhByABQdQAaigCACIDBEAgA0H/////AEsNAiADQQN0IgZBAEgNAiADQYCAgIABSUECdCEEIAYEfyAGIAQQ0AoFIAQLIglFDQMLIAkgByAGEK4LIQQgAkE4aiIJIAJBQGsiAUE4aikDADcDACACQTBqIgYgAUEwaikDADcDACACQShqIgcgAUEoaikDADcDACACQSBqIgogAUEgaikDADcDACACQRhqIgsgAUEYaikDADcDACACQRBqIgwgAUEQaikDADcDACACQQhqIg0gAUEIaikDADcDACACIAIpA0A3AwBB2ABBBBDQCiIBRQ0DIAEgAikDADcCACABIAM2AlQgASAENgJQIAEgAzYCTCABIAg2AkggASAFNgJEIAEgCDYCQCABQThqIAkpAwA3AgAgAUEwaiAGKQMANwIAIAFBKGogBykDADcCACABQSBqIAopAwA3AgAgAUEYaiALKQMANwIAIAFBEGogDCkDADcCACABQQhqIA0pAwA3AgAgAEGcvcIANgIEIAAgATYCACACQYABaiQADwsgBSADQcDDwwAoAgAiAEGkBiAAGxEAAAALEIoJAAsgBiAEQcDDwwAoAgAiAEGkBiAAGxEAAAALQdgAQQRBwMPDACgCACIAQaQGIAAbEQAAAAusBAMFfQV/An4jAEEgayIHJAAgAUEIaigCACIIBEBEAAAAAAAA8D8gCLijtiICIAFBBGooAgAiASkCACIMQiCIp76UIQMgASAIQQN0aiEKIAIgDKe+lCEEAkAgCEEBRg0AIAhB/v///wFqQf////8BcSELIAhBAXEEfyABQQhqBSAEIAIgASkCCCIMp76UkiEEIAMgAiAMQiCIp76UkiEDIAFBEGoLIQkgC0UNAANAIAQgAiAJKQIAIgynvpSSIAIgCUEIaikCACINp76UkiEEIAMgAiAMQiCIp76UkiACIA1CIIinvpSSIQMgCUEQaiIJIApHDQALCyAIQQFrQf////8BcSEJAkAgCEEBcUUEQEMAAAAAIQIMAQsgBCABKgIAkyICIAKUIAMgAUEEaioCAJMiAiAClJJDAAAAAJIiAkMAAAAAIAJDAAAAAF4bIQIgAUEIaiEBCyAJBEADQCAEIAFBCGoqAgCTIgUgBZQgAyABQQxqKgIAkyIFIAWUkkMAAAAAkiIFIAQgASoCAJMiBiAGlCADIAFBBGoqAgCTIgYgBpSSQwAAAACSIgYgAiACIAZdGyICIAIgBV0bIQIgCiABQRBqIgFHDQALCyAAIAIQdjgCCCAAIAS8rSADvK1CIIaENwIAIAdBIGokAA8LIAdBFGpBATYCACAHQRxqQQA2AgAgB0H45cIANgIQIAdB5PDBADYCGCAHQQA2AgggB0EIakHk5sIAELwJAAvaBQMEfwV9BH4jAEEgayIHJAAgByAAKQIINwMAIAdBCGogASAHIAIRAgACQCAHKQMAIhCnviAHKQMIIhKnvpMiDCAMlCAQQiCIp74gEkIgiKe+kyILIAuUkkMAAAAAkiINQwAAAABeRQ0AIAdBGGooAgAhASAHKAIUIQkgBy0AECEKIAsgDRB2IguVvCECIAwgC5W8IQggCkEBcQR+IAuMIQsgCEGAgICAeHOtIAJBgICAgHhzrUIghoQFIAitIAKtQiCGhAshESALIAMgBJJfRQRAIAVBkAFqIgAoAgBFDQEgAEEANgIADAELIABBBGoqAgAiDCARp74iDZQgACoCACIOIBFCIIinviIPlJMhBCAMIA+MlCAOIA2UkyIMIAOUvK0gBCADlLytQiCGhCEQIAEhAEEAIQEjAEEgayICJAACQAJAAkACQAJAAkAgCUEBaw4CAQIACyACIABBgICAgHxxIgE2AgQgAQ0CIABBgICAgARyIQEMAQsgAiAAQYCAgIB8cSIBNgIEIAENAiAAQYCAgIB8ciEBCyACQSBqJAAMAgsgAkEANgIQIAJBBGogAkEIakGs08IAEOIHAAsgAkEANgIQIAJBBGogAkEIakG808IAEOIHAAtBABDPCCEAAkAgBgRAIBAhEyASIRAgACECIAEhAAwBCyASIRMgASECCyALIAOTIQMCQAJAIAVBkAFqIgEoAgBBAUcEQCAFIBM3AkggAUEBNgIAIAVB6ABqIAA2AgAgBUHkAGogAjYCACAFQeAAaiADOAIAIAVB2ABqQgA3AgAgBUHQAGogEDcCACAGRQ0BDAILIAUgEzcCSCAFQegAaiAANgIAIAVB5ABqIAI2AgAgBUHQAGogEDcCACAFQeAAaiADOAIAIAYNAQsgBSAMOAIIIAUgETcCACAFQQxqIAQ4AgAMAQsgBSARNwIIIAUgBDgCBCAFIAw4AgALIAdBIGokAAuWBAMFfQJ+An8CQAJAAkACfSACRQRAQwAAAAAgASgCaCICQQFqIgpFDQEaIAEqAlAiAyABQRhqKQIAIginvpRDAAAAAJIhBSADIAFBEGopAgAiCae+lEMAAAAAkiEEIAMgCEIgiKe+lEMAAAAAkiEGIAMgCUIgiKe+lEMAAAAAkiIDIAJFDQEaIApBAkcNAiAFIAFB1ABqKgIAIgcgAUEwaikCACIIp76UkiEFIAQgByABQShqKQIAIgmnvpSSIQQgBiAHIAhCIIinvpSSIQYgAyAHIAlCIIinvpSSDAELQwAAAAAgASgCZCIKQQFqIgtFDQAaIAEoAlgiAkEDTw0DIAEqAgAiAyABIAJBGGxqIgJBGGopAgAiCKe+lEMAAAAAkiEFIAMgAkEQaikCACIJp76UQwAAAACSIQQgAyAIQiCIp76UQwAAAACSIQYgAyAJQiCIp76UQwAAAACSIgMgCkUNABogAUHcAGooAgAiAkECSw0DIAtBAkcNAiAFIAEqAgQiByABIAJBGGxqIgFBGGopAgAiCKe+lJIhBSAEIAcgAUEQaikCACIJp76UkiEEIAYgByAIQiCIp76UkiEGIAMgByAJQiCIp76UkgshAyAAIAY4AgwgACAFOAIIIAAgAzgCBCAAIAQ4AgAPC0ECQQJB0JzCABCjBwALQQJBAkGAncIAEKMHAAsgAkEDQZCdwgAQowcAC/EEAgN/AXwjAEHQAGsiAyQAIAMgAigCGAR/IAJBHGooAgAhBCADQTBqIgUgAkEgaigCADYCBCAFIAQ2AgAgAysDMBABBUEhCzYCPCADIAIoAiQEfyACQShqKAIAIQQgA0EoaiIFIAJBLGooAgA2AgQgBSAENgIAIAMrAygQAQVBIQs2AkAgAigCACEEIANBIGoiBSACKAIENgIEIAUgBDYCACADIAMrAyAQATYCSCACKAIIIQQgA0EYaiIFIAJBDGooAgA2AgQgBSAENgIAIAMgAysDGBABNgJMIAMgAUEEaiABIANByABqIANBzABqELkKNgJEIANBEGogA0HEAGogASADQTxqIANBQGsQuAggAygCFCECAn8CQCADKAIQBEAgAkEkTwRAIAIQAAsgAygCRCIBQSRPBEAgARAACyADKAJMIgFBJE8EQCABEAALIAMoAkgiAUEkSQ0BIAEQAAwBCyADKAJEIgFBJE8EQCABEAALIAMoAkwiAUEkTwRAIAEQAAsgAygCSCIBQSRPBEAgARAACyADIAIQAiADKAIABEACfyADKwMIIgZEAAAAAAAAAABmIQQgBCAGRAAAAAAAAPBBY3EEQCAGqwwBC0EACyEBIAJBJE8EQCACEAALIAFBACAEGyEBIAZEAADg////70FkIQIgAygCQCIEQSRPBEAgBBAAC0F/IAEgAhshAiADKAI8IgFBJE8EQCABEAALIAJBAkkMAgsgAkEkSQ0AIAIQAAsgAygCQCIBQSRPBEAgARAACyADKAI8IgJBJE8EQCACEAALQQALIQEgACACNgIEIAAgATYCACADQdAAaiQAC+oEAQl/IwBBIGsiAiQAIAAtABxFBEAgAC0AACEBIABBAToAACACIAFBAXEiAToABwJAAkACQCABRQRAQdTDwwAoAgBB/////wdxBEBBxMfDACgCAEVFIQgLIAAtAAFFBEAgAC0AHA0EIAJBCGogAEEEahCwAgJAIAIoAhAiAUUNACABIAEoAgAiAUEBazYCACABQQFHDQAgAigCEBCoCAsgAEEYaiIBKAIAIQMgAUEANgIAIANBDGwhBSAAQRRqKAIAIgYhBCADRQ0CIAUhASAGIQMDQCADKAIIIgdFBEAgA0EMaiEEDAQLIAdBEGoiBCgCACEJIAQgCSADKAIAIAkbNgIAIAlFBEAgB0EYaigCAEEQahCrAwsgByAHKAIAIgRBAWs2AgAgBEEBRgRAIAcQqAgLIANBDGohAyABQQxrIgENAAsMAwsgAiAIOgAMIAIgADYCCEH4g8AAQSsgAkEIakHEhMAAQbSEwAAQ2wYACyACQQA2AhwgAkG4gMAANgIYIAJBATYCFCACQaiPwAA2AhAgAkEANgIIIAJBB2ogAkEIahDbBwALIAUgBmoiASAERg0AIAEgBGtBDG5BDGwhAyAEIAAoAhQiAWtBDG5BDGwgAWpBCGohBQNAIAUoAgAiASgCACEGIAEgBkEBazYCACAGQQFGBEAgBSgCABCoCAsgBUEMaiEFIANBDGsiAw0ACwsgACAAQQxqKAIABH9BAQUgAEEYaigCAAtFOgAcCwJAIAgNAEHUw8MAKAIAQf////8HcUUNAEHEx8MAKAIARQ0AIABBAToAAQsgAEEAOgAACyACQSBqJAAL6gQBCX8jAEEgayICJAAgAC0AHEUEQCAALQAAIQEgAEEBOgAAIAIgAUEBcSIBOgAHAkACQAJAIAFFBEBB1MPDACgCAEH/////B3EEQEHEx8MAKAIARUUhCAsgAC0AAUUEQCAALQAcDQQgAkEIaiAAQQRqELICAkAgAigCECIBRQ0AIAEgASgCACIBQQFrNgIAIAFBAUcNACACKAIQEKgICyAAQRhqIgEoAgAhAyABQQA2AgAgA0EMbCEFIABBFGooAgAiBiEEIANFDQIgBSEBIAYhAwNAIAMoAggiB0UEQCADQQxqIQQMBAsgB0EQaiIEKAIAIQkgBCAJIAMoAgAgCRs2AgAgCUUEQCAHQRhqKAIAQRBqEKsDCyAHIAcoAgAiBEEBazYCACAEQQFGBEAgBxCoCAsgA0EMaiEDIAFBDGsiAQ0ACwwDCyACIAg6AAwgAiAANgIIQdjDwABBKyACQQhqQcjHwABBlMTAABDbBgALIAJBADYCHCACQfS+wAA2AhggAkEBNgIUIAJBzMvAADYCECACQQA2AgggAkEHaiACQQhqEN0HAAsgBSAGaiIBIARGDQAgASAEa0EMbkEMbCEDIAQgACgCFCIBa0EMbkEMbCABakEIaiEFA0AgBSgCACIBKAIAIQYgASAGQQFrNgIAIAZBAUYEQCAFKAIAEKgICyAFQQxqIQUgA0EMayIDDQALCyAAIABBDGooAgAEf0EBBSAAQRhqKAIAC0U6ABwLAkAgCA0AQdTDwwAoAgBB/////wdxRQ0AQcTHwwAoAgBFDQAgAEEBOgABCyAAQQA6AAALIAJBIGokAAuoBAMDfwh9BH4jAEHQAGsiBSQAIAVBMGogASkCACIQNwMAIAVBIGogASkCECIRNwMAIAUgETcDKCAFIAEpAggiEjcDGCAFIBI3AxAgBSAQNwMIAkACQCAERQ0AIBKnviIJIBCnviIIkyACKQIAIhNCIIinviIKIBBCIIinviILk5QgEkIgiKe+IgwgC5MgE6e+Ig0gCJOUk0MAAAAAXiEBIAEgEae+Ig4gCZMgCiAMk5QgEUIgiKe+Ig8gDJMgDSAJk5STQwAAAABeRUYNACABIAggDpMgCiAPk5QgCyAPkyANIA6TlJNDAAAAAF5zDQAgAEEANgIQIABCATcCCCAAQoCAgICAgIDAPzcCAAwBCyAFQRhqIQYgBUE4aiAFQQhqIAIgA0EAEKgBQ///f38hCQJ/QQMgBSgCQCIEQQNGDQAaQQMgBSoCSCIIQ///f39dRQ0AGiAFNQJEIAi8rUIghoQhESAFKQM4IRAgCCEJIAQLIQEgBUEoaiEHIAVBOGogBiACIANBABCoAQJAIAUoAkAiBEEDRg0AIAUqAkgiCCAJXUUNACAFNQJEIAi8rUIghoQhESAFKQM4IRAgBCEBIAghCQsgBUE4aiAHIAIgA0EAEKgBAkAgBSgCQCICQQNGDQAgBSoCSCIDIAldRQ0AIAU1AkQgA7ytQiCGhCERIAUpAzghECACIQELIAAgETcCDCAAIAE2AgggACAQNwIACyAFQdAAaiQAC7QEAw1/Cn0BfiABBEAgAEEcaioCACAAKQIQIhlCIIinvpIhEiAAQdwAaiEFIAFBAWshBiAAKgIYIBmnvpIhEwNAIAAgA0HUAGxqIgIqAgghDyACIAIqAkwgAioCUCAPIBMgD5SUIAJBDGoqAgAiDyASIA+UlJIgAioCOCIPIA+UkiACKgI8Ig8gD5SSIg+UkiIQOAJMIAJDAAAAAEMAAIA/IA8gEJIiEJUiESAQQwjlPB5dGyARIBBDCOU8nl4bOAJAIANBAWohAwJAIAIqAgBD//9//1wNACACKgIEQ///f39cDQAgASADTQ0AQwAAAABDAACAPyAPlSIQIA9DCOU8Hl0bIBAgD0MI5TyeXhshECACQTxqIQkgAkE4aiEKIAJBCGohByACQcQAaiELIAJByABqIQwgBSECIAYhCANAIAcpAgAhGSAQIBMgByoCAJQgAioCACIRlCASIAdBBGoqAgCUIAJBBGoiBCoCACIUlJIgCioCACIVIAJBMGoiDSoCACIWlJIgCSoCACIXIAJBNGoiDioCACIYlJKUIQ8gDiAYIBcgD5STOAIAIA0gFiAVIA+UkzgCACAEIBQgDyAZQiCIp76UkzgCACACIBEgDyAZp76UkzgCACACQUBrIgQgBCoCACAPIAwqAgCUkzgCACACQTxqIgQgBCoCACAPIAsqAgCUkzgCACACQdQAaiECIAhBAWsiCA0ACwsgBUHUAGohBSAGQQFrIQYgASADRw0ACwsLxgQBC38jAEEgayIFJAAgAEEYaigCACIHIAFqIQYgACgCBCEJIAAoAgAhCgJAIAAoAhAiAiAHayIDIAFPDQACQCAGIAdJDQAgBkGUAmwhBCAGQYLz2gNJQQJ0IQgCQCACBEAgBUEENgIYIAUgAkGUAmw2AhQgBSAAQRRqKAIANgIQDAELIAVBADYCGAsgBSAEIAggBUEQahDPBSAFKAIEIQIgBSgCAEUEQCAAIAY2AhAgAEEUaiACNgIAIAEhAwwCCyAFQQhqKAIAIgRBgYCAgHhGDQEgBEUNACACIARBwMPDACgCACIAQaQGIAAbEQAAAAsQigkACyADQQAgBiAHIgJrIgMgAyAGSxsiA0kEQCAAQRBqIAcgAxC4BCAAKAIYIQILAkAgBiAHTQ0AIABBFGooAgAhCCAGQQFrIQsCQCABQQFxRQRAIAchAwwBCyAIIAJBlAJsaiIEQQI6AIwCIAQgCSAHQQFqIgMgByALRiIMGzYCBCAEIApBASAMGzYCACACQQFqIQILIAFBAUYNACADQX9zIAZqIQQgAkGUAmwgCGpBoARqIQEDQCABQQI6AAAgAUGUAmtBAjoAACABQaAEa0EBIAogBBs2AgAgAUGcBGsgA0EBaiIIIAkgBBs2AgAgAUGIAmsgCSADQQJqIgMgCCALRiIIGzYCACABQYwCayAKQQEgCBs2AgAgBEECayEEIAFBqARqIQEgAkECaiECIAMgBkcNAAsLIAAgBzYCBCAAQQE2AgAgACACNgIYIAVBIGokAAuYBAIJfwJ+IwBB4AFrIgckAAJAIAIgAUEUaigCACIFTwRAIABBAjoAXAwBCyABQQRqKAIAIQgCQCABQQhqKAIAIgkgAUEQaigCACIGIAJB1AFsaiIKKQIIIg2nIgNNDQAgCikCACEMIA1CIIinIQsCQAJAIAIgCCADQQR0aiIEKAIIIgNGBEAgBEEIaiEEDAELA0AgAyAFTw0CIAYgA0HUAWxqIgQoAgAiAyACRw0ACwsgBCAMPgIACyAJIAtNDQAgAiAIIAtBBHRqQQxqIgQoAgAiA0cEfwNAIAMgBU8NAiAGIANB1AFsaiIEKAIEIgMgAkcNAAsgBEEEagUgBAsgDEIgiD4CAAsgB0EIaiAKQdQBEK4LGiAKIAYgBUEBayIDQdQBbGpB1AEQrAshBCABQRRqIAM2AgAgAiADTwRAIAAgB0EYakHEARCuCxoMAQsCQCAEQQhqKQIAIgynIgEgCU8NACAMQiCIpyEFAkACQCAIIAFBBHRqIgEoAggiBCADRgRAIAFBCGohAQwBCwNAIAMgBE0NAiADIAYgBEHUAWxqIgEoAgAiBEcNAAsLIAEgAjYCAAsgBSAJTw0AIAggBUEEdGpBDGoiASgCACIEIANHBH8DQCADIARNDQIgAyAGIARB1AFsaiIBKAIEIgRHDQALIAFBBGoFIAELIAI2AgALIAAgB0EYakHEARCuCxoLIAdB4AFqJAALwgQBFH0gAUE8aioCACEMIAJBHGoqAgAhCSABKgIcIQ0gAioCDCEGIAEqAgwhDiABQSxqKgIAIQ8gAUE4aioCACEQIAJBGGoqAgAhByABKgIYIREgAioCCCEEIAEqAgghEiABQShqKgIAIRMgAUE0aioCACEUIAJBFGoqAgAhCCABKgIUIRUgAioCBCEFIAEqAgQhCiABQSRqKgIAIRYgASoCACACKgIAIgOTIgsgAyABKgIgkyIDIAMgC18bIgNDAAAAACADQwAAAABgGyIDIAOUIAEqAhAgAioCECIDkyILIAMgAUEwaioCAJMiAyADIAtfGyIDQwAAAAAgA0MAAAAAYBsiAyADlJJDAAAAAJIQdiEDIAogBZMiCiAFIBaTIgUgBSAKXxsiBUMAAAAAIAVDAAAAAGAbIgUgBZQgFSAIkyIFIAggFJMiCCAFIAhgGyIIQwAAAAAgCEMAAAAAYBsiCCAIlJJDAAAAAJIQdiEIIBIgBJMiBSAEIBOTIgQgBCAFXxsiBEMAAAAAIARDAAAAAGAbIgQgBJQgESAHkyIEIAcgEJMiByAEIAdgGyIHQwAAAAAgB0MAAAAAYBsiByAHlJJDAAAAAJIQdiEHIAAgDiAGkyIEIAYgD5MiBiAEIAZgGyIGQwAAAAAgBkMAAAAAYBsiBiAGlCANIAmTIgYgCSAMkyIJIAYgCWAbIglDAAAAACAJQwAAAABgGyIJIAmUkkMAAAAAkhB2OAIMIAAgBzgCCCAAIAg4AgQgACADOAIAC8IEAgF/AX0gACgCACICKAIIIQAgAigCACAAa0EHTQRAIAIgAEEIEO4EIAIoAgghAAsgAigCBCAAakICNwAAIAIgAEEIaiIANgIIIAEqAgAhAyACKAIAIABrQQNNBEAgAiAAQQQQ7gQgAigCCCEACyACKAIEIABqIAM4AAAgAiAAQQRqIgA2AgggASoCBCEDIAIoAgAgAGtBA00EQCACIABBBBDuBCACKAIIIQALIAIoAgQgAGogAzgAACACIABBBGoiADYCCCABKgIIIQMgAigCACAAa0EDTQRAIAIgAEEEEO4EIAIoAgghAAsgAigCBCAAaiADOAAAIAIgAEEEaiIANgIIIAEqAgwhAyACKAIAIABrQQNNBEAgAiAAQQQQ7gQgAigCCCEACyACKAIEIABqIAM4AAAgAiAAQQRqIgA2AgggASoCECEDIAIoAgAgAGtBA00EQCACIABBBBDuBCACKAIIIQALIAIoAgQgAGogAzgAACACIABBBGoiADYCCCABQRRqKgIAIQMgAigCACAAa0EDTQRAIAIgAEEEEO4EIAIoAgghAAsgAigCBCAAaiADOAAAIAIgAEEEaiIANgIIIAFBGGoqAgAhAyACKAIAIABrQQNNBEAgAiAAQQQQ7gQgAigCCCEACyACKAIEIABqIAM4AAAgAiAAQQRqIgA2AgggAUEcaioCACEDIAIoAgAgAGtBA00EQCACIABBBBDuBCACKAIIIQALIAIgAEEEajYCCCACKAIEIABqIAM4AABBAAuuBAIGfwN9IwBBIGsiBCQAAkACQAJAAkAgAkEMaigCACIGIABBFGooAgAiAyAAQRBqKAIAIgdqTwRAIAFBCGooAgAhBSABQQRqKAIAIQggAkEEaigCACEBIAQgBjYCCCAEIAM2AgQgBCABIAdBAnRqIgc2AgAgAEEYaigCACIBIAVLDQEgA0EBaiICIANqIQYgBiAFIAFrIAJqSw0CIAQgAzYCGCAEIAM2AhQgBCAIIAFBAnRqNgIQIARBEGogBBCYASEJIAAgACoCICIKIAAqAiQgCSAAKgIokiAKIAAqAjSUk5SSIgkgACoCBCILIAkgC10bIAAqAgAiCyAJIAteGyIJOAIgIAEgA2oiACAFSw0DIAIgBWogAGsgBkkNBAJAIANFDQAgCSAKkyEKIAggAEECdGohBSADQQFxIQhBACEAIANBAUcEQEEAIQJBACADQX5xayEDIAUhASAHIQADQCAAIAAqAgAgCiABKgIAlJM4AgAgAEEEaiIGIAYqAgAgCiABQQRqKgIAlJM4AgAgAUEIaiEBIABBCGohACADIAJBAmsiAkcNAAtBACACayEACyAIRQ0AIABBAnQiACAHaiIBIAEqAgAgCiAAIAVqKgIAlJM4AgALIARBIGokAA8LQbj3wABBHUHA+MAAEJIKAAsgASAFQfi/wQAQlgsAC0G0+8AAQSlBzPzAABCSCgALIAAgBUGIwMEAEJYLAAtBtPvAAEEpQcz8wAAQkgoAC68EAgl/AX4jAEEgayIFJAAgBUEIaiIEIAI2AgQgBCABNgIAIAUoAgwhCyAAQQhqKAIAIgQgBSgCCCIGTQRAIAVBEGoiAUJ/NwIAIAFC/////w83AgggAEEIagJ/IAZBAWoiCSAETQRAIAkMAQsgBCEIIAkgBGsiCiAAKAIAIARrSwRAIAAgBCAKELYEIABBCGooAgAhCAsgACgCBCAIQRRsaiECIApBAk8EfyAGIARrIgdBA3EhASAGIARBf3NqQQNPBEAgB0F8cSEHIAVBGGohDANAIAJBfzYCACACIAUpAxAiDTcCBCACQRRqQX82AgAgAkEYaiANNwIAIAJBKGpBfzYCACACQSxqIA03AgAgAkE8akF/NgIAIAJBQGsgDTcCACACQQxqIAwpAwAiDTcCACACQSBqIA03AgAgAkE0aiANNwIAIAJByABqIA03AgAgAkHQAGohAiAHQQRrIgcNAAsLIAEEQCAFQRhqIQcDQCACQX82AgAgAiAFKQMQNwIEIAJBDGogBykDADcCACACQRRqIQIgAUEBayIBDQALCyAIIApqQQFrBSAICyIBIAQgCUYNABogAkF/NgIAIAIgBSkDEDcCBCACQQxqIAVBGGopAwA3AgAgAUEBagsiBDYCAAsgBCAGSwRAIABBBGooAgAgBkEUbGoiACALNgIAIAAgAykCADcCBCAAQQxqIANBCGopAgA3AgAgBUEgaiQADwsgBiAEQeygwAAQowcAC7oEAgF/An0gAEEEaioCACEDIAAqAgAhBCABKAIAIgEoAgghAiABKAIAIAJrQQdNBEAgASACQQgQ7gQgASgCCCECCyABKAIEIAJqQgI3AAAgASACQQhqIgI2AgggASgCACACa0EDTQRAIAEgAkEEEO4EIAEoAgghAgsgASgCBCACaiAEOAAAIAEgAkEEaiICNgIIIAEoAgAgAmtBA00EQCABIAJBBBDuBCABKAIIIQILIAEoAgQgAmogAzgAACABIAJBBGoiAjYCCCAAQQxqKgIAIQMgAEEIaioCACEEIAEoAgAgAmtBB00EQCABIAJBCBDuBCABKAIIIQILIAEoAgQgAmpCAjcAACABIAJBCGoiAjYCCCABKAIAIAJrQQNNBEAgASACQQQQ7gQgASgCCCECCyABKAIEIAJqIAQ4AAAgASACQQRqIgI2AgggASgCACACa0EDTQRAIAEgAkEEEO4EIAEoAgghAgsgASgCBCACaiADOAAAIAEgAkEEaiICNgIIIABBFGoqAgAhAyAAQRBqKgIAIQQgASgCACACa0EHTQRAIAEgAkEIEO4EIAEoAgghAgsgASgCBCACakICNwAAIAEgAkEIaiIANgIIIAEoAgAgAGtBA00EQCABIABBBBDuBCABKAIIIQALIAEoAgQgAGogBDgAACABIABBBGoiADYCCCABKAIAIABrQQNNBEAgASAAQQQQ7gQgASgCCCEACyABIABBBGo2AgggASgCBCAAaiADOAAAQQAL+wMDAn8EfQF+IwBBMGsiBiQAIAYgASkCCDcDACAGQRhqIgcgAiAGIAMoAjARAgAgBkEQaiAHQQhqKAIANgIAIAYgBikDGCIMNwMIAn4CQCAMp74gBioCAJMiCSAJlCAMQiCIp74gBioCBJMiCCAIlJJDAAAAAJIiCkMAAIAoXgRAIAggChB2IgiVIQogCSAIlSEJIAYtABANASAIIASTIQggCbxBgICAgHhzrSAKvEGAgICAeHOtQiCGhAwCCyAGQRhqIAIgBigCJCAGQShqKAIAIAZBCGogAygCtAERCAAgBIwhCCAGKAIYBEAgBikCHAwCCyAGKQMIIgynviIJIAmUIAxCIIinviIKIAqUkkMAAAAAkiILQwAAgCheBEAgCSALEHYiCZW8rSAKIAmVvK1CIIaEDAILQoCAgICAgIDAPwwBCyAIjCAEkyEIIAm8rSAKvK1CIIaECyEMAkAgBSAIYEUEQCAAQQA2AgAMAQsgACAGKQMINwIEIABBATYCACAAQSRqIAg4AgAgAEEUaiAMNwIAIAFBBGoqAgAiCCAMp74iCZQgASoCACIKIAxCIIinviILlJMhBSAAQRxqIAggC4yUIAogCZSTIgi8rSAFvK1CIIaENwIAIABBDGogCCAElLytIAUgBJS8rUIghoQ3AgALIAZBMGokAAuiBQEEfyAAIAFqIQICQAJAAkAgACgCBEEBcQ0AIAAoAgAhAwJAIAAtAARBA3EEQCABIANqIQEgACADayIAQaDHwwAoAgBHDQEgAigCBEEDcUEDRw0CQZjHwwAgATYCACACIAIoAgRBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAA8LDAILIANBgAJPBEAgABCqAwwBCyAAQQxqKAIAIgQgAEEIaigCACIFRwRAIAUgBDYCDCAEIAU2AggMAQtBkMfDAEGQx8MAKAIAQX4gA0EDdndxNgIACyACLQAEQQJxQQF2BEAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCAAIAFqIAE2AgAMAgsCQEGkx8MAKAIAIAJHBEAgAkGgx8MAKAIARw0BQaDHwwAgADYCAEGYx8MAQZjHwwAoAgAgAWoiATYCACAAIAFBAXI2AgQgACABaiABNgIADwtBpMfDACAANgIAQZzHwwBBnMfDACgCACABaiIBNgIAIAAgAUEBcjYCBCAAQaDHwwAoAgBHDQFBmMfDAEEANgIAQaDHwwBBADYCAA8LIAIoAgRBeHEiAyABaiEBAkAgA0GAAk8EQCACEKoDDAELIAJBDGooAgAiBCACQQhqKAIAIgJHBEAgAiAENgIMIAQgAjYCCAwBC0GQx8MAQZDHwwAoAgBBfiADQQN2d3E2AgALIAAgAUEBcjYCBCAAIAFqIAE2AgAgAEGgx8MAKAIARw0BQZjHwwAgATYCAAsPCyABQYACTwRAIAAgARCmAw8LIAFBeHFBiMXDAGohAgJ/QZDHwwAoAgAiA0EBIAFBA3Z0IgFxBEAgAigCCAwBC0GQx8MAIAEgA3I2AgAgAgshASACIAA2AgggASAANgIMIAAgAjYCDCAAIAE2AggLygQCCH8BfiMAQTBrIgIkACACIAE2AgwgAkECNgIIIAJBEGogAkEIahC3AgJAAkACfyACKAIQRQRAIAJBGGooAgAiBw0CQQBBlIfAAEG0gcAAELsGDAELIAIoAhQLIQEgAEEANgIEIAAgATYCAAwBCyACKAIUIQgCQAJAAkAgAigCCCIBBEAgAkEcaigCACEJIAIgAUEBazYCCCACKAIMIgYoAgQiAUEHTQRAIAJCgcoANwMQIAJBEGoQ6wkhAwwECyAGIAFBCGs2AgQgBiAGKAIAIgFBCGo2AgAgAkEgaiABKQAAEKcEIAIoAiQhAyACKAIgDQMCQCADQYAgIANBgCBJGyIFRQRAQQQhBAwBCyAFQQN0IgFBBBDQCiIERQ0DC0EAIQEgAkEANgIoIAIgBDYCJCACIAU2AiAgAwRAA0AgAkEQaiAGEIEDIAIoAhAEQCACKAIUIQMgAigCIEUNBiAEEIcBDAYLIANBAWshAyACKQIUIQogAigCICABRgRAIAJBIGogARC/BCACKAIkIQQgAigCKCEBCyAEIAFBA3RqIAo3AgAgAiABQQFqIgE2AiggAw0ACyACKAIkIQQgAigCICEFCyAEDQEgBSEDDAMLQQFBlIfAAEG0gcAAELsGIQMMAgsgACABNgIUIAAgBDYCECAAIAU2AgwgACAJNgIIIAAgBzYCBCAAIAg2AgAMAgsgAUEEQcDDwwAoAgAiAEGkBiAAGxEAAAALIABBADYCBCAAIAM2AgAgCEUNACAHEIcBCyACQTBqJAAL9AMCBH8KfSMAQSBrIgYkAAJAIAJBAkkNACADQQxqKgIAIQ4gA0EIaioCACEPIANBBGoqAgAhCiAEQiCIp74hECADKgIAIQsgBKe+IREgAiEIIAEhBwNAIAdBCGoiCSoCACESIAdBDGoqAgAhEyAGIAsgByoCBCAQlCIMlCAHKgIAIBGUIg0gCpSSIA6SOAIEIAYgDyANIAuUIAwgCpSTkjgCACAGIA4gCiASIBGUIgyUIAsgEyAQlCINlJKSOAIMIAYgDyALIAyUIAogDZSTkjgCCCAGQRBqIgdBCGogBUEIaikCADcDACAGIAUpAgA3AxAgACAGIAZBCGogBxCFAiAJIQcgCEEBayIIQQJPDQALIAJBAk0NACACQQN0IAFqQQhrIgJBBGoqAgAhDyACKgIAIRAgA0EIaioCACEOIAYgAyoCACIKIAEqAgQgBEIgiKe+IhKUIhOUIAEqAgAgEZQiDCADQQRqKgIAIguUkiADQQxqKgIAIg2SOAIEIAYgDiAMIAqUIBMgC5STkjgCACAGIA0gCyAQIBGUIgyUIAogDyASlCINlJKSOAIMIAYgDiAKIAyUIAsgDZSTkjgCCCAGQRBqIgFBCGogBUEIaikCADcDACAGIAUpAgA3AxAgACAGIAZBCGogARCFAgsgBkEgaiQAC/YEAxF/AX4CfSMAQZABayIDJAAgASgCACgCACEEIAEoAgQiBSgCACINBEAgA0EYaiIGIAUoAgQiBUH//wNxNgIEIAYgBUEQdjYCACADKAIYIQ4gAygCHCEFCyAEQUFxIQcgASgCCCIGKAIAIg8EQCADQRBqIgggBikDCCIUQiCIPgIEIAggFD4CACADKAIUIQggAygCECEGC0EAIAQgBxshByABKAIMIgQoAgAiEARAIANBCGoiCSAEKQMIIhRCIIg+AgQgCSAUPgIAIAMoAgwhCSADKAIIIQQLIAEoAhQoAgAiCioCACEVIAoqAgQhFiADIAEoAhAoAgApAgA3AyggAyAWOAIkIAMgFTgCICABKAIkKAIAIQogASgCICgCACERIAEoAhwoAgAhEiABKAIYKAIAIRMgAyABKAIoKAIAIgsoAgQiDDYCBCADIAsoAgAgDCgCCEEHakF4cWo2AgAgASgCLCoCACEVIAEoAjAtAAAhASADKAIEIQsgAygCACEMIAMgCTYCjAEgAyAENgKIASADIBA2AoQBIAMgCDYCgAEgAyAGNgJ8IAMgDzYCeCADIAU2AnQgAyAONgJwIAMgDTYCbCADIAc2AmggA0Ggu8AANgJkIAMgAjYCYCADQTBqIBMgEiARIANBIGogCiAMIAsgFSABIANB4ABqECECQCADLQBcQQRGBEAgAEEEOgAsDAELIAAgAykDMDcCACAAIAMpAzg3AgggAEEQaiADQTBqIgFBEGopAwA3AgAgAEEYaiABQRhqKQMANwIAIABBIGogAUEgaikDADcCACAAQShqIAFBKGopAwA3AgALIANBkAFqJAALowQBAn8jAEGAAWsiDSQAAkACQCAARQ0AIAAoAgAiDkF/Rg0BIAAgDkEBajYCACABRQ0AIAEoAgAiDkF/Rg0BIAEgDkEBajYCACACRQ0AIAIoAgAiDkF/Rg0BIAIgDkEBajYCACADRQ0AIAMoAgAiDkF/Rg0BIAMgDkEBajYCACANIAQ2AgggDSAMNgIMIA0gCzkDSCANIApBAEetNwNAIA0gCTkDOCANIAhBAEetNwMwIA0gBzYCLCANIAY2AiggDSAFNgIkIA0gA0EEajYCHCANIAJBBGo2AhggDSABQQRqNgIUIA0gAEEEajYCECANIA1BCGo2AiACQCAMEARBAUYEQCANIA1BDGo2AlQgDSANQRxqNgJ4IA0gDUEYajYCdCANIA1BFGo2AnAgDSANQRBqNgJsIA0gDUEgajYCaCANIA1BQGs2AmQgDSANQTBqNgJgIA0gDUEoajYCXCANIA1BJGo2AlggDUHYAGogDUHUAGoQYwwBCyANIA1BHGo2AnggDSANQRhqNgJ0IA0gDUEUajYCcCANIA1BEGo2AmwgDSANQSBqNgJoIA0gDUFAazYCZCANIA1BMGo2AmAgDSANQShqNgJcIA0gDUEkajYCWCANQdgAakEAEGMLIAMgAygCAEEBazYCACACIAIoAgBBAWs2AgAgASABKAIAQQFrNgIAIAAgACgCAEEBazYCACANQYABaiQADwsQpgsACxCnCwAL/wMCCH8EfSABQQhqIgMoAgAiB0UEQCAAQQA2AgAPCyADIAdBAWsiBDYCACABQQRqKAIAIgIgBEEDdGoiASoCBCEKIAEoAgAhBgJAIARFBEAgCiEMIAYhCAwBCyACKgIEIQwgAiAKOAIEIAIoAgAhCCACIAY2AgACQAJAAkAgBEEDTwRAQQAgBEECayIBIAEgBEsbIQlBASEFQQAhA0EAIQEDQCACIAFBA3RqIAIgBUEAQX8gA0EDdCACakEUaioCACILIAIgBUEDdGpBBGoqAgAiDV8iARtBAUECIAEbIAsgDWAbQQFqQQJJaiIBQQN0aiIEKQIANwIAIAkgAUEBdCIDQQFyIgVPDQALIAdBAmsgBUYEQCABIQMMAgsgBCAKOAIEIAQgBjYCACABDQJBACEDDAMLQQAhA0EBIQUgBEECRw0CCyACIANBA3RqIAIgBUEDdGoiASkCADcCACABIAo4AgQgASAGNgIAIAUhAQsDQEEAQX8gAiABQQFrIgVBAXYiA0EDdGoiBEEEaioCACILIApfIgcbQQFBAiAHGyAKIAtfG0EBakECSQRAIAEhAwwCCyACIAFBA3RqIAQpAgA3AgAgAyEBIAVBAk8NAAsLIAIgA0EDdGoiASAKOAIEIAEgBjYCAAsgACAINgIEIABBCGogDDgCACAAQQE2AgALpAQBCH8jAEEgayICJAACfyABKAIAIgNFBEAgAEEIakEANgIAQQAMAQsgASADQQFrNgIAAkACQAJAIAEoAgQiBCgCBCIBQQdNBEAgAkKBygA3AwggAkEIahDrCSEBDAELIAQgAUEIayIINgIEIAQgBCgCACIBQQhqNgIAIAJBGGogASkAABCnBCACKAIcIQEgAigCGA0AAkAgAUGAICABQYAgSRsiA0UEQEEEIQUMAQsgA0EDdCIGQQQQ0AoiBUUNAgsgAkEANgIQIAIgBTYCDCACIAM2AgggAQRAA0ACQAJ/IAhBA00EQCACQoHKADcDGCACQRhqEOsJDAELIAQgCEEEayIDNgIEIAQgBCgCACIGQQRqNgIAIANBA0sNASACQoHKADcDGCACQRhqEOsJCyEBIAIoAghFDQMgAigCDBCHAQwDCyABQQFrIQEgBigAACEJIAQgA0EEayIINgIEIAQgBkEIajYCACAGKAAEIQYgAigCCCAHRgRAIAJBCGogBxC/BCACKAIMIQUgAigCECEHCyAFIAdBA3RqIgMgBjYCBCADIAk2AgAgAiAHQQFqIgc2AhAgAQ0ACyACKAIMIQUgAigCCCEDCyAFDQIgAyEBCyAAIAE2AgRBAQwCCyAGQQRBwMPDACgCACIAQaQGIAAbEQAAAAsgACADNgIEIABBDGogBzYCACAAQQhqIAU2AgBBAAshASAAIAE2AgAgAkEgaiQAC6gEAgZ/AX4jAEEwayICJAACfyABKAIAIgNFBEAgAEEIakEANgIAQQAMAQsgASADQQFrNgIAAkAgASgCBCIGKAIEIgdBB00EQCACQoHKADcDGCACQRhqEOsJIQQMAQsgBiAHQQhrNgIEIAYgBigCACIBQQhqNgIAIAJBCGogASkAABCnBCACKAIMIQQgAigCCA0AAkACQAJAAkACQCAEQYAgIARBgCBJGyIDRQRAQQQhBQwBCyADQQJ0IgFBBBDQCiIFRQ0BC0EAIQEgAkEANgIQIAIgBTYCDCACIAM2AgggBARAIAdBEGshAwNAIANBCGpBCEkNAyAGIAM2AgQgBiAGKAIAIgdBCGo2AgAgBykAACIIQoCAgIAQWgRAIAJBAToAGCACIAg3AyAgAkEYaiACQShqQeyAwAAQhAchBAwGCyAEQQFrIQQgCKchByACKAIIIAFGBEAgAkEIaiABEL0EIAIoAgwhBSACKAIQIQELIAUgAUECdGogBzYCACACIAFBAWoiATYCECADQQhrIQMgBA0ACyACKAIMIQUgAigCCCEDCyAFDQIgAyEEDAQLIAFBBEHAw8MAKAIAIgBBpAYgABsRAAAACyACQoHKADcDGCACQRhqEOsJIQQMAQsgACADNgIEIABBDGogATYCACAAQQhqIAU2AgBBAAwCCyACKAIIRQ0AIAIoAgwQhwELIAAgBDYCBEEBCyEBIAAgATYCACACQTBqJAAL3QMDCH0BfwN+IwBBEGsiECQAAkACQAJAAkAgB0UEQCACKgIAIAMqAgCUIAJBBGoqAgAgA0EEaioCAJSSQwAAAABeDQELIBAgAykCACISp74iCYw4AgggECASQiCIp74iCowiDzgCDCAQIAQgASAQQQhqIAUoAhQRAQAgAikCACERIAogECkDACITQiCIp74iDIyUIAkgE6e+Ig6UIg2TIgtDAAAAAF5FBEAgCyAJIBGnvpQgCiARQiCIp76UkpUiCEMAAAAAYEUNAiAGIAhgRQ0CCyAGIAhdDQIgCCARp76UIA6SIQYgCCARQiCIp76UIAySIQtBAyEDIAAgDSAKIAyUkkMAAAAAXQR/QQMFIAsgCyAKlCAGIAmUkiINIAqUkyELIAYgDSAJlJMhBkEBCzoAJCAAIAg4AiAgACASNwIQIAAgCzgCBCAAIAY4AgAgACABQQRqKgIAIgYgD5QgASoCACIIIAmUk7ytIAYgCZQgCCAKlJO8rUIghoQ3AhggACAIIA4gAUEIaioCAJMiCZQgBiAMIAFBDGoqAgCTIgqUkrytIAggCpQgBiAJlJO8rUIghoQ3AggMAwsgAEEEOgAkDAILIABBBDoAJAwBCyAAQQQ6ACQLIBBBEGokAAvcAwMJfQJ+AX8jAEEQayIQJAAgAwRAAn4gASkCACIOp74gACoCACIHkyIIIAiUIA5CIIinviAAKgIEIgaTIgUgBZSSQwAAAACSIglDAAAAAF5FBEBDAAAAACEFQgAMAQsgBSAJEHYiC5UhBSAIIAuVvK0LIQ8CQCACKQIAIg6nviAHkyIMIAyUIA5CIIinviAGkyIHIAeUkkMAAAAAkiIGQwAAAABeRQ0AIAYQdiEKIAlDAAAAAF5FDQAgBkMAAAAAXkUNACAQQQhqQwAAgD8gA7MiCJUgByAKlSIJIA+nviIHlCAFIAwgCpUiBpSTIAUgCZQgBiAHlJIQkAOUEGggA0EBayICRQ0AIAogC5MgCJUhDCAQKgIMIQ0gECoCCCEKIAApAgAiDkIgiKe+IQggBCgCCCEAIA6nviEJA0AgDSAFlCAKIA+nviIHlJIhBiANIAeUIAogBZSTIgUgDCALkiILlCAJkrytIAYgC5QgCJK8rUIghoQhDiAFvK0hDyAEIAQoAgAgAEcEfyAABSAEIAAQvwQgBCgCCAsiA0EBaiIANgIIIAQoAgQgA0EDdGogDjcCACAGIQUgAkEBayICDQALCyAQQRBqJAAPC0GX5cIAQR5BuOXCABDJCAALpAQCAn8GfSAAKAIAIgUoAgghBCAFKAIAIARrQQFNBEAgBSAEQQIQsgQgBSgCCCEECyAFKAIEIARBAnRqIAEpAgA3AgAgBSAEQQJqIgQ2AgggBSgCACAEa0EBTQRAIAUgBEECELIEIAUoAgghBAsgBSgCBCAEQQJ0aiACKQIANwIAIAUgBEECajYCCCADKgIEQwAAgD8gAyoCCCILIAuSQwAAgL+Si5OUIgdDAACAPyADKgIAIgggCEMAALRDlY5DAAC0Q5STQwAAcEKVIgYQiwJDAACAv5KLk5QhCAJAAkAgBkMAAAAAYEUNACAGQwAAgD9dRQ0AIAchCgwBCwJAIAZDAACAP2BFDQAgBkMAAABAXUUNACAIIQogByEIDAELAkAgBkMAAABAYEUNACAGQwAAQEBdRQ0AIAghCSAHIQgMAQsCQCAGQwAAQEBgRQ0AIAZDAACAQF1FDQAgByEJDAELIAggByAGQwAAoEBdIAZDAACAQGBxIgEbIQogByAIIAEbIQlDAAAAACEICyADKgIMIQYgACgCBCIAKAIIIQMgACgCACADa0EHTQRAIAAgA0EIELIEIAAoAgghAwsgACADQQhqNgIIIAAoAgQgA0ECdGoiACAGOAIcIAAgBjgCDCAAIAsgB0MAAAC/lJIiByAJkiIJOAIYIAAgByAIkiIIOAIUIAAgByAKkiIHOAIQIAAgCTgCCCAAIAg4AgQgACAHOAIAC8GhAgMZfwJ+An0jAEEQayIdJAACQAJAIABFDQAgACgCACIKQX9GDQEgACAKQQFqNgIAIAFFDQAgASgCACIKQX9GDQEgASAKQQFqNgIAIAJFDQAgAigCACIKQX9GDQEgAiAKQQFqNgIAIANFDQAgAygCACIKQX9GDQEgAyAKQQFqNgIAIARFDQAgBCgCACIKQX9GDQEgBCAKQQFqNgIAIAVFDQAgBSgCACIKQX9GDQEgBSAKQQFqNgIAIAZFDQAgBigCACIKQX9GDQEgBiAKQQFqNgIAIAdFDQAgBygCACIKQX9GDQEgByAKQQFqNgIAIAhFDQAgCCgCACIKQX9GDQEgCCAKQQFqNgIAIAlFDQAgCSgCACIKQX9GDQEgCSAKQQFqNgIAIB1BCGohHyMAQeAAayIYJAAgGCAJQQRqIhA2AiggGCAIQQRqIgw2AiQgGCAHQQRqIg82AiAgGCAGQQRqIg42AhwgGCAFQQRqIg02AhggGCAEQQRqIhM2AhQgGCADQQRqIgo2AhAgGCACQQRqNgIMIBggAUEEajYCCCAKQQxqKAIAIQsgGCAYQdgAajYCSCALQQN0QQhrrULtAHxC5QAgCxshIyAKQRhqKAIAIgsEfiAjIAtBA3RBCGutfEIQfAUgI0IIfAshIyAKQSRqKAIAIgoEfiAjIApBAnRBBGtBAnatQgOGfEIQfAUgI0IIfAtCDHwhIyATQQxqKAIAIgoEQCAKQSRsIQogE0EIaigCAEEYaiELA0ACfiAjQgx8IAtBBGsoAgBFDQAaICNCBXwgCygCACIWRQ0AGiAWQRBqKAIAIhEEfiAjIBFBA3RBCGutfEIdfAUgI0IVfAshIyAWQTBqKAIAIhEEfiAjIBFBA3RBCGutfEIYfAUgI0IQfAshIyAWQcwAaigCACIRBH4gIyARQQJ0QQRrrXxCDHwFICNCCHwLISMgFkHsAGooAgAiFgR+ICMgFkECdEEEa618QhR8BSAjQhB8C0IOfAshJCALQSRqIQsgJEImfCEjIApBJGsiCg0ACwsgI0IMfCEjIBNBGGooAgAiCgRAIApBBnQhFiATQRRqKAIAQTpqIQsDQCAjQgJCASALQQJrLQAAG3xCAkIBIAstAAAbfCEjIAtBHmsoAgAiCgR+IApBBHRBEGtBBHatQhR+ICN8QiJ8BSAjQg58CyEjIAtBQGshCyAWQUBqIhYNAAsLIBNBNGooAgAiCgR+ICMgCkEEdEEQa0EEdkEMbK18QhZ8BSAjQgp8CyEjIA1BEGooAgAiCgR+ICMgCkEEdEEQa618QiB8BSAjQhB8C0IIfCEjIA1BHGooAgAiCgRAIA1BGGooAgAiCyAKQThsaiESA0AgI0IYfCEjIAtBMGooAgAiCgRAIApBxAFsIRdBlH8gC0EsaigCACIRayEKIBFByABqIRlBACEWA0AgESAWaiITQZABaigCACIbBH4gIyAKIBYgGWogG0EkbGpqQSRurUI0fnxCPHwFICNCCHwLISMgI0IZQgEgE0GcAWooAgAbfEIZQgEgE0GwAWooAgAbfEIJQgEgE0EsaigCABt8QglCASATQThqKAIAG3whIyAKQcQBayEKIBNBKGooAgAiEwR+IBNBBXRBIGtBBXatQi5+ICN8QvIAfAUgI0LEAHwLQgZ8ISMgFyAWQcQBaiIWRw0ACwsgC0E4aiEKAkAgC0EgaigCACIWRQRAICNCA3whIwwBCyAYQdAAaiAWIAtBJGooAgAoAiwRAAAgGCgCVCELAkACQAJAAkACQAJAIBgoAlBBAWsOBQECAwQFAAsgC0FAaygCACIWBH4gIyAWQQJ0QQRrrXxCE3wFICNCD3wLISMgC0HMAGooAgAiFgR+ICMgFkECdEEEa618Qix8BSAjQih8CyEjIAtBGGooAgAiFgR+ICMgFkECdEEEa618Qgx8BSAjQgh8C0IIfCEjIAtBNGooAgAiC0UNBSAjIAtBA3RBCGtBAXZBBGqtfCEjDAULIAtBGGooAgAiC0UEQCAjQhB8ISMMBQsgIyALQQR0QRBrQQR2QQ1srXxCHXwhIwwECyALQRhqKAIAIgtFBEAgI0IQfCEjDAQLICMgC0EUbEEUa0EUbq1CEX58QiF8ISMMAwsgC0EYaigCACILRQRAICNCEHwhIwwDCyAjIAtBFGxBFGtBFG6tQhF+fEIhfCEjDAILIAtBGGooAgAiC0UEQCAjQhB8ISMMAgsgIyALQQR0QRBrQQR2QQ1srXxCHXwhIwwBCyAjQgt8ISMLICNCEHwhIyASIAoiC0cNAAsLIA1BKGooAgAiCgR+ICMgCkEEdEEQa618Qhh8BSAjQgh8CyEjIA1BNGooAgAiCgR+ICMgCkEUbEEUa0EUbq1CEn58Qhp8BSAjQgh8CyEjIA1BQGsoAgAiCgR+ICMgCkEMbEEMa0EMbq1CDH58QhR8BSAjQgh8C0IIfCEjIA5BJGooAgAiCgRAIA5BIGooAgAhCyAKQegBbCEWA0ACfiALKAIARQRAICNCBUIBIAtBBGooAgAbfEIEfAwBCyAjQtIAfCEjIAtB8ABqKAIAIgoEQEIIQhwgCigCABsgI3whIwsgC0G8AWooAgAiCgR+ICMgCkEDdEEIa618QrYBfAUgI0KuAXwLQit8CyEjIAtB6AFqIQsgFkHoAWsiFg0ACwsgI0IFQgEgDigCDBt8ISMgDkEIaigCACIKBH4gIyAKQQN0QQhrrXxCHHwFICNCFHwLQgh8ISMCQAJAAkACQAJ/AkACQCAPQTBqKAIAIgoEQCAPQSxqKAIAIQsgCkGQAWwhFgNAAn4gCygCAEUEQCAjQgVCASALQQRqKAIAG3xCBHwMAQsgGCAjQgx8NwNAIAtBKGogGEFAaxBbIgoNAyAYKQNAQv4AQuoAIAtBMGooAgBBAk8bfEIhQgEgC0HsAGooAgAbfAshIyALQZABaiELIBggIzcDQCAWQZABayIWDQALCyAjQgVCASAPKAIYG3whIyAPQQhqKAIAIgoEfiAjIApBA3RBCGutfEIcfAUgI0IUfAshIyAPQRRqKAIAIgoEfiAjIApBA3RBCGutfEIQfAUgI0IIfAshIyAMQSBqKAIAIgoEfiAjIApBA3RBCGutfEIQfAUgI0IIfAtCCHwhIwJAIAxByABqKAIAIgpFDQAgDEHEAGooAgAhDQJAIApBDGwiD0EMayITQQxuQQFqQQNxIgpFBEAgDSELDAELIApBDGwhCiANIRYDQEIMQglCBSAWQQRqKAIAGyAWKAIAGyAjfCEjIBZBDGoiCyEWIApBDGsiCg0ACwsgE0EkSQ0AIA0gD2ohCgNAQgxCCUIFIAtBBGooAgAbIAsoAgAbICN8QgxCCUIFIAtBEGooAgAbIAtBDGooAgAbfEIMQglCBSALQRxqKAIAGyALQRhqKAIAG3xCDEIJQgUgC0EoaigCABsgC0EkaigCABt8ISMgCiALQTBqIgtHDQALCyAjQgVCASAMKAIwG3whIyAMQQhqKAIAIgoEfiAjIApBBHRBEGutfEIkfAUgI0IUfAshIyAMQRRqKAIAIgoEfiAjIApB1AFsQdQBa0HUAW6tQu0BfnxC9QF8BSAjQgh8CyEjIAxBLGooAgAiCgR+ICMgCkEDdEEIa618QhB8BSAjQgh8C0IIfCEjIBBByABqKAIAIgoEQCAKQZQCbCAQQcQAaigCACIKaiEWA0AgCkGUAmohDQJ+IAotAIwCQQJGBEAgI0IFQgEgCigCABt8QgR8DAELIApBoAFqKAIAIgsEfiAjIAtBhAJsQYQCa0GEAm6tQtECfnxC4QJ8BSAjQhB8CyEjIApBCGooAgAiCwR+ICMgC0ECdEEEa618Qgx8BSAjQgh8CyEjIApBGGooAgAiCwR+ICMgC0ECdEEEa618QhR8BSAjQhB8CyEjIApBKGooAgAiCwR+ICMgC0ECdEEEa618QhR8BSAjQhB8CyIkQhB8ISMCQCAKQawBaigCACIMRQ0AIAxBAWtB/////wBxIRMgCkGoAWooAgAiDyELIAxBAXEEQCAPQQhqKAIAIgsEfiAkIAtBAnRBBGutfEIcfAUgJEIYfAtCCHwhIyAPQRBqIQsLIBNFDQAgDyAMQQR0aiEPA0AgC0EIaigCACIMBH4gIyAMQQJ0QQRrrXxCDHwFICNCCHwLISMgC0EgaiEMIAtBGGooAgAiCwR+ICMgC0ECdEEEa618QhR8BSAjQhB8C0IIfCEjIA8gDCILRw0ACwsgCkG4AWooAgAiCwR+ICMgC0ECdEEEa618Qgx8BSAjQgh8CyEjIApByABqKAIAIgsEfiAjIAtBAnRBBGutfEIcfAUgI0IYfAshIyAKQdwAaigCACILBH4gIyALQQN0QQhrQQN2rUIEhnxCMHwFICNCIHwLISMgCkHMAWooAgAiCwR+ICMgC0ECdEEEa618QhR8BSAjQhB8CyEjIApB8ABqKAIAIgsEfiAjIAtBAnRBBGutfEIcfAUgI0IYfAshIyAKQYQBaigCACILBH4gIyALQQN0QQhrQQN2rUIEhnxCMHwFICNCIHwLISMgCkHwAWooAgAiCwR+ICMgC0EMbEEMa0EMbq1CFH58QjV8BSAjQiF8CyEjIApB4AFqKAIAIgsEfiAjIAtBAnRBBGutfEIMfAUgI0IIfAsiJEIQfCEjAkAgCkH8AWooAgAiDEUNACAMQQFrQf////8AcSETIApB+AFqKAIAIg8hCyAMQQFxBEAgD0EIaigCACILBH4gJCALQQJ0QQRrrXxCHHwFICRCGHwLQgh8ISMgD0EQaiELCyATRQ0AIA8gDEEEdGohDwNAIAtBCGooAgAiDAR+ICMgDEECdEEEa618Qgx8BSAjQgh8CyEjIAtBIGohDCALQRhqKAIAIgsEfiAjIAtBAnRBBGutfEIUfAUgI0IQfAtCCHwhIyAPIAwiC0cNAAsLICNCCHwhJAJAIApBiAJqKAIAIgxFDQAgDEEBa0H/////AHEhEyAKQYQCaigCACIPIQsgDEEBcQRAIA9BCGooAgAiCwR+ICMgC0ECdEEEa618QhR8BSAjQhB8C0IIfCEkIA9BEGohCwsgE0UNACAPIAxBBHRqIQ8DQCALQQhqKAIAIgwEfiAkIAxBAnRBBGutfEIMfAUgJEIIfAshIyALQSBqIQwgC0EYaigCACILBH4gIyALQQJ0QQRrrXxCFHwFICNCEHwLQgh8ISQgDyAMIgtHDQALCyAKQThqKAIAIgoEfiAkIApBAnRBBGutfEIMfAUgJEIIfAtCCHwLISMgFiANIgpHDQALCyAjQgVCASAQKAIwG3whIyAQQSBqKAIAIgoEfiAKQRRsQRRrQRRurUIYfiAjfEIsfAUgI0IUfAshIyAQQQhqKAIAIgoEfiAjIApBBHRBEGutfEIYfAUgI0IIfAshIyAQQRRqKAIAIgoEfiAjIApBBHRBEGutfEIYfAUgI0IIfAshIwJAIBBBLGooAgAiCgR+ICMgCkEDdEEIa618QhB8BSAjQgh8C6ciCkUEQEEBIRYMAQsgCkEATiILRQ0EIAogCxDQCiIWRQ0FCyAYQQA2AjggGCAWNgI0IBggCjYCMCMAQRBrIhEkACARIBhBMGoiCjYCACAYQQhqIhsoAgAiC0EEaioCACElIAsqAgAhJiAKKAIAIAooAggiC2tBB00EQCAKIAtBCBDuBCAKKAIIIQsLIAooAgQgC2pCAjcAACAKIAtBCGoiCzYCCCAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqICY4AAAgCiALQQRqIgs2AgggCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiAlOAAAIAogC0EEajYCCCAbKAIEIgsqAgAhJSARKAIAIgooAgghDCAKKAIAIAxrQQNNBEAgCiAMQQQQ7gQgCigCCCEMCyAKKAIEIAxqICU4AAAgCiAMQQRqIgw2AgggCyoCBCElIAooAgAgDGtBA00EQCAKIAxBBBDuBCAKKAIIIQwLIAooAgQgDGogJTgAACAKIAxBBGoiDDYCCCALKgIIISUgCigCACAMa0EDTQRAIAogDEEEEO4EIAooAgghDAsgCigCBCAMaiAlOAAAIAogDEEEaiIMNgIIIAsqAgwhJSAKKAIAIAxrQQNNBEAgCiAMQQQQ7gQgCigCCCEMCyAKKAIEIAxqICU4AAAgCiAMQQRqIgw2AgggCyoCECElIAooAgAgDGtBA00EQCAKIAxBBBDuBCAKKAIIIQwLIAooAgQgDGogJTgAACAKIAxBBGoiDDYCCCALKgIUISUgCigCACAMa0EDTQRAIAogDEEEEO4EIAooAgghDAsgCigCBCAMaiAlOAAAIAogDEEEaiIMNgIIIAsqAhghJSAKKAIAIAxrQQNNBEAgCiAMQQQQ7gQgCigCCCEMCyAKKAIEIAxqICU4AAAgCiAMQQRqIgw2AgggCyoCHCElIAooAgAgDGtBA00EQCAKIAxBBBDuBCAKKAIIIQwLIAooAgQgDGogJTgAACAKIAxBBGoiDDYCCCALKgIgISUgCigCACAMa0EDTQRAIAogDEEEEO4EIAooAgghDAsgCigCBCAMaiAlOAAAIAogDEEEaiIMNgIIIAs1AiQhIyAKKAIAIAxrQQdNBEAgCiAMQQgQ7gQgCigCCCEMCyAKKAIEIAxqICM3AAAgCiAMQQhqIgw2AgggCzUCKCEjIAooAgAgDGtBB00EQCAKIAxBCBDuBCAKKAIIIQwLIAooAgQgDGogIzcAACAKIAxBCGoiDDYCCCALNQIsISMgCigCACAMa0EHTQRAIAogDEEIEO4EIAooAgghDAsgCigCBCAMaiAjNwAAIAogDEEIaiIMNgIIIAstADghDSAMIAooAgBGBEAgCiAMQQEQ7gQgCigCCCEMCyAKKAIEIAxqIA06AAAgCiAMQQFqIgw2AgggCzUCMCEjIAooAgAgDGtBB00EQCAKIAxBCBDuBCAKKAIIIQwLIAooAgQgDGogIzcAACAKIAxBCGoiDDYCCCALNQI0ISMgCigCACAMa0EHTQRAIAogDEEIEO4EIAooAgghDAsgCiAMQQhqNgIIIAooAgQgDGogIzcAACAbKAIIIhBBDGooAgAhDSAQQQhqKAIAIQ8gESgCACIKKAIIIQ4gCigCACAOa0EHTQRAIAogDkEIEO4EIAooAgghDgsgCiAOQQhqIgs2AgggCigCBCAOaiANrTcAACANBEAgDyANQQN0aiENA0AgD0EEaigCACETIA8oAgAhDCAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqIAw2AAAgCiALQQRqIgw2AgggCigCACAMa0EDTQRAIAogDEEEEO4EIAooAgghDAsgCiAMQQRqIgs2AgggCigCBCAMaiATNgAAIA0gD0EIaiIPRw0ACwsgEEEYaigCACENIBBBFGooAgAhDyAKKAIAIAtrQQdNBEAgCiALQQgQ7gQgCigCCCELCyAKIAtBCGoiDDYCCCAKKAIEIAtqIA2tNwAAIA0EQCAPIA1BA3RqIQ0DQCAPQQRqKAIAIRMgDygCACELIAooAgAgDGtBA00EQCAKIAxBBBDuBCAKKAIIIQwLIAooAgQgDGogCzYAACAKIAxBBGoiCzYCCCAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKIAtBBGoiDDYCCCAKKAIEIAtqIBM2AAAgDSAPQQhqIg9HDQALCyAQQSRqKAIAIQ0gEEEgaigCACEPIAooAgAgDGtBB00EQCAKIAxBCBDuBCAKKAIIIQwLIAogDEEIaiILNgIIIAooAgQgDGogDa03AAAgDQRAIA1BAnQhDgNAIA81AgAhIyAPQQRqIQ8gCiAKKAIAIAtrQQdLBH8gCwUgCiALQQgQ7gQgCigCCAsiDUEIaiILNgIIIAooAgQgDWogIzcAACAOQQRrIg4NAAsLIBAoAgAhDSAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKIAtBBGo2AgggCigCBCALaiANNgAAIBsoAgwiEkEMaigCACELIBJBCGooAgAhDSARKAIAIgooAgghDyAKKAIAIA9rQQdNBEAgCiAPQQgQ7gQgCigCCCEPCyAKIA9BCGoiDDYCCCAKKAIEIA9qIAutNwAAAkAgCwRAIA0gC0EkbGohFwNAIBEoAgAhCgJAIA0oAhRFBEAgDUEcaigCACEMIA0oAhghECAKKAIAIAooAggiC2tBA00EQCAKIAtBBBDuBCAKKAIIIQsLIAooAgQgC2pBADYAACAKIAtBBGoiCzYCCCAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqIBA2AAAgCiALQQRqIgs2AgggCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCiALQQRqNgIIIAooAgQgC2ogDDYAAAwBCyANKAIYIRMgCigCACAKKAIIIgxrQQNNBEAgCiAMQQQQ7gQgCigCCCEMCyAKIAxBBGoiCzYCCCAKKAIEIAxqQQE2AAAgCgJ/IBNFBEAgCyAKKAIARgRAIAogC0EBEO4EIAooAgghCwsgCigCBCALakEAOgAAIAtBAWoMAQsgCyAKKAIARgRAIAogC0EBEO4EIAooAgghCwsgCigCBCALakEBOgAAIAogC0EBaiILNgIIIBMqAgAhJSAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqICU4AAAgCiALQQRqIgs2AgggEyoCBCElIAooAgAgC2tBA00EQCAKIAtBBBDuBCAKKAIIIQsLIAooAgQgC2ogJTgAACAKIAtBBGoiDDYCCCATQRBqKAIAIRAgE0EMaigCACEPIAooAgAgDGtBB00EQCAKIAxBCBDuBCAKKAIIIQwLIAogDEEIaiILNgIIIAooAgQgDGogEK03AAAgEARAIA8gEEEDdGohEANAIA9BBGooAgAhDiAPKgIAISUgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiAlOAAAIAogC0EEaiIMNgIIIAooAgAgDGtBA00EQCAKIAxBBBDuBCAKKAIIIQwLIAogDEEEaiILNgIIIAooAgQgDGogDjYAACAQIA9BCGoiD0cNAAsLIBMqAiAhJSAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqICU4AAAgCiALQQRqIgs2AgggE0EkaioCACElIAooAgAgC2tBA00EQCAKIAtBBBDuBCAKKAIIIQsLIAooAgQgC2ogJTgAACAKIAtBBGoiDDYCCCATQTBqKAIAIRAgE0EsaigCACEPIAooAgAgDGtBB00EQCAKIAxBCBDuBCAKKAIIIQwLIAogDEEIaiILNgIIIAooAgQgDGogEK03AAAgEARAIA8gEEEDdGohEANAIA9BBGooAgAhDiAPKgIAISUgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiAlOAAAIAogC0EEaiIMNgIIIAooAgAgDGtBA00EQCAKIAxBBBDuBCAKKAIIIQwLIAogDEEEaiILNgIIIAooAgQgDGogDjYAACAQIA9BCGoiD0cNAAsLIBNBzABqKAIAIRAgE0HIAGooAgAhDyAKKAIAIAtrQQdNBEAgCiALQQgQ7gQgCigCCCELCyAKIAtBCGoiDDYCCCAKKAIEIAtqIBCtNwAAIBAEQCAQQQJ0IQ4DQCAPKAIAIRAgD0EEaiEPIAogCigCACAMa0EDSwR/IAwFIAogDEEEEO4EIAooAggLIgtBBGoiDDYCCCAKKAIEIAtqIBA2AAAgDkEEayIODQALCyATNQJAISMgCigCACAMa0EHTQRAIAogDEEIEO4EIAooAgghDAsgCigCBCAMaiAjNwAAIAogDEEIaiIPNgIIIBNB7ABqKAIAIRAgE0HoAGooAgAhDCAKKAIAIA9rQQdNBEAgCiAPQQgQ7gQgCigCCCEPCyAKIA9BCGoiCzYCCCAKKAIEIA9qIBCtNwAAIBAEQCAQQQJ0IQ4DQCAMKAIAIQ8gDEEEaiEMIAogCigCACALa0EDSwR/IAsFIAogC0EEEO4EIAooAggLIhBBBGoiCzYCCCAKKAIEIBBqIA82AAAgDkEEayIODQALCyATKAJQIQwgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiAMNgAAIAogC0EEaiILNgIIIBMtAHAhDCALIAooAgBGBEAgCiALQQEQ7gQgCigCCCELCyAKKAIEIAtqIAw6AAAgCiALQQFqIgs2AgggEy0AcSEMIAsgCigCAEYEQCAKIAtBARDuBCAKKAIIIQsLIAooAgQgC2ogDDoAACAKIAtBAWoiCzYCCCATNQJUISMgCigCACALa0EHTQRAIAogC0EIEO4EIAooAgghCwsgCigCBCALaiAjNwAAIAtBCGoLNgIICyANIBEQ4wIiCg0CIA0oAhAhDCARKAIAIgooAgghCyAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqIAw2AAAgCiALQQRqNgIIIA0tACAhECANQSRqIQogESgCACIMKAIIIQsgCyAMKAIARgRAIAwgC0EBEO4EIAwoAgghCwsgDCgCBCALaiAQOgAAIAwgC0EBajYCCCANLQAhIQwgESgCACINKAIIIQsgCyANKAIARgRAIA0gC0EBEO4EIA0oAgghCwsgDSALQQFqNgIIIA0oAgQgC2ogDDoAACAXIAoiDUcNAAsgESgCACIKKAIIIQwLIBIoAgAhCyAKKAIAIAxrQQNNBEAgCiAMQQQQ7gQgCigCCCEMCyAKKAIEIAxqIAs2AAAgCiAMQQRqNgIIIBJBGGooAgAhCyASQRRqKAIAIQ0gESgCACIKKAIIIQ8gCigCACAPa0EHTQRAIAogD0EIEO4EIAooAgghDwsgCiAPQQhqIgw2AgggCigCBCAPaiALrTcAACALBEAgDSALQQZ0aiETA0AgDS0APCELIAwgCigCAEYEQCAKIAxBARDuBCAKKAIIIQwLIAooAgQgDGogCzoAACAKIAxBAWoiDDYCCCANLQA9IRAgDCAKKAIARgRAIAogDEEBEO4EIAooAgghDAsgCiAMQQFqIgs2AgggCigCBCAMaiAQOgAAAkACQCANQThqLQAARQRAQQAhDCAKKAIAIAtGDQEMAgsgDUE5ai0AACEMIAsgCigCAEYEQCAKIAtBARDuBCAKKAIIIQsLIAooAgQgC2pBAToAACAKIAtBAWoiCzYCCCAKKAIAIAtHDQELIAogC0EBEO4EIAooAgghCwsgCigCBCALaiAMOgAAIAogC0EBaiILNgIIAkACQCANQTpqLQAARQRAQQAhDCAKKAIAIAtGDQEMAgsgDUE7ai0AACEMIAsgCigCAEYEQCAKIAtBARDuBCAKKAIIIQsLIAooAgQgC2pBAToAACAKIAtBAWoiCzYCCCAKKAIAIAtHDQELIAogC0EBEO4EIAooAgghCwsgCigCBCALaiAMOgAAIAogC0EBaiILNgIIIA0qAgAhJSAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqICU4AAAgCiALQQRqIg82AgggDUEcaigCACEQIA1BGGooAgAhCyANQUBrIQ0gCigCACAPa0EHTQRAIAogD0EIEO4EIAooAgghDwsgCiAPQQhqIgw2AgggCigCBCAPaiAQrTcAACAQBEAgCyAQQQR0aiEQA0AgC0EMaigCACEOIAtBBGooAgAhDyALKAIAIRcgCigCACAMa0EHTQRAIAogDEEIEO4EIAooAgghDAsgCigCBCAMakICNwAAIAogDEEIaiIMNgIIIAooAgAgDGtBA00EQCAKIAxBBBDuBCAKKAIIIQwLIAooAgQgDGogFzYAACAKIAxBBGoiDDYCCCAKKAIAIAxrQQNNBEAgCiAMQQQQ7gQgCigCCCEMCyAKKAIEIAxqIA82AAAgCiAMQQRqIg82AgggCigCACAPa0EDTQRAIAogD0EEEO4EIAooAgghDwsgCiAPQQRqIgw2AgggCigCBCAPaiAONgAAIBAgC0EQaiILRw0ACwsgDSATRw0ACwsgEi0AYCENIBEoAgAiCigCCCELIAsgCigCAEYEQCAKIAtBARDuBCAKKAIIIQsLIAooAgQgC2ogDToAACAKIAtBAWo2AgggEi0AYSENIBEoAgAiCigCCCELIAsgCigCAEYEQCAKIAtBARDuBCAKKAIIIQsLIAooAgQgC2ogDToAACAKIAtBAWo2AgggEkE0aigCACENIBJBMGooAgAhCyARKAIAIgooAgghDiAKKAIAIA5rQQdNBEAgCiAOQQgQ7gQgCigCCCEOCyAKIA5BCGoiDDYCCCAKKAIEIA5qIA2tNwAAIA0EQCALIA1BBHRqIQ0DQCALQQxqKAIAIRAgC0EEaigCACEPIAsoAgAhEyAKKAIAIAxrQQNNBEAgCiAMQQQQ7gQgCigCCCEMCyAKKAIEIAxqIBM2AAAgCiAMQQRqIgw2AgggCigCACAMa0EDTQRAIAogDEEEEO4EIAooAgghDAsgCigCBCAMaiAPNgAAIAogDEEEaiIPNgIIIAooAgAgD2tBA00EQCAKIA9BBBDuBCAKKAIIIQ8LIAogD0EEaiIMNgIIIAooAgQgD2ogEDYAACANIAtBEGoiC0cNAAsLIBJB1ABqKAIAIQ0gEkHIAGooAgAhDCASQcwAaigCACEQIBEoAgAiCigCCCELIAooAgAgC2tBB00EQCAKIAtBCBDuBCAKKAIIIQsLIAogC0EIajYCCCAKKAIEIAtqIAwgEGoiCiANIAogDUkbrTcAACARIBsoAhAiGUEMaigCACAZQRBqKAIAEPMCIgoNACAZQRxqKAIAIQ0gGUEYaigCACEMIBEoAgAiCigCCCELIAooAgAgC2tBB00EQCAKIAtBCBDuBCAKKAIIIQsLIAogC0EIajYCCCAKKAIEIAtqIA2tNwAAIBEgETYCBCARIAw2AgwgESAMIA1BOGxqNgIIIBFBBGohCyMAQSBrIgokAAJAAkACQAJAIBFBCGoiICgCBCIPICAoAgAiIUcEQCALKAIAIRcDQCAgIA9BOGoiEzYCBCAPQRRqKAIAIQ0gD0EQaigCACEQIBcoAgAiCygCCCEMIAsoAgAgDGtBA00EQCALIAxBBBDuBCALKAIIIQwLIAsoAgQgDGogEDYAACALIAxBBGoiDDYCCCALKAIAIAxrQQNNBEAgCyAMQQQQ7gQgCygCCCEMCyALIAxBBGo2AgggCygCBCAMaiANNgAAIA9BHGooAgAhDSAPQRhqKAIAIRAgFygCACILKAIIIQwgCygCACAMa0EDTQRAIAsgDEEEEO4EIAsoAgghDAsgCygCBCAMaiAQNgAAIAsgDEEEaiIMNgIIIAsoAgAgDGtBA00EQCALIAxBBBDuBCALKAIIIQwLIAsgDEEEajYCCCALKAIEIAxqIA02AAAgD0EwaigCACEMIA9BLGooAgAhECAXKAIAIg0oAgghCyANKAIAIAtrQQdNBEAgDSALQQgQ7gQgDSgCCCELCyANIAtBCGo2AgggDSgCBCALaiAMrTcAACAMBEAgECAMQcQBbGohIgNAIBBBkAFqKAIAIQ4gFygCACIMKAIIIQsgDCgCACALa0EHTQRAIAwgC0EIEO4EIAwoAgghCwsgDCALQQhqIg02AgggDEEEaiISKAIAIAtqIA6tNwAAIA4EQCAQQcgAaiILIA5BJGxqIRoDQCALQQRqKgIAISUgCyoCACEmIAwoAgAiDiANa0EHTQRAIA0gDUEIaiINSw0IIA5BAXQiFCANIA0gFEkbIg1Bf3NBH3YhFCAKIA4EfyAKIA42AhQgCiASKAIANgIQQQEFQQALNgIYIAogDSAUIApBEGoQzwUgCigCBCEOAkAgCigCAEUEQCAMIA02AgAgEiAONgIADAELIAooAggiDUGBgICAeEYNACANRQ0JDAoLIAwoAgghDQsgEigCACANakICNwAAIAwgDUEIaiINNgIIIAwoAgAiDiANa0EDTQRAIA0gDUEEaiINSw0IIA5BAXQiFCANIA0gFEkbIg1BCCANQQhLGyINQX9zQR92IRQgCiAOBH8gCiAONgIUIAogEigCADYCEEEBBUEACzYCGCAKIA0gFCAKQRBqEM8FIAooAgQhDgJAIAooAgBFBEAgDCANNgIAIBIgDjYCAAwBCyAKKAIIIg1BgYCAgHhGDQAgDUUNCQwKCyAMKAIIIQ0LIBIoAgAgDWogJjgAACAMIA1BBGoiDTYCCCAMKAIAIg4gDWtBA00EQCANIA1BBGoiDUsNCCAOQQF0IhQgDSANIBRJGyINQQggDUEISxsiDUF/c0EfdiEUIAogDgR/IAogDjYCFCAKIBIoAgA2AhBBAQVBAAs2AhggCiANIBQgCkEQahDPBSAKKAIEIQ4CQCAKKAIARQRAIAwgDTYCACASIA42AgAMAQsgCigCCCINQYGAgIB4Rg0AIA1FDQkMCgsgDCgCCCENCyASKAIAIA1qICU4AAAgDCANQQRqIg02AgggC0EMaioCACElIAtBCGoqAgAhJiAMKAIAIg4gDWtBB00EQCANIA1BCGoiDUsNCCAOQQF0IhQgDSANIBRJGyINQX9zQR92IRQgCiAOBH8gCiAONgIUIAogEigCADYCEEEBBUEACzYCGCAKIA0gFCAKQRBqEM8FIAooAgQhDgJAIAooAgBFBEAgDCANNgIAIBIgDjYCAAwBCyAKKAIIIg1BgYCAgHhGDQAgDUUNCQwKCyAMKAIIIQ0LIBIoAgAgDWpCAjcAACAMIA1BCGoiDTYCCCAMKAIAIg4gDWtBA00EQCANIA1BBGoiDUsNCCAOQQF0IhQgDSANIBRJGyINQQggDUEISxsiDUF/c0EfdiEUIAogDgR/IAogDjYCFCAKIBIoAgA2AhBBAQVBAAs2AhggCiANIBQgCkEQahDPBSAKKAIEIQ4CQCAKKAIARQRAIAwgDTYCACASIA42AgAMAQsgCigCCCINQYGAgIB4Rg0AIA1FDQkMCgsgDCgCCCENCyASKAIAIA1qICY4AAAgDCANQQRqIg02AgggDCgCACIOIA1rQQNNBEAgDSANQQRqIg1LDQggDkEBdCIUIA0gDSAUSRsiDUEIIA1BCEsbIg1Bf3NBH3YhFCAKIA4EfyAKIA42AhQgCiASKAIANgIQQQEFQQALNgIYIAogDSAUIApBEGoQzwUgCigCBCEOAkAgCigCAEUEQCAMIA02AgAgEiAONgIADAELIAooAggiDUGBgICAeEYNACANRQ0JDAoLIAwoAgghDQsgEigCACANaiAlOAAAIAwgDUEEaiINNgIIIAtBGGoqAgAhJSAMKAIAIg4gDWtBA00EQCANIA1BBGoiDUsNCCAOQQF0IhQgDSANIBRJGyINQQggDUEISxsiDUF/c0EfdiEUIAogDgR/IAogDjYCFCAKIBIoAgA2AhBBAQVBAAs2AhggCiANIBQgCkEQahDPBSAKKAIEIQ4CQCAKKAIARQRAIAwgDTYCACASIA42AgAMAQsgCigCCCINQYGAgIB4Rg0AIA1FDQkMCgsgDCgCCCENCyASKAIAIA1qICU4AAAgDCANQQRqIg02AgggC0EcaigCACEUIAwoAgAiDiANa0EDTQRAIA0gDUEEaiINSw0IIA5BAXQiHCANIA0gHEkbIg1BCCANQQhLGyINQX9zQR92IRwgCiAOBH8gCiAONgIUIAogEigCADYCEEEBBUEACzYCGCAKIA0gHCAKQRBqEM8FIAooAgQhDgJAIAooAgBFBEAgDCANNgIAIBIgDjYCAAwBCyAKKAIIIg1BgYCAgHhGDQAgDUUNCQwKCyAMKAIIIQ0LIBIoAgAgDWogFDYAACAMIA1BBGoiDTYCCCALQSBqKAIAIRQgDCgCACIOIA1rQQNNBEAgDSANQQRqIg1LDQggDkEBdCIcIA0gDSAcSRsiDUEIIA1BCEsbIg1Bf3NBH3YhHCAKIA4EfyAKIA42AhQgCiASKAIANgIQQQEFQQALNgIYIAogDSAcIApBEGoQzwUgCigCBCEOAkAgCigCAEUEQCAMIA02AgAgEiAONgIADAELIAooAggiDUGBgICAeEYNACANRQ0JDAoLIAwoAgghDQsgEigCACANaiAUNgAAIAwgDUEEaiINNgIIIAtBFGoqAgAhJSALQRBqKgIAISYgDCgCACIOIA1rQQNNBEAgDSANQQRqIg1LDQggDkEBdCIUIA0gDSAUSRsiDUEIIA1BCEsbIg1Bf3NBH3YhFCAKIA4EfyAKIA42AhQgCiASKAIANgIQQQEFQQALNgIYIAogDSAUIApBEGoQzwUgCigCBCEOAkAgCigCAEUEQCAMIA02AgAgEiAONgIADAELIAooAggiDUGBgICAeEYNACANRQ0JDAoLIAwoAgghDQsgEigCACANaiAmOAAAIAwgDUEEaiIONgIIIAwoAgAiDSAOa0EDTQRAIA4gDkEEaiIOSw0IIA1BAXQiFCAOIA4gFEkbIg5BCCAOQQhLGyIOQX9zQR92IRQgCiANBH8gCiANNgIUIAogEigCADYCEEEBBUEACzYCGCAKIA4gFCAKQRBqEM8FIAooAgQhDQJAIAooAgBFBEAgDCAONgIAIBIgDTYCAAwBCyAKKAIIIg5BgYCAgHhGDQAgDkUNCQwSCyAMKAIIIQ4LIAwgDkEEaiINNgIIIBIoAgAgDmogJTgAACAaIAtBJGoiC0cNAAsLIBBBBGoqAgAhJSAQKgIAISYgDCgCACANa0EHTQRAIAwgDUEIEO4EIAwoAgghDQsgEigCACANakICNwAAIAwgDUEIaiILNgIIIAwoAgAgC2tBA00EQCAMIAtBBBDuBCAMKAIIIQsLIBIoAgAgC2ogJjgAACAMIAtBBGoiCzYCCCAMKAIAIAtrQQNNBEAgDCALQQQQ7gQgDCgCCCELCyASKAIAIAtqICU4AAAgDCALQQRqIgs2AgggEEEMaioCACElIBBBCGoqAgAhJiAMKAIAIAtrQQdNBEAgDCALQQgQ7gQgDCgCCCELCyASKAIAIAtqQgI3AAAgDCALQQhqIgs2AgggDCgCACALa0EDTQRAIAwgC0EEEO4EIAwoAgghCwsgEigCACALaiAmOAAAIAwgC0EEaiILNgIIIAwoAgAgC2tBA00EQCAMIAtBBBDuBCAMKAIIIQsLIBIoAgAgC2ogJTgAACAMIAtBBGoiCzYCCCAQKAKUASENIAwoAgAgC2tBA00EQCAMIAtBBBDuBCAMKAIIIQsLIAwgC0EEajYCCCASKAIAIAtqIA02AAAgECgCmAEhDSAXKAIAIgsoAgghDCALKAIAIAxrQQNNBEAgCyAMQQQQ7gQgCygCCCEMCyALIAxBBGo2AgggCygCBCAMaiANNgAAAkAgECgCnAFFBEAgFygCACILKAIIIQwgDCALKAIARgRAIAsgDEEBEO4EIAsoAgghDAsgCyAMQQFqNgIIIAsoAgQgDGpBADoAAAwBCyAQQaABaiENIBcoAgAiCygCCCEMIAwgCygCAEYEQCALIAxBARDuBCALKAIIIQwLIAsgDEEBajYCCCALKAIEIAxqQQE6AAAgDSAXEJcDIg0NBQsCQCAQKAKwAUUEQCAXKAIAIgsoAgghDCAMIAsoAgBGBEAgCyAMQQEQ7gQgCygCCCEMCyALIAxBAWo2AgggCygCBCAMakEAOgAADAELIBBBtAFqIQ0gFygCACILKAIIIQwgDCALKAIARgRAIAsgDEEBEO4EIAsoAgghDAsgCyAMQQFqNgIIIAsoAgQgDGpBAToAACANIBcQlwMiDQ0FCyAXKAIAIQsCQCAQQSxqKAIARQRAIAsoAggiDCALKAIARgRAIAsgDEEBEO4EIAsoAgghDAsgCyAMQQFqNgIIIAsoAgQgDGpBADoAAAwBCyAQQTRqKAIAIQ0gEEEwaigCACEOIAsoAggiDCALKAIARgRAIAsgDEEBEO4EIAsoAgghDAsgCygCBCAMakEBOgAAIAsgDEEBaiIMNgIIIAsoAgAgDGtBA00EQCALIAxBBBDuBCALKAIIIQwLIAsoAgQgDGogDjYAACALIAxBBGoiDDYCCCALKAIAIAxrQQNNBEAgCyAMQQQQ7gQgCygCCCEMCyALIAxBBGo2AgggCygCBCAMaiANNgAACyAXKAIAIQsCQCAQQThqKAIARQRAIAsoAggiDCALKAIARgRAIAsgDEEBEO4EIAsoAgghDAsgCyAMQQFqNgIIIAsoAgQgDGpBADoAAAwBCyAQQUBrKAIAIQ0gEEE8aigCACEOIAsoAggiDCALKAIARgRAIAsgDEEBEO4EIAsoAgghDAsgCygCBCAMakEBOgAAIAsgDEEBaiIMNgIIIAsoAgAgDGtBA00EQCALIAxBBBDuBCALKAIIIQwLIAsoAgQgDGogDjYAACALIAxBBGoiDDYCCCALKAIAIAxrQQNNBEAgCyAMQQQQ7gQgCygCCCEMCyALIAxBBGo2AgggCygCBCAMaiANNgAACyAQQRhqKAIAIQ0gFygCACILKAIIIQwgCygCACAMa0EDTQRAIAsgDEEEEO4EIAsoAgghDAsgCyAMQQRqNgIIIAsoAgQgDGogDTYAACAQQRRqKgIAISUgEEEQaioCACEmIBcoAgAiCygCCCEMIAsoAgAgDGtBB00EQCALIAxBCBDuBCALKAIIIQwLIAsoAgQgDGpCAjcAACALIAxBCGoiDDYCCCALKAIAIAxrQQNNBEAgCyAMQQQQ7gQgCygCCCEMCyALKAIEIAxqICY4AAAgCyAMQQRqIgw2AgggCygCACAMa0EDTQRAIAsgDEEEEO4EIAsoAgghDAsgCyAMQQRqNgIIIAsoAgQgDGogJTgAACAQQShqKAIAIRIgEEEkaigCACEUIBcoAgAiCygCCCEOIAsoAgAgDmtBB00EQCALIA5BCBDuBCALKAIIIQ4LIAsgDkEIaiINNgIIIAtBBGoiDCgCACAOaiASrTcAACASBEAgEkEFdCEcQQAhGgNAIBQgGmoiEkEcai0AACEVIA0gCygCAEYEQCANQQFqIg5FDQggDUEBdCIeIA4gDiAeSRsiDkEIIA5BCEsbIg5Bf3NBH3YhHiAKIA0EfyAKIA02AhQgCiAMKAIANgIQQQEFQQALNgIYIAogDiAeIApBEGoQzwUgCigCBCENAkAgCigCAEUEQCALIA42AgAgDCANNgIADAELIAooAggiDkGBgICAeEYNACAORQ0JDBILIAsoAgghDQsgDCgCACANaiAVOgAAIAsgDUEBaiINNgIIIBJBBGoqAgAhJSASKgIAISYgCygCACIOIA1rQQdNBEAgDSANQQhqIg1LDQggDkEBdCIVIA0gDSAVSRsiDUF/c0EfdiEVIAogDgR/IAogDjYCFCAKIAwoAgA2AhBBAQVBAAs2AhggCiANIBUgCkEQahDPBSAKKAIEIQ4CQCAKKAIARQRAIAsgDTYCACAMIA42AgAMAQsgCigCCCINQYGAgIB4Rg0AIA1FDQkMCgsgCygCCCENCyAMKAIAIA1qQgI3AAAgCyANQQhqIg02AgggCygCACIOIA1rQQNNBEAgDSANQQRqIg1LDQggDkEBdCIVIA0gDSAVSRsiDUEIIA1BCEsbIg1Bf3NBH3YhFSAKIA4EfyAKIA42AhQgCiAMKAIANgIQQQEFQQALNgIYIAogDSAVIApBEGoQzwUgCigCBCEOAkAgCigCAEUEQCALIA02AgAgDCAONgIADAELIAooAggiDUGBgICAeEYNACANRQ0JDAoLIAsoAgghDQsgDCgCACANaiAmOAAAIAsgDUEEaiINNgIIIAsoAgAiDiANa0EDTQRAIA0gDUEEaiINSw0IIA5BAXQiFSANIA0gFUkbIg1BCCANQQhLGyINQX9zQR92IRUgCiAOBH8gCiAONgIUIAogDCgCADYCEEEBBUEACzYCGCAKIA0gFSAKQRBqEM8FIAooAgQhDgJAIAooAgBFBEAgCyANNgIAIAwgDjYCAAwBCyAKKAIIIg1BgYCAgHhGDQAgDUUNCQwKCyALKAIIIQ0LIAwoAgAgDWogJTgAACALIA1BBGoiDTYCCCASQRBqKgIAISUgCygCACIOIA1rQQNNBEAgDSANQQRqIg1LDQggDkEBdCIVIA0gDSAVSRsiDUEIIA1BCEsbIg1Bf3NBH3YhFSAKIA4EfyAKIA42AhQgCiAMKAIANgIQQQEFQQALNgIYIAogDSAVIApBEGoQzwUgCigCBCEOAkAgCigCAEUEQCALIA02AgAgDCAONgIADAELIAooAggiDUGBgICAeEYNACANRQ0JDAoLIAsoAgghDQsgDCgCACANaiAlOAAAIAsgDUEEaiINNgIIIBJBFGoqAgAhJSALKAIAIg4gDWtBA00EQCANIA1BBGoiDUsNCCAOQQF0IhUgDSANIBVJGyINQQggDUEISxsiDUF/c0EfdiEVIAogDgR/IAogDjYCFCAKIAwoAgA2AhBBAQVBAAs2AhggCiANIBUgCkEQahDPBSAKKAIEIQ4CQCAKKAIARQRAIAsgDTYCACAMIA42AgAMAQsgCigCCCINQYGAgIB4Rg0AIA1FDQkMCgsgCygCCCENCyAMKAIAIA1qICU4AAAgCyANQQRqIg02AgggEkEYaioCACElIAsoAgAiDiANa0EDTQRAIA0gDUEEaiINSw0IIA5BAXQiFSANIA0gFUkbIg1BCCANQQhLGyINQX9zQR92IRUgCiAOBH8gCiAONgIUIAogDCgCADYCEEEBBUEACzYCGCAKIA0gFSAKQRBqEM8FIAooAgQhDgJAIAooAgBFBEAgCyANNgIAIAwgDjYCAAwBCyAKKAIIIg1BgYCAgHhGDQAgDUUNCQwKCyALKAIIIQ0LIAwoAgAgDWogJTgAACALIA1BBGoiDTYCCCASQQxqKgIAISUgEkEIaioCACEmIAsoAgAiDiANa0EHTQRAIA0gDUEIaiINSw0IIA5BAXQiFSANIA0gFUkbIg1Bf3NBH3YhFSAKIA4EfyAKIA42AhQgCiAMKAIANgIQQQEFQQALNgIYIAogDSAVIApBEGoQzwUgCigCBCEOAkAgCigCAEUEQCALIA02AgAgDCAONgIADAELIAooAggiDUGBgICAeEYNACANRQ0JDAoLIAsoAgghDQsgDCgCACANakICNwAAIAsgDUEIaiINNgIIIAsoAgAiDiANa0EDTQRAIA0gDUEEaiINSw0IIA5BAXQiFSANIA0gFUkbIg1BCCANQQhLGyINQX9zQR92IRUgCiAOBH8gCiAONgIUIAogDCgCADYCEEEBBUEACzYCGCAKIA0gFSAKQRBqEM8FIAooAgQhDgJAIAooAgBFBEAgCyANNgIAIAwgDjYCAAwBCyAKKAIIIg1BgYCAgHhGDQAgDUUNCQwKCyALKAIIIQ0LIAwoAgAgDWogJjgAACALIA1BBGoiDTYCCCALKAIAIg4gDWtBA00EQCANIA1BBGoiDUsNCCAOQQF0IhUgDSANIBVJGyINQQggDUEISxsiDUF/c0EfdiEVIAogDgR/IAogDjYCFCAKIAwoAgA2AhBBAQVBAAs2AhggCiANIBUgCkEQahDPBSAKKAIEIQ4CQCAKKAIARQRAIAsgDTYCACAMIA42AgAMAQsgCigCCCINQYGAgIB4Rg0AIA1FDQkMCgsgCygCCCENCyAMKAIAIA1qICU4AAAgCyANQQRqIg42AgggEkEdai0AACESIA4gCygCAEYEQCAOQQFqIg1FDQggDkEBdCIVIA0gDSAVSRsiDUEIIA1BCEsbIg1Bf3NBH3YhFSAKIA4EfyAKIA42AhQgCiAMKAIANgIQQQEFQQALNgIYIAogDSAVIApBEGoQzwUgCigCBCEOAkAgCigCAEUEQCALIA02AgAgDCAONgIADAELIAooAggiDUGBgICAeEYNACANRQ0JDAoLIAsoAgghDgsgCyAOQQFqIg02AgggDCgCACAOaiASOgAAIBwgGkEgaiIaRw0ACwsgEEHEAGovAQAhDiAXKAIAIg0oAgghDCAQQcQBaiELIA0oAgAgDGtBAU0EQCANIAxBAhDuBCANKAIIIQwLIA0gDEECajYCCCANKAIEIAxqIA47AAAgEEEcaigCACEQIBcoAgAiDSgCCCEMIA0oAgAgDGtBA00EQCANIAxBBBDuBCANKAIIIQwLIA0gDEEEajYCCCANKAIEIAxqIBA2AAAgIiALIhBHDQALCyAPQTRqLQAAIQ0gFygCACILKAIIIQwgDCALKAIARgRAIAsgDEEBEO4EIAsoAgghDAsgCyAMQQFqNgIIIAsoAgQgDGogDToAACAPQTVqLQAAIQ0gFygCACILKAIIIQwgDCALKAIARgRAIAsgDEEBEO4EIAsoAgghDAsgCyAMQQFqNgIIIAsoAgQgDGogDToAAAJAIA9BIGooAgAiC0UEQCAXKAIAIgsoAgghDCAMIAsoAgBGBEAgCyAMQQEQ7gQgCygCCCEMCyALIAxBAWo2AgggCygCBCAMakEAOgAADAELIA9BJGooAgAhDSAXKAIAIhAoAgghDCAMIBAoAgBGBEAgECAMQQEQ7gQgECgCCCEMCyAQIAxBAWo2AgggECgCBCAMakEBOgAAIApBEGogCyANKAIsEQAAAkACQAJAAkACQAJAIAooAhBBAWsOBQECAwQFAAsgCigCFCESIBAoAgAgECgCCCIMa0EDTQRAIBAgDEEEEO4EIBAoAgghDAsgECgCBCAMakEANgAAIBAgDEEEaiINNgIIIBJBQGsoAgAhDiASQTxqKAIAIQwgECgCACANa0EHTQRAIBAgDUEIEO4EIBAoAgghDQsgECANQQhqIgs2AgggECgCBCANaiAOrTcAACAOBEAgDkECdCEOA0AgDCgCACEaIAxBBGohDCAQIBAoAgAgC2tBA0sEfyALBSAQIAtBBBDuBCAQKAIICyINQQRqIgs2AgggECgCBCANaiAaNgAAIA5BBGsiDg0ACwsgEiAXEOMCIg0NCCASQcwAaigCACEQIBJByABqKAIAIQwgFygCACINKAIIIQ4gDSgCACAOa0EHTQRAIA0gDkEIEO4EIA0oAgghDgsgDSAOQQhqIgs2AgggDSgCBCAOaiAQrTcAACAQBEAgEEECdCEOA0AgDCgCACEaIAxBBGohDCANIA0oAgAgC2tBA0sEfyALBSANIAtBBBDuBCANKAIICyIQQQRqIgs2AgggDSgCBCAQaiAaNgAAIA5BBGsiDg0ACwsgEkEYaigCACEQIBJBFGooAgAhCyAXKAIAIg0oAgghDiANKAIAIA5rQQdNBEAgDSAOQQgQ7gQgDSgCCCEOCyANIA5BCGoiDDYCCCANKAIEIA5qIBCtNwAAIBAEQCAQQQJ0IQ4DQCALKAIAIRogC0EEaiELIA0gDSgCACAMa0EDSwR/IAwFIA0gDEEEEO4EIA0oAggLIhBBBGoiDDYCCCANKAIEIBBqIBo2AAAgDkEEayIODQALCyASQTRqKAIAIRAgEkEwaigCACESIA0oAgAgDGtBB00EQCANIAxBCBDuBCANKAIIIQwLIA0gDEEIaiILNgIIIA0oAgQgDGogEK03AAAgEEUNBSAQQQN0IQ4gEkEEaiEMA0AgDCgCACESIA0gDSgCACALa0EDSwR/IAsFIA0gC0EEEO4EIA0oAggLIhBBBGoiCzYCCCANKAIEIBBqIBI2AAAgDEEIaiEMIA5BCGsiDg0ACwwFCyAKKAIUIQsgECgCACAQKAIIIgxrQQNNBEAgECAMQQQQ7gQgECgCCCEMCyAQKAIEIAxqQQE2AAAgECAMQQRqIgw2AgggCy0AHCENIAwgECgCAEYEQCAQIAxBARDuBCAQKAIIIQwLIBAoAgQgDGogDToAACAQIAxBAWoiDTYCCCALQRhqKAIAIQ4gC0EUaigCACEMIBAoAgAgDWtBB00EQCAQIA1BCBDuBCAQKAIIIQ0LIBAgDUEIaiILNgIIIBAoAgQgDWogDq03AAAgDkUNBCAOQQR0IQ4DQCAMQQRqLQAAIRIgDEEMaigCACENIAw1AgAhIyAQKAIAIAtrQQNNBEAgECALQQQQ7gQgECgCCCELCyAQKAIEIAtqIA02AAAgECALQQRqIgs2AgggECgCACALa0EHTQRAIBAgC0EIEO4EIBAoAgghCwsgECgCBCALaiAjNwAAIBAgC0EIaiINNgIIIAxBEGohDCANIBAoAgBGBEAgECANQQEQ7gQgECgCCCENCyAQIA1BAWoiCzYCCCAQKAIEIA1qIBJBAEc6AAAgDkEQayIODQALDAQLIAooAhQhCyAQKAIAIBAoAggiDGtBA00EQCAQIAxBBBDuBCAQKAIIIQwLIBAoAgQgDGpBAjYAACAQIAxBBGoiDDYCCCALLQAcIQ0gDCAQKAIARgRAIBAgDEEBEO4EIBAoAgghDAsgECgCBCAMaiANOgAAIBAgDEEBaiINNgIIIAtBGGooAgAhDiALQRRqKAIAIQwgECgCACANa0EHTQRAIBAgDUEIEO4EIBAoAgghDQsgECANQQhqIgs2AgggECgCBCANaiAOrTcAACAORQ0DIAwgDkEUbGohDgNAIAxBDGotAAAhEiAMQQhqNQIAISMgDEEEaigCACENIAwoAgAhGiAQKAIAIAtrQQNNBEAgECALQQQQ7gQgECgCCCELCyAQKAIEIAtqIBo2AAAgECALQQRqIgs2AgggECgCACALa0EDTQRAIBAgC0EEEO4EIBAoAgghCwsgECgCBCALaiANNgAAIBAgC0EEaiILNgIIIBAoAgAgC2tBB00EQCAQIAtBCBDuBCAQKAIIIQsLIBAoAgQgC2ogIzcAACAQIAtBCGoiDTYCCCANIBAoAgBGBEAgECANQQEQ7gQgECgCCCENCyAQIA1BAWoiCzYCCCAQKAIEIA1qIBJBAEc6AAAgDiAMQRRqIgxHDQALDAMLIAooAhQhCyAQKAIAIBAoAggiDGtBA00EQCAQIAxBBBDuBCAQKAIIIQwLIBAoAgQgDGpBAzYAACAQIAxBBGoiDDYCCCALLQAcIQ0gDCAQKAIARgRAIBAgDEEBEO4EIBAoAgghDAsgECgCBCAMaiANOgAAIBAgDEEBaiINNgIIIAtBGGooAgAhDiALQRRqKAIAIQwgECgCACANa0EHTQRAIBAgDUEIEO4EIBAoAgghDQsgECANQQhqIgs2AgggECgCBCANaiAOrTcAACAORQ0CIAwgDkEUbGohDgNAIAxBDGotAAAhEiAMQQhqNQIAISMgDEEEaigCACENIAwoAgAhGiAQKAIAIAtrQQNNBEAgECALQQQQ7gQgECgCCCELCyAQKAIEIAtqIBo2AAAgECALQQRqIgs2AgggECgCACALa0EDTQRAIBAgC0EEEO4EIBAoAgghCwsgECgCBCALaiANNgAAIBAgC0EEaiILNgIIIBAoAgAgC2tBB00EQCAQIAtBCBDuBCAQKAIIIQsLIBAoAgQgC2ogIzcAACAQIAtBCGoiDTYCCCANIBAoAgBGBEAgECANQQEQ7gQgECgCCCENCyAQIA1BAWoiCzYCCCAQKAIEIA1qIBJBAEc6AAAgDiAMQRRqIgxHDQALDAILIAooAhQhCyAQKAIAIBAoAggiDGtBA00EQCAQIAxBBBDuBCAQKAIIIQwLIBAoAgQgDGpBBDYAACAQIAxBBGoiDDYCCCALLQAcIQ0gDCAQKAIARgRAIBAgDEEBEO4EIBAoAgghDAsgECgCBCAMaiANOgAAIBAgDEEBaiINNgIIIAtBGGooAgAhDiALQRRqKAIAIQwgECgCACANa0EHTQRAIBAgDUEIEO4EIBAoAgghDQsgECANQQhqIgs2AgggECgCBCANaiAOrTcAACAORQ0BIA5BBHQhDgNAIAxBBGotAAAhEiAMQQxqKAIAIQ0gDDUCACEjIBAoAgAgC2tBA00EQCAQIAtBBBDuBCAQKAIIIQsLIBAoAgQgC2ogDTYAACAQIAtBBGoiCzYCCCAQKAIAIAtrQQdNBEAgECALQQgQ7gQgECgCCCELCyAQKAIEIAtqICM3AAAgECALQQhqIg02AgggDEEQaiEMIA0gECgCAEYEQCAQIA1BARDuBCAQKAIIIQ0LIBAgDUEBaiILNgIIIBAoAgQgDWogEkEARzoAACAOQRBrIg4NAAsMAQsgCigCFCELIBAoAgAgECgCCCIMa0EDTQRAIBAgDEEEEO4EIBAoAgghDAsgECgCBCAMakEFNgAAIBAgDEEEaiIMNgIIIBAoAgAgDGtBA00EQCAQIAxBBBDuBCAQKAIIIQwLIBAgDEEEajYCCCAQKAIEIAxqIAs2AAALIA9BBGooAgAhDSAPKAIAIRAgFygCACILKAIIIQwgCygCACAMa0EDTQRAIAsgDEEEEO4EIAsoAgghDAsgCygCBCAMaiAQNgAAIAsgDEEEaiIMNgIIIAsoAgAgDGtBA00EQCALIAxBBBDuBCALKAIIIQwLIAsgDEEEajYCCCALKAIEIAxqIA02AAAgD0EMaigCACENIA9BCGooAgAhECAXKAIAIgsoAgghDCALKAIAIAxrQQNNBEAgCyAMQQQQ7gQgCygCCCEMCyALKAIEIAxqIBA2AAAgCyAMQQRqIgw2AgggCygCACAMa0EDTQRAIAsgDEEEEO4EIAsoAgghDAsgCyAMQQRqNgIIIAsoAgQgDGogDTYAACAhIBMiD0cNAAsLQQAhDQsgCkEgaiQAIA0hCgwCCxCKCQALIA4gDUHAw8MAKAIAIgBBpAYgABsRAAAACyAKDQAgESAZQSRqKAIAIBlBKGooAgAQ8wIiCg0AIBlBNGooAgAhCyAZQTBqKAIAIQ0gESgCACIKKAIIIQ4gCigCACAOa0EHTQRAIAogDkEIEO4EIAooAgghDgsgCiAOQQhqIgw2AgggCigCBCAOaiALrTcAACALBEAgC0EUbCEQQQAhDgNAIA0gDmoiC0ERai0AACEPIAtBEGotAAAhEyAMIAooAgBGBEAgCiAMQQEQ7gQgCigCCCEMCyAKKAIEIAxqIBM6AAAgCiAMQQFqIgw2AgggDCAKKAIARgRAIAogDEEBEO4EIAooAgghDAsgCigCBCAMaiAPQQBHOgAAIAogDEEBaiIMNgIIIAtBBGooAgAhDyALKAIAIRMgCigCACAMa0EDTQRAIAogDEEEEO4EIAooAgghDAsgCigCBCAMaiATNgAAIAogDEEEaiIMNgIIIAooAgAgDGtBA00EQCAKIAxBBBDuBCAKKAIIIQwLIAooAgQgDGogDzYAACAKIAxBBGoiDDYCCCALQQxqKAIAIQ8gC0EIaigCACELIAooAgAgDGtBA00EQCAKIAxBBBDuBCAKKAIIIQwLIAooAgQgDGogCzYAACAKIAxBBGoiCzYCCCAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKIAtBBGoiDDYCCCAKKAIEIAtqIA82AAAgECAOQRRqIg5HDQALCyAZQUBrKAIAIQ0gGUE8aigCACELIBEoAgAiCigCCCEPIAooAgAgD2tBB00EQCAKIA9BCBDuBCAKKAIIIQ8LIAogD0EIaiIMNgIIIAooAgQgD2ogDa03AAAgDQRAIAsgDUEMbGohDQNAIAsoAgAhECAKKAIAIAxrQQNNBEAgCiAMQQQQ7gQgCigCCCEMCyAKKAIEIAxqIBA2AAAgCiAMQQRqIgw2AgggC0EIaigCACEQIAtBBGooAgAhDyAKKAIAIAxrQQNNBEAgCiAMQQQQ7gQgCigCCCEMCyAKKAIEIAxqIA82AAAgCiAMQQRqIg82AgggCigCACAPa0EDTQRAIAogD0EEEO4EIAooAgghDwsgCiAPQQRqIgw2AgggCigCBCAPaiAQNgAAIA0gC0EMaiILRw0ACwsgGygCFCINQSRqKAIAIQsgDUEgaigCACEOIBEoAgAiCigCCCEMIAooAgAgDGtBB00EQCAKIAxBCBDuBCAKKAIIIQwLIAogDEEIajYCCCAKKAIEIAxqIAutNwAAIAsEQCAOIAtB6AFsaiETA0ACQAJAIA4oAgBFBEAgESgCACIKKAIIIQsgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALakEANgAAIAogC0EEajYCCCARKAIAIQogDkEEaigCAA0BIAooAggiCyAKKAIARgRAIAogC0EBEO4EIAooAgghCwsgCiALQQFqNgIIIAooAgQgC2pBADoAAAwCCyARKAIAIgooAgghCyAOQQhqIQwgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALakEBNgAAIAogC0EEajYCCCAOKAIEIRAgESgCACIKKAIIIQsgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCiALQQRqNgIIIAooAgQgC2ogEDYAACAMIBEQlwMiCg0EIA5BGGogERCXAyIKDQQgDkHQAGohDCAOQfgAai0AACEQIBEoAgAiCigCCCELIAsgCigCAEYEQCAKIAtBARDuBCAKKAIIIQsLIAogC0EBajYCCCAKKAIEIAtqIBA6AAAgDCAREKEDIgoNBAJAIA5B8ABqKAIAIgxFBEAgESgCACIKKAIIIQsgCyAKKAIARgRAIAogC0EBEO4EIAooAgghCwsgCiALQQFqNgIIIAooAgQgC2pBADoAAAwBCyARKAIAIgooAgghDyAPIAooAgBGBEAgCiAPQQEQ7gQgCigCCCEPCyAKIA9BAWoiCzYCCCAKKAIEIA9qQQE6AAAgDCgCAEUEQCAMQQRqIQwgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCiALQQRqNgIIIAooAgQgC2pBADYAACAMIBEQoQMiCkUNAQwGCyAMKgIEISUgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALakEBNgAAIAogC0EEaiILNgIIIAooAgAgC2tBA00EQCAKIAtBBBDuBCAKKAIIIQsLIAogC0EEajYCCCAKKAIEIAtqICU4AAALIA5B5ABqKgIAISUgDkHgAGoqAgAhJiARKAIAIgooAgghCyAKKAIAIAtrQQdNBEAgCiALQQgQ7gQgCigCCCELCyAKKAIEIAtqQgI3AAAgCiALQQhqIgs2AgggCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiAmOAAAIAogC0EEaiILNgIIIAooAgAgC2tBA00EQCAKIAtBBBDuBCAKKAIIIQsLIAooAgQgC2ogJTgAACAKIAtBBGo2AgggDkHsAGoqAgAhJSAOQegAaioCACEmIBEoAgAiCigCCCELIAooAgAgC2tBB00EQCAKIAtBCBDuBCAKKAIIIQsLIAooAgQgC2pCAjcAACAKIAtBCGoiCzYCCCAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqICY4AAAgCiALQQRqIgs2AgggCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiAlOAAAIAogC0EEajYCCCAOQfQAaioCACElIBEoAgAiCigCCCELIAooAgAgC2tBA00EQCAKIAtBBBDuBCAKKAIIIQsLIAogC0EEajYCCCAKKAIEIAtqICU4AAAgDkH8AGogERD0AyIKDQQgDkGIAWogERD0AyIKDQQgDkHMAGoqAgAhJSAOQcgAaioCACEmIBEoAgAiCigCCCELIAooAgAgC2tBA00EQCAKIAtBBBDuBCAKKAIIIQsLIAooAgQgC2ogJjgAACAKIAtBBGoiCzYCCCAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqICU4AAAgCiALQQRqNgIIIA5BmAFqKgIAISUgDkGUAWoqAgAhJiARKAIAIgooAgghCyAKKAIAIAtrQQdNBEAgCiALQQgQ7gQgCigCCCELCyAKKAIEIAtqQgI3AAAgCiALQQhqIgs2AgggCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiAmOAAAIAogC0EEaiILNgIIIAooAgAgC2tBA00EQCAKIAtBBBDuBCAKKAIIIQsLIAooAgQgC2ogJTgAACAKIAtBBGoiCzYCCCAOQaQBaioCACElIAooAgAgC2tBA00EQCAKIAtBBBDuBCAKKAIIIQsLIAooAgQgC2ogJTgAACAKIAtBBGoiCzYCCCAOQagBaioCACElIAooAgAgC2tBA00EQCAKIAtBBBDuBCAKKAIIIQsLIAooAgQgC2ogJTgAACAKIAtBBGoiCzYCCCAOQaABaioCACElIA5BnAFqKgIAISYgCigCACALa0EHTQRAIAogC0EIEO4EIAooAgghCwsgCigCBCALakICNwAAIAogC0EIaiILNgIIIAooAgAgC2tBA00EQCAKIAtBBBDuBCAKKAIIIQsLIAooAgQgC2ogJjgAACAKIAtBBGoiCzYCCCAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqICU4AAAgCiALQQRqIgs2AgggDkGsAWoqAgAhJSAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqICU4AAAgCiALQQRqNgIIIA5BwAFqKgIAISUgESgCACIKKAIIIQsgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiAlOAAAIAogC0EEaiILNgIIIA5BxAFqKgIAISUgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiAlOAAAIAogC0EEaiILNgIIIA5ByAFqLQAAIQwgCyAKKAIARgRAIAogC0EBEO4EIAooAgghCwsgCigCBCALaiAMOgAAIAogC0EBaiILNgIIIA5ByQFqLQAAIQwgCyAKKAIARgRAIAogC0EBEO4EIAooAgghCwsgCigCBCALaiAMOgAAIAogC0EBajYCCCAOQShqNQIAISMgESgCACIKKAIIIQsgCigCACALa0EHTQRAIAogC0EIEO4EIAooAgghCwsgCigCBCALaiAjNwAAIAogC0EIaiILNgIIIA5BLGo1AgAhIyAKKAIAIAtrQQdNBEAgCiALQQgQ7gQgCigCCCELCyAKKAIEIAtqICM3AAAgCiALQQhqIgs2AgggDkEwajUCACEjIAooAgAgC2tBB00EQCAKIAtBCBDuBCAKKAIIIQsLIAooAgQgC2ogIzcAACAKIAtBCGoiCzYCCCAOQTRqKAIAIQwgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiAMNgAAIAogC0EEajYCCCAOQbwBaigCACEMIA5BuAFqKAIAIQ8gESgCACIKKAIIIRAgCigCACAQa0EHTQRAIAogEEEIEO4EIAooAgghEAsgCiAQQQhqIgs2AgggCigCBCAQaiAMrTcAACAMBEAgDyAMQQN0aiEQA0AgD0EEaigCACESIA8oAgAhDCAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqIAw2AAAgCiALQQRqIgw2AgggCigCACAMa0EDTQRAIAogDEEEEO4EIAooAgghDAsgCiAMQQRqIgs2AgggCigCBCAMaiASNgAAIBAgD0EIaiIPRw0ACwsgDkHMAWoqAgAhJSARKAIAIgooAgghCyAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqICU4AAAgCiALQQRqIgs2AgggDkHQAWoqAgAhJSAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqICU4AAAgCiALQQRqIgs2AgggDkHUAWoqAgAhJSAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqICU4AAAgCiALQQRqIgs2AgggDkHYAWoqAgAhJSAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqICU4AAAgCiALQQRqIgs2AgggDkHcAWotAAAhDCALIAooAgBGBEAgCiALQQEQ7gQgCigCCCELCyAKKAIEIAtqIAw6AAAgCiALQQFqNgIIIA5BsAFqKAIAIQwgESgCACIKKAIIIQsgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiAMNgAAIAogC0EEajYCCCARKAIAIQoCQAJAAkACQAJAAkAgDkHhAWotAABBAWsOAwECAwALQQAhDCAKKAIAIAooAggiC2tBBEkNAwwEC0EBIQwgCigCACAKKAIIIgtrQQRJDQIMAwtBAiEMIAooAgAgCigCCCILa0EESQ0BDAILQQMhDCAKKAIAIAooAggiC2tBA0sNAQsgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqIAw2AAAgCiALQQRqNgIIIA5B4AFqLQAAIQwgESgCACIKKAIIIQsgCyAKKAIARgRAIAogC0EBEO4EIAooAgghCwsgCigCBCALaiAMOgAAIAogC0EBajYCCCAOQeIBai0AACEMIBEoAgAiCigCCCELIAsgCigCAEYEQCAKIAtBARDuBCAKKAIIIQsLIAooAgQgC2ogDDoAACAKIAtBAWo2AgggDkFAaykDACEjIA5BOGopAwAhJCARKAIAIgooAgghCyAKKAIAIAtrQQ9NBEAgCiALQRAQ7gQgCigCCCELCyAKIAtBEGo2AgggCigCBCALaiIKICM3AAggCiAkNwAADAELIA5BCGooAgAhDCAKKAIIIgsgCigCAEYEQCAKIAtBARDuBCAKKAIIIQsLIAooAgQgC2pBAToAACAKIAtBAWoiCzYCCCAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKIAtBBGo2AgggCigCBCALaiAMNgAACyATIA5B6AFqIg5HDQALCyANQRRqKAIAIQwgESgCACIKKAIIIQsgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiAMNgAAIAogC0EEajYCCCARKAIAIQoCQCANQQxqKAIARQRAIAooAggiCyAKKAIARgRAIAogC0EBEO4EIAooAgghCwsgCiALQQFqNgIIIAooAgQgC2pBADoAAAwBCyANQRBqKAIAIQwgCigCCCILIAooAgBGBEAgCiALQQEQ7gQgCigCCCELCyAKKAIEIAtqQQE6AAAgCiALQQFqIgs2AgggCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCiALQQRqNgIIIAooAgQgC2ogDDYAAAsgDUEYajUCACEjAn8gESgCACILKAIIIQwgCyIKIAooAgAgDGtBB0sNABogCyAMQQgQ7gQgCygCCCEMIBEo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AgggDUEgaikDACEjIA1BGGopAwAhJCARKAIAIgooAgghCyAKKAIAIAtrQQ9NBEAgCiALQRAQ7gQgCigCCCELCyAKIAtBEGo2AgggCigCBCALaiIKICM3AAggCiAkNwAADAELIA1BCGooAgAhDSAKKAIIIgsgCigCAEYEQCAKIAtBARDuBCAKKAIIIQsLIAooAgQgC2pBAToAACAKIAtBAWoiCzYCCCAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKIAtBBGo2AgggCigCBCALaiANNgAACyASIAxBkAFqIgxHDQALCyAQQSBqKAIAIQ0gESgCACIKKAIIIQsgCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCigCBCALaiANNgAAIAogC0EEajYCCCARKAIAIQoCQCAQQRhqKAIARQRAIAooAggiCyAKKAIARgRAIAogC0EBEO4EIAooAgghCwsgCiALQQFqNgIIIAooAgQgC2pBADoAAAwBCyAQQRxqKAIAIQ0gCigCCCILIAooAgBGBEAgCiALQQEQ7gQgCigCCCELCyAKKAIEIAtqQQE6AAAgCiALQQFqIgs2AgggCigCACALa0EDTQRAIAogC0EEEO4EIAooAgghCwsgCiALQQRqNgIIIAooAgQgC2ogDTYAAAsgEEEkajUCACEjAn8gESgCACILKAIIIQwgCyIKIAooAgAgDGtBB0sNABogCyAMQQgQ7gQgCygCCCEMIBEoAgALIQogCyAMQQhqNgIIIAsoAgQgDGogIzcAACAQQQhqKAIAIQ0gEEEEaigCACEPIAooAgAgCigCCCIOa0EHTQRAIAogDkEIEO4EIAooAgghDgsgCiAOQQhqIgs2AgggCigCBCAOaiANrTcAACANBEAgDyANQQN0aiENA0AgD0EEaigCACETIA8oAgAhDCAKKAIAIAtrQQNNBEAgCiALQQQQ7gQgCigCCCELCyAKKAIEIAtqIAw2AAAgCiALQQRqIgw2AgggCigCACAMa0EDTQRAIAogDEEEEO4EIAooAgghDAsgCiAMQQRqIgs2AgggCigCBCAMaiATNgAAIA0gD0EIaiIPRw0ACwsgEEEUaigCACENIBBBEGooAgAhDyARKAIAIgooAgghDiAKKAIAIA5rQQdNBEAgCiAOQQgQ7gQgCigCCCEOCyAK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MGooAgAiASAGKAIAIgpNDQAgEUEsaigCACAKQZABbGpBACABIApLGyISKAIAQQFHDQAgBigCBCIMIBIoAgRHDQAgA0EIaiAPQSBqKAIAIA9BJGooAgAgCiAMIBJBCGoiCRCfAkUNACADIBJBKGoiBigCBCIBNgIEIAMgBigCACABKAIIQQdqQXhxajYCACADKAIEIQYgAygCACEBIAMgCSoCACItIBZBBGoqAgAiJZQgEkEMaioCACIuIBYqAgAiI5STOALUASADIC0gI5QgLiAllJI4AtABIAMgLSAWKgIIIBJBEGoqAgCTIiWUIC4gFkEMaioCACASQRRqKgIAkyIjlJK8rSAtICOUIC4gJZSTvK1CIIaENwPYASAZIANB0AFqIAEgBiALIAggGCgCEBEaAEH9AXFFDQAgDK1CIIYhICAKrSEfIAMoAkgEQCADKAJMEIcBCyAfICCEISEMBgsgAkEEaiECICBCAXwiIEIEUg0ACyADIA4oAAA2AmggAyAQKAAANgBrCyAFQdgAaiEPIANBAjoAnAEgA0ECOgCQASADQQI6AIQBIANBAjoAeCANQQNqIAMoAGs2AAAgDSADKAJoNgAAIAMgK7w6ANgBIAMgLDgC1AEgAyAqOALQAUIAISADQCAgIh9CAXwhIAJAICIgH4inQQFxRQ0AIB+nIQEgDy0AAEEBcQRAIAFBAnQiBiADQdABamoqAgAiIyAkXUUNASADQfAAaiABQQxsaiICLQAIIgFBAkYNASATIAUgBmpBQGsoAgBNDQEgAikCACEhIAEhByAjISQMAQsgAUECdCIBIAVqQUBrKAIAIgkgG08NACADQdABaiABaioCAIwhIyADKAJQIgIhASADKAJIIAJGBEAgA0HIAGogAhC/BCADKAJQIQELIAMoAkwiCiABQQN0aiIGICM4AgQgBiAJNgIAIAMgAUEBajYCUCAKIAJBA3RqIgEqAgQhJSABKAIAIRECQCACRQRAQQAhAQwBCwNAQQBBfyAKIAJBAWsiDEEBdiIBQQN0aiIJQQRqKgIAIiMgJV8iBhtBAUECIAYbICMgJWAbQQFqQQJJBEAgAiEBDAILIAogAkEDdGogCSkCADcCACABIQIgDEEBSw0ACwsgCiABQQN0aiIBICU4AgQgASARNgIACyAgQgRSDQALIANB2ABqIANByABqEIAC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ISADQCAgIiFCAXwhIAJAICMgIYinQQFxRQ0AICGnIQEgDC0AAEEBcQRAIAFBAnQiByADQaACamoqAgAiJSAmXUUNASADQbACaiABQRRsaiICLQAIIgFBAkYNASARIAYgB2pBQGsoAgBNDQEgA0GWAWogAkELai0AADoAACADIAIvAAk7AZQBIAIoAhAhFiACKAIMIRIgAikCACEiIAEhBSAlISYMAQsgAUECdCIBIAZqQUBrKAIAIgogFU8NACADQaACaiABaioCAIwhJSADKAKQASIBIQIgAygCiAEgAUYEQCADQYgBaiABEL8EIAMoApABIQILIAMoAowBIgcgAkEDdGoiCCAlOAIEIAggCjYCACADIAJBAWo2ApABIAcgAUEDdGoiAioCBCElIAIoAgAhCgJAIAFFBEBBACECDAELA0BBAEF/IAcgAUEBayIIQQF2IgJBA3RqIg1BBGoqAgAiJyAlXyILG0EBQQIgCxsgJSAnXxtBAWpBAkkEQCABIQIMAgsgByABQQN0aiANKQIANwIAIAIhASAIQQFLDQALCyAHIAJBA3RqIgEgJTgCBCABIAo2AgALICBCBFINAAsgA0GYAWogA0GIAWoQgAIgAygCmAFBAUYNAAsLIANBsgJqIANBlgFqLQAAOgAAIAMgAy8BlAE7AbACIAMoAogBRQ0AIAMoAowBEIcBCyAFQf8BcUECRw0BCyAJQQI6ABAMAQsgCSADLwGwAjsAESAJIAU6ABAgCSAiNwIIIAkgFjYCBCAJIBI2AgAgCUETaiADQbICai0AADoAAAsgA0GQA2okAAJAIAQtADBBAkYEQCAAQQM2AggMAQsgBCkDICEgIARBzABqIARBMGooAgA2AgAgAEECNgIIIAAgIDcCACAEIAQpAyg3AkQgACAEKQJANwIMIABBFGogBEHIAGopAgA3AgALIARB8ABqJAALigMDE30BfwJ+IAIqAgAiByABQcQAaioCACABQcwAaioCAJJDAAAAP5QiBJQgAUFAayIXKgIAIAFByABqIgEqAgCSQwAAAD+UIgsgAkEEaioCACIIlJIgAkEMaioCAJIiDiAIiyIPIAEpAgAiGKe+IgkgFykCACIZp74iCpNDAAAAP5QiBZQgB4siECAYQiCIp74gGUIgiKe+k0MAAAA/lCIGlJIiEZIhDCAEIAMqAgAiDZQg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KAIAIgRFBEAgAEEIakEANgIAQQAMAQsgASAEQQFrNgIAAkACQAJAIAEoAgQiBigCBCIBQQdNBEAgAkKBygA3AxAgAkEQahDrCSEDDAELIAYgAUEIazYCBCAGIAYoAgAiAUEIajYCACACIAEpAAAQpwQgAigCBCEDIAIoAgANAAJAIANBgCAgA0GAIEkbIgRFBEBBBCEFDAELIARBA3QiAUEEENAKIgVFDQILQQAhASACQQA2AgggAiAFNgIEIAIgBDYCACADBEADQCACQRBqIAYQgQMgAigCEARAIAIoAhQhAyACKAIARQ0DIAUQhwEMAwsgA0EBayEDIAIpAhQhByACKAIAIAFGBEAgAiABEL8EIAIoAgQhBSACKAIIIQELIAUgAUEDdGogBzcCACACIAFBAWoiATYCCCADDQALIAIoAgQhBSACKAIAIQQLIAUNAiAEIQMLIAAgAzYCBEEBDAILIAFBBEHAw8MAKAIAIgBBpAYgABsRAAAACyAAIAQ2AgQgAEEMaiABNgIAIABBCGogBTYCAEEACyEBIAAgATYCACACQSBqJAALuwMBCH8jAEEQayIHJAAgB0EIaiIFIAI2AgQgBSABNgIAIAcoAgwhCyAAQQhqKAIAIgQgBygCCCIGTQRAIABBCGoCfyAGQQFqIgkgBE0EQCAJDAELIAQhBSAJIARrIgogACgCACAEa0sEQCAAIAQgChC0BCAAQQhqKAIAIQULIAAoAgQgBUEDdGohAiAKQQJPBH8gBiAEayIIQQdxIQEgBiAEQX9zakEHTwRAIAhBeHEhCANAIAJC/////w83AgAgAkE4akL/////DzcCACACQTBqQv////8PNwIAIAJBKGpC/////w83AgAgAkEgakL/////DzcCACACQRhqQv////8PNwIAIAJBEGpC/////w83AgAgAkEIakL/////DzcCACACQUBrIQIgCEEIayIIDQALCyABBEADQCACQv////8PNwIAIAJBCGohAiABQQFrIgENAAsLIAUgCmpBAWsFIAULIgEgBCAJRg0AGiACQv////8PNwIAIAFBAWoLIgQ2AgALIAQgBksEQCAAQQRqKAIAIAZBA3RqIgAgAzYCBCAAIAs2AgAgB0EQaiQADwsgBiAEQeygwAAQowcAC7cGAgl/AX4jAEHQAGsiByQAAkACQAJAIABFDQAg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DQEgBDUADCEJIAEgBkEUayIFNgIEIAEgBEEUajYCACADQQNHBEAgBUEESQ0CIAEgBkEYazYCBCABIARBGGo2AgBBAyACQZCAwAAQuwYMAwsgBDUAECEKIAAgBzYCBCAAQQE2AgAgACAKQiCGIAmENwIIDAMLIAUgAkGQgMAAELsGDAELIAJBADoACyACQSU7AAkgAkEANgIMIAJBAToACCACQQhqEOsJCyEDIABBAjYCACAAIAM2AgQLIAJBEGokAAu5AwEEfyMAQdAAayIBJAACQCAABEAgACgCAEUNARCnCwALEKYLAAsgAEEANgIAIABBtANqIgMoAgAhBCADQQI2AgAgAUEgaiIDQQhqIABBjANqKQIANwMAIANBEGogAEGUA2opAgA3AwAgAUE4aiAAQZwDaikCADcDACABQUBrIABBpANqKQIANwMAIAFByABqIABBrANqKQIANwMAIAFBCGoiA0EIaiAAQcADaikCADcDACADQRBqIABByANqKQIANwMAIAEgAEGEA2opAgA3AyAgASAAQbgDaikCADcDCAJAIARBAkcEQEHQAEEEENAKIgJFDQEgAkEANgIAIAIgASkDIDcCBCACIAQ2AjQgAiABKQMINwI4IAJBDGogAUEgaiIAQQhqKQMANwIAIAJBFGogAEEQaikDADcCACACQRxqIAFBOGopAwA3AgAgAkEkaiABQUBrKQMANwIAIAJBLGogAUHIAGopAwA3AgAgAkFAayABQQhqIgBBCGopAwA3AgAgAkHIAGogAEEQaikDADcCAAsgAUHQAGokACACDwtB0ABBBEHAw8MAKAIAIgBBpAYgABsRAAAAC7kDAQR/IwBB0ABrIgEkAAJAIAAEQCAAKAIARQ0BEKcLAAsQpgsACyAAQQA2AgAgAEGABGoiAygCACEEIANBAjYCACABQSBqIgNBCGogAEHYA2opAgA3AwAgA0EQaiAAQeADaikCADcDACABQThqIABB6ANqKQIANwMAIAFBQGsgAEHwA2opAgA3AwAgAUHIAGogAEH4A2opAgA3AwAgAUEIaiIDQQhqIABBjARqKQIANwMAIANBEGogAEGUBGopAgA3AwAgASAAQdADaikCADcDICABIABBhARqKQIANwMIAkAgBEECRwRAQdAAQQQQ0AoiAkUNASACQQA2AgAgAiABKQMgNwIE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CkEMaiALNgIAIApBCWogAy8BzAM7AAAgCkELaiAILQAAOgAAIAMtAHhFDQAgDEUNACADIAopAgA3A5ACIAMgCkEIaigCADYCmAIgCUEIdiEjIAlBEHYhJCAJQRh2ISUgBCEWIAchASALIQIMAgsgBkEEaiEGIAJBHGohAiAuQgF8Ii5CBFINAAsgEyADKQPYAjcCACATQQhqIANB2AJqIgJBCGopAwA3AgAgE0EQaiACQRBqKAIANgIAIANB4AFqIgJBCGogEkEIaikCADcDACACQRBqIBJBEGopAgA3AwAgAyADKQPIAjcDkAIgAyASKQIANwPgASADIBcoAgA2ApgCIAMoAtQCIQIgAygC7AIhBiADQcgBaiIEQQhqIBFBCGopAgA3AwAgBEEQaiARQRBqKQIANwMAIANBwAFqIBBBEGopAgA3AwAgAyARKQIANwPIASADIBApAgA3A7ABIAMgEEEIaikCADcDuAEgBkEERwRAIAMoAsQDIQwgAygCpAMhCCADKALAAyELIAMoAogDDAMLIA4hCQsgAiEYIANB4wJqIAMoApgCNgAAIAMgAykDkAI3ANsCIAMgAykA2AI3A9ADIAMgA0HfAmopAAA3ANcDICRBEHRBgID8B3EgI0EIdEGA/gNxIAlB/wFxcnIhBCAlQRh0IQIgAygCgAEEQCADKAKEARCHAQsgAiAEciEcDAYLIAMgAygCqAI2ApgCIAMgAykDoAI3A5ACICm8IQJBAyEGQQMhCEEDIQtBAwshBCANQdgAaiEJIBIgAykD4AE3AgAgESADKQPIATcCACADQdgCaiIHQRBqIBNBEGooAgA2AgAgB0EIaiATQQhqKQIANwMAIBJBCGogA0HgAWoiB0EIaikDADcCACASQRBqIAdBEGopAwA3AgAgEUEIaiADQcgBaiIHQQhqKQMANwIAIBFBEGogB0EQaikDADcCACADIAY2AuwCIAMgBDYCiAMgAyATKQIANwPYAiAQIAMpA7ABNwIAIBBBCGogAykDuAE3AgAgEEEQaiADQcABaikDADcCACADIAg2AqQDIAMgCzYCwAMgAyAMNgLEAyADIAMoApgCNgLYAyADIAMpA5ACNwPQAyADIAI2AtwDICcgK15BAXQgDnIgJyAqXkECdHIgJyApXkEDdHKtIS9CACEuA0AgLiItQgF8IS4CQCAv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ACADKAIADQEgA0F/NgIAIARFDQAgBCgCAA0BIARBfzYCACAFRQ0AIAUoAgANASAFQX82AgAgBkUNACAGKAIADQEgBkF/NgIAIAdFDQAgBygCAA0BIAdBfzYCACAIRQ0AIAgoAgANASAIQX82AgAgCUUNACAJKAIADQEgCUF/NgIAIApFDQAgCigCAA0BIApBfzYCACAAQQhqIAFBBGogAkEEaiADQQRqIARBBGogBUEEaiAGQQRqIAdBBGogCEEEaiAJQQRqIApBBGpBuIDAAEGousAAQbiAwABBzLrAABAYIApBADYCACAJQQA2AgAgCEEANgIAIAdBADYCACAGQQA2AgAgBUEANgIAIARBADYCACADQQA2AgAgAiACKAIAQQFrNgIAIAEgASgCAEEBazYCACAAQQA2AgAPCxCmCwALEKcLAAugAwEEfyMAQUBqIgEkAAJAIAAEQCAAKAIARQ0BEKcLAAsQpgsACyAAQQA2AgAgAEHMAmoiBC0AACEDIARBAjoAACABQRBqIABBnAJqKQIANwMAIAFBGGogAEGkAmopAgA3AwAgAUEgaiAAQawCaikCADcDACABQShqIABBtAJqKQIANwMAIAFBMGogAEG8AmopAgA3AwAgAUE4aiAAQcQCaikCADcDACABQQZqIABBzwJqLQAAOgAAIAEgAEGUAmopAgA3AwggASAAQc0Cai8AADsBBAJAIANBAkcEQEHAAEEEENAKIgJFDQEgAkEANgIAIAIgASkDCDcCBCACIAM6ADwgAiABLwEEOwA9IAJBDGogAUEQaikDADcCACACQRRqIAFBGGopAwA3AgAgAkEcaiABQSBqKQMANwIAIAJBJGogAUEoaikDADcCACACQSxqIAFBMGopAwA3AgAgAkE0aiABQThqKQMANwIAIAJBP2ogAUEGai0AADoAAAsgAUFAayQAIAIPC0HAAEEEQcDDwwAoAgAiAEGkBiAAGxEAAAALqQMBBH8jAEEwayIHJAACQAJAIABFDQAgACgCACIGQX9GDQEgACAGQQFqNgIAIAFFDQAgASgCACIGQX9GDQEgASAGQQFqNgIAIAJFDQAgAigCACIGQX9GDQEgAiAGQQFqNgIAIANFDQAgAygCACIGQX9GDQEgAyAGQQFqNgIAIARFDQAgBCgCACIGQX9GDQEgBCAGQQFqNgIAIAVF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IgFFDQEgASAENgIMIAEgBTcCBCABQQA2AgAgASACKQMINwIQIAFBGGogAkEQaikDADcCACABQSBqIAJBGGopAwA3AgAgAUEoaiACQQhqIgBBGGopAwA3AgAgAUEwaiAAQSBqKQMANwIAIAFBOGogAEEoaikDADcCACABQUBrIABBMGooAgA2AgALIAJBQGskACABDwtBxABBBEHAw8MAKAIAIgBBpAYgABsRAAAAC4UZAx9/CX0DfiMAQeAAayIFJAAgASgCACgCACEOIAEoAgQiCigCACIWBEAgBUEQaiIGIAooAgQiBEH//wNxNgIEIAYgBEEQdjYCACAFKAIUIQogBSgCECEPCyABKAIIIgwoAgAiHARAIAVBCGoiBCAMKQMIIitCIIg+AgQgBCArPgIAIAUoAgghDCAFKAIMIRcLIAEoAgwiDSgCACIdBEAgBSANKQMIIitCIIg+AgQgBSArPgIAIAUoAgAhDSAFKAIEIQcLIAUgASgCECgCACkCADcDKCAFIAEoAhQoAgApAgA3AzAgBUEYaiIIIAVBMGoiBCkCADcCCCAIIAVBKGopAgA3AgAgASgCKC0AACEQIAEoAiQqAgAhIiABKAIgKAIAIQsgASgCHCgCACEGIAEoAhgoAgAhASAFIAc2AlwgBSANNgJYIAUgHTYCVCAFIBc2AlAgBSAMNgJMIAUgHDYCSCAFIAo2AkQgBSAPNgJAIAUgFjYCPCAFQQAgDiAOQUFxGzYCOCAFQaC7wAA2AjQgBSACNgIwQQAhDCMAQfACayIDJAAgA0FAayIHQShqIARBKGopAgA3AwAgB0EgaiAEQSBqKQIANwMAIAdBGGogBEEYaikCADcDACAHQRBqIARBEGopAgA3AwAgB0EIaiAEQQhqKQIANwMAIAMgCzYCeCADIAY2AnQgAyABNgJwIAMgBCkCADcDQCADQYACaiICQQhqIAhBCGopAgA3AwAgAyAIKQIANwOAAiADQYABaiACEIQGIAMgCDYCyAEgAyAQOgDMASADICI4AsABIAMgBzYCxAEgACICAn9BACABQRhqKAIAIgpFDQAaIANBADYC2AEgA0KAgICAwAA3A9ABIANB0AFqIgRBABC/BCADKALUASADKALYASIAQQN0akKAgICA8P///343AgAgAyAAQQFqNgLYASADQfABaiAEEIACAkAg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DUEDDAMLIAAoAggiAyAAKAIARgRAIAAgAxDzBCAAKAIIIQMLIAAgA0EBajYCCCAAKAIEIANqIAE6AAAMAwsgAiABQT9xQYABcjoADSACIAFBBnZBwAFyOgAMQQIMAQsgAiABQT9xQYABcjoADyACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA0gAiABQRJ2QQdxQfABcjoADEEECyIBIAAoAgAgACgCCCIDa0sEQCAAIAMgARDuBCAAKAIIIQMLIAAoAgQgA2ogAkEMaiABEK4LGiAAIAEgA2o2AggLIAJBEGokAEEAC/IFAgV/BH4jAEHQAmsiBSQAAkACQAJAIABFDQAgACgCACIEQX9GDQIgACAEQQFqNgIAIAFFDQAgASgCACIEQX9GDQIgASAEQQFqNgIAIAJFDQAgAigCACIEQX9GDQIgAiAEQQFqNgIAIANFDQAgAygCACIEQX9GDQIgAyAEQQFqNgIAIAMpAgQhCSACKQIEIQogASkCBCELIAApAgQhDCMAQTBrIgZBHWoiB0ELakIANwAAIAZBCmoiCEELakIANwAAIAZCADcAICAFQaABaiIEIAYpAB03AF0gBEHlAGogB0EIaikAADcAACAEQewAaiAHQQ9qKAAANgAAIAZCADcADSAEIAYpAAo3AHkgBEGBAWogCEEIaikAADcAACAEQYgBaiAIQQ9qKAAANgAAIARByABqQgA3AgAgBEIANwJAIARBgAI7AZwBIARBBzYCmAEgBEEAOgCUASAEQv////sHNwKMASAEQQA6AHggBEL////7BzcCcCAEQQA6AFwgBEEANgJYIARB0ABqQoCAgIDw//+//wA3AgAgBEL////7////v/8ANwI4IARC////+wc3AjAgBEKAgICA8P//v383AiggBEL////7////v/8ANwIgIARCADcCGCAEQoCAgPwDNwIQIARCADcCCCAEQoCAgPwDNwIAIAUgDDcDyAIgBSALNwPAAiAEIAVBwAJqIgYpAgA3AgAgBEEIaiAGQQhqKQIANwIAIAUgBEGgARCuCxogBSAKNwPIAiAFIAk3A8ACIAUgBikCADcCECAFQRhqIAZBCGopAgA3AgAgBCAFQaABEK4LGiAFIAQQjgsgAyADKAIAQQFrNgIAIAIgAigCAEEBazYCACABIAEoAgBBAWs2AgAg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QQIgAiAEakGAAWpBACACaxC5ASEADAMLIAAoAgAhAEEAIQIDQCACIARqQf8AaiAAQQ9xIgNBMEE3IANBCkkbajoAACACQQFrIQIgAEEPSyEDIABBBHYhACADDQALIAJBgAFqIgBBgQFPDQEgAUEBQdyfwwBBAiACIARqQYABakEAIAJrELkBIQAMAgsgAEGAAUHMn8MAEJYLAAsgAEGAAUHMn8MAEJYLAAsgBEGAAWokACAAC68CAQh/IwBBEGsiBSQAIAVBCGoiBCACNgIEIAQgATYCACAFKAIMIQggAEEIaigCACICIAUoAggiA00EQCAAQQhqIQkCQCADQQFqIgQgAk0EQCAEIQEMAQsgAiEBIAQgAmsiBiAAKAIAIAJrSwRAIAAgAiAGELQEIABBCGooAgAhAQsgACgCBCIKIAFBA3RqIQcgBkECTwRAIAdB/wEgAyACa0EDdBCtCxogCiABIANqIAJrQQN0aiEHIAEgBmpBAWshAQsgAiAERg0AIAdCfzcCACABQQFqIQELIAkgASICNgIACwJAIAIgA0sEQCAAQQRqKAIAIANBA3RqIgAoAgAgCEYNASAAIAg2AgAgAEF/NgIEDAELIAMgAkHcoMAAEKMHAAsgBUEQaiQAIABBBGoLkAUBBX8jAEGQA2siAyQAAkACQAJAIABFDQAgACgCACICQX9GDQIgACACQQFqNgIAIAFFDQAgASgCACICQX9GDQIgASACQQFqNgIAIwBBMGsiBEEdaiIFQQtqQgA3AAAgBEEKaiIGQQtqQgA3AAAgBEIANwAgIANB8AFqIgIgBCkAHTcAXSACQeUAaiAFQQhqKQAANwAAIAJB7ABqIAVBD2ooAAA2AAAgBEIANwANIAIgBCkACjcAeSACQYEBaiAGQQhqKQAANwAAIAJBiAFqIAZBD2ooAAA2AAAgAkHIAGpCADcCACACQgA3AkAgAkGAAjsBnAEgAkEDNgKYASACQQA6AJQBIAJC////+wc3AowBIAJBADoAeCACQv////sHNwJwIAJBADoAXCACQQA2AlggAkHQAGpCgICAgPD//7//ADcCACACQv////v///+//wA3AjggAkL////7BzcCMCACQoCAgIDw//+/fzcCKCACQv////v///+//wA3AiAgAkIANwIYIAJCgICA/AM3AhAgAkIANwIIIAJCgICA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BCABIAJBAXEiAjoABwJAAkAgAkUEQCAAQQRqIQICQEHUw8MAKAIAQf////8HcQRAQcTHwwAoAgBFIQMgAC0ABQRAIANFIQMMAgsgA0UNBAwDCyAALQAFRQ0CCyABIAM6AAwgASACNgIIQaT1wgBBKyABQQhqQbj7wgBBgP7CABDbBgALIAFBADYCHCABQeDxwgA2AhggAUEBNgIUIAFB5PrCADYCECABQQA2AgggAUEHaiABQQhqEOYHAAtB1MPDACgCAEH/////B3FFDQBBxMfDACgCAEUNACAAQQE6AAULIAJBADoAAAsgAUEgaiQAC54CAQJ/IwBB8ABrIgEkAAJAIAAEQCAAKAIARQ0BEKcLAAsQpgsACyAAQQA2AgAgAUE4aiICQRBqIABBEGopAgA3AwAgAkEIaiAAQQhqKQIANwMAIAJBGGogAEEYaikCADcDACACQSBqIABBIGopAgA3AwAgAkEoaiAAQShqKQIANwMAIAJBMGogAEEwaikCADcDACABQQhqIAFBxABqKQIANwMAIAFBEGogAUHMAGopAgA3AwAgAUEYaiABQdQAaikCADcDACABQSBqIAFB3ABqKQIANwMAIAFBKGogAUHkAGopAgA3AwAgAUEwaiABQewAaigCADYCACABIAApAgA3AzggASABKQI8NwMAIAAQhwEgARCbBCABQfAAaiQAC4oCAQJ9IAAgAUEgaioCACICIAFBJGoqAgAiAyACIANgGyICIAFBKGoqAgAiAyACIANgGyICIAFBLGoqAgAiAyACIANgG7ytIAFBMGoqAgAiAiABQTRqKgIAIgMgAiADYBsiAiABQThqKgIAIgMgAiADYBsiAiABQTxqKgIAIgMgAiADYBu8rUIghoQ3AgggACABKgIAIgIgASoCBCIDIAIgA18bIgIgASoCCCIDIAIgA18bIgIgASoCDCIDIAIgA18bvK0gAUEQaioCACICIAFBFGoqAgAiAyACIANfGyICIAFBGGoqAgAiAyACIANfGyICIAFBHGoqAgAiAyACIANfG7ytQiCGhDcCAAubAgMFfQF/AX4jAEEwayIIJAAgACoCACEDIAAqAgQhBCAIIAApAgAiCTcDECAIIAOMIgW8rSAEjCIDvK1CIIaENwMIIAMgAUEEaioCACIGkyIDIAYgCUIgiKe+kyIEIAMgBGAbIgND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CSATKAIsIQYLIBMgBkEBajYCLCAJIAZBA3RqIgYgHjYCBCAGIBU2AgAgByEGDAELCwwDCyAaIAlB0OTBABCjBwALIBdBEGokACAiIBBBCGpB4AEQrgsaCyAQQfAEaiQADAELQeTBwABBK0Hw5MEAEMkIAAsCQCAdLQDQAUECRg0AIB1B+ABqKAIAIgYEQCAGEIcBCyAdKAK8AUUNACAdQcABaigCABCHAQsgBUEANgIAIARBADYCACADQQA2AgAgAkEANgIAIABBADYCACAdQfABaiQADwsQpgsACxCnCwALmwIDA38CfgF9IwBBIGsiAyACKQIAIgY3AwAgAyABKQIANwMIIANCADcDECAGQiCIp0H/////B3G+IAanQf////8Hcb5dIgJBAnQiASADQQhqIgRyKgIAIQggA0EQaiIFIAFyIAg4AgAgBSACRUECdCICciACIARyKgIAIAIgA3IqAgCYOAIAIAMgAykDECIGNwMYIANBGGogAXIgCIw4AgAgAEECNgIcIAAgBjcCACAAIAMpAxgiBzcCCCAAIAZCPoinQQJxIAanQR92ciIBQYCAgIAEcq0gB0I+iKdBAnEgB6dBH3ZyIgJBgICAgARyrUIghoQ3AhAgACABIAIgASACSxtBAnQgASACIAEgAkkbckGwgICAfHI2AhgLoQICBX0BfiAAIAEqAggiA0Orqqo+lCABKQIAIginvkOrqqo+lJIgASoCECIFQ6uqqj6UkiIHIAWTIgUgBZQgAUEMaioCACIEQ6uqqj6UIAhCIIinvkOrqqo+lJIgAUEUaioCACIGQ6uqqj6UkiIFIAaTIgYgBpSSQwAAAACSIgYgByADkyIDIAOUIAUgBJMiAyADlJJDAAAAAJIiAyAHIAEqAgCTIgQgBJQgBSABKgIEkyIEIASUkkMAAAAAkiIEQwAAAAAgBEMAAAAAXhsiBCADIAReGyIDIAMgBl0bEHY4AgggACACKgIAIgMgBZQgByACQQRqKgIAIgSUkiACQQxqKgIAkjgCBCAAIAJBCGoqAgAgByADlCAFIASUk5I4AgALngIBAX8jAEEQayICJAAgACgCACEAAn8CQCABKAIIQQFHBEAgASgCEEEBRw0BCyACQQA2AgwgASACQQxqAn8CQAJAIABBgAFPBEAgAEGAEEkNASAAQYCABE8NAiACIABBP3FB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IgiUkiIJIAIpAggiC0IgiKe+IgqSkjgCACAAIAQgByAGlCAFIAiUkiIFIAunviIGkpI4AgggACAGIAWTIASTvK0gCiAJkyAEk7ytQiCGhDcCACADQSBqJAALkMABAyx/Bn4JfSAAQfwDakEANgIAIABBiARqIj1BADYCACADIRMgBiEuIAkhGCAKITwgAEGABGohOiMAQdAAayIUJAAgDCE2IAshDCALIDZBA3RqIScCQAJAAkACQAJAAkACQCA2RQ0AIBNBJGooAgAEQCATQShqKAIAIiRBBGshKSATQRRqKAIAITEgE0EYaigCACEzIBNBCGooAgAhGyATQQxqKAIAISMgE0EcaigCACEfIBNBNGooAgAhISATQTBqKAIAITIgDCEXA0AgF0EEaigCACIDIBcoAgAiCkG5893xeWxBBXdzQbnz3fF5bCIGQRl2rUKBgoSIkKDAgAF+IUAgF0EIaiEXQQAhEgJAAkADQCAGIB9xIhwgJGopAAAiQSBAhSI+QoGChIiQoMCAAX0gPkJ/hYNCgIGChIiQoMCAf4MhPwNAID9QBEAgQSBBQgGGg0KAgYKEiJCgwIB/g1BFDQQgHCASQQhqIhJqIQYMAgsgKSA/eqdBA3YgHGogH3FBAnRrKAIAIgYgIU8NAiA/QgF9ID+DIT8gMiAGQQR0aiIGKAIAIApHDQAgBkEEaigCACADRw0ACwsgBigCDCIDQX9GDQEgAyAjSQRAIBsgA0EkbGoiAy0AICIGIDNJBEAgAykCACFAIANC////9/f////+ADcCACADQQhqIgMpAgAhPiADQv////f3/////gA3AgAgQKe+IDEgBkEGdGoiEioCACJElY4iRkMAAADPYCEGID6nviBElY4iRUMAAADPYCEDQQBB/////wcCfyBGi0MAAABPXQRAIEaoDAELQYCAgIB4C0GAgICAeCAGGyBGQ////05eGyBGIEZcGyEcQQBB/////wcCfyBFi0MAAABPXQRAIEWoDAELQYCAgIB4C0GAgICAeCADGyBFQ////05eGyBFIEVcGyElAn8gQEIgiKe+IESVjiJFi0MAAABPXQRAIEWoDAELQYCAgIB4CyEKIBwgJUohAwJ/ID5CIIinviBElY4iRItDAAAAT10EQCBEqAwBC0GAgICAeAshBiADDQNBAEH/////ByAKQYCAgIB4IEVDAAAAz2AbIEVD////Tl4bIEUgRVwbIgpBAEH/////ByAGQYCAgIB4IERDAAAAz2AbIERD////Tl4bIEQgRFwbIhZKBEADQCAcICVODQUgJSAcIBwgJUhqIhxODQAMBQsACwJAIBJBDGooAgAEQCASQRBqKAIAIjRBBGshNSASQQRqKAIAITcgEkEcaigCACEiIBJBGGooAgAhHgwBCwNAIAohBgNAIAYgFkgEQCAWIAYgBiAWSGoiBk4NAQsLIBwgJU4NBSAlIBwgHCAlSGoiHE4NAAsMBAsDQCAlIBwiFUwhICAVIBUgJUhqIRwgFUHRpePmeXNBufPd8XlsQQV3IR0gCiEDA0AgFiADIhJMIRkgAyADIBZIaiEDIBIgHXNBufPd8XlsIgZBGXatQoGChIiQoMCAAX4hQEEAIRoDQAJAAkAgBiA3cSIoIDRqKQAAIkEgQIUiPkKBgoSIkKDAgAF9ID5Cf4WDQoCBgoSIkKDAgH+DIj9QDQACQANAIDUgP3qnQQN2IChqIDdxQQJ0aygCACIGICJJBEAgFSAeIAZBBHRqIgYoAgBGBEAgBkEEaigCACASRg0DCyA/QgF9ID+DIj9QRQ0BDAMLCyAGICJBgPXAABCjBwALAkAgBigCDCIGICNJBEAgGyAGQSRsaiIGKAIUQQFHDQ4gBkEUaigCBCIGRQ0BIAYgBi0AcCIGQQEgBkEBSxs6AHAMAwsgBiAjQdDdwQAQowcACwwNCyBBIEFCAYaDQoCBgoSIkKDAgH+DUEUNACAoIBpBCGoiGmohBgwBCwsgGSADIBZKckUNAAsgICAcICVKckUNAAsMAwsgBiAzQezSwQAQowcACyADICNB3NLBABCjBwALIAYgIUGA9cAAEKMHAAsgFyAnRw0ACwwBCyA2QQFrQf////8BcSEKIAwhBiA2QQdxIgMEQANAIAZBCGohBiADQQFrIgMNAAsLIApBB0kNAANAICcgBkFAayIGRw0ACwsCQCA8RQ0AIBggPEEDdGohNCATQSxqITMgE0E4aiElIBNBBGohGyABQwAAAD+UIUggLkEwaigCACEfIC5BLGooAgAhNSATQQxqIRUgE0EYaiEhIBNBFGohN0EAIRwDQAJAIBgoAgAiFyAfTw0AIDUgF0GQAWxqQQAgFyAfSRsiKigCAEEBRw0AIBhBBGoiHigCACIZICooAgRHDQACQCAqQeoAai0AAEUEQCAqQThqLQAAQSxxDQELDAELICpBPGooAgAhGiAUQQhqIgogKkEoaiIGKAIEIgM2AgQgCiAGKAIAIAMoAghBB2pBeHFqNgIAIBRBIGogFCgCCCAqQQhqIBQoAgwoAogBEQIAAkACQAJAAkACQAJ/AkAgSEMAAAAAYARAAkAgFCkDICI+p74gSJMiR7xB/////wdxvkMAAIB/XUUNACA+QiCIp74gSJMiRrxB/////wdxvkMAAIB/XUUNACBIIBQpAygiPqe+kiJFvEH/////B3G+QwAAgH9dRQ0AIEggPkIgiKe+kiJEvEH/////B3G+QwAAgH9dRQ0AIBQgREP//39+IERD//9/fl0bQ///f/4gREP//3/+Xhs4AhwgFCBFQ///f34gRUP//39+XRtD//9//iBFQ///f/5eGzgCGCAUIEZD//9/fiBGQ///f35dG0P//3/+IEZD//9//l4bOAIUIBQgR0P//39+IEdD//9/fl0bQ///f/4gR0P//3/+Xhs4AhAgE0EIaiEiAkACfwJAIBUoAgAiJCAaSyIDBEAgIigCACIgIBpBJGwiHWpBACADGyIKKQIAIT4gFEEoaiAKQQhqIgMpAgA3AwAgFCA+NwMgIBQpAxAhPiADIBRBGGopAwA3AgAgCiA+NwIAIAotACAhEiAqLQA4QSBxRQ0GQwAAAMNDAAAAwyAUKQMYIkCnviAUKQMQIj6nvpNDAAAAP5QiRCBElCBAQiCIp74gPkIgiKe+k0MAAAA/lCJEIESUkkMAAAAAkhB2IkQgRJJDAAAgQZQQlgRDEALOP5UiRLxBgICAgHhxQf////cDcr4gRJKPIkQgREMAAADDXRsgRCBEXBsiREMAAP5CIERDAAD+Ql0bIkRDAAAAw2AhAyBEi0MAAABPXUUNASBEqAwCC0MAAADDQwAAAMMgFEEYaiIGKQMAIkCnviAUKQMQIj6nvpNDAAAAP5QiRCBElCBAQiCIp74gPkIgiKe+k0MAAAA/lCJEIESUkkMAAAAAkhB2IkQgRJJDAAAgQZQQlgRDEALOP5UiRLxBgICAgHhxQf////cDcr4gRJKPIkQgREMAAADDXRsgRCBEXBsiREMAAP5CIERDAAD+Ql0bIkRDAAAAw2AhAyATQQBB/wACfyBEi0MAAABPXQRAIESoDAELQYCAgIB4C0GAfyADGyBEQwAA/kJeGyBEIERcGyIKEJ4BIRIgFEEoaiAGKQMAIkA3AwAgFCAUKQMQIj43AyAgFEFAayIGIEA3AwAgFCA+NwM4IBUoAgAhAyATKAIAIhpBf0YEQCADIBsoAgBGBEAgGyADEMkEIBUoAgAhAwsgFSADIhpBAWo2AgAgIigCACADQSRsaiIDIBQpAzg3AgAgAyAKOgAhIAMgEjoAICADIBk2AhwgAyAXNgIYIANC/////w83AhAgA0EIaiAGKQMANwIADAYLIAMgGk0NAiATICIoAgAgGkEkbGoiHSgCEDYCAAJAIB0oAhRFDQAgHUEYaiIDKAIARQ0AIAMQkAQLIB0gFCkDODcCACAdIAo6ACEgHSASOgAgIB0gGTYCHCAdIBc2AhggHUL/////DzcCECAdQQhqIAYpAwA3AgAMBQtBgICAgHgLIQZBAEH/ACAGQYB/IAMbIERDAAD+Ql4bIEQgRFwbIikgCiwAIUwNAyAhKAIAIgMgCi0AICIGSwRAIDcoAgAgBkEGdGoiCkEcaigCACIGBEAgCkEYaigCACEDIAZBBHQhF0EBIBp0IRkgGkEFdiExIApBJGohEiAKQShqISggCkEgaiEyA0ACQCADQQxqKAIAIgYgJEkEQCAgIAZBJGxqIgYoAhRBAUcNEiAGQRRqKAIEIgZFDRMgBigCQCAaTQ0BIDEgBkHMAGooAgBPDQEgBkHIAGooAgAgMUECdGooAgAgGXFFDQEgBkHUAGoiBigCAEEBayEKIAYgCjYCACAKDQEgAykCACE+ICgoAgAiCiAyKAIARgRAIDIgChC/BCAoKAIAIQoLICggCkEBajYCACASKAIAIApBA3RqID43AgAMAQsgBiAkQcDewQAQowcACyADQRBqIQMgF0EQayIXDQALCyATICkQngEhEiAVKAIAIgMgGksEQCAiKAIAIB1qIgMgKToAISADIBI6ACAMBQsgGiADQZjUwQAQowcACyAGIANBiNTBABCjBwALIBogA0Gs4MEAEKMHAAtBAAwCCyAUQcQAakEBNgIAIBRBzABqQQA2AgAgFEGcv8AANgJAIBRB9L7AADYCSCAUQQA2AjggFEE4akGQwMAAELwJAAsgISgCACIDIBJB/wFxIgpNDQEgNygCACEGIBQgFCoCKCJFIBQqAhgiRCBEIEVfGyJJvK0gFCoCLCJFIBQqAhwiRCBEIEVfGyJHvK1CIIaENwNAIBQgFCoCICJFIBQqAhAiRCBEIEVgGyJGvK0gFCoCJCJFIBQqAhQiRCBEIEVgGyJEvK1CIIaENwM4IBRBOGohAyAGIApBBnRqIgYgGiBJIEaTIEcgRJOUIBQpAxgiQKe+IBQpAxAiPqe+kyBAQiCIp74gPkIgiKe+k5RDAACgP5ReBH8gBiAaIBRBEGpBACATICUQhQEgFEEgagUgAwsgFEEQaiATICUQhQEgBkE0aigCAEEARwsgHHIhHCAqKAI8IBpGDQUgHigCACIoIBgoAgAiIkG5893xeWxBBXdzQbnz3fF5bCISQRl2IiStQoGChIiQoMCAAX4hQCATQShqIikoAgAiI0EEayEGIBNBNGoiLygCACEZIBNBMGoiFigCACEgIBMoAhwhF0EAIQogEiEDAkADQCADIBdxIh0gI2opAAAiQSBAhSI+QoGChIiQoMCAAX0gPkJ/hYNCgIGChIiQoMCAf4MhPwNAID9QBEAgQSBBQgGGg0KAgYKEiJCgwIB/g1BFDQMgHSAKQQhqIgpqIQMMAgsgBiA/eqdBA3YgHWogF3FBAnRrKAIAIgMgGU8NBCA/QgF9ID+DIT8gICADQQR0aiIDKAIAICJHDQAgA0EEaigCACAoRw0ACwsgAyAaNgIMICogGjYCPAwGCyAjIBIgF3EiCmopAABCgIGChIiQoMCAf4MiP1AEQEEIIQMDQCADIApqIQYgA0EIaiEDICMgBiAXcSIKaikAAEKAgYKEiJCgwIB/gyI/UA0ACwsgIyA/eqdBA3YgCmogF3EiA2osAAAiBkEATgR/ICMgIykDAEKAgYKEiJCgwIB/g3qnQQN2IgNqLQAABSAGC0EBcSExAkAgEygCIA0AIDFFDQAjAEFAaiI5JAAgOSAZNgI0IDkgIDYCMCATQRxqIiZBCGooAgAhKyA5IDlBMGo2AjwCQCArQQFqIgZFBEAQnwggOSgCDBoMAQsCQAJAAkACQAJAAn8gJigCACI7QQFqISMCQCA7ICNBA3ZBB2wgO0EISRsiA0EBdiAGSQRAIAYgA0EBaiIDIAMgBkkbIgZBCEkNAUF/IAZBA3RBB25BAWtndkEBaiAGIAZB/////wFxRg0CGhCfCCA5KAIsQYGAgIB4Rw0IIDkoAigMAgsgJiA5QTxqQa8BEL0BDAcLQQRBCCAGQQRJGwsiA0H/////A3EgA0cNACADQQJ0IgZBB2ohCiAGIApLDQAgCkF4cSIXIANBCGoiCmohHSAXIB1LDQAgHUEASA0BIB1BCBDQCiIGRQRAIB1BCEHAw8MAKAIAIgBBpAYgABsRAAAACyAGIBdqQf8BIAoQrQshMCADQQFrIjggA0EDdkEHbCA4QQhJGyArayEyICNFBEAgJiAyNgIEICYgODYCACAmKAIMISwgJiAwNgIMICZBCGogKzYCAAwFCyAmQQxqKAIAIixBBGshICA5KAIwIR0gOSgCNCEeQQAhLQNAICwgLWosAABBAE4EQCAgIC1BAnQiF2soAgAiAyAeTw0EIDAgHSADQQR0aigCCCIKIDhxIgZqKQAAQoCBgoSIkKDAgH+DIj9QBEBBCCEDA0AgAyAGaiEGIANBCGohAyAwIAYgOHEiBmopAABCgIGChIiQoMCAf4MiP1ANAAsLIDAgP3qnQQN2IAZqIDhxIgNqLAAAQQBOBEAgMCkDAEKAgYKEiJCgwIB/g3qnQQN2IQMLIAMgMGogCkEZdiIGOgAAIANBCGsgOHEgMGpBCGogBjoAACAwIANBAnRrQQRrICwgF2tBBGsoAAA2AgALIC0gO0YhAyAtQQFqIS0gA0UNAAsMAwsQnwggOSgCFBoMBAsQnwggOSgCHBoMAwsgAyAeQaj3wAAQowcACyAmIDA2AgwgJiAyNgIEICYgODYCACAmQQhqICs2AgAgOw0ADAELICwgI0ECdEEHakF4cWsQhwELIDlBQGskACASIBMoAhwiF3EiCiApKAIAIiNqKQAAQoCBgoSIkKDAgH+DIj9QBEBBCCEDA0AgAyAKaiEGIANBCGohAyAjIAYgF3EiCmopAABCgIGChIiQoMCAf4MiP1ANAAsLICMgP3qnQQN2IApqIBdxIgNqLAAAQQBIDQAgIykDAEKAgYKEiJCgwIB/g3qnQQN2IQMLIBMgEygCICAxazYCICADICNqICQ6AAAgA0EIayAXcSAjakEIaiAkOgAAIBMgEygCJEEBajYCJCApKAIAIANBAnRrQQRrIBk2AgAgGSATKAIsIgNHDQQgEygCICATKAIkaiAvKAIAIgZrIQMgAyAZIAZrTQRAIBkhAwwFCyAGIAMgBmoiA0sNAyADQQR0IQogA0GAgIDAAElBAnQhBiAUIBkEfyAUIBlBBHQ2AjwgFCAWKAIANgI4QQQFQQALNgJAIBRBIGogCiAGIBRBOGoQzwUgFCgCJCEGIBQoAiBFBEAgEyADNgIsIBYgBjYCAAwFCyAUKAIoIgNBgYCAgHhGDQIgA0UNAyAGIANBwMPDACgCACIAQaQGIAAbEQAAAAsgCiADQajUwQAQowcACyADIBlBgPXAABCjBwALIDMoAgAhAwwBCxCKCQALIC8oAgAiFyADRgRAIDMgAxC+BCAvKAIAIRcLIC8gF0EBajYCACAWKAIAIBdBBHRqIgMgGjYCDCADIBI2AgggAyAoNgIEIAMgIjYCACAqIBo2AjwLIDQgGEEIaiIYRw0ACyAcQQFxRQ0AIBMtAGAhEiATQRhqIRwgE0EUaiEYA0ACQCAcKAIAIgogEkH/AXEiGksEQCAYKAIAIgYgGkEGdGoiFy0AOiEVIBdBO2otAAAhEiAXQTRqIhkoAgAiA0UNASAVBEAgEiAaRg0HIAogEk0NCCAZQQA2AgAgA0ECdCEDIAYgEkEGdGohCiAXQTBqKAIAIQYDQCAKIAYoAgAgEyAlEJYBIAZBBGohBiADQQRrIgMNAAsgGUEANgIADAILIBlBADYCAAwDCyAaIApBuNTBABCjBwALIBUNAAsLAkACQCATQRhqIjMoAgBFDQAgE0HEAGohOyAUQShqIRsgEy0AYSEKIBNBFGohHyATQdwAaiEhIBNB2ABqITEgE0EMaiE3A0ACQCAzKAIAIhogCkH/AXEiJUsEQAJAICVBBnQiMiAfKAIAaiIGQRxqKAIAIgMEQCAGQRhqKAIAIhcgA0EEdGohNCAGQSRqITUgBkEoaiEWIAZBIGohIiAGQTxqIR4gE0EIaigCACE4IDcoAgAhMANAAkACQAJAAkACQAJAAkACQAJAIBcoAgwiAyAwSQRAIDggA0EkbGoiAygCFEEBRw0JIANBFGoiAygCBCEmIANBADYCBCAmRQ0JICYtAHAiIEUNCCAeLAAAIShBASEcQQAhLEEAISpBACEGAkADQCAmIAZBBXRqIiNBDGooAgAhFSAjQRBqKAIAIi1BAWsiHUECTwRAQQEhGCAtQQEgLUEBSxshJCAGQQJ0IgMgG2ohGiAUQSBqIANqIRkgFSESA0ACQAJAAkACQCAYICRHBEAgFSAYQQN0aigCBCIpQf////8HcSIvIDBJBEAgGyA4IC9BJGxqIgNBCGopAgA3AwAgFCADKQIANwMgIClBAEgNBCAtIBhBAWsiBk0NAyAaKgIAIUggFCoCLCFJIBQqAighRyAUKgIkIUYgFCoCICFFIBIhAyAYIQoDQCAKIQYgAyoCACJEIEheRQ0GAkACQCAGIC1JBEAgA0EMaiADQQRqKAIAIgo2AgAgA0EIaiBEOAIAIApBAE4NAiAKQf////8HcSIrIDBPDQECQCBFIDggK0EkbGoiCioCCF9FDQAgRiAKQQxqKgIAX0UNACBHIAoqAgBgRQ0AIEkgCkEEaioCAGANAwsgFCArNgIQIBQgLzYCNCArIC9GDSQgOyAvICsgKyAvSxsgLyArICsgL0kbQQAQkQEMAgsgBiAtQbTawQAQowcACyArIDBBxNrBABCjBwALIANBCGshAyAGQQFrIQogLSAGQQJrSw0ACwwCCyAvIDBB5NnBABCjBwALICQgLUHU2cEAEKMHAAsgCkEBayEGCyAGIC1BpNrBABCjBwALIC0gGEEBayIDSwR/IBkqAgAhSCAUKgIsIUkgFCoCKCFHIBQqAiQhRiAUKgIgIUUgEiEDIBghCgNAIAohBiADKgIAIkQgSF5FDQICQAJAIAYgLUkEQCADQQxqIANBBGooAgAiKzYCACADQQhqIEQ4AgAgK0EASA0CICsgME8NASBFIDggK0EkbGoiCioCCF9FDQIgRiAKQQxqKgIAX0UNAiBHIAoqAgBgRQ0CIEkgCkEEaioCAGBFDQIgFCArNgIQIBQgLzYCNCArIC9GDSAgOyAvICsgKyAvSxsgLyArICsgL0kbQQEQkQEMAgsgBiAtQYTawQAQowcACyArIDBBlNrBABCjBwALIANBCGshAyAGQQFrIQogBkECayAtSQ0ACyAKQQFrBSADCyAtQfTZwQAQowcACyAGIC1PDQMgFSAGQQN0aiIDICk2AgQgAyBIOAIAIBJBCGohEiAdIBhBAWoiGEcNAAsLIBUgLUEDdCIDaiEdICZByABqKAIAIS0gJkHMAGooAgAhLyAmKAJAISsgIyoCACFEQQAhEkEAIQogFSEGA0AgRCAGKgIAXgRAAkAgBkEEaigCACIpQQBIDQACQCApQf////8HcSIkICtJBEAgJEEFdiIYIC9JDQELQYDzwABBE0H02MEAEJoLAAtB4PDBAEHh8MEAIC0gGEECdGoiGigCACIZQQEgKXQiGHEbLQAARQ0AIBogGSAYQX9zcTYCACAkIDBJBEAgCkEBaiEKIBIgOCAkQSRsaiwAISAoTGohEgwBCyAkIDBBhNnBABCjBwALIB0gBkEIaiIGRw0BCwsgIyoCBCFEA0AgRCADIBVqIgZBCGsqAgBdBEACQCAGQQRrKAIAIhpBAE4NAAJAIBpB/////wdxIh0gK0kEQCAdQQV2IgYgL0kNAQtBgPPAAEETQZTZwQAQmgsAC0Hg8MEAQeHwwQAgLSAGQQJ0aiIZKAIAIhhBASAadCIGcRstAABFDQAgGSAYIAZBf3NxNgIAIB0gMEkEQCAKQQFqIQogEiA4IB1BJGxqLAAhIChMaiESDAELIB0gMEGk2cEAEKMHAAsgA0EIayIDDQELCyASICpqISogCiAsaiEsQQEhBiAcIQNBACEcIAMNAAsgLEUNCCAmICYoAlQgKms2AlQgJkEQaigCACIVRQRAQQAhA0EAIQoMAwsgJkEMaigCAEEEaiEGQQAhA0Hg8MEALQAAIRxB4fDBAC0AACESA0ACQCAGKAIAIhhB/////wdxIgpB/////wdGDQAgCiArTw0GIApBBXYiCiAvTw0GIBwgEiAtIApBAnRqKAIAIBh2QQFxG0H/AXENAEEBIQogA0EBaiEDDAQLIAZBCGohBiAVIANBAWoiA0cNAAtBACEKDAMLIAYgLUHU2sEAEKMHAAsgAyAwQeDdwQAQowcACyADIBVGDQAgJkEMaigCACADQQN0aiEGIBUgA2shAwNAAkACQCAGQQRqKAIAIhJB/////wdxIhhB/////wdGDQAgGCArTw0HIBhBBXYiGCAvTw0HQeDwwQBB4fDBACAtIBhBAnRqKAIAIBJ2QQFxGy0AAA0AIApBAWohCgwBCyAGIApBA3RrIAYpAgA3AgALIAZBCGohBiADQQFrIgMNAAsLICYgFSAKazYCECAmQTBqKAIAIhVFBEBBACEDQQAhCgwCCyAmQSxqKAIAQQRqIQZBACEDQeDwwQAtAAAhHEHh8MEALQAAIRIDQAJAIAYoAgAiGEH/////B3EiCkH/////B0YNACAKICtPDQIgCkEFdiIKIC9PDQIgHCASIC0gCkECdGooAgAgGHZBAXEbQf8BcQ0AQQEhCiADQQFqIQMMAwsgBkEIaiEGIBUgA0EBaiIDRw0AC0EAIQoMAgtBgPPAAEETQbTZwQAQmgsACyADIBVGDQAgJkEsaigCACADQQN0aiEGIBUgA2shAwNAAkACQCAGQQRqKAIAIhJB/////wdxIhhB/////wdGDQAgGCArTw0EIBhBBXYiGCAvTw0EQeDwwQBB4fDBACAtIBhBAnRqKAIAIBJ2QQFxGy0AAA0AIApBAWohCgwBCyAGIApBA3RrIAYpAgA3AgALIAZBCGohBiADQQFrIgMNAAsLICYgFSAKazYCMAwBC0GA88AAQRNBtNnBABCaCwALICYgIEEBazoAcAsgJkHgAGoiCigCACIGBEAgJkEgakEBICZB3ABqIgMoAgAgBiATQQAQKiAmQQAgAygCACAKKAIAIBMgOxAqICZBAToAcCAKQQA2AgALAkACQCAmQewAaigCACIDBEAgJkHoAGooAgAhBiADQQJ0IRoDQCAGKAIAIgMgME8NAiA4IANBJGxqIgMoAhRBAUcNDSADQRRqKAIEIgNFDQ4gBkEEaiEGIAMgAy0AcCIDQQEgA0EBSxs6AHAgGkEEayIaDQALCyAmQdQAaigCAA0BIBcpAgAhPiAWKAIAIgYgIigCAEYEQCAiIAYQvwQgFigCACEGCyAWIAZBAWo2AgAgNSgCACAGQQN0aiA+NwIADAELIAMgMEHw3cEAEKMHAAsgFygCDCIDIDBPDQMgOCADQSRsaiIDQRRqIQYCQCADKAIURQ0AIAYoAgRFDQAgBkEEahCQBAsgBiAmNgIEIAZBATYCAAsgNCAXQRBqIhdHDQALIDMoAgAhGgsgGiAlSwRAIB8oAgAgMmoiAy0AOCESIANBOWotAAAhCiAhKAIAIgNFDQMgMSgCACIGIANBBHRqIRgDQAJAIAYoAgAiFyAGQQRqKAIAIhlHBEAgNygCACIDIBdNDQ0gAyAZTQ0NIBNBCGooAgAiAyAZQSRsaiIVKAIUIRwCQAJAIAMgF0EkbGoiAygCFEUEQCAcDQEgFUEcaigCACEXIBVBGGooAgAhGSADQRxqKAIAIRUgA0EYaigCACEcIAZBDGotAAANAiA6KAIIIgMgOigCAEYEQCA6IAMQwwQgOigCCCEDCyA6IANBAWo2AgggOigCBCADQRRsaiIDIBw2AgQgA0EBNgIAIANBEGogFzYCACADQQxqIBk2AgAgA0EIaiAVNgIADAQLIBwNAyAGQQxqLQAARQ0DIANBFGooAgQiA0UNDSADIBlBABC7AQwDCyAGQQxqLQAARQ0CIBVBFGooAgQiA0UNDCADIBdBABC7AQwCCyA6KAIIIgMgOigCAEYEQCA6IAMQwwQgOigCCCEDCyA6IANBAWo2AgggOigCBCADQRRsaiIDIBw2AgQgA0EANgIAIANBEGogFzYCACADQQxqIBk2AgAgA0EIaiAVNgIADAELDAsLIBggBkEQaiIGRw0ACwwDCyAlIBpB2NTBABCjBwALIAMgMEGA3sEAEKMHAAsgJSAaQcjUwQAQowcACyA7KAIAIgMEQCATKAJQQf8BIANBCWoQrQsaCyATQQA2AkwgIUEANgIAIBMgAyADQQFqQQN2QQdsIANBCEkbNgJIIBINAAsgE0EYaigCACIaRQ0AIBogEy0AYCIDTQRAIAMhBgwCCyATQThqIRcgE0EUaiEcIBNB3ABqIRIgE0EYaiEYIAMhBgNAIBwoAgAiGSADQQZ0aiIVLQA6BEAgBkH/AXEhCiAKIBVBO2otAAAiBkYNBiADIBpPDQcgBiAaTw0HIBUgGSAGQQZ0aiATIBcQPiATKAJEIgMEQCATKAJQQf8BIANBCWoQrQsaCyATQQA2AkwgEkEANgIAIBMgAyADQQFqQQN2QQdsIANBCEkbNgJIIAYiAyAYKAIAIhpJDQEMAwsLIBkgA0EGdGpBACATIBcQPiATKAJEIgMEQCATKAJQQf8BIANBCWoQrQsaCyATQQA2AkwgE0HcAGpBADYCACATIAMgA0EBakEDdkEHbCADQQhJGzYCSCA2RQ0AIBNBKGooAgAiJEEEayExIBNBIGooAgAhIyATQTRqIh4oAgAhAyATQSRqKAIAIQogLkEwaigCACEyIC5BLGooAgAhICATQQhqKAIAIR0gE0EMaigCACE0IBNBHGooAgAhKCATQTBqKAIAISkgEygCACEYA0AgDCISQQRqITUCQCAKRQRAQQAhCgwBCyA1KAIAIhwgEigCACIZQbnz3fF5bEEFd3NBufPd8XlsIgZBGXatQoGChIiQoMCAAX4hQEEAIRoCQAJAAkADQCAGIChxIhcgJGopAAAiQSBAhSI+QoGChIiQoMCAAX0gPkJ/hYNCgIGChIiQoMCAf4MhPwNAID9QBEAgQSBBQgGGg0KAgYKEiJCgwIB/g1BFDQYgFyAaQQhqIhpqIQYMAgsgMSA/eqdBA3YgF2ogKHFBAnQiDGsiFSgCACIGIANPDQIgP0IBfSA/gyE/ICkgBkEEdGoiBigCACAZRw0AIAZBBGooAgAgHEcNAAsLQYABIQYgDEECdSIMICRqIhwpAAAiPkIBhiA+g0KAgYKEiJCgwIB/g3qnQQN2ICQgDEEIayAocWoiDCkAACI+QgGGID6DQoCBgoSIkKDAgH+DeadBA3ZqQQdNBEAgEyAjQQFqIiM2AiBB/wEhBgsgHCAGOgAAIAxBCGogBjoAACATIApBAWsiCjYCJCAVKAIAIhUgA08NASAeIANBAWsiAzYCACApIANBBHRqIgZBCGopAgAhPiApIBVBBHRqIhwgBikCADcCACAcKAIMIQwgHEEIaiA+NwIAIAMgFUsEQCAcKAIIIgZBGXatQoGChIiQoMCAAX4hQEEAIRcDQCAGIChxIhwgJGopAAAiQSBAhSI+QoGChIiQoMCAAX0gPkJ/hYNCgIGChIiQoMCAf4MhPwNAID9QBEAgQSBBQgGGg0KAgYKEiJCgwIB/g1AEQCAcIBdBCGoiF2ohBgwDC0GQ9cAAQQ9BoPXAABCaCwALID96IT4gP0IBfSA/gyE/IDEgPqdBA3YgHGogKHFBAnRrIgYoAgAgA0cNAAsLIAYgFTYCAAsgDEF/Rg0DIAwgNE8NAiATIAw2AgAgHSAMQSRsaiAYNgIQIAwhGAwDCyAGIANBgPXAABCjBwALIBUgAxChBwALIAwgNEG84MEAEKMHAAsgEkEIaiEMAkAgEigCACIGIDJPDQAgICAGQZABbGpBACAGIDJJGyIGKAIAQQFHDQAgBigCBCA1KAIARw0AIAZBPGpBfzYCAAsgDCAnRw0ACwsgFEHQAGokAAwGCyAGIBpB/NLBABCjBwALIBRBxABqQQE2AgAgFEHMAGpBADYCACAUQeTewQA2AkAgFEH0vsAANgJIIBRBADYCOCAUQThqQYzgwQAQvAkAC0HkwcAAQStBnODBABDJCAALIBRBxABqQQE2AgAgFEHMAGpBADYCACAUQZjvwQA2AkAgFEH0vsAANgJIIBRBADYCOCAUQThqQYDwwQAQvAkACyAUQcQAakEBNgIAIBRBzABqQQA2AgAgFEGQ8MEANgJAIBRB9L7AADYCSCAUQQA2AjggFEE4akGY8MEAELwJAAsgFEEANgJAQQEgFEE0aiAUQRBqIBRBOGpBzOPBABDgBwALIBEEQAJAIAkhHCALIRgjAEGAAWsiFSQAIBUCfkHgw8MAKQMAUEUEQEHww8MAKQMAIUBB6MPDACkDAAwBCyAVQQhqIgNCAjcDCCADQgE3AwBB4MPDAEIBNwMAQfDDwwAgFSkDECJANwMAIBUpAwgLIj43AxhB6MPDACA+QgJ8NwMAIBVBmPTAADYCNCAVQQA2AjAgFUIANwMoIBUgQDcDICAVQZj0wAA2AlQgFUEANgJQIBVCADcDSCAVIEA3A0AgFSA+QgF8NwM4AkACQCA2RQRAIARBJGooAgAhKiAEQTBqKAIAISwgBEEMaigCACElIARBGGooAgAhJyAEQTxqKAIAITMgBEFAaygCACEjDAELIBggNkEDdGohNiAEQTxqKAIAITMgBEFAaygCACEjIARBJGooAgAhKiAEQTBqKAIAISwgBEEMaigCACElIARBGGooAgAhJyAEQRBqITEgBEEcaiEpIARBKGohHSAEQTRqITIgLkEsaiEUA0ACQAJAIBgoAgAiAyAjTw0AIDMgA0EMbGpBACADICNJGyIDKAIAIBhBBGoiEygCAEcNACADQX82AgAgA0EIaigCACEMIAMoAgQhJCADQn83AgQCQCAVKAIwRQ0AIBUpAxggFSkDICAYEJECIj5CGYhC/wCDQoGChIiQoMCAAX4hQCA+pyEGIBUoAjQiC0EMayEKIBMoAgAhCSAYKAIAIQNBACEWIBUoAighEgNAIAYgEnEiESALaikAACJBIECFIj5CgYKEiJCgwIABfSA+Qn+Fg0KAgYKEiJCgwIB/gyE/A0AgP1AEQCBBIEFCAYaDQoCBgoSIkKDAgH+DUEUNAyARIBZBCGoiFmohBgwCCyA/eiE+ID9CAX0gP4MhPyAKID6nQQN2IBFqIBJxQXRsaiIGKAIAIANHDQAgBkEEaigCACAJRw0ACwsgBigCCCEMCwJAIBUoAlBFDQAgFSkDOCAVKQNAIBgQkQIiPkIZiEL/AINCgYKEiJCgwIABfiFAID6nIQYgFSgCVCIRQQxrIQsgEygCACEKIBgoAgAhA0EAIQkgFSgCSCETA0AgBiATcSISIBFqKQAAIkEgQIUiPkKBgoSIkKDAgAF9ID5Cf4WDQoCBgoSIkKDAgH+DIT8DQCA/UARAIEEgQUIBhoNCgIGChIiQoMCAf4NQRQ0DIBIgCUEIaiIJaiEGDAILID96IT4gP0IBfSA/gyE/IAsgPqdBA3YgEmogE3FBdGxqIgYoAgAgA0cNACAGQQRqKAIAIApHDQALCyAGKAIIISQLAkACQCACBEBBfyESQX8hAyAkIDEoAgAiC08NASAlICRBBHRqIgYoAgghAyAGQQxqKAIAIRIMAQtBfyEDQX8hBiAkIDEoAgAiC0kEQCAlICRBBHRqIgYoAgghAyAGQQxqKAIAIQYLICkoAgAhEwJAAkADQAJAIAMgE0kEQCAnIANBOGxqKAIAIQoMAQsDQCATIAYiCU0NBiAnIAlBOGxqIgooAgQhBiAKKAIIICRGDQALIAMhCiAJIQMLIAMgE0kEQCAnIANBOGxqIhJBCGooAgAiESALTw0CIBJBDGooAgAiCSALTw0DIAohAyASQTVqLQAARQ0BICUgEUEEdGopAgAhPiAVICUgCUEEdGopAgA3A3ggFSA+NwNwIBVCgYCAgCA3A2ggDyAFIC4gFUHoAGogEkEQaiAQKAIQEQgADAELCwwICyARIAtB0OTBABCjBwALIAkgC0Hg5MEAEKMHAAsgKSgCACETAkACQANAAkAgAyATSQRAICcgAyIGQThsaigCACEDDAELA0AgEyASIgZNDQUgJyAGQThsaiIJKAIEIRIgCSgCCCAkRg0ACwsgBiATSQRAICcgBkE4bGoiF0EIaigCACIJIAtPDQIgF0EMaigCACIGIAtPDQMgFCgCACEWICUgBkEEdGoiBigCBCEZIAYoAgAhICAlIAlBBHRqIgooAgQhEQJAIC5BMGoiBigCACIJIAooAgAiCk0NACAWIApBkAFsakEAIAkgCksbIhooAgBBAUcNACAaKAIEIBFHDQAgGkHsAGooAgBFDQAgAiAFIBpBgAFqKAIAIBpBhAFqKAIAEJwDIAYoAgAhCSAUKAIAIRYLAkAgCSAgTQ0AIBYgIEGQAWxqQQAgCSAgSxsiBigCAEEBRw0AIAYoAgQgGUcNACAGQewAaigCAEUNACACIAUgBkGAAWooAgAgBkGEAWooAgAQnAMLIBdBNWotAABFDQEgFSAZNgJ8IBUgIDYCeCAVIBE2AnQgFSAKNgJwIBVCgYCAgCA3A2ggDyAFIC4gFUHoAGogF0EQaiAQKAIQEQgADAELCwwHCyAJIAtB0OTBABCjBwALIAYgC0Hg5MEAEKMHAAtBfyEKQX8hEiAMIB0oAgAiCUkEQCAqIAxBBHRqIgMoAgghCiADQQxqKAIAIRILIDIoAgAhBgJAA0ACQAJAAkACQAJAIAYgCksEQCAsIApBFGxqKAIAIQMMAQsDQCASIhEgBk8NAiAsIBFBFGxqIgMoAgQhEiADKAIIIAxGDQALIAohAyARIQoLIAYgCk0NCiAsIApBFGxqIhdBCGooAgAiGSAJTw0BIBdBDGooAgAiESAJSQ0CIBEgCUHg5MEAEKMHAAsgCSAMTQ0EICogDEEEdGoiIEEIaiEaICAoAggiEkF/Rg0CA0ACQCAGIBJNDQAgLCASQRRsaiIXQQhqIRkCQCAXKQIIIj6nIgMgCU8NACAXKQIAIUAgPkIgiKchEQJAAkAgEiAqIANBBHRqIgMoAggiCkYEQCADQQhqIQMMAQsDQCAGIApNDQIgEiAsIApBFGxqIgMoAgAiCkcNAAsLIAMgQD4CAAsgCSARTQ0AIBIgKiARQQR0akEMaiIDKAIAIgpHBH8DQCAGIApNDQIgEiAsIApBFGxqIgMoAgQiCkcNAAsgA0EEagUgAwsgQEIgiD4CAAsgMiAGQQFrIgY2AgAgLCAGQRRsaiIDKQIAIUAgA0EIaikCACE+IBdBEGogA0EQaigCADYCACAZID43AgAgFyBANwIAIAYgEk0NACAZKQIAIj6nIgMgCU8NACA+QiCIpyERAkACQCAqIANBBHRqIgMoAggiCiAGRgRAIANBCGohAwwBCwNAIAYgCk0NAiAsIApBFGxqIgMoAgAiCiAGRw0ACwsgAyASNgIACyAJIBFNDQAgKiARQQR0akEMaiIDKAIAIgogBkcEfwNAIAYgCk0NAiAsIApBFGxqIgMoAgQiCiAGRw0ACyADQQRqBSADCyASNgIACyAaKAIAIhJBf0cNAAsMAgsgGSAJQdDkwQAQowcACyADIQogF0ERai0AAEUNASAqIBlBBHRqKQIAIT4gFSAqIBFBBHRqKQIANwN4IBUgPjcDcCAVQoGAgIAwNwNoIA8gBSAuIBVB6ABqQQAgECgCEBEIAAwBCwsgIEEMaiIRKAIAIhJBf0cEQANAAkAgBiASTQ0AICwgEkEUbGoiHkEIaiEXAkAgHikCCCI+pyIDIAlPDQAgHikCACFAID5CIIinIRkCQAJAIBIgKiADQQR0aiIDKAIIIgpGBEAgA0EIaiEDDAELA0AgBiAKTQ0CIBIgLCAKQRRsaiIDKAIAIgpHDQALCyADIEA+AgALIAkgGU0NACASICogGUEEdGpBDGoiAygCACIKRwR/A0AgBiAKTQ0CIBIgLCAKQRRsaiIDKAIEIgpHDQALIANBBGoFIAMLIEBCIIg+AgALIDIgBkEBayIGNgIAICwgBkEUbGoiAykCACFAIANBCGopAgAhPiAeQRBqIANBEGooAgA2AgAgFyA+NwIAIB4gQDcCACAGIBJNDQAgFykCACI+pyIDIAlPDQAgPkIgiKchGQJAAkAgKiADQQR0aiIDKAIIIgogBkYEQCADQQhqIQMMAQsDQCAGIApNDQIgLCAKQRRsaiIDKAIAIgogBkcNAAsLIAMgEjYCAAsgCSAZTQ0AICogGUEEdGpBDGoiAygCACIKIAZHBH8DQCAGIApNDQIgLCAKQRRsaiIDKAIEIgogBkcNAAsgA0EEagUgAwsgEjYCAAsgESgCACISQX9HDQALCyAdIAlBAWsiCTYCACAqIAlBBHRqIgMpAgAhPiAaIANBCGopAgA3AgAgICA+NwIAIAkgDE0NACAaKQIAIj5CIIinIRIgPqciCiAGSQRAA0AgLCAKQRRsaiIDIAw2AgggAygCACIKIAZJDQALCyAGIBJNDQADQCAsIBJBFGxqIgNBDGogDDYCACADKAIEIhIgBkkNAAsLAkACQAJAIAkgDEsEQCAqIAxBBHRqIgNBBGooAgAhCSADKAIAIgYgI08NASAzIAZBDGxqIgMoAgAgCUcNASADQQhqIAw2AgALIAsgJE0NAiAlICRBBHRqIjRBCGohNSA0KAIIIgZBf0YNAQNAAkAgBiATTw0AICcgBkE4bGoiEUEIaiEKAkAgESkCCCI+pyIDIAtPDQAgESkCACFAID5CIIinIQkCQAJAICUgA0EEdGoiAygCCCISIAZGBEAgA0EIaiEDDAELA0AgEiATTw0CICcgEkE4bGoiAygCACISIAZHDQALCyADIEA+AgALIAkgC08NACAlIAlBBHRqQQxqIgMoAgAiEiAGRwR/A0AgEiATTw0CICcgEkE4bGoiAygCBCISIAZHDQALIANBBGoFIAMLIEBCIIg+AgALICcgE0EBayITQThsaiIDQTBqKQIAIUIgA0EoaikCACFDIANBIGopAgAhPyADQRhqKQIAIUEgA0EQaikCACFAIANBCGopAgAhPiARIAMpAgA3AgAgCiA+NwIAIBFBEGogQDcCACARQRhqIEE3AgAgEUEgaiIDKAIAISAgESgCJCEaIAMgPzcCACARQShqIgMoAgAhDCARKAIsIRcgAyBDNwIAIBFBMGoiAygCACEZIBEtADQhCSADIEI3AgAgKSATNgIAAkAgBiATTw0AIAopAgAiPqciAyALTw0AID5CIIinIRECQAJAIBMgJSADQQR0aiIDKAIIIhJGBEAgA0EIaiEKDAELA0AgEiATTw0CIBMgJyASQThsaiIKKAIAIhJHDQALCyAKIAY2AgALIAsgEU0NACATICUgEUEEdGpBDGoiAygCACISRwR/A0AgEiATTw0CIBMgJyASQThsaiIDKAIEIhJHDQALIANBBGoFIAMLIAY2AgALIAlBAkYNACAZBEAgGUHEAWwhEiAXQZABaiEGA0AgBigCAARAIAZBADYCAAsgBkHwAGsoAgAEQCAGQewAaygCABCHAQsgBkHEAWohBiASQcQBayISDQALCyAMBEAgFxCHAQsgIEUNACAgIBooAgARBwAgGkEEaigCAEUNACAaQQhqKAIAGiAgEIcBCyA1KAIAIgZBf0cNAAsMAQsgFUEYaiAGIAkgDBDBAUG0xMAAQShB4ObBABDJCAALIDRBDGoiESgCACIGQX9HBEAgKSgCACESA0ACQCAGIBJPDQAgJyAGQThsaiIZQQhqIQoCQCAZKQIIIj6nIgMgC08NACAZKQIAIUAgPkIgiKchCQJAAkAgJSADQQR0aiIDKAIIIhMgBkYEQCADQQhqIQMMAQsDQCASIBNNDQIgJyATQThsaiIDKAIAIhMgBkcNAAsLIAMgQD4CAAsgCSALTw0AICUgCUEEdGpBDGoiAygCACITIAZHBH8DQCASIBNNDQIgJyATQThsaiIDKAIEIhMgBkcNAAsgA0EEagUgAwsgQEIgiD4CAAsgJyASQQFrIhJBOGxqIgNBMGopAgAhQiADQShqKQIAIUMgA0EgaikCACE/IANBGGopAgAhQSADQRBqKQIAIUAgA0EIaikCACE+IBkgAykCADcCACAKID43AgAgGUEQaiBANwIAIBlBGGogQTcCACAZQSBqIgMoAgAhHiAZKAIkISAgAyA/NwIAIBlBKGoiAygCACEMIBkoAiwhGiADIEM3AgAgGUEwaiIDKAIAIRcgGS0ANCEJIAMgQjcCACApIBI2AgACQCAGIBJPDQAgCikCACI+pyIDIAtPDQAgPkIgiKchGQJAAkAgJSADQQR0aiIDKAIIIhMgEkYEQCADQQhqIQoMAQsDQCASIBNNDQIgJyATQThsaiIKKAIAIhMgEkcNAAsLIAogBjYCAAsgCyAZTQ0AICUgGUEEdGpBDGoiAygCACITIBJHBH8DQCASIBNNDQIgJyATQThsaiIDKAIEIhMgEkcNAAsgA0EEagUgAwsgBjYCAAsgCUECRg0AIBcEQCAXQcQBbCETIBpBkAFqIQYDQCAGKAIABEAgBkEANgIACyAGQfAAaygCAARAIAZB7ABrKAIAEIcBCyAGQcQBaiEGIBNBxAFrIhMNAAsLIAwEQCAaEIcBCyAeRQ0AIB4gICgCABEHACAgQQRqKAIARQ0AICBBCGooAgAaIB4QhwELIBEoAgAiBkF/Rw0ACwsgMSALQQFrIgs2AgAgJSALQQR0aiIDKQIAIT4gNSADQQhqKQIANwIAIDQgPjcCACALICRNDQAgNSkCACI+QiCIpyEGID6nIhIgKSgCACIJSQRAA0AgJyASQThsaiIDICQ2AgggCSADKAIAIhJLDQALCyAGIAlPDQADQCAnIAZBOGxqIgNBDGogJDYCACAJIAMoAgQiBksNAAsLIAsgJE0NACAlICRBBHRqIgNBBGooAgAhCSADKAIAIgYgI08NASAzIAZBDGxqIgMoAgAgCUcNASADICQ2AgQLIDYgGEEIaiIYRw0BDAILCyAVQThqIAYgCSAkEMEBQbTEwABBKEHw5sEAEMkIAAsgFUEANgJgIBVCgICAgMAANwNYIAJBBGohNSAcIDxBA3RqIRQgBEEoaigCACEkIARBNGooAgAhMiAEQRBqKAIAIRsgBEEcaigCACEoIC5BMGohGiAuQSxqIRcgFUHqAGohGSAFQSRqITYgBUEgaiESQQQhN0EAIRYCQAJAA0AgGigCACEfIBcoAgAhKQNAIBxBCGshBgJAAkADQCAUIAYiDEEIaiIGRgRAIBUoAlwhAwJAIBYEQCAWQRRsIScgAyEGA0AgBCACIC4gBSAGIA8gECAGQRBqLQAAEHggBkEUaiEGICdBFGsiJw0ACyAWQRRsIScgFSgCWCEMIBVB+QBqIhJBAmohGCAuQSxqIREgLkEwaiELIAMhBgNAIAYtABAiCkEDRg0CIBIgBi8AETsAACAVQegAaiIJQQhqIAZBCGopAgA3AwAgGCAGQRNqLQAAOgAAIBUgCjoAeCAVIAYpAgA3A2ggBCARKAIAIAsoAgAgCRBAIAZBFGohBiAnQRRrIicNAAsMAQsgFSgCWCEMCyAMBEAgAxCHAQsCQCAVKAJIIgNFDQAgAyADQQFqrUIMfqdBB2pBeHEiA2pBd0YNACAVKAJUIANrEIcBCwJAIBUoAigiA0UNACADIANBAWqtQgx+p0EHakF4cSIDakF3Rg0AIBUoAjQgA2sQhwELIBVBgAFqJAAMCQsgBigCACIKIB9PDQEgKSAKQZABbGpBACAKIB9JGyIiKAIAQQFHDQEgDEEMaigCACIJICIoAgRHDQEgIkE4aigCACIDQQNJDQALIAogI08NACAzIApBDGxqIh4oAgAgCUcNACAeQQRqISAgAgR/ICJB7ABqKAIAQQFGBEAgAiAFICJBgAFqKAIAICJBhAFqKAIAEJwDC0F/IRNBfyEDICAoAgAiHSAbSQRAICUgHUEEdGoiCSgCCCEDIAlBDGooAgAhEwsgNigCACEYIBIoAgAhEQJAAkACQAJAA0ACQCADIChJBEAgJyADQThsaigCACEJDAELA0AgKCATIgpNDQYgJyAKQThsaiIJKAIEIRMgCSgCCCAdRg0ACyADIQkgCiEDCyADIChJBEAgJyADQThsaiIDQQhqKAIAIgsgG08NAiADQQxqKAIAIgogG08NAyAlIAtBBHRqIgMoAgQhHCADKAIAIgsgBigCAEYEQCAlIApBBHRqIgooAgQgHCAcIAZBBGooAgBGIgMbIRwgCigCACALIAMbIQsLIAkhAyALIB9PDQEgKSALQZABbGpBACALIB9JGyILKAIAQQFHDQEgCygCBCAcRw0BIAtB7ABqKAIARQ0BIAtBgAFqKAIAIjEgGE8NASARIDFB6AFsaiIhQQAgGCAxSxsiCigCAEEBRw0BIAtBhAFqKAIAIjQgCigCBEcNASAKQeEBai0AAA0BICEoAgBBAUcNBCAhKAIEIDRHDQQgIUGwAWotAABBBHENASAhQdgBakEANgIAICFB3AFqQQA6AAAgIUHiAWotAABFDQECQCACQQxqIgsoAgAiHCAhQSxqKAIAIgNNDQAgAkEIaigCACADQQN0aiIKKAIAIDFHDQAgCSEDIApBBGooAgAgNEYNAgsgISAcNgIsIDUoAgAgHEYEQCA1IBwQvwQgCygCACEcCyALIBxBAWo2AgAgAkEIaigCACAcQQN0aiIDIDQ2AgQgAyAxNgIAIAkhAwwBCwsMCwsgCyAbQdDkwQAQowcACyAKIBtB4OTBABCjBwALQZSPwQBBE0GQ0cEAEJoLAAsgIigCOAUgAwtBwABxDQELIAxBEGohHAwBCwsgBkEIaiEcICJBiAFqLQAARQRAQX8hGEF/IQYgHkEIaigCACITICRJBEAgKiATQQR0aiIDKAIIIRggA0EMaigCACEGCwJAAkACQAJAA0AgGCELAkADQAJAIAsgMkkEQCAsIAtBFGxqKAIAIhghCQwBCwNAIDIgBiIDTQ0KICwgA0EUbGoiCSgCBCEGIAkoAgggE0YNAAsgCyEJIAMhCwsgCyAyTw0BICwgC0EUbGoiA0EIaigCACIKICRPDQMgA0EMaigCACIRICRPDQQgKiAKQQR0aiIDKAIAIh0gH08NBSApIB1BkAFsakEAIB0gH0kbIgwoAgBBAUcNBSADKAIEIgogDCgCBEcNBSAJIQsgDEGIAWotAAANACAqIBFBBHRqIgMoAgAiDCAfTw0GICkgDEGQAWxqQQAgDCAfSRsiCSgCAEEBRw0GIAMoAgQiAyAJKAIERw0GIAlBiAFqLQAADQALIBUoAlggFkYEQCAVQdgAaiAWEMMEIBUoAmAhFgsgFSgCXCI3IBZBFGxqIglBAToAECAJIAM2AgwgCSAMNgIIIAkgCjYCBCAJIB02AgAgFSAWQQFqIhY2AmAMAQsLDAgLIAogJEHQ5MEAEKMHAAsgESAkQeDkwQAQowcAC0GUj8EAQRNBgOfBABCaCwALQZSPwQBBE0GQ58EAEJoLAAtBfyEDQX8hBiAgKAIAIhEgG0kEQCAlIBFBBHRqIgYoAgghAyAGQQxqKAIAIQYLA0ACQCADIChJBEAgJyADQThsaigCACEMDAELA0AgKCAGIglNDQMgJyAJQThsaiIKKAIEIQYgCigCCCARRg0ACyADIQwgCSEDCyADIChJBEAgJyADQThsaiIDQQhqKAIAIgkgG08NAyADQQxqKAIAIgMgG08NBCAlIANBBHRqIgMoAgQhCyADKAIAIQogJSAJQQR0aiIDKAIAIQkgAygCBCEDIBUoAlggFkYEQCAVQdgAaiAWEMMEIBUoAmAhFiAVKAJcITcLIDcgFkEUbGoiGEEAOgAQIBggCzYCDCAYIAo2AgggGCADNgIEIBggCTYCACAYIBUvAGg7ABEgGEETaiAZLQAAOgAAIBUgFkEBaiIWNgJgIAwhAwwBCwsLDAILIAkgG0HQ5MEAEKMHAAsgAyAbQeDkwQAQowcAC0HkwcAAQStB8OTBABDJCAALCyA9KAIAIgMEQCAAQYQEaigCACEAIANBFGwhDCAuQTBqIQYgLkEsaiEDA0ACQCAAKAIARQRAIAQgAygCACAGKAIAIABBBGoQQAwBCyAEIAIgLiAFIABBBGogDyAQQQIQeAsgAEEUaiEAIAxBFGsiDA0ACwsgASFGQQAhI0EAITRBACE1QQAhHkEAISAjAEGQAWsiFiQAAkAgPEUNACAEQRxqKAIAIgBFDQAgBEEYaigCACIbIABBOGxqIRogBCgCACAEKAIEIhcoAghBB2pBeHFqIRkgLkEsaiE2IC5BMGohEyAFQSRqISQgBUEgaiEpIAdBCGohFSAQQRBqIRwDQAJAAkACQAJAAkACQCATKAIAIgMgGygCECICTQ0AIDYoAgAiACACQZABbGpBACACIANJGyIfKAIAQQFHDQAgHygCBCAbQRRqKAIARw0AAkAgG0EYaigCACICIANPDQAgACACQZABbGpBACACIANJGyIhKAIAQQFHDQAgISgCBCAbQRxqKAIARw0AIBtBNGotAAAhEiAfQThqKAIAQQJNBEAgIUE4aigCAEEDSQ0HC0EBISJBASEoAkAgH0HsAGooAgAiAkEBRgRAICQoAgAiACAfQYABaigCACIDTQ0BICkoAgAgA0HoAWxqQQAgACADSxsiACgCAEEBRw0BIAAoAgQgH0GEAWooAgBHDQEgAEHhAWotAAAhKAsgIUHsAGooAgBBAUcNAwJAICQoAgAiACAhQYABaigCACIUTQ0AICkoAgAgFEHoAWxqQQAgACAUSxsiACgCAEEBRw0AICFBhAFqKAIAIgsgACgCBEcNACAAQeEBai0AACEiIAJFDQQgB0EcaigCACEGIB9BhAFqKAIAIQpBACEzQQAhAiAHQSBqKAIAIgMgH0GAAWooAgAiGEsEQCAGIBhBA3RqIgBBBGpBACAAKAIAIApGGyECCyADIBRLBEAgBiAUQQN0aiIAQQRqQQAgACgCACALRhshMwsgAkEAIDMbQQAgAhshAiAHQRRqKAIAIREgB0EQaigCACEJIBUoAgAhDCAHQQRqKAIAIQYDQAJAAkAgAkUNACACKAIAIgAgDE8NACAzKAIAISMCQCARIAYgAEEEdGpBACAAIAxJGyIDKAIIIgJLBEADQCAJIAJB1AFsaiIAQQxqKAIAICNGDQIgESAAKAIAIgJLDQALCyARIANBDGooAgAiAk0NAQNAIAkgAkHUAWxqIgAoAgggI0YNASARIAAoAgQiAksNAAsMAQsgAiARTw0AIAkgAkHUAWxqIgBBCGooAgAgDE8NACAAQQxqKAIAIAxJDQELIBZBQGshEQJAAkAgCEEgaigCACICIBhNDQAgCEEcaigCACIGIBhBFGxqIgAoAgAgCkcNACACIBRNDQAgBiAUQRRsaiICKAIAIAtHDQAgAEEEaiIAKAIAIgMgAigCBEcNACACQQhqKAIAIABBBGooAgAiAkcNACAIQcgAaigCACIAIANNDQAgCEHEAGooAgAgA0GUAmxqQQAgACADSxsiDC0AjAJBAkYNACAMKAKQAiACRw0AIAYgGEEUbGpBEGooAgAiCSAMQaABaigCACIDSSIARQ0AIAxBnAFqKAIAIgIgCUGEAmxqQQAgABsiACgCOEUNAAJAIAYgFEEUbGpBEGooAgAiBiAAKAJARwRAIAMgBksiAEUNAQJAIAIgBkGEAmxqQQAgABsiACgCOARAIAAoAkAgCUYNAQwECwwDCyARIAA2AgwgESAMNgIIIBEgCzYCBCARIBQ2AgAMAwsgESAANgIMIBEgDDYCCCARIAo2AgQgESAYNgIADAILIBFBADYCCAwBCyARQQA2AggLIBYoAkhFDQYgFigCTEHtAWotAAANBiAbQTBqIgAoAgAhAiAAQQA2AgAgAgRAIAJBxAFsISIgG0EsaigCAEGQAWohAgNAIAIoAgAEQCACQQA2AgALIAJB8ABrKAIABEAgAkHsAGsoAgAQhwELIAJBxAFqIQIgIkHEAWsiIg0ACwsgG0EAOgA0IBtBIGooAgAiAkUNByACIBtBJGooAgAiACgCABEHACAAQQRqKAIARQ0HIABBCGooAgAaIAIQhwEMBwtBACECIABBrQFqLQAADQALIBtBMGoiACgCACECIABBADYCACACBEAgAkHEAWwhIiAbQSxqKAIAQZABaiECA0AgAigCAARAIAJBADYCAAsgAkHwAGsoAgAEQCACQewAaygCABCHAQsgAkHEAWohAiAiQcQBayIiDQALCyAbQQA6ADQgG0EgaigCACICRQ0FIAIgG0EkaigCACIAKAIAEQcAIABBBGooAgBFDQUgAEEIaigCABogAhCHAQwFC0GUj8EAQRNBsOjBABCaCwALQZSPwQBBE0Gg6MEAEJoLAAtBlI/BAEETQZDowQAQmgsAC0GUj8EAQRNBgOjBABCaCwALAkACQAJAAkBBASAiQf8BcSILdCICIB9B6ABqLwEAIgYgKEECdEH8AXEiA3ZxDQBBASAodCIAIAYgIkECdEH8AXEiI3ZxDQAgIUHoAGovAQAiIiADdiACcQ0AICIgI3YgAHFFDQELICFB1ABqKAIAIB8oAlBxRQ0BIB9B1ABqKAIAICFB0ABqKAIAcUUNAUEBIRQgIUHgAGooAgAgH0HgAGooAgByIjFBAXENAgwECyAbQTBqIgAoAgAhAiAAQQA2AgAgAgRAIAJBxAFsISIgG0EsaigCAEGQAWohAgNAIAIoAgAEQCACQQA2AgALIAJB8ABrKAIABEAgAkHsAGsoAgAQhwELIAJBxAFqIQIgIkHEAWsiIg0ACwsgG0EAOgA0IBtBIGooAgAiAkUNAiACIBtBJGooAgAiACgCABEHACAAQQRqKAIARQ0CIABBCGooAgAaIAIQhwEMAgsgG0EwaiIAKAIAIQIgAEEANgIAIAIEQCACQcQBbCEiIBtBLGooAgBBkAFqIQIDQCACKAIABEAgAkEANgIACyACQfAAaygCAARAIAJB7ABrKAIAEIcBCyACQcQBaiECICJBxAFrIiINAAsLIBtBADoANCAbQSBqKAIAIgJFDQEgAiAbQSRqKAIAIgAoAgARBwAgAEEEaigCAEUNASAAQQhqKAIAGiACEIcBDAELIBspAhAhPiAWIC42AlQgFiAFNgJQIBYgGykCGDcDSCAWID43A0AgFiAhQYABaikCADcDaCAWICEoAmxBAEc2AmQgFiAfQYABaikCADcCXCAWIB8oAmxBAEc2AlggFkEQaiANIBZBQGsgDigCDBECACAWKAIQQQFGBEAgFigCFCEUDAILIBtBMGoiACgCACECIABBADYCACACBEAgAkHEAWwhIiAbQSxqKAIAQZABaiECA0AgAigCAARAIAJBADYCAAsgAkHwAGsoAgAEQCACQewAaygCABCHAQsgAkHEAWohAiAiQcQBayIiDQALCyAbQQA6ADQgG0EgaigCACICRQ0AIAIgG0EkaigCACIAKAIAEQcAIABBBGooAgBFDQAgAEEIaigCABogAhCHAQsgG0EANgIgDAELICFB2ABqKAIAITIgH0HcAGooAgAhMyAfQdgAaigCACE3ICFB3ABqKAIAIQogHygCOCAhQThqKAIAckEgcQRAAkAgG0EgaigCACIARQ0AIAAgG0EkaiIAKAIAKAIAEQcAIAAoAgAiAEEEaigCAEUNACAAQQhqKAIAGiAbKAIgEIcBCyAbQQA2AiALIBYgH0EIaioCACJHICFBDGoqAgAiRJQgH0EMaiIdKgIAIkUgIUEIaioCACIBlJM4AhwgFiBHIAGUIEUgRJSSOAIYIBYgRyAhQRBqKgIAIB9BEGoqAgCTIkSUIEUgIUEUaioCACAfQRRqIhgqAgCTIgGUkrytIEcgAZQgRSBElJO8rUIghoQ3AyAgFkEIaiIDIB9BKGoiAigCBCIANgIEIAMgAigCACAAKAIIQQdqQXhxajYCACAWKAIMIQYgFigCCCEDIBYgIUEoaiICKAIEIgA2AgQgFiACKAIAIAAoAghBB2pBeHFqNgIAIBkgFkEYaiADIAYgFigCACAWKAIEIEYgG0EoaiAbQSBqIBcoAigRNwAaICFBxABqKgIAIUQgH0HEAGoqAgAhAQJ9AkACQAJAIB9BzABqLQAAIgIgIUHMAGotAAAiACAAIAJJGyIAQQNxQQNHBEAgAEEBaw4CAgMBCyBEIEQgASABIERdGyABIAFcGwwDCyABIESSQwAAAD+UDAILIAEgASBEIAEgRF0bIEQgRFwbDAELIAEgRJQLIUQgIUHIAGoqAgAhRSAfQcgAaioCACEBAn0CQAJAAkAgH0HNAGotAAAiAiAhQc0Aai0AACIAIAAgAkkbIgBBA3FBA0cEQCAAQQFrDgICAwELIEUgRSABIAEgRV0bIAEgAVwbDAMLIAEgRZJDAAAAP5QMAgsgASABIEUgASBFXRsgRSBFXBsMAQsgASBFlAshASAkKAIAIQMgKSgCACECAkAgHygCbCIJBEAgHygCgAEiACADTw0BIAIgAEHoAWxqQQAgACADSRsiACgCAEEBRw0BIAAoAgQgH0GEAWooAgBHDQEgAEHgAWotAAAhIwsCQCAhKAJsIgYEQCAhKAKAASIAIANPDQEgAiAAQegBbGpBACAAIANJGyIAKAIAQQFHDQEgACgCBCAhQYQBaigCAEcNASAAQeABai0AACEiCyAbQQA6ADQgG0EwaigCACIDRQ0CIBQgFEF+cSIAIDIgM3EbIAAgCiA3cRshESAbQSxqKAIAIgIgA0HEAWxqIQxBgAEgI0EYdEEYdUEAIAlBAXEbICgbQYABQQAgBkEBcWsgIkEYdEEYdXEgCxtrIQsgMUEEcSEKA0ACfSACKAKcAUEBRgRAIB8qAhAgAkGoAWoqAgAiRyAfKgIIIkiUIAJBrAFqKgIAIkUgHSoCACJJlJOSvK0gRSBIlCBHIEmUkiAYKgIAkrytQiCGhCE+IAJBpAFqKgIAIkcgSJQgAkGgAWoqAgAiRSBJlJIhSiBFIEiUIEcgSZSTDAELIB0qAgAhSiAfKQMQIT4gHyoCCAshRSACQShqQQA2AgAgHygCgAEhACACQTRqIB8oAoQBIDMgHygCbCIDGyIzNgIAIAJBMGogACA3IAMbIjc2AgAgAkEsaiADQQBHNgIAICEoAoABIQMgISgChAEhACAhKAJsIQYgAkHEAGogCzsBACACQRhqIBE2AgAgAkEUaiBKIAIqAgAiSZQgRSACKgIEIkeUkjgCACACIEUgSZQgSiBHlJM4AhAgAkFAayAAIDEgBhsiMTYCACACQTxqIAMgMiAGGyIyNgIAIAJBOGogBkEARzYCACACQSBqIT0gAkGQAWooAgAiAARAIABBJGwhIyA+QiCIp74hTCA+p74hSEEAISJBACEoA0ACQCAiQYDIAEcEQCBGIAIgImoiAEHgAGoqAgAiS15FDQEgRSAAQcgAaioCACJJlCBKIABBzABqKgIAIkeUkyBIkiBLIAIpAhAiPqe+lEMAAAA/lJK8rSBKIEmUIEUgR5SSIEySIEsgPkIgiKe+lEMAAAA/lJK8rUIghoQhPiAAQdgAaioCAEMAAAAAWyEAIAIoAigiFCACKAIgRgRAID0gFBDBBCACKAIoIRQLIAIgFEEBajYCKCACQSRqKAIAIBRBBXRqIgMgADoAHSADICg6ABwgAyABOAIYIAMgRDgCFCADIEs4AhAgA0IANwIIIAMgPjcCACAbQQE6ADQMAQsgFkHMAGpBATYCACAWQdQAakEANgIAIBZBhOnBADYCSCAWQfS+wAA2AlAgFkEANgJAIBZBQGtBjOnBABC8CQALIChBAWohKCAjICJBJGoiIkcNAAsLIAJBxAFqIQAgCgRAIBZBKGoiA0EIaiIJID1BCGoiIygCADYCACACQQA2AiggPSkCACE+IAJBADYCICAWID43AyggAkEkaiIGQQQ2AgAgFiACQRxqKAIANgI0IBYgAikCEDcDOCAbKQIQIT4gFiAuNgJUIBYgBTYCUCAWIBspAhg3A0ggFiA+NwNAIBYgAjYCWCAWICEoAoQBIDQgISgCbCIUGyI0NgJ8IBYgISgCgAEgNSAUGyI1NgJ4IBYgFEEARzYCdCAWIB8oAoQBIB4gHygCbCIUGyIeNgJwIBYgHygCgAEgICAUGyIgNgJsIBYgFEEARzYCaCAWIBZBNGo2AmQgFiAWQThqNgJgIBYgAzYCXCANIBZBQGsgDigCFBEAACAWQYgBaiIDIAkoAgA2AgAgFiAWKQMoNwOAASACKAIgBEAgBigCABCHAQsgPSAWKQOAATcCACAjIAMoAgA2AgAgAiAWKQM4NwIQIAIgFigCNDYCHAsgDCAAIgJHDQALDAILQZSPwQBBE0Gs6cEAEJoLAAtBlI/BAEETQZzpwQAQmgsACyASQQBHIBstADQiAEEAR3NFDQAgIUHkAGooAgAgH0HkAGooAgByQQFxRQ0AIBtBEGohAyAcKAIAIQIgAEUEQCAbQTVqQQA6AAAgFkIBNwNAIBYgGykCGDcDUCAWIBspAhA3A0ggDyAFIC4gFkFAayADIAIRCAAMAQsgG0E1akEBOgAAIBZCADcDQCAWIBspAhg3A1AgFiAbKQIQNwNIIA8gBSAuIBZBQGsgAyACEQgACyAaIBtBOGoiG0cNAAsLIBZBkAFqJAAjAEFAaiIeJAACQCA8RQ0AIARBNGooAgAiAEUNACAEKAIAIAQoAgQiFSgCCEEHakF4cWohHCAAQRRsIREgBEEwaigCAEERaiEGIARBKGooAgAhFyAEQSRqKAIAITwgLkEsaiESIC5BMGohGCAFQSBqIRMgEEEQaiEQA0ACQAJ/AkACQAJAAkACQAJAIAZBCWsoAgAiACAXSQRAIAZBBWsoAgAiAyAXTw0BIDwgAEEEdGoiACgCACIUIBgoAgAiBE8NAiASKAIAIgIgFEGQAWxqQQAgBCAUSxsiICgCAEEBRw0CIAAoAgQiGSAgKAIERw0CIDwgA0EEdGoiACgCACIaIARPDQMgAiAaQZABbGpBACAEIBpLGyIdKAIAQQFHDQMgACgCBCI2IB0oAgRHDQMgBkEBayILLQAAIQogIEE4aigCAEECTQRAIB1BOGooAgBBA0kNCQtBASEAQQEhDCAgQewAaigCACIJQQFGBEAgBUEkaigCACICICBBgAFqKAIAIgNNDQUgEygCACADQegBbGpBACACIANLGyICKAIAQQFHDQUgAigCBCAgQYQBaigCAEcNBSACQeEBai0AACEMCyAdQewAaigCACIIQQFGBEAgBUEkaigCACIAIB1BgAFqKAIAIgJNDQYgEygCACACQegBbGpBACAAIAJLGyIAKAIAQQFHDQYgACgCBCAdQYQBaigCAEcNBiAAQeEBai0AACEACwJAAkBBASAAdCIEICBB6ABqLwEAIgIgDEECdEH8AXEiB3ZxDQBBASAMdCIDIAIgAEECdEH8AXEiAnZxDQAgBCAdQegAai8BACIAIAd2cQ0AIAAgAnYgA3FFDQELIB1B1ABqKAIAICAoAlBxRQ0AICBB1ABqKAIAIB1B0ABqKAIAcUUNACAdQeAAaigCACAgQeAAaigCAHJBAnFFDQcgHiAuNgIkIB4gBTYCICAeIAg2AjQgHiAJNgIoIB4gNjYCHCAeIBo2AhggHiAZNgIUIB4gFDYCECAeIB1BgAFqKQIANwM4IB4gIEGAAWopAgA3AiwgDSAeQRBqIA4oAhARAwANBwtBAAwHCyAAIBdBoOfBABCjBwALIAMgF0Gw58EAEKMHAAtBlI/BAEETQcDnwQAQmgsAC0GUj8EAQRNB0OfBABCaCwALQZSPwQBBE0Hg58EAEJoLAAtBlI/BAEETQfDnwQAQmgsACyAeICBBCGoqAgAiRiAdQQxqKgIAIkSUICBBDGoqAgAiRSAdQQhqKgIAIgGUkzgCFCAeIEYgAZQgRSBElJI4AhAgHiBGIB1BEGoqAgAgIEEQaioCAJMiRJQgRSAdQRRqKgIAICBBFGoqAgCTIgGUkrytIEYgAZQgRSBElJO8rUIghoQ3AxggHkEIaiIDICBBKGoiAigCBCIANgIEIAMgAigCACAAKAIIQQdqQXhxajYCACAeKAIMIQQgHigCCCEDIB4gHUEoaiICKAIEIgA2AgQgHiACKAIAIAAoAghBB2pBeHFqNgIAIBwgHkEQaiADIAQgHigCACAeKAIEIBUoAhARGgBB/wFxIgAgAEECR3ELIQAgCyAAOgAAIApBAEcgAEEAR0YNACAdQeQAaigCACAgQeQAaigCAHJBAXFFDQAgECgCACECIABFBEAgBkEAOgAAIB4gNjYCJCAeIBo2AiAgHiAZNgIcIB4gFDYCGCAeQoGAgIAQNwMQIA8gBSAuIB5BEGpBACACEQgADAELIAZBAToAACAeIDY2AiQgHiAaNgIgIB4gGTYCHCAeIBQ2AhggHkKAgICAEDcDECAPIAUgLiAeQRBqQQAgAhEIAAsgBkEUaiEGIBFBFGsiEQ0ACwsgHkFAayQAC+cBAgF/Bn0jAEGAAWsiBSQAIAJBDGoqAgAhByADQQRqKgIAIQYgAkEEaioCACEIIAJBCGoqAgAhCyACKgIAIQkgAyoCACEKIAVB8ABqQgI3AwAgBUEANgJ4IAVCgICAgBA3A2ggBUEQaiICQQBB2AAQrQsaIAUgASACIAogC5MiCiAJlCAGIAeTIgYgCJSSvK0gCSAGlCAIIAqUk7ytQiCGhCAEEBogACAFLQAIOgAIIAAgByAIIAUqAgAiB5QgCSAFKgIEIgaUkpI4AgQgACALIAkgB5QgCCAGlJOSOAIAIAVBgAFqJAAL5wECAX8GfSMAQYABayIFJAAgAkEMaioCACEHIANBBGoqAgAhBiACQQRqKgIAIQggAkEIaioCACELIAIqAgAhCSADKgIAIQogBUHwAGpCAjcDACAFQQA2AnggBUKAgICAEDcDaCAFQRBqIgJBAEHYABCtCxogBSABIAIgCiALkyIKIAmUIAYgB5MiBiAIlJK8rSAJIAaUIAggCpSTvK1CIIaEIAQQHCAAIAUtAAg6AAggACAHIAggBSoCACIHlCAJIAUqAgQiBpSSkjgCBCAAIAsgCSAHlCAIIAaUk5I4AgAgBUGAAWokAAvnAQIBfwZ9IwBBgAFrIgUkACACQQxqKgIAIQcgA0EEaioCACEGIAJBBGoqAgAhCCACQQhqKgIAIQsgAioCACEJIAMqAgAhCiAFQfAAakICNwMAIAVBADYCeCAFQoCAgIAQNwNoIAVBEGoiAkEAQdgAEK0LGiAFIAEgAiAKIAuTIgogCZQgBiAHkyIGIAiUkrytIAkgBpQgCCAKlJO8rUIghoQgBBAbIAAgBS0ACDoACCAAIAcgCCAFKgIAIgeUIAkgBSoCBCIGlJKSOAIEIAAgCyAJIAeUIAggBpSTkjgCACAFQYABaiQAC4gCAgF/BH0CQAJAAn8gALwiAUGAgIAETgRAIAFB////+wdLDQJDAAAAACEAQYF/IAFBgICA/ANHDQEaDAILIAFB/////wdxRQRAQwAAgL8gACAAlJUPCyABQQBIDQIgAEMAAABMlLwhAUHofgsgAUGN9qsCaiIBQRd2arIhAyABQf///wNxQfOJ1PkDar5DAACAv5IiACAAQwAAAECSlSIEIASUIgUgBZQhAiADQ4BxMT+UIAAgA0PR9xc3lCAEIAAgAEMAAAA/lJQiACAFIAJD7umRPpRDqqoqP5KUIAIgAkMmnng+lEMTzsw+kpSSkpSSIACTkpIhAAsgAA8LIAAgAJNDAAAAAJUL6gEBBH0jAEEgayIEJAAgBCACKgIAIgcgA0EEaioCACACQQxqKgIAkyIGlCADKgIAIAJBCGoqAgCTIgggAkEEaioCACIJlJM4AgQgBCAIIAeUIAYgCZSSOAIAIARBCGogASkCACABQQhqKQIAIAQQjwIgBCgCECEBAkAgBCoCACAEKgIIIgeTIgYgBpQgBCoCBCAEKgIMIgaTIgggCJSSQwAAAACSEHYgBV5FIAFB/wFxQQJHcUUEQCAAQQI6AAgMAQsgBCABNgIQIAQgBjgCDCAEIAc4AgggACAEQQhqIAIQlQgLIARBIGokAAvTAwMEfwF+An0jAEEgayIGJAACQAJAAkAgAEUNACAAKAIADQIgAEF/NgIAIAJFDQAgAigCACIFQX9GDQIgAiAFQQFqNgIAIANFDQAgAygCACIFQX9GDQIgAyAFQQFqNgIAIAZBCGoiBSABvSIJQiCIPgIEIAUgCT4CACAAQQRqIAYoAgggBigCDBDyBSIFRQ0BIAYgAikCBDcDECAGIAMpAgQ3AxggBkEYaiEHIARBAEchCAJAAkAgBkEQaiIEKgIAIgtDAAAAAFsEQCAEQQRqKgIAIgpDAAAAAFsNAiAFLQDZAUUNAQwCCyAFLQDZAQ0BIAQqAgQhCgsgBUGUAWoiBCALIAQqAgCSOAIAIAVBmAFqIgQgCiAEKgIAkjgCACAFQaQBaiIEIAQqAgAgCiAHKQIAIgmnviAFQdgAaioCAJOUIAsgCUIgiKe+IAVB3ABqKgIAk5STkjgCACAIRQ0AIAVB1AFqLQAABEAgBSAFKAKoAUEEcjYCqAELIAVBADoA1AEgBUHQAWpBADYCAAsgAyADKAIAQQFrNgIAIAIgAigCAEEBazYCACAAQQA2AgAgBkEgaiQADwsQpgsAC0GAtcAAQc0AQYi2wAAQmgsACxCnCwALvgQDA38BfgR9IwBBIGsiBiQAAkACQAJAIABFDQAgACgCAA0CIABBfzYCACACRQ0AIAIoAgAiBUF/Rg0CIAIgBUEBajYCACADRQ0AIAMoAgAiBUF/Rg0CIAMgBUEBajYCACAGQQhqIgUgAb0iCEIgiD4CBCAFIAg+AgAgAEEEaiAGKAIIIAYoAgwQ8gUiBUUNASAGIAIpAgQ3AxAgBiADKQIENwMYIARBAEchByAFQdwAaioCACEJIAZBGGopAgAhCCAFQdgAaioCACEKIAZBEGoiBCoCBCELAkACQAJAIAQqAgAiDEMAAAAAWwRAIAUtANkBIQQgC0MAAAAAWw0CIARFDQEMAgsgBS0A2QENAgsgBSAFQeAAaioCACAMlCAFKgKAAZI4AoABIAVBhAFqIgQgBUHkAGoqAgAgC5QgBCoCAJI4AgBBACEEIAdFDQAgBUHUAWotAAAEQCAFIAUoAqgBQQRyNgKoAQsgBUEAOgDUASAFQdABakEANgIACyAIp74gCpMgC5QgDCAIQiCIp74gCZOUkyIJQwAAAABbDQAgBA0AIAVBiAFqIgQgBCoCACAFQewAaioCACIKIAkgCpSUkjgCACAHRQ0AIAVB1AFqLQAABEAgBSAFKAKoAUEEcjYCqAELIAVBADoA1AEgBUHQAWpBADYCAAsgAyADKAIAQQFrNgIAIAIgAigCAEEBazYCACAAQQA2AgAgBkEgaiQADwsQpgsAC0GAtcAAQc0AQYi2wAAQmgsACxCnCwALxgICDH0BfyABKgIEIgwgAioCACIIlCABKgIAIgUgAkEEaioCACIJlJIgAkEMaioCACIEkiEDIABBDGogBCAJIAEqAhAiDZQgCCABQRRqKgIAIgaUkpIiByAHIAQgCSABKgIIIg6UIAggAUEMaioCACIKlJKSIgQgBCADIgsgAyAEXSIPGyADIANcGyIDIAMgB10bIAMgA1wbOAIAIAJBCGoqAgAiAyAFIAiUIAwgCZSTkiEFIAAgAyAIIA2UIAkgBpSTkiIGIAYgAyAIIA6UIAkgCpSTkiIDIAMgBSADIAVeIgEbIAUgBVwbIgogBiAKXhsgCiAKXBs4AgggACALIAsgBCAPGyAEIARcGyIEIAQgByAEIAddGyAHIAdcGzgCBCAAIAUgBSADIAEbIAMgA1wbIgMgAyAGIAMgBl0bIAYgBlwbOAIAC8cBAQV/IABBMGooAgAiAgRAIABBLGooAgAhASACQZABbCECA0ACQCABKAIARQ0AIAFBKGoiBCgCACIFKAIAIQMgBSADQQFrNgIAIANBAUYEQCAEKAIAIAFBLGooAgAQnQcLIAFBMGooAgBBAkkNACABQTRqKAIAEIcBCyABQZABaiEBIAJBkAFrIgINAAsLIAAoAigEQCAAQSxqKAIAEIcBCyAAKAIABEAgAEEEaigCABCHAQsgACgCDARAIABBEGooAgAQhwELC+IBAgd9AX4gASkCACIKp74iAyADlCAKQiCIp74iBiAGlJJDAAAAAJIgACoCACIEIASUkyEEAkACQCABQQhqKgIAIgcgB5QgAUEMaioCACIIIAiUkkMAAAAAkiIJQwAAAABcBEAgByADlCAIIAaUkiEDQQAhASAEQwAAAABeRQ0BIANDAAAAAF5FDQEMAgtBASEBIARDAAAAAF5FDQFBACEBDAELIAMgA5QgCSAElJMiBEMAAAAAXQ0AQwAAAAAgA4wgBBB2kyAJlSIDIANDAAAAAF8bIQVBASEBCyABIAIgBWBxC+EBAgV9An4gACABKQIAIginviIDQwAAAD+UIAFBCGopAgAiCae+IgRDAAAAP5SSIgYgBJMiBCAElCAIQiCIp74iB0MAAAA/lCAJQiCIp74iBUMAAAA/lJIiBCAFkyIFIAWUkkMAAAAAkiIFIAYgA5MiAyADlCAEIAeTIgMgA5SSQwAAAACSIgNDAAAAACADQwAAAABeGyIDIAMgBV0bEHY4AgggACACQQxqKgIAIAJBBGoqAgAiAyAGlCACKgIAIgcgBJSSkjgCBCAAIAJBCGoqAgAgByAGlCADIASUk5I4AgALlQIBAn8jAEEgayIBJAAgAC0AACECIABBAToAACABIAJBAXEiAjoABwJAIAJFBEBBACECQdTDwwAoAgBB/////wdxBEBBxMfDACgCAEVFIQILIAAtAAENASAAQTRqLQAARQRAIABBAToANCAAQQRqENACIABBHGoQ0AILAkAgAg0AQdTDwwAoAgBB/////wdxRQ0AQcTHwwAoAgBFDQAgAEEBOgABCyAAQQA6AAAgAUEgaiQADwsgAUEANgIcIAFBuIDAADYCGCABQQE2AhQgAUGoj8AANgIQIAFBADYCCCABQQdqIAFBCGoQ2wcACyABIAI6AAwgASAANgIIQfiDwABBKyABQQhqQcSEwABBwIXAABDbBgAL5QECAX8EfSMAQTBrIgYkACAGIAIqAgAiCCADQQRqKgIAIAJBDGoqAgCTIgeUIAMqAgAgAkEIaioCAJMiCSACQQRqKgIAIgqUkzgCDCAGIAkgCJQgByAKlJI4AgggBkEQaiABIAZBCGogBBBpIAYoAhghAQJAIAYqAgggBioCECIIkyIHIAeUIAYqAgwgBioCFCIHkyIJIAmUkkMAAAAAkhB2IAVeRSABQf8BcUECR3FFBEAgAEECOgAIDAELIAYgATYCGCAGIAc4AhQgBiAIOAIQIAAgBkEQaiACEJUICyAGQTBqJAALiAICA38BfiMAQRBrIgIkAAJAIAAEQCAAKAIAIgNBf0cNARCnCwALEKYLAAsgACADQQFqNgIAIAJBCGoiAyABvSIFQiCIPgIEIAMgBT4CACACIABBBGogAigCCCACKAIMENAFAkACQCACKAIAIgMEQCACKAIEIgQgA0GgAWooAgBPDQEgA0GcAWooAgAgBEGEAmxqQdgAaikCACEFIAAgACgCAEEBazYCAEEMQQQQ0AoiAEUNAiAAIAU3AgQgAEEANgIAIAJBEGokACAADwtByLPAAEHJAEHQtMAAEJoLAAtB0IXAAEErQcC0wAAQyQgAC0EMQQRBwMPDACgCACIAQaQGIAAbEQAAAAuIAgIDfwF+IwBBEGsiAiQAAkAgAARAIAAoAgAiA0F/Rw0BEKcLAAsQpgsACyAAIANBAWo2AgAgAkEIaiIDIAG9IgVCIIg+AgQgAyAFPgIAIAIgAEEEaiACKAIIIAIoAgwQ0AUCQAJAIAIoAgAiAwRAIAIoAgQiBCADQaABaigCAE8NASADQZwBaigCACAEQYQCbGpB6ABqKQIAIQUgACAAKAIAQQFrNgIAQQxBBBDQCiIARQ0CIAAgBTcCBCAAQQA2AgAgAkEQaiQAIAAPC0HIs8AAQckAQdC0wAAQmgsAC0HQhcAAQStBwLTAABDJCAALQQxBBEHAw8MAKAIAIgBBpAYgABsRAAAAC64BAQJ/IABByABqKAIAIgEEQCAAQcQAaigCACECIAFBlAJsIQEDQCACQYwCai0AAEECRwRAIAIQvwELIAJBlAJqIQIgAUGUAmsiAQ0ACwsgACgCQARAIABBxABqKAIAEIcBCyAAKAIYBEAgAEEcaigCABCHAQsgACgCAARAIABBBGooAgAQhwELIAAoAgwEQCAAQRBqKAIAEIcBCyAAKAIkBEAgAEEoaigCABCHAQsLigICBX8BfiMAQSBrIgQkAAJAAkACQCAARQ0AIAAoAgAiA0F/Rg0CIAAgA0EBajYCACACRQ0AIAIoAgAiA0F/Rg0CIAIgA0EBajYCACAEQRBqIgMgAb0iCEIgiD4CBCADIAg+AgAgAEEEaiAEKAIQIAQoAhQQpAgiA0UNASAEIAIpAgQ3AxggBEEIaiIFIANBIGoiBigCBCIHNgIEIAUgBigCACAHKAIIQQdqQXhxajYCACAEKAIIIAMgBEEYaiAEKAIMKAJIEQUAIQMgAiACKAIAQQFrNgIAIAAgACgCAEEBazYCACAEQSBqJAAgAw8LEKYLAAtBmLbAAEHMAEGMt8AAEJoLAAsQpwsAC8cBAQp9IAEqAgQiBSACKgIAIgOUIAEqAgAiCSACQQRqKgIAIgeUkiACQQxqKgIAIgSSIQYgBCAHIAEqAggiCpQgAyABQQxqKgIAIguUkpIhBCAAIAEqAhAiCCACQQhqKgIAIgwgCSADlCAFIAeUk5IiBSAMIAMgCpQgByALlJOSIgMgAyAFXxuSvK0gCCAGIAQgBCAGXxuSvK1CIIaENwIIIAAgBSADIAMgBWAbIAiTvK0gBiAEIAQgBmAbIAiTvK1CIIaENwIAC/ABAgN/AX4jAEEwayIGJAACQAJAAkAgAEUNACAAKAIADQIgAEF/NgIAIANFDQAgAygCACIHQX9GDQIgAyAHQQFqNgIAIAYgAb0iCUIgiD4CBCAGIAk+AgAgAEEEaiAGKAIAIAYoAgQQ8gUiB0UNASAGIAMpAgQ3AxggBkEIaiAGQRhqIgggAiAEEKkJIAZBJGogBkEQaikDADcCACAGIAYpAwg3AhwgBkEANgIYIAcgCCAFQQBHEPECIAMgAygCAEEBazYCACAAQQA2AgAgBkEwaiQADwsQpgsAC0GAtcAAQc0AQYi2wAAQmgsACxCnCwALtgMCBH8BfiMAQTBrIgckAAJAAkACQCAARQ0AIAAoAgANAiAAQX82AgAgA0UNACADKAIAIgVBf0YNAiADIAVBAWo2AgAgB0EIaiIFIAG9IglCIIg+AgQgBSAJPgIAIABBBGogBygCCCAHKAIMEPMFIgVFDQEgByADKQIENwMgIAdBEGoiBiAHQSBqIgggAiAEEKkJIAhBCGogBkEIaikDADcDACAHIAcpAxA3AyACQAJAAkBBEEEEENAKIgYEQCAGIAgpAgA3AgAgBkEIaiAIQQhqKQIANwIAIAUoAihBAkcNAQJAAkAgBioCACAFQSxqKAIAIggqAgBcDQAgBkEEaioCACAIQQRqKgIAXA0AIAYqAgggCCoCCFwNACAGKgIMIAgqAgxbDQELIAUgBSgCMEECcjYCMCAIEIcBDAMLIAYQhwEMAwtBEEEEQcDDwwAoAgAiAEGkBiAAGxEAAAALIAUgBSgCMEECcjYCMAsgBUECNgIoIAVBLGogBjYCAAsgAyADKAIAQQFrNgIAIABBADYCACAHQTBqJAAPCxCmCwALQZi2wABBzABBnLfAABCaCwALEKcLAAuDAgECfyMAQdAAayICJAAgAiABNwMAAkAgAAJ/IAFCgICAgBBaBEAgAkE0akEBNgIAIAJByLzAADYCMCACQZcBNgIsIAIgAjYCKCACQQI2AkwgAkEDNgJEIAJBsLzAADYCQCACQQA2AjggAiACQShqNgJIIAJBGGoiAyACQThqEIoCIAJBFGogA0EIaigCADYAACACIAIpAxg3AAxBEEEEENAKIgNFDQIgA0EIOgAAIAMgAikACTcAASADQQhqIAJBEGopAAA3AAAgACADNgIEQQEMAQsgACABPgIEQQALNgIAIAJB0ABqJAAPC0EQQQRBwMPDACgCACIAQaQGIAAbEQAAAAvoAQEDfSMAQRBrIgEkAAJAAkACQAJAAkAgAg4CAgEACyAAQQA2AgAMAgsgAUIANwMIQwAAgD8hBSADQQJPBEBDAACAvyEFIANBAmsiA0ECTw0DCyABQQhqIANBAnRqIAU4AgAgAEEBNgIAIAAgASkDCDcCBAwBCyADQQRPBEAgAEEANgIADAELIANBAnQiAkHc6MIAaioCACIFIAWUIAJB7OjCAGoqAgAiBiAGlJJDAAAAAJIQdiEHIABBATYCACAAIAYgB5W8rSAFIAeVvK1CIIaENwIECyABQRBqJAAPC0GUrcIAEJMKAAvxAQMDfwF+AX0jAEEQayIDJAACQCAABEAgACgCACIEQX9HDQEQpwsACxCmCwALIAAgBEEBajYCAAJAAkAgAkEDSQRAIANBCGoiBCABvSIGQiCIPgIEIAQgBj4CACADIABBBGogAygCCCADKAIMENAFIAMoAgAiBEUNASADKAIEIgUgBEGgAWooAgBPDQIgBEGcAWooAgAgBUGEAmxqIAJBDGxqQfAAaioCACEHIAAgACgCAEEBazYCACADQRBqJAAgBw8LQcK3wABBGRClCwALQcizwABByQBB0LTAABCaCwALQdCFwABBK0HAtMAAEMkIAAvxAQMDfwF+AX0jAEEQayIDJAACQCAABEAgACgCACIEQX9HDQEQpwsACxCmCwALIAAgBEEBajYCAAJAAkAgAkEDSQRAIANBCGoiBCABvSIGQiCIPgIEIAQgBj4CACADIABBBGogAygCCCADKAIMENAFIAMoAgAiBEUNASADKAIEIgUgBEGgAWooAgBPDQIgBEGcAWooAgAgBUGEAmxqIAJBDGxqQfQAaioCACEHIAAgACgCAEEBazYCACADQRBqJAAgBw8LQcK3wABBGRClCwALQcizwABByQBB0LTAABCaCwALQdCFwABBK0HAtMAAEMkIAAvdAQIBfwZ9IwBBMGsiBSQAIAUgAioCACIIIANBBGoqAgAgAkEMaioCACIKkyIGlCADKgIAIAJBCGoqAgAiC5MiByACQQRqKgIAIgmUkzgCBCAFIAcgCJQgBiAJlJI4AgAgASoCACEGIAEqAgQhByAFIAEpAgA3AxAgBSAHjDgCDCAFIAaMOAIIIAVBGGogBUEIaiAFIAQQlgIgBSoCGCEGIAUqAhwhByAAIAUtACA6AAggACAKIAkgBpQgCCAHlJKSOAIEIAAgCyAIIAaUIAkgB5STkjgCACAFQTBqJAAL7gEBBH8jAEEgayIFJAACQAJAAkAgASAAQdQAaigCACIESQRAIABB0ABqKAIAIAFBDGxqIgQoAgAiBiAAQcgAaigCACIBTw0BIAEgBCgCBCIHTQ0CIAQoAggiBCABTw0DIAUgAEHEAGooAgAiACAGQQN0aikCADcDCCAFIAAgBEEDdGopAgA3AxggBSAAIAdBA3RqKQIANwMQIAJBACAFQQhqQZy3wgAgAygCEBEBACAFQSBqJAAPCyABIARBhNLCABCjBwALIAYgAUGU0sIAEKMHAAsgByABQaTSwgAQowcACyAEIAFBtNLCABCjBwAL1gECAX8GfSMAQTBrIgYkACAGIAIqAgAiCCADQQRqKgIAIAJBDGoqAgAiCpMiB5QgAyoCACACQQhqKgIAIguTIgwgAkEEaioCACIJlJM4AgQgBiAMIAiUIAcgCZSSOAIAIAZBCGogASAGIAQgBRA6AkACQCAGKAIYQQRHBEAgBi0AECIBQQJHDQELIABBAjoACAwBCyAGKgIMIQUgBioCCCEHIAAgAToACCAAIAogCSAHlCAIIAWUkpI4AgQgACALIAggB5QgCSAFlJOSOAIACyAGQTBqJAALxAICCH0CfyMAQSBrIgokACABKgIYIglDAAAAAGBFBEAgCkEIaiIAQQxqQQE2AgAgAEEUakEANgIAIApB4PrBADYCECAKQeTwwQA2AhggCkEANgIIIABB6PrBABC8CQALIAEqAhAhBCABKgIIIQYgASoCACECIABBDGogAUEUaioCACIHIAcgAUEMaioCACIIIAggASoCBCIDIAMgCF0iARsgAyADXBsiBSAFIAddGyAFIAVcGyAJkjgCACAAIAQgBCAGIAYgAiACIAZdIgsbIAIgAlwbIgUgBCAFXhsgBSAFXBsgCZI4AgggACACIAIgBiALGyAGIAZcGyICIAIgBCACIARdGyAEIARcGyAJk7ytIAMgAyAIIAEbIAggCFwbIgMgAyAHIAMgB10bIAcgB1wbIAmTvK1CIIaENwIAIApBIGokAAv5AQICfwF+IwBBEGsiAiQAAkAgAARAIAAoAgAiA0F/Rw0BEKcLAAsQpgsACyAAIANBAWo2AgAgAkEIaiIDIAG9IgRCIIg+AgQgAyAEPgIAAkAgAEEEaiACKAIIIAIoAgwQpAgiAwRAIAIgAxCxCQJAIAIoAgAgAigCBBDyCCIDRQRAIAAgACgCAEEBazYCAEEAIQAMAQsgAykCACEEIAAgACgCAEEBazYCAEEMQQQQ0AoiAEUNAiAAIAQ3AgQgAEEANgIACyACQRBqJAAgAA8LQZi2wABBzABBjLfAABCaCwALQQxBBEHAw8MAKAIAIgBBpAYgABsRAAAAC8wBAQZ9IAFBBGoqAgAiCiACKgIAIgYgA0EEaioCACACQQxqKgIAkyIHlCADKgIAIAJBCGoqAgCTIgggAkEEaioCACIJlJOMlCABKgIAIgsgCCAGlCAHIAmUkpSTIQcCfwJAIAVFDQAgB0MAAAAAXkUNAEMAAAAAIQZBAQwBCyAHIAsgCSADQQxqKgIAIgeUIAYgA0EIaioCACIIlJKUIAogBiAHlCAJIAiUk5SSlSIGQwAAAABgIAQgBmBxCyECIAAgBjgCBCAAIAI2AgAL1AECAX4DfSABQQRqKgIAIgYgAikCACIFQiCIp0GAgICAeHO+lCABKgIAIgggBae+lJMhBwJAIARFRSAHQwAAAABecUUEQCAHIAggAkEIaioCAJQgBiACQQxqKgIAlJKVIgZDAAAAAGAgAyAGYHENASAAQQM2AggPCyAAQQA2AhAgAEIBNwIIIABCADcCAA8LIAEpAgAhBSAAIAY4AhAgAEIBNwIIIAAgB0MAAAAAXgR+IAWnQYCAgIB4c60gBUIgiKdBgICAgHhzrUIghoQFIAULNwIAC+oBAQN/IwBBIGsiAyQAAkACQCABIAEgAmoiAUsNACAAKAIAIgJBAXQiBCABIAEgBEkbIgFBBCABQQRLGyIBQQJ0IQQgAUGAgICAAklBAnQhBQJAIAIEQCADIAJBAnQ2AhQgA0EENgIYIAMgAEEEaigCADYCEAwBCyADQQA2AhgLIAMgBCAFIANBEGoQzwUgAygCBCECIAMoAgBFBEAgACABNgIAIAAgAjYCBAwCCyADQQhqKAIAIgBBgYCAgHhGDQEgAEUNACACIABBwMPDACgCACIAQaQGIAAbEQAAAAsQigkACyADQSBqJAAL6wEBA38jAEEgayIDJAACQAJAIAEgASACaiIBSw0AIAAoAgAiAkEBdCIEIAEgASAESRsiAUEEIAFBBEsbIgFBkAFsIQQgAUG5nI4HSUEDdCEFAkAgAgRAIANBCDYCGCADIAJBkAFsNgIUIAMgAEEEaigCADYCEAwBCyADQQA2AhgLIAMgBCAFIANBEGoQzwUgAygCBCECIAMoAgBFBEAgACABNgIAIAAgAjYCBAwCCyADQQhqKAIAIgBBgYCAgHhGDQEgAEUNACACIABBwMPDACgCACIAQaQGIAAbEQAAAAsQigkACyADQSBqJAAL6gEBA38jAEEgayIDJAACQAJAIAEgASACaiIBSw0AIAAoAgAiAkEBdCIEIAEgASAESRsiAUEEIAFBBEsbIgFBA3QhBCABQYCAgIABSUECdCEFAkAgAgRAIAMgAkEDdDYCFCADQQQ2AhggAyAAQQRqKAIANgIQDAELIANBADYCGAsgAyAEIAUgA0EQahDPBSADKAIEIQIgAygCAEUEQCAAIAE2AgAgACACNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAIgAEHAw8MAKAIAIgBBpAYgABsRAAAACxCKCQALIANBIGokAAvqAQEDfyMAQSBrIgMkAAJAAkAgASABIAJqIgFLDQAgACgCACICQQF0IgQgASABIARJGyIBQQQgAUEESxsiAUEMbCEEIAFBq9Wq1QBJQQJ0IQUCQCACBEAgAyACQQxsNgIUIANBBDYCGCADIABBBGooAgA2AhAMAQsgA0EANgIYCyADIAQgBSADQRBqEM8FIAMoAgQhAiADKAIARQRAIAAgATYCACAAIAI2AgQMAgsgA0EIaigCACIAQYGAgIB4Rg0BIABFDQAgAiAAQcDDwwAoAgAiAEGkBiAAGxEAAAALEIoJAAsgA0EgaiQAC+kBAQN/IwBBIGsiAyQAAkACQCABIAEgAmoiAUsNACAAKAIAIgJBAXQiBCABIAEgBEkbIgFBBCABQQRLGyIBQRRsIQQgAUHnzJkzSUECdCEFAkAgAgRAIAMgAkEUbDYCFCADQQQ2AhggAyAAQQRqKAIANgIQDAELIANBADYCGAsgAyAEIAUgA0EQahDPBSADKAIEIQIgAygCAEUEQCAAIAE2AgAgACACNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAIgAEHAw8MAKAIAIgBBpAYgABsRAAAACxCKCQALIANBIGokAAvrAQEDfyMAQSBrIgMkAAJAAkAgASABIAJqIgFLDQAgACgCACICQQF0IgQgASABIARJGyIBQQQgAUEESxsiAUHoAWwhBCABQcz7tARJQQN0IQUCQCACBEAgA0EINgIYIAMgAkHoAWw2AhQgAyAAQQRqKAIANgIQDAELIANBADYCGAsgAyAEIAUgA0EQahDPBSADKAIEIQIgAygCAEUEQCAAIAE2AgAgACACNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAIgAEHAw8MAKAIAIgBBpAYgABsRAAAACxCKCQALIANBIGokAAvrAQEDfyMAQSBrIgMkAAJAAkAgASABIAJqIgFLDQAgACgCACICQQF0IgQgASABIARJGyIBQQQgAUEESxsiAUGUAmwhBCABQYLz2gNJQQJ0IQUCQCACBEAgAyACQZQCbDYCFCADQQQ2AhggAyAAQQRqKAIANgIQDAELIANBADYCGAsgAyAEIAUgA0EQahDPBSADKAIEIQIgAygCAEUEQCAAIAE2AgAgACACNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAIgAEHAw8MAKAIAIgBBpAYgABsRAAAACxCKCQALIANBIGokAAvqAQEDfyMAQSBrIgMkAAJAAkAgASABIAJqIgFLDQAgACgCACICQQF0IgQgASABIARJGyIBQQQgAUEESxsiAUEEdCEEIAFBgICAwABJQQJ0IQUCQCACBEAgA0EENgIYIAMgAkEEdDYCFCADIABBBGooAgA2AhAMAQsgA0EANgIYCyADIAQgBSADQRBqEM8FIAMoAgQhAiADKAIARQRAIAAgATYCACAAIAI2AgQMAgsgA0EIaigCACIAQYGAgIB4Rg0BIABFDQAgAiAAQcDDwwAoAgAiAEGkBiAAGxEAAAALEIoJAAsgA0EgaiQAC+sBAQR/IwBBIGsiAiQAAkACQCABIAFBAWoiAUsNACAAKAIAIgNBAXQiBCABIAEgBEkbIgFBBCABQQRLGyIBQZwBbCEEIAFBoZrIBklBAnQhBQJAIAMEQCACIANBnAFsNgIUIAJBBDYCGCACIABBBGooAgA2AhAMAQsgAkEANgIYCyACIAQgBSACQRBqEM8FIAIoAgQhAyACKAIARQRAIAAgATYCACAAIAM2AgQMAgsgAkEIaigCACIAQYGAgIB4Rg0BIABFDQAgAyAAQcDDwwAoAgAiAEGkBiAAGxEAAAALEIoJAAsgAkEgaiQAC8oBAwV9AX8BfiACKgIAIgMgA5QgAioCBCIEIASUkkMAAAAAkhB2IQUgAyAFlSIDIAFBEGoiAioCAJQgBCAFlSIEIAFBFGoqAgCUkiEFAkAgAyABKgIAlCAEIAFBBGoqAgCUkiIGIAMgAUEIaiIIKgIAlCAEIAFBDGoqAgCUkiIHXkUEQCAFIAddRQ0BIAghAgwBCyABIAIgBSAGXRshAgsgACADIAEqAhgiA5QgAikCACIJp76SOAIAIAAgBCADlCAJQiCIp76SOAIEC+gBAQR/IwBBIGsiAiQAAkACQCABQQFqIgFFDQAgACgCACIDQQF0IgQgASABIARJGyIBQQQgAUEESxsiAUEMbCEEIAFBq9Wq1QBJQQJ0IQUCQCADBEAgAiADQQxsNgIUIAJBBDYCGCACIABBBGooAgA2AhAMAQsgAkEANgIYCyACIAQgBSACQRBqEM8FIAIoAgQhAyACKAIARQRAIAAgATYCACAAIAM2AgQMAgsgAkEIaigCACIAQYGAgIB4Rg0BIABFDQAgAyAAQcDDwwAoAgAiAEGkBiAAGxEAAAALEIoJAAsgAkEgaiQAC+gBAQR/IwBBIGsiAiQAAkACQCABQQFqIgFFDQAgACgCACIDQQF0IgQgASABIARJGyIBQQQgAUEESxsiAUECdCEEIAFBgICAgAJJQQJ0IQUCQCADBEAgAiADQQJ0NgIUIAJBBDYCGCACIABBBGooAgA2AhAMAQsgAkEANgIYCyACIAQgBSACQRBqEM8FIAIoAgQhAyACKAIARQRAIAAgATYCACAAIAM2AgQMAgsgAkEIaigCACIAQYGAgIB4Rg0BIABFDQAgAyAAQcDDwwAoAgAiAEGkBiAAGxEAAAALEIoJAAsgAkEgaiQAC+gBAQR/IwBBIGsiAiQAAkACQCABQQFqIgFFDQAgACgCACIDQQF0IgQgASABIARJGyIBQQQgAUEESxsiAUEEdCEEIAFBgICAwABJQQJ0IQUCQCADBEAgAkEENgIYIAIgA0EEdDYCFCACIABBBGooAgA2AhAMAQsgAkEANgIYCyACIAQgBSACQRBqEM8FIAIoAgQhAyACKAIARQRAIAAgATYCACAAIAM2AgQMAgsgAkEIaigCACIAQYGAgIB4Rg0BIABFDQAgAyAAQcDDwwAoAgAiAEGkBiAAGxEAAAALEIoJAAsgAkEgaiQAC+gBAQR/IwBBIGsiAiQAAkACQCABQQFqIgFFDQAgACgCACIDQQF0IgQgASABIARJGyIBQQQgAUEESxsiAUEDdCEEIAFBgICAgAFJQQJ0IQUCQCADBEAgAiADQQN0NgIUIAJBBDYCGCACIABBBGooAgA2AhAMAQsgAkEANgIYCyACIAQgBSACQRBqEM8FIAIoAgQhAyACKAIARQRAIAAgATYCACAAIAM2AgQMAgsgAkEIaigCACIAQYGAgIB4Rg0BIABFDQAgAyAAQcDDwwAoAgAiAEGkBiAAGxEAAAALEIoJAAsgAkEgaiQAC+cBAQR/IwBBIGsiAiQAAkACQCABQQFqIgFFDQAgACgCACIDQQF0IgQgASABIARJGyIBQQQgAUEESxsiAUEYbCEEIAFB1qrVKklBAnQhBQJAIAMEQCACIANBGGw2AhQgAkEENgIYIAIgAEEEaigCADYCEAwBCyACQQA2AhgLIAIgBCAFIAJBEGoQzwUgAigCBCEDIAIoAgBFBEAgACABNgIAIAAgAzYCBAwCCyACQQhqKAIAIgBBgYCAgHhGDQEgAEUNACADIABBwMPDACgCACIAQaQGIAAbEQAAAAsQigkACyACQSBqJAAL5wEBBH8jAEEgayICJAACQAJAIAFBAWoiAUUNACAAKAIAIgNBAXQiBCABIAEgBEkbIgFBBCABQQRLGyIBQQV0IQQgAUGAgIAgSUECdCEFAkAgAwRAIAIgA0EFdDYCFCACQQQ2AhggAiAAQQRqKAIANgIQDAELIAJBADYCGAsgAiAEIAUgAkEQahDPBSACKAIEIQMgAigCAEUEQCAAIAE2AgAgACADNgIEDAILIAJBCGooAgAiAEGBgICAeEYNASAARQ0AIAMgAEHAw8MAKAIAIgBBpAYgABsRAAAACxCKCQALIAJBIGokAAvpAQEEfyMAQSBrIgIkAAJAAkAgAUEBaiIBRQ0AIAAoAgAiA0EBdCIEIAEgASAESRsiAUEEIAFBBEsbIgFBxAFsIQQgAUGG3pwFSUECdCEFAkAgAwRAIAIgA0HEAWw2AhQgAkEENgIYIAIgAEEEaigCADYCEAwBCyACQQA2AhgLIAIgBCAFIAJBEGoQzwUgAigCBCEDIAIoAgBFBEAgACABNgIAIAAgAzYCBAwCCyACQQhqKAIAIgBBgYCAgHhGDQEgAEUNACADIABBwMPDACgCACIAQaQGIAAbEQAAAAsQigkACyACQSBqJAAL5wEBBH8jAEEgayICJAACQAJAIAFBAWoiAUUNACAAKAIAIgNBAXQiBCABIAEgBEkbIgFBBCABQQRLGyIBQRRsIQQgAUHnzJkzSUECdCEFAkAgAwRAIAIgA0EUbDYCFCACQQQ2AhggAiAAQQRqKAIANgIQDAELIAJBADYCGAsgAiAEIAUgAkEQahDPBSACKAIEIQMgAigCAEUEQCAAIAE2AgAgACADNgIEDAILIAJBCGooAgAiAEGBgICAeEYNASAARQ0AIAMgAEHAw8MAKAIAIgBBpAYgABsRAAAACxCKCQALIAJBIGokAAvpAQEEfyMAQSBrIgIkAAJAAkAgAUEBaiIBRQ0AIAAoAgAiA0EBdCIEIAEgASAESRsiAUEEIAFBBEsbIgFBhAJsIQQgAUHhj/gDSUECdCEFAkAgAwRAIAIgA0GEAmw2AhQgAkEENgIYIAIgAEEEaigCADYCEAwBCyACQQA2AhgLIAIgBCAFIAJBEGoQzwUgAigCBCEDIAIoAgBFBEAgACABNgIAIAAgAzYCBAwCCyACQQhqKAIAIgBBgYCAgHhGDQEgAEUNACADIABBwMPDACgCACIAQaQGIAAbEQAAAAsQigkACyACQSBqJAAL6QEBBH8jAEEgayICJAACQAJAIAFBAWoiAUUNACAAKAIAIgNBAXQiBCABIAEgBEkbIgFBBCABQQRLGyIBQeAAbCEEIAFB1qrVCklBBHQhBQJAIAMEQCACQRA2AhggAiADQeAAbDYCFCACIABBBGooAgA2AhAMAQsgAkEANgIYCyACIAQgBSACQRBqEM8FIAIoAgQhAyACKAIARQRAIAAgATYCACAAIAM2AgQMAgsgAkEIaigCACIAQYGAgIB4Rg0BIABFDQAgAyAAQcDDwwAoAgAiAEGkBiAAGxEAAAALEIoJAAsgAkEgaiQAC+cBAQR/IwBBIGsiAiQAAkACQCABQQFqIgFFDQAgACgCACIDQQF0IgQgASABIARJGyIBQQQgAUEESxsiAUE4bCEEIAFBk8mkEklBAnQhBQJAIAMEQCACIANBOGw2AhQgAkEENgIYIAIgAEEEaigCADYCEAwBCyACQQA2AhgLIAIgBCAFIAJBEGoQzwUgAigCBCEDIAIoAgBFBEAgACABNgIAIAAgAzYCBAwCCyACQQhqKAIAIgBBgYCAgHhGDQEgAEUNACADIABBwMPDACgCACIAQaQGIAAbEQAAAAsQigkACyACQSBqJAAL5wEBBH8jAEEgayICJAACQAJAIAFBAWoiAUUNACAAKAIAIgNBAXQiBCABIAEgBEkbIgFBBCABQQRLGyIBQQZ0IQQgAUGAgIAQSUECdCEFAkAgAwRAIAIgA0EGdDYCFCACQQQ2AhggAiAAQQRqKAIANgIQDAELIAJBADYCGAsgAiAEIAUgAkEQahDPBSACKAIEIQMgAigCAEUEQCAAIAE2AgAgACADNgIEDAILIAJBCGooAgAiAEGBgICAeEYNASAARQ0AIAMgAEHAw8MAKAIAIgBBpAYgABsRAAAACxCKCQALIAJBIGokAAvpAQEEfyMAQSBrIgIkAAJAAkAgAUEBaiIBRQ0AIAAoAgAiA0EBdCIEIAEgASAESRsiAUEEIAFBBEsbIgFB1AFsIQQgAUHooeoESUECdCEFAkAgAwRAIAIgA0HUAWw2AhQgAkEENgIYIAIgAEEEaigCADYCEAwBCyACQQA2AhgLIAIgBCAFIAJBEGoQzwUgAigCBCEDIAIoAgBFBEAgACABNgIAIAAgAzYCBAwCCyACQQhqKAIAIgBBgYCAgHhGDQEgAEUNACADIABBwMPDACgCACIAQaQGIAAbEQAAAAsQigkACyACQSBqJAAL5wEBBH8jAEEgayICJAACQAJAIAFBAWoiAUUNACAAKAIAIgNBAXQiBCABIAEgBEkbIgFBBCABQQRLGyIBQSRsIQQgAUHk8bgcSUECdCEFAkAgAwRAIAIgA0EkbDYCFCACQQQ2AhggAiAAQQRqKAIANgIQDAELIAJBADYCGAsgAiAEIAUgAkEQahDPBSACKAIEIQMgAigCAEUEQCAAIAE2AgAgACADNgIEDAILIAJBCGooAgAiAEGBgICAeEYNASAARQ0AIAMgAEHAw8MAKAIAIgBBpAYgABsRAAAACxCKCQALIAJBIGokAAvnAQEEfyMAQSBrIgIkAAJAAkAgAUEBaiIBRQ0AIAAoAgAiA0EBdCIEIAEgASAESRsiAUEEIAFBBEsbIgFBNGwhBCABQePO2BNJQQJ0IQUCQCADBEAgAiADQTRsNgIUIAJBBDYCGCACIABBBGooAgA2AhAMAQsgAkEANgIYCyACIAQgBSACQRBqEM8FIAIoAgQhAyACKAIARQRAIAAgATYCACAAIAM2AgQMAgsgAkEIaigCACIAQYGAgIB4Rg0BIABFDQAgAyAAQcDDwwAoAgAiAEGkBiAAGxEAAAALEIoJAAsgAkEgaiQAC+kBAQR/IwBBIGsiAiQAAkACQCABQQFqIgFFDQAgACgCACIDQQF0IgQgASABIARJGyIBQQQgAUEESxsiAUHYAGwhBCABQZi60QtJQQJ0IQUCQCADBEAgAiADQdgAbDYCFCACQQQ2AhggAiAAQQRqKAIANgIQDAELIAJBADYCGAsgAiAEIAUgAkEQahDPBSACKAIEIQMgAigCAEUEQCAAIAE2AgAgACADNgIEDAILIAJBCGooAgAiAEGBgICAeEYNASAARQ0AIAMgAEHAw8MAKAIAIgBBpAYgABsRAAAACxCKCQALIAJBIGokAAvpAQEEfyMAQSBrIgIkAAJAAkAgAUEBaiIBRQ0AIAAoAgAiA0EBdCIEIAEgASAESRsiAUEEIAFBBEsbIgFBnAFsIQQgAUGhmsgGSUECdCEFAkAgAwRAIAIgA0GcAWw2AhQgAkEENgIYIAIgAEEEaigCADYCEAwBCyACQQA2AhgLIAIgBCAFIAJBEGoQzwUgAigCBCEDIAIoAgBFBEAgACABNgIAIAAgAzYCBAwCCyACQQhqKAIAIgBBgYCAgHhGDQEgAEUNACADIABBwMPDACgCACIAQaQGIAAbEQAAAAsQigkACyACQSBqJAAL4AEBAn8CQAJAAkAgAiAAKAKAASIDSwRAIAAtAIYBIgRFDQIgAC0AhAEiAiABIANBAnRqKAIAIgNBkAFqKAIAIgFJBEAgA0HIAGoiAyACQSRsaiICIABBKGoqAgA4AhAgAkEUaiAAQTxqKgIAOAIAIARBAUYNAyABIABBhQFqLQAAIgJLDQILIAIgAUGEzMEAEKMHAAsgAyACQeTLwQAQowcACyADIAJBJGxqIgEgAEHUAGoqAgA4AhAgAUEUaiAAQegAaioCADgCACAEQQJHDQELDwtBAkECQfTLwQAQowcAC9wBAQJ/AkACQAJAIAIgACgCZCIDSwRAIAAtAGoiBEUNAiAALQBoIgIgASADQQJ0aigCACIDQZABaigCACIBSQRAIANByABqIgMgAkEkbGoiAiAAQSxqKgIAOAIQIAJBFGogAEEYaioCADgCACAEQQFGDQMgASAAQekAai0AACICSw0CCyACIAFBqM7BABCjBwALIAMgAkGIzsEAEKMHAAsgAyACQSRsaiIBIABB0ABqKgIAOAIQIAFBFGogAEE8aioCADgCACAEQQJHDQELDwtBAkECQZjOwQAQowcAC+cBAQR/IwBBIGsiAiQAAkACQCABQQFqIgFFDQAgACgCACIDQQF0IgQgASABIARJGyIBQQQgAUEESxsiAUEobCEEIAFBtObMGUlBAnQhBQJAIAMEQCACIANBKGw2AhQgAkEENgIYIAIgAEEEaigCADYCEAwBCyACQQA2AhgLIAIgBCAFIAJBEGoQzwUgAigCBCEDIAIoAgBFBEAgACABNgIAIAAgAzYCBAwCCyACQQhqKAIAIgBBgYCAgHhGDQEgAEUNACADIABBwMPDACgCACIAQaQGIAAbEQAAAAsQigkACyACQSBqJAALlBgDDH8BfQF+IwBBEGsiCyQAAkAgAQRAIAEoAgAiBUF/Rw0BEKcLAAsQpgsACyABIAVBAWo2AgBBACEFIwBBgAFrIgQkACAEQdAAaiIDIAK9IhBCIIg+AgQgAyAQPgIAAkACQAJAAkACQAJAAkACQAJAIAFBBGogBCgCUCAEKAJUEKQIIgMEQCAEQcgAaiADELEJAkACQCAEKAJIIAQoAkwoApQBEQQAQf8BcUEDaw4LAQgHBgAAAAUABAMACyALQQA2AgQMCAsgBEEIaiADELEJIAQoAgghAyAEKAIMIQYjAEEQayIFJAAgBUEIaiADIAYoAmARAAAgBSgCCCIDIAUoAgxBDGooAgARBgAhECAFQRBqJAAgA0EAIBBC2dSd3cjuqJ0xURsiBUUEQCALQQA2AgQMCAsgBSkCACEQIAQgBUEIaikCADcDYCAEIBA3A1hBEEEEENAKIgoEQCAEQdgAaiIHQQhqIQYgCiAQPgIAIARBATYCeCAEIAo2AnQgBEEENgJwIAdBBHIhA0EEIQ1BASEIQQEhBUEBIQwDQAJAIAUEQCAFIQkMAQsgDEECRwRAIAxBA3QhBSAEQdgAaiIDIAxBAWoiDEEDdGohBkECIQkgAyAFaiIDIQcMAQsgCyAEKQNwNwIAIAtBCGogBEH4AGooAgA2AgAMCgsgAyAGRgRAIAdBCGoiAyEHIAZBCGohBgsgAyoCACEPIANBBGogAyAJQQFrIgUbIQMgBCgCcCAIRgRAIARB8ABqIAggCRCyBCAEKAJ0IQoLIAogDWogDzgCACAEIAhBAWoiCDYCeCANQQRqIQ0MAAsACwwIC0GYtsAAQcwAQYy3wAAQmgsACyAEQUBrIAMQsQkgBCgCQCAEKAJEEPwIIgNFBEAgC0EANgIEDAYLQQQhBQJAIANBCGooAgAiBkUEQEEAIQMMAQsgA0EEaigCACIHKgIAIQ9BEEEEENAKIgoEQCAHIAZBA3RqIQ4gCiAPOAIAIARBATYCYCAEIAo2AlwgBEEENgJYIAdBBGohA0EEIQ1BASEIQQEhBSAHQQhqIgkhBgNAAkAgBQRAIAUhDAwBCwJAIAZFDQAgBiAORg0AQQIhDCAGIgMhByADQQhqIgkhBgwBCyAEKAJcIQUgBCgCWCEDDAMLIAMgCUYEQCAHQQhqIgMhByAJQQhqIQkLIAMqAgAhDyADQQRqIAMgDEEBayIFGyEDIAQoAlggCEYEQCAEQdgAaiAIIAwQsgQgBCgCXCEKCyAKIA1qIA84AgAgBCAIQQFqIgg2AmAgDUEEaiENDAALAAsMBwsgCyAINgIIIAsgBTYCBCALIAM2AgAMBQsgBEE4aiADELEJIAQoAjggBCgCPBD7CCIFRQRAIAtBADYCBAwFCyAEIAUpAhA3A2ggBCAFKQIINwNgIAQgBSkCACIQNwNYQRBBBBDQCiIKBEAgBEHYAGoiB0EIaiEGIAogED4CACAEQQE2AnggBCAKNgJ0IARBBDYCcCAHQQRyIQNBBCENQQEhCEEBIQVBASEMA0ACQCAFBEAgBSEJDAELIAxBA0cEQCAMQQN0IQUgBEHYAGoiAyAMQQFqIgxBA3RqIQZBAiEJIAMgBWoiAyEHDAELIAsgBCkDcDcCACALQQhqIARB+ABqKAIANgIADAcLIAMgBkYEQCAHQQhqIgMhByAGQQhqIQYLIAMqAgAhDyADQQRqIAMgCUEBayIFGyEDIAQoAnAgCEYEQCAEQfAAaiAIIAkQsgQgBCgCdCEKCyAKIA1qIA84AgAgBCAIQQFqIgg2AnggDUEEaiENDAALAAsMBQsgBEEwaiADELEJIAQoAjAhAyAEKAI0IQYjAEEQayIFJAAgBUEIaiADIAYoAmARAAAgBSgCCCIDIAUoAgxBDGooAgARBgAhECAFQRBqJAAgA0EAIBBC4+e5wZebv62of1EbIgNFBEAgC0EANgIEDAQLQQQhBQJAIANBCGooAgAiBkUEQEEAIQMMAQsgA0EEaigCACIHKgIAIQ9BEEEEENAKIgoEQCAHIAZBA3RqIQ4gCiAPOAIAIARBATYCYCAEIAo2AlwgBEEENgJYIAdBBGohA0EEIQ1BASEIQQEhBSAHQQhqIgkhBgNAAkAgBQRAIAUhDAwBCwJAIAZFDQAgBiAORg0AQQIhDCAGIgMhByADQQhqIgkhBgwBCyAEKAJcIQUgBCgCWCEDDAMLIAMgCUYEQCAHQQhqIgMhByAJQQhqIQkLIAMqAgAhDyADQQRqIAMgDEEBayIFGyEDIAQoAlggCEYEQCAEQdgAaiAIIAwQsgQgBCgCXCEKCyAKIA1qIA84AgAgBCAIQQFqIgg2AmAgDUEEaiENDAALAAsMBQsgCyAINgIIIAsgBTYCBCALIAM2AgAMAwsgBEEoaiADELEJIAQoAiggBCgCLBD3CCIDRQRAIAtBADYCBAwDCyAEQSBqIANBxABqKQIANwMAAkAgBCgCJCIDRQRAQQQhAwwBCyAEKAIgIgcqAgAhD0EQQQQQ0AoiCgRAIAcgA0EDdGohDiAKIA84AgAgBEEBNgJgIAQgCjYCXCAEQQQ2AlggB0EEaiEDQQQhDUEBIQhBASEFIAdBCGoiCSEGA0ACQCAFBEAgBSEMDAELAkAgBkUNACAGIA5GDQBBAiEMIAYiAyEHIANBCGoiCSEGDAELIAQoAlwhAyAEKAJYIQUMAwsgAyAJRgRAIAdBCGoiAyEHIAlBCGohCQsgAyoCACEPIANBBGogAyAMQQFrIgUbIQMgBCgCWCAIRgRAIARB2ABqIAggDBCyBCAEKAJcIQoLIAogDWogDzgCACAEIAhBAWoiCDYCYCANQQRqIQ0MAAsACwwECyALIAg2AgggCyADNgIEIAsgBTYCAAwCCyAEQRhqIAMQsQkgBCgCGCAEKAIcEPYIIgVFBEAgC0EANgIEDAILAkAgBUHIAGooAgAiA0UEQEEEIQNBACEFDAELIAVBxABqKAIAIgcqAgAhD0EQQQQQ0AoiCgRAIAcgA0EDdGohDiAKIA84AgAgBEEBNgJgIAQgCjYCXCAEQQQ2AlggB0EEaiEDQQQhDUEBIQhBASEFIAdBCGoiCSEGA0ACQCAFBEAgBSEMDAELAkAgBkUNACAGIA5GDQBBAiEMIAYiAyEHIANBCGoiCSEGDAELIAQoAlwhAyAEKAJYIQUMAwsgAyAJRgRAIAdBCGoiAyEHIAlBCGohCQsgAyoCACEPIANBBGogAyAMQQFrIgUbIQMgBCgCWCAIRgRAIARB2ABqIAggDBCyBCAEKAJcIQoLIAogDWogDzgCACAEIAhBAWoiCDYCYCANQQRqIQ0MAAsACwwDCyALIAg2AgggCyADNgIEIAsgBTYCAAwBCyAEQRBqIAMQsQkgBCgCECAEKAIUEPUIIgVFBEAgC0EANgIEDAELIAQgBSkCEDcDaCAEIAUpAgg3A2AgBCAFKQIAIhA3A1hBEEEEENAKIgoEQCAEQdgAaiIHQQhqIQYgCiAQPgIAIARBATYCeCAEIAo2AnQgBEEENgJwIAdBBHIhA0EEIQ1BASEIQQEhBUEBIQwDQAJAIAUEQCAFIQkMAQsgDEEDRwRAIAxBA3QhBSAEQdgAaiIDIAxBAWoiDEEDdGohBkECIQkgAyAFaiIDIQcMAQsgCyAEKQNwNwIAIAtBCGogBEH4AGooAgA2AgAMAwsgAyAGRgRAIAdBCGoiAyEHIAZBCGohBgsgAyoCACEPIANBBGogAyAJQQFrIgUbIQMgBCgCcCAIRgRAIARB8ABqIAggCRCyBCAEKAJ0IQoLIAogDWogDzgCACAEIAhBAWoiCDYCeCANQQRqIQ0MAAsACwwBCyAEQYABaiQADAELQRBBBEHAw8MAKAIAIgBBpAYgABsRAAAACyALKAIIIQMgCygCBCEFIAsoAgAhBiABIAEoAgBBAWs2AgACQAJAIAVFBEBBACEDQQAhAQwBCyADIAZPBEAgBSEBDAELIAZBAnQhASADRQRAQQQhASAFEIcBDAELIAUgAUEEIANBAnQiBRC/CiIBRQ0BCyAAIAM2AgQgACABNgIAIAtBEGokAA8LIAVBBEHAw8MAKAIAIgBBpAYgABsRAAAAC5sIAgl/AX4jAEEQayIHJAACQCABBEAgASgCACIDQX9HDQEQpwsACxCmCwALIAEgA0EBajYCAEEAIQMjAEFAaiIEJAAgBEEoaiIFIAK9IgxCIIg+AgQgBSAMPgIAAkACQAJAAkAgAUEEaiAEKAIoIAQoAiwQpAgiBQRAIARBIGogBRCxCQJAAkAgBCgCICAEKAIkKAKUAREEAEH/AXFBBWsOAgEDAAsgB0EANgIEDAQLIARBCGogBRCxCSAEKAIIIAQoAgwQ9ggiBUUEQCAHQQA2AgQMBAsgBUHUAGooAgAiBkUEQEEEIQgMAwsgBUHQAGooAgAiAygCACEFQRBBBBDQCiIKBEAgAyAGQQxsaiELIAogBTYCACAEQQE2AjggBCAKNgI0IARBBDYCMCADQQRqIQZBBCEIQQEhCSADQQxqIQUDQAJAAkACQCAFIAZHBEAgBiEDDAELIAVFDQEgBSALRg0BIAUiA0EMaiEFCyADQQRqIQYgAygCACEDIAkgBCgCMEcNASAEQTBqIAkgBSAGa0ECdkEBahCyBCAEKAI0IQoMAQsgBCgCNCEIIAQoAjAhAwwFCyAIIApqIAM2AgAgBCAJQQFqIgk2AjggCEEEaiEIDAALAAsMBAtBmLbAAEHMAEGMt8AAEJoLAAsgBEEYaiAFELEJIAQoAhggBCgCHBD3CCIDRQRAIAdBADYCBAwCCyAEQRBqIANB0ABqKQIANwMAAkACQCAEKAIQIgMEQCAEKAIUIgUNAQtBBCEIQQAhAwwBCyADKAIAIQZBEEEEENAKIgoEQCADIAVBA3RqIQsgCiAGNgIAIARBATYCOCAEIAo2AjQgBEEENgIwIANBBGohBkEEIQhBASEJIANBCGohBQNAAkACQAJAIAUgBkcEQCAGIQMMAQsgBUUNASAFIAtGDQEgBSIDQQhqIQULIANBBGohBiADKAIAIQMgCSAEKAIwRw0BIARBMGogCSAFIAZrQQJ2QQFqELIEIAQoAjQhCgwBCyAEKAI0IQggBCgCMCEDDAMLIAggCmogAzYCACAEIAlBAWoiCTYCOCAIQQRqIQgMAAsACwwDCyAHIAk2AgggByAINgIEIAcgAzYCAAwBCyAHIAk2AgggByAINgIEIAcgAzYCAAsgBEFAayQAIAcoAgghBSAHKAIEIQMgBygCACEGIAEgASgCAEEBazYCAAJAAkAgA0UEQEEAIQVBACEBDAELIAUgBk8EQCADIQEMAQsgBkECdCEBIAVFBEBBBCEBIAMQhwEMAQsgAyABQQQgBUECdCIDEL8KIgFFDQELIAAgBTYCBCAAIAE2AgAgB0EQaiQADwsgA0EEQcDDwwAoAgAiAEGkBiAAGxEAAAALQRBBBEHAw8MAKAIAIgBBpAYgABsRAAAAC5kEAgd/AX4jAEEQayIGJAACQCABBEAgASgCACIDQX9HDQEQpwsACxCmCwALIAEgA0EBajYCACMAQSBrIgQkACAEQRhqIgMgAr0iCkIgiD4CBCADIAo+AgACQAJAAkAgAUEEaiAEKAIYIAQoAhwQpAgiAwRAIARBEGogAxCxCQJAIAQoAhAgBCgCFCgClAERBABB/wFxQQhGBEAgBEEIaiADELEJIAQoAgggBCgCDBD4CCIFRQRAIAZBADYCBAwCC0EEIQMgBUEEaigCACEJIAVBCGooAgAiBwRAIAdB/////wFLDQQgB0ECdCIIQQBIDQQgB0GAgICAAklBAnQhBSAIBH8gCCAFENAKBSAFCyIDRQ0FCyADIAkgCBCuCyEDIAYgBzYCCCAGIAM2AgQgBiAHNgIADAELIAZBADYCBAsgBEEgaiQADAMLQZi2wABBzABBjLfAABCaCwALEIoJAAsgCCAFQcDDwwAoAgAiAEGkBiAAGxEAAAALIAYoAgghBSAGKAIEIQMgBigCACEEIAEgASgCAEEBazYCAAJAAkAgA0UEQEEAIQVBACEBDAELIAQgBU0EQCADIQEMAQsgBEECdCEBIAVFBEBBBCEBIAMQhwEMAQsgAyABQQQgBUECdCIDEL8KIgFFDQELIAAgBTYCBCAAIAE2AgAgBkEQaiQADwsgA0EEQcDDwwAoAgAiAEGkBiAAGxEAAAALzgEDA30CfwF+AkAgAiAFKAIAIglLBEAgBSgCBCIKIAJPDQEgACABIApBGGxqIgIqAgAgASAJQRhsaiIBKgIAkyIHIAeUIAJBBGoqAgAgAUEEaioCAJMiBiAGlJJDAAAAAJIiCEMAAIAoXiIBBH4gBiAIEHYiBpW8rSAHjCAGlbytQiCGhAVCAAs3AgggACAEKQIANwIYIAAgAykCADcCECAAIAUpAgA3AgAgACABRToAIA8LIAkgAkGEl8IAEKMHAAsgCiACQZSXwgAQowcAC8YBAwR9AX4BfyACKQIAIgmnIgq+IQUCQAJAIAIqAgAiByAHlCACQQRqKgIAIgcgB5SSQwAAAACSIgggASoCACIGIAaUXyICRQ0AIANFDQAgBSEGQQEhAgwBCyAGIAgQdpUiCCAFlCIGvCIKrSAIIAlCIIinvpS8rUIghoQhCQsgBSAGkyIFIAWUIAcgCUIgiKciAb6TIgUgBZSSQwAAAACSEHYgBF5FBEAgACACOgAIIAAgATYCBCAAIAo2AgAPCyAAQQI6AAgLyAEDAX8EfQJ+IwBBIGsiAyQAIAMgASoCACIEIAJBBGoqAgAgAUEMaioCAJMiBZQgAioCACABQQhqKgIAkyIGIAFBBGoqAgAiB5STOAIEIAMgBiAElCAFIAeUkjgCACADQQhqIAApAgAgACkCCCADEKACQQEhASADKQMAIginviADKQMIIgmnvpMiBCAElCAIQiCIp74gCUIgiKe+kyIEIASUkkMAAAAAkiIEQwAAgCheBEAgBBB2IAAqAhBfIQELIANBIGokACABC9YBAgF/BH0jAEEwayIGJAAgBiACKgIAIgcgA0EEaioCACACQQxqKgIAkyIIlCADKgIAIAJBCGoqAgCTIgkgAkEEaioCACIKlJM4AhQgBiAJIAeUIAggCpSSOAIQIAYgByADQQxqKgIAIgiUIAogA0EIaioCACIJlJM4AhwgBiAHIAmUIAogCJSSOAIYIAYgBkEYaiICKQIANwIIIAYgBkEQaikCADcCACACIAEgBiAEIAUQ5QEgBigCICEBIAAgBioCKDgCBCAAIAFBA0c2AgAgBkEwaiQAC9YBAgF/BH0jAEEwayIGJAAgBiACKgIAIgcgA0EEaioCACACQQxqKgIAkyIIlCADKgIAIAJBCGoqAgCTIgkgAkEEaioCACIKlJM4AhQgBiAJIAeUIAggCpSSOAIQIAYgByADQQxqKgIAIgiUIAogA0EIaioCACIJlJM4AhwgBiAHIAmUIAogCJSSOAIYIAYgBkEYaiICKQIANwIIIAYgBkEQaikCADcCACACIAEgBiAEIAUQqAEgBigCICEBIAAgBioCKDgCBCAAIAFBA0c2AgAgBkEwaiQAC40DAgR/AX4CQAJAIABFDQAgACgCACIFQX9GDQEgACAFQQFqNgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIANFDQAgAygCACIFQX9GDQEgAyAFQQFqNgIAIARFDQAgBCgCACIFQX9GDQEgBCAFQQFqNgIAIAJBBGohBiMAQSBrIgUkACAFIANBBGopAgA3AxggBSAEQQRqKQIANwMQIAVBCGoiByABvSIJQiCIPgIEIAcgCT4CACAAQQRqIAUoAgggBSgCDBCkCCIHRQRAQZi2wABBzABBjLfAABCaCwALIAUgBigCBCIINgIEIAUgBigCACAIKAIIQQdqQXhxajYCACAHQSBqIggoAgQhBiAHIAgoAgAgBigCCEEHakF4cWogBiAFQRBqIAUoAgAgBSgCBBCrBSEGIAVBIGokACAEIAQoAgBBAWs2AgAgAyADKAIAQQFrNgIAIAIgAigCAEEBazYCACAAIAAoAgBBAWs2AgAgBkH/AXEiACAAQQJHcQ8LEKYLAAsQpwsAC6gCAgZ/AX4jAEEQayIFJAACQAJAAkACQCAARQ0AIAAoAgANAyAAQX82AgAgAkUNACACKAIAIgRBf0YNAyACIARBAWo2AgAgBUEIaiIEIAG9IglCIIg+AgQgBCAJPgIAIABBBGogBSgCCCAFKAIMEPMFIgNFDQEgAkEIaigCACEEIAJBBGooAgAiBygCACEGIAcgBkEBajYCACAGQQBIDQIgAyADKAIwQSByNgIwIAMoAiAiBigCACEIIAYgCEEBazYCACAIQQFGBEAgA0EgaigCACADQSRqKAIAEJ0HCyADIAc2AiAgA0EkaiAENgIAIAIgAigCAEEBazYCACAAQQA2AgAgBUEQaiQADwsQpgsAC0GYtsAAQcwAQZy3wAAQmgsACwALEKcLAAvWAQIBfwR9IwBBMGsiBiQAIAYgAioCACIHIANBBGoqAgAgAkEMaioCAJMiCJQgAyoCACACQQhqKgIAkyIJIAJBBGoqAgAiCpSTOAIUIAYgCSAHlCAIIAqUkjgCECAGIAcgA0EMaioCACIIlCAKIANBCGoqAgAiCZSTOAIcIAYgByAJlCAKIAiUkjgCGCAGIAZBGGoiAikCADcCCCAGIAZBEGopAgA3AgAgAiABIAYgBCAFEKkBIAYoAiAhASAAIAYqAig4AgQgACABQQNHNgIAIAZBMGokAAvFAQMFfQF+AX8gAikCACIKpyILviEFAkACQCABKgIAIgYgAioCAJQgAUEEaioCACIIIAJBBGoqAgAiCZSSIgdDAAAAAF8iAkUNACADRQ0AIAUhBkEBIQIMAQsgBSAGIAeUkyIGvCILrSAKQiCIp74gCCAHlJO8rUIghoQhCgsgBSAGkyIFIAWUIAkgCkIgiKciAb6TIgUgBZSSQwAAAACSEHYgBF5FBEAgACACOgAIIAAgATYCBCAAIAs2AgAPCyAAQQI6AAgL2QECA38BfiMAQZABayIDJAAgA0HoAGpBAjYCACADQoCAgIAQNwNgIANBCGoiBEEAQdgAEK0LGiADIAEpAggiBqdBgICAgHhzNgKAASADIAZCIIinQYCAgIB4czYChAEgA0H4AGogACADQYABaiIFELUCIANBIGpCADcDACADQRhqIAMpA3giBqe+IAEqAgCTvK0gBkIgiKe+IAEqAgSTvK1CIIaEIgY3AwAgA0IANwJsIAMgBjcDECAFIAAgBCABIAIQgAEgAygCgAEhACADQZABaiQAIABBAEcLyQECAX8GfSMAQSBrIgYkACAGIAIqAgAiByADQQRqKgIAIAJBDGoqAgAiCJMiCpQgAyoCACACQQhqKgIAIguTIgwgAkEEaioCACIJlJM4AhwgBiAMIAeUIAogCZSSOAIYIAZBCGogASAGQRhqIAQgBRCwAQJAIAYtABAiAUECRgRAIABBAjoACAwBCyAAIAE6AAggACAIIAkgBioCCCIFlCAHIAYqAgwiCJSSkjgCBCAAIAsgByAFlCAJIAiUk5I4AgALIAZBIGokAAvRAQIBfwZ9IwBBMGsiBSQAIAUgAioCACIIIANBBGoqAgAgAkEMaioCACIKkyIGlCADKgIAIAJBCGoqAgAiC5MiByACQQRqKgIAIgmUkzgCBCAFIAcgCJQgBiAJlJI4AgAgBUEIaiABIAUgBEP//39/EDogBSgCGEEERgRAQYD5wQBBK0HEpsIAEMkIAAsgBSoCCCEGIAUqAgwhByAAIAUtABA6AAggACAKIAkgBpQgCCAHlJKSOAIEIAAgCyAIIAaUIAkgB5STkjgCACAFQTBqJAAL0QECAX8EfSMAQTBrIgQkACAEIAEqAgAiBSACQQRqKgIAIAFBDGoqAgCTIgaUIAIqAgAgAUEIaioCAJMiByABQQRqKgIAIgiUkzgCBCAEIAcgBZQgBiAIlJI4AgAgBEEIaiAAIAQgA0P//39/EDogBCgCGEEERgRAQYD5wQBBK0HEpsIAEMkIAAsgBC0AECEAIAQqAgggBCoCAJMiBSAFlCAEKgIMIAQqAgSTIgUgBZSSQwAAAACSEHYhBSAEQTBqJAAgBSAFIAWMIABBAUcbIAMbC7cBAgJ/BH4jAEEgayIDJAAgA0EIaiABKQIAIgYgAUEIaikCACIHIAIQoAIgAygCECEBIAMpAwghBQJ/IAMoAhQiBEUEQCADQRhqKAIADAELIAdCIIinviAGQiCIp76TIAIpAgAiCKe+IAWnvpOUIAenviAGp76TIAhCIIinviAFQiCIp76TlJNDAAAAAGBFCyECIAAgBDYCDCAAIAE2AgggACAFNwIAIABBEGogAjYCACADQSBqJAALvAECBn0BfiACKgIAIgYgAyoCACIElCACQQRqKgIAIgcgA0EEaioCACIIlJIiBSABKgIQIgmUIAEgAUEIaiIDIAEqAgAgBZQgBiAIlCAHIASUkyIEIAFBBGoqAgCUkiAFIAMqAgCUIAQgAUEMaioCAJSSXhspAgAiCqe+kiEFIAAgAkEMaioCACAHIAWUIAYgBCAJlCAKQiCIp76SIgSUkpI4AgQgACACQQhqKgIAIAYgBZQgByAElJOSOAIAC9YBAQF/IwBBIGsiAyQAIAAoAgAhACADQSE2AhggA0EQaiIEIAI2AgQgBCABNgIAIAMgAysDEBABNgIcIANBCGogACADQRhqIANBHGoQzAggAygCDCEAAkACQCADKAIIRQRAQQEhAkEAIQECQAJAAkAgABADDgIAAQILQQAhAgwBC0EBIQFBACECCyABIAJyIQIgAEEkSQ0CDAELQQEhAiAAQSNNDQELIAAQAAsgAygCHCIAQSRPBEAgABAACyADKAIYIgBBJE8EQCAAEAALIANBIGokACACC78CAgN/An4jAEEgayIDJAACQAJAAkAgAEUNACAAKAIAIgJBf0YNAiAAIAJBAWo2AgAgAUUNACABKAIAIgJBf0YNAiABIAJBAWo2AgAgAyAAKQIENwMQIAMgASkCBDcDGCADQQhqIQQgA0EYaikCACEFIANBEGopAgAhBkEYQQQQ0AoiAkUEQEEYQQRBwMPDACgCACIAQaQGIAAbEQAAAAsgAiAFNwIQIAIgBjcCCCACQoGAgIAQNwIAIARBkKrCADYCBCAEIAI2AgAgAygCDCECIAMoAgghBCABIAEoAgBBAWs2AgAgACAAKAIAQQFrNgIAQQxBBBDQCiIARQ0BIAAgAjYCCCAAIAQ2AgQgAEEANgIAIANBIGokACAADwsQpgsAC0EMQQRBwMPDACgCACIAQaQGIAAbEQAAAAsQpwsAC8UBAgJ/BH0jAEEwayIGJAAgBkEIaiIHQQxqIAIqAgAiCCADQQxqKgIAIgmUIAJBBGoqAgAiCiADQQhqKgIAIguUkzgCACAGIAggC5QgCiAJlJI4AhAgBiAIIANBBGoqAgAgAkEMaioCAJMiCZQgCiADKgIAIAJBCGoqAgCTIguUkzgCDCAGIAsgCJQgCSAKlJI4AgggBkEYaiABIAcgBCAFEPEBIAYoAiAhASAAIAYqAig4AgQgACABQQNHNgIAIAZBMGokAAvEAQICfwR9IwBBMGsiBiQAIAZBCGoiB0EMaiACKgIAIgggA0EMaioCACIJlCACQQRqKgIAIgogA0EIaioCACILlJM4AgAgBiAIIAuUIAogCZSSOAIQIAYgCCADQQRqKgIAIAJBDGoqAgCTIgmUIAogAyoCACACQQhqKgIAkyILlJM4AgwgBiALIAiUIAkgCpSSOAIIIAZBGGogASAHIAQgBRB7IAYoAiAhASAAIAYqAig4AgQgACABQQNHNgIAIAZBMGokAAvFAQICfwR9IwBBMGsiBiQAIAZBCGoiB0EMaiACKgIAIgggA0EMaioCACIJlCACQQRqKgIAIgogA0EIaioCACILlJM4AgAgBiAIIAuUIAogCZSSOAIQIAYgCCADQQRqKgIAIAJBDGoqAgCTIgmUIAogAyoCACACQQhqKgIAkyILlJM4AgwgBiALIAiUIAkgCpSSOAIIIAZBGGogASAHIAQgBRDRASAGKAIgIQEgACAGKgIoOAIEIAAgAUEDRzYCACAGQTBqJAALxQECBH0BfyMAQTBrIgUkACAFQQhqIgpBDGogAioCACIGIANBDGoqAgAiB5QgAkEEaioCACIIIANBCGoqAgAiCZSTOAIAIAUgBiAJlCAIIAeUkjgCECAFIAYgA0EEaioCACACQQxqKgIAkyIHlCAIIAMqAgAgAkEIaioCAJMiCZSTOAIMIAUgCSAGlCAHIAiUkjgCCCAFQRhqIAEgCiAEQQAQqAEgBSgCICEBIAAgBSoCKDgCBCAAIAFBA0c2AgAgBUEwaiQAC8QBAgR9AX8jAEEwayIFJAAgBUEIaiIKQQxqIAIqAgAiBiADQQxqKgIAIgeUIAJBBGoqAgAiCCADQQhqKgIAIgmUkzgCACAFIAYgCZQgCCAHlJI4AhAgBSAGIANBBGoqAgAgAkEMaioCAJMiB5QgCCADKgIAIAJBCGoqAgCTIgmUkzgCDCAFIAkgBpQgByAIlJI4AgggBUEYaiABIAogBEEAEGYgBSgCICEBIAAgBSoCKDgCBCAAIAFBA0c2AgAgBUEwaiQAC8UBAgJ/BH0jAEEwayIGJAAgBkEIaiIHQQxqIAIqAgAiCCADQQxqKgIAIgmUIAJBBGoqAgAiCiADQQhqKgIAIguUkzgCACAGIAggC5QgCiAJlJI4AhAgBiAIIANBBGoqAgAgAkEMaioCAJMiCZQgCiADKgIAIAJBCGoqAgCTIguUkzgCDCAGIAsgCJQgCSAKlJI4AgggBkEYaiABIAcgBCAFEKkBIAYoAiAhASAAIAYqAig4AgQgACABQQNHNgIAIAZBMGokAAvFAQICfwR9IwBBMGsiBiQAIAZBCGoiB0EMaiACKgIAIgggA0EMaioCACIJlCACQQRqKgIAIgogA0EIaioCACILlJM4AgAgBiAIIAuUIAogCZSSOAIQIAYgCCADQQRqKgIAIAJBDGoqAgCTIgmUIAogAyoCACACQQhqKgIAkyILlJM4AgwgBiALIAiUIAkgCpSSOAIIIAZBGGogASAHIAQgBRCnASAGKAIgIQEgACAGKgIoOAIEIAAgAUEDRzYCACAGQTBqJAALxQECAn8EfSMAQTBrIgYkACAGQQhqIgdBDGogAioCACIIIANBDGoqAgAiCZQgAkEEaioCACIKIANBCGoqAgAiC5STOAIAIAYgCCALlCAKIAmUkjgCECAGIAggA0EEaioCACACQQxqKgIAkyIJlCAKIAMqAgAgAkEIaioCAJMiC5STOAIMIAYgCyAIlCAJIAqUkjgCCCAGQRhqIAEgByAEIAUQywEgBigCICEBIAAgBioCKDgCBCAAIAFBA0c2AgAgBkEwaiQAC8YBAQZ9IAIqAgAiByADKgIAIgSUIAJBBGoqAgAiCCADQQRqKgIAIgaUkiIFIAWUIAcgBpQgCCAElJMiBCAElJJDAAAAAJIQdiEGIAAgAkEMaioCACAHIAQgBpUiBCABKgIIIgmUIAEoAgRB/////wdxIAS8QYCAgIB4cXK+kiIElCAIIAUgBpUiBSAJlCAFvEGAgICAeHEgASgCAEH/////B3FyvpIiBZSSkjgCBCAAIAJBCGoqAgAgByAFlCAIIASUk5I4AgALtgEBAn8gAEEgaigCACIBBEAgAUHEAWwhAiAAQRxqKAIAQZABaiEBA0AgASgCAARAIAFBADYCAAsgAUHwAGsoAgAEQCABQewAaygCABCHAQsgAUHEAWohASACQcQBayICDQALCyAAKAIYBEAgAEEcaigCABCHAQsCQCAAKAIQIgFFDQAgASAAQRRqIgEoAgAoAgARBwAgASgCACIBQQRqKAIARQ0AIAFBCGooAgAaIAAoAhAQhwELC9wBAQJ/IwBBIGsiAyQAAkACQCABIAEgAmoiAUsNACAAKAIAIgJBAXQiBCABIAEgBEkbIgFBCCABQQhLGyIBQX9zQR92IQQCQCACBEAgA0EBNgIYIAMgAjYCFCADIABBBGooAgA2AhAMAQsgA0EANgIYCyADIAEgBCADQRBqEM8FIAMoAgQhAiADKAIARQRAIAAgATYCACAAIAI2AgQMAgsgA0EIaigCACIAQYGAgIB4Rg0BIABFDQAgAiAAQcDDwwAoAgAiAEGkBiAAGxEAAAALEIoJAAsgA0EgaiQAC9IBAQF/IwBBkAFrIgEkAAJAIAAEQCAAKAIARQ0BEKcLAAsQpgsACyAAQQA2AgAgAUHIAGogAEHEABCuCxogAUFAayABQYQBaikCADcDACABQThqIAFB/ABqKQIANwMAIAFBMGogAUH0AGopAgA3AwAgAUEoaiABQewAaikCADcDACABQSBqIAFB5ABqKQIANwMAIAFBGGogAUHcAGopAgA3AwAgAUEQaiABQdQAaikCADcDACABIAEpAkw3AwggABCHASABQQhqEIUGIAFBkAFqJAALgAQCCX8BfiMAQRBrIgUkAAJAIAAEQCAAKAIAIgNBf0cNARCnCwALEKYLAAsgACADQQFqNgIAIAVBCGoiAyABvSIMQiCIPgIEIAMgDD4CACAFKAIMIQMgBSgCCCEGIAUgAr0iDEIgiD4CBCAFIAw+AgAgBSgCACEHIAUoAgQhCQJAIABBBGoiBEFAaygCACIIIAZNDQAgAyAGQQxsIARBPGooAgAiBmoiCygCAEcNACAHIAhPDQAgBiAHQQxsaiIHKAIAIAlHDQAgBEEQaigCACIGIAtBBGooAgAiA00NACAHKAIEIQkgBEEYaigCACEHAkAgBEEMaigCACADQQR0akEAIAMgBkkbIggoAggiAyAEQRxqKAIAIgRJBEADQCAHIANBOGxqIgtBDGooAgAgCUYNAiAEIAsoAgAiA0sNAAsLIAQgCEEMaigCACIDTQ0BA0AgByADQThsaiIIKAIIIAlGDQEgBCAIKAIEIgNLDQALDAELIAMgBE8NACAHIANBOGxqIgNBCGooAgAgBk8NACADQRBqQQAgA0EMaigCACAGSRshCgsgACAAKAIAQQFrNgIAAkACQCAKRQRAQQAhAAwBC0EIQQQQ0AoiAEUNASAAIAo2AgQgAEEANgIACyAFQRBqJAAgAA8LQQhBBEHAw8MAKAIAIgBBpAYgABsRAAAAC9IBAQd+IAAgASkCCCICPgIgIAAgASkCMCIDPgIMIAAgASkCICIEPgIIIAAgASkCECIFPgIEIAAgASkCACIGPgIAIABBMGogAkIgiD4CACAAQSxqIAFBOGopAgAiAj4CACAAQShqIAFBKGopAgAiBz4CACAAQSRqIAFBGGopAgAiCD4CACAAIANCIIg+AhwgACAEQiCIPgIYIAAgBUIgiD4CFCAAIAZCIIg+AhAgAEE8aiACQiCIPgIAIABBOGogB0IgiD4CACAAQTRqIAhCIIg+AgAL3AEBAn8jAEEgayIDJAACQAJAIAEgASACaiIBSw0AIAAoAgAiAkEBdCIEIAEgASAESRsiAUEIIAFBCEsbIgFBf3NBH3YhBAJAIAIEQCADQQE2AhggAyACNgIUIAMgAEEEaigCADYCEAwBCyADQQA2AhgLIAMgASAEIANBEGoQjwUgAygCBCECIAMoAgBFBEAgACABNgIAIAAgAjYCBAwCCyADQQhqKAIAIgBBgYCAgHhGDQEgAEUNACACIABBwMPDACgCACIAQaQGIAAbEQAAAAsQigkACyADQSBqJAAL2gEBA38jAEEgayICJAACQAJAIAFBAWoiAUUNACAAKAIAIgNBAXQiBCABIAEgBEkbIgFBCCABQQhLGyIBQX9zQR92IQQCQCADBEAgAkEBNgIYIAIgAzYCFCACIABBBGooAgA2AhAMAQsgAkEANgIYCyACIAEgBCACQRBqEM8FIAIoAgQhAyACKAIARQRAIAAgATYCACAAIAM2AgQMAgsgAkEIaigCACIAQYGAgIB4Rg0BIABFDQAgAyAAQcDDwwAoAgAiAEGkBiAAGxEAAAALEIoJAAsgAkEgaiQAC84BAgF/BH0jAEFAaiIFJAAgBSACKgIAIgYgA0EEaioCACACQQxqKgIAkyIHlCADKgIAIAJBCGoqAgCTIgggAkEEaioCACIJlJM4AgwgBSAIIAaUIAcgCZSSOAIIIAEqAgAhBiABKgIEIQcgBSABKQIANwMYIAUgB4w4AhQgBSAGjDgCECAFQSBqIgEgBUEQaiAFQQhqIAQQlgIgBS0AKCEDIAUgBSkDIDcDOCABIAM6AAggASAFQThqKQIANwIAIAAgASACEJUIIAVBQGskAAvEAQIBfwZ9IwBBIGsiBCQAIAQgAioCACIFIANBBGoqAgAgAkEMaioCACIGkyIHlCADKgIAIAJBCGoqAgAiCZMiCiACQQRqKgIAIgiUkzgCHCAEIAogBZQgByAIlJI4AhggBCABIARBGGpBABBIIABBEGogBEEQaigCADYCACAAQQI2AgwgACAELQAIOgAIIAAgBiAIIAQqAgAiBpQgBSAEKgIEIgeUkpI4AgQgACAJIAUgBpQgCCAHlJOSOAIAIARBIGokAAvFAQIBfwZ9IwBBIGsiBCQAIAQgAioCACIFIANBBGoqAgAgAkEMaioCACIGkyIHlCADKgIAIAJBCGoqAgAiCZMiCiACQQRqKgIAIgiUkzgCHCAEIAogBZQgByAIlJI4AhggBCABIARBGGpBABCaAiAAQRBqIARBEGooAgA2AgAgAEECNgIMIAAgBC0ACDoACCAAIAYgCCAEKgIAIgaUIAUgBCoCBCIHlJKSOAIEIAAgCSAFIAaUIAggB5STkjgCACAEQSBqJAALwQECAn8EfSMAQSBrIgYkACAGQRBqIgdBDGogAioCACIIIANBDGoqAgAiCZQgAkEEaioCACIKIANBCGoqAgAiC5STOAIAIAYgCCALlCAKIAmUkjgCGCAGIAggA0EEaioCACACQQxqKgIAkyIJlCAKIAMqAgAgAkEIaioCAJMiC5STOAIUIAYgCyAIlCAJIAqUkjgCECAGQQhqIAEgByAEIAUQMSAGKAIIIQEgACAGKgIMOAIEIAAgATYCACAGQSBqJAALwQECAn8EfSMAQSBrIgYkACAGQRBqIgdBDGogAioCACIIIANBDGoqAgAiCZQgAkEEaioCACIKIANBCGoqAgAiC5STOAIAIAYgCCALlCAKIAmUkjgCGCAGIAggA0EEaioCACACQQxqKgIAkyIJlCAKIAMqAgAgAkEIaioCAJMiC5STOAIUIAYgCyAIlCAJIAqUkjgCECAGQQhqIAEgByAEIAUQPCAGKAIIIQEgACAGKgIMOAIEIAAgATYCACAGQSBqJAALwQECAn8EfSMAQSBrIgYkACAGQRBqIgdBDGogAioCACIIIANBDGoqAgAiCZQgAkEEaioCACIKIANBCGoqAgAiC5STOAIAIAYgCCALlCAKIAmUkjgCGCAGIAggA0EEaioCACACQQxqKgIAkyIJlCAKIAMqAgAgAkEIaioCAJMiC5STOAIUIAYgCyAIlCAJIAqUkjgCECAGQQhqIAEgByAEIAUQNCAGKAIIIQEgACAGKgIMOAIEIAAgATYCACAGQSBqJAALugEDBH0CfwJ+IAIqAgAiBCABQRBqIgcqAgCUIAJBBGoqAgAiAyABQRRqKgIAlJIhBQJAIAEqAgAgBJQgAUEEaioCACADlJIiBiAEIAFBCGoiCCoCAJQgAyABQQxqKgIAlJIiA15FBEAgAyAFXkUNASAIIQcMAQsgASAHIAUgBl0bIQcLIAAgASoCGCIDIAIpAgAiCae+lCAHKQIAIgqnvpI4AgAgACADIAlCIIinvpQgCkIgiKe+kjgCBAugAgMDfwN9AX4jAEEQayIBJAACQCAABEAgACgCACICQX9HDQEQpwsACxCmCwALIAAgAkEBajYCACAAKgIEIgQgBJQgAEEIaioCACIFIAWUkkMAAAAAkhB2IQYgASAEIAaVvK0gBSAGlbytQiCGhDcDCCABQQhqKQIAIQdBEEEEENAKIgJFBEBBEEEEQcDDwwAoAgAiAEGkBiAAGxEAAAALIAIgBzcCCCACQoGAgIAQNwIAIAFBpMjCADYCBCABIAI2AgAgASgCBCECIAEoAgAhAyAAIAAoAgBBAWs2AgBBDEEEENAKIgBFBEBBDEEEQcDDwwAoAgAiAEGkBiAAGxEAAAALIAAgAjYCCCAAIAM2AgQgAEEANgIAIAFBEGokACAAC8QBAgF/Bn0jAEGAAWsiAyQAIAFBDGoqAgAhBCACQQRqKgIAIQggAUEEaioCACEGIAFBCGoqAgAhBSABKgIAIQcgAioCACEJIANB8ABqQgI3AwAgA0EANgJ4IANCgICAgBA3A2ggA0EQaiIBQQBB2AAQrQsaIAMgAEEEaigCACAAQQhqKAIAIAEgCSAFkyIFIAeUIAggBJMiBCAGlJK8rSAHIASUIAYgBZSTvK1CIIaEQQEQGSADLQAIIQAgA0GAAWokACAAC80BAgN9AX4CQAJAAkACQCABKQIIIginviABKgIAkyIFIAWUIAhCIIinviABKgIEkyIGIAaUkkMAAAAAkiIHQwAAgCheBEAgBiAHEHYiB5UhBiAFIAeVIQVBACEBIAIOAgIBBAsgAEKAgICAgICAwD83AgQMAgsgAEEIaiAFIAWMIAMbOAIAIAAgBowgBiADGzgCBAwBCyADBEAgAEEIaiAGjDgCACAAIAWMOAIEDAELIAAgBTgCBCAAQQhqIAY4AgALQQEhAQsgACABNgIAC4gCAQJ/IwBBIGsiBSQAQdTDwwBB1MPDACgCACIGQQFqNgIAAkACQCAGQQBIDQBBxMfDAEHEx8MAKAIAQQFqIgY2AgAgBkECSw0AIAUgBDoAGCAFIAM2AhQgBSACNgIQIAVByPjCADYCDCAFQeDxwgA2AghBxMPDACgCACICQQBIDQBBxMPDACACQQFqIgI2AgBBxMPDAEHMw8MAKAIABH8gBSAAIAEoAhARAAAgBSAFKQMANwMIQczDwwAoAgAgBUEIakHQw8MAKAIAKAIUEQAAQcTDwwAoAgAFIAILQQFrNgIAIAZBAUsNACAEDQELAAsjAEEQayICJAAgAiABNgIMIAIgADYCCAALxwECAX8EfSMAQTBrIgQkACAEIAEqAgAiBSACQQRqKgIAIAFBDGoqAgCTIgaUIAIqAgAgAUEIaioCAJMiByABQQRqKgIAIgiUkzgCFCAEIAcgBZQgBiAIlJI4AhAgBCAFIAJBDGoqAgAiBpQgCCACQQhqKgIAIgeUkzgCHCAEIAUgB5QgCCAGlJI4AhggBCAEQRhqIgEpAgA3AgggBCAEQRBqKQIANwIAIAEgACAEIANBARCoASAEKAIgIQAgBEEwaiQAIABBA0cLxwECAX8EfSMAQTBrIgQkACAEIAEqAgAiBSACQQRqKgIAIAFBDGoqAgCTIgaUIAIqAgAgAUEIaioCAJMiByABQQRqKgIAIgiUkzgCFCAEIAcgBZQgBiAIlJI4AhAgBCAFIAJBDGoqAgAiBpQgCCACQQhqKgIAIgeUkzgCHCAEIAUgB5QgCCAGlJI4AhggBCAEQRhqIgEpAgA3AgggBCAEQRBqKQIANwIAIAEgACAEIANBARDlASAEKAIgIQAgBEEwaiQAIABBA0cL0wECA38BfiMAQRBrIgMkAAJAIAAEQCAAKAIAIgJBf0cNARCnCwALEKYLAAsgACACQQFqNgIAIANBCGoiAiABvSIFQiCIPgIEIAIgBT4CACADIABBBGogAygCCCADKAIMENAFAkAgAygCACICBEAgAygCBCIEIAJBoAFqKAIATw0BIAJBnAFqKAIAIARBhAJsakHtAWotAAAhAiAAIAAoAgBBAWs2AgAgA0EQaiQAIAIPC0HIs8AAQckAQdC0wAAQmgsAC0HQhcAAQStBwLTAABDJCAALxwECAX8EfSMAQTBrIgQkACAEIAEqAgAiBSACQQRqKgIAIAFBDGoqAgCTIgaUIAIqAgAgAUEIaioCAJMiByABQQRqKgIAIgiUkzgCFCAEIAcgBZQgBiAIlJI4AhAgBCAFIAJBDGoqAgAiBpQgCCACQQhqKgIAIgeUkzgCHCAEIAUgB5QgCCAGlJI4AhggBCAEQRhqIgEpAgA3AgggBCAEQRBqKQIANwIAIAEgACAEIANBARCpASAEKAIgIQAgBEEwaiQAIABBA0cLuQECAX4DfUKAgICAgICAwD8hAyACKgIAIgQgBJQgAioCBCIFIAWUkkMAAAAAkiIGQwAAAABeBEAgBCAGEHYiBJW8rSAFIASVvK1CIIaEIQMLIAEgAUEIaiICIAEqAgAgA6e+IgSUIAFBBGoqAgAgA0IgiKe+IgWUkiACKgIAIASUIAFBDGoqAgAgBZSSXhspAgAhAyAAIAEqAhAiBiAElCADp76SOAIAIAAgBiAFlCADQiCIp76SOAIEC98BAwJ/AX4CfSMAQRBrIgMkAAJAIAAEQCAAKAIAIgJBf0cNARCnCwALEKYLAAsgACACQQFqNgIAIANBCGoiAiABvSIEQiCIPgIEIAIgBD4CAAJAIABBBGogAygCCCADKAIMEIcHIgIEQCACQRRqKgIAIQUgAkEQaioCACEGIAAgACgCAEEBazYCAEEMQQQQ0AoiAEUNASAAIAU4AgggACAGOAIEIABBADYCACADQRBqJAAgAA8LQaiywABB0ABBqLPAABCaCwALQQxBBEHAw8MAKAIAIgBBpAYgABsRAAAAC7YBAgJ/BH0jAEEwayIEJAAgBEEIaiIFQQxqIAEqAgAiBiACQQxqKgIAIgeUIAFBBGoqAgAiCCACQQhqKgIAIgmUkzgCACAEIAYgCZQgCCAHlJI4AhAgBCAGIAJBBGoqAgAgAUEMaioCAJMiB5QgCCACKgIAIAFBCGoqAgCTIgmUkzgCDCAEIAkgBpQgByAIlJI4AgggBEEYaiAAIAUgA0EAEKgBIAQoAiAhACAEQTBqJAAgAEEDRwu1AQICfwR9IwBBMGsiBCQAIARBCGoiBUEMaiABKgIAIgYgAkEMaioCACIHlCABQQRqKgIAIgggAkEIaioCACIJlJM4AgAgBCAGIAmUIAggB5SSOAIQIAQgBiACQQRqKgIAIAFBDGoqAgCTIgeUIAggAioCACABQQhqKgIAkyIJlJM4AgwgBCAJIAaUIAcgCJSSOAIIIARBGGogACAFIANBABBmIAQoAiAhACAEQTBqJAAgAEEDRwu2AQICfwR9IwBBMGsiBCQAIARBCGoiBUEMaiABKgIAIgYgAkEMaioCACIHlCABQQRqKgIAIgggAkEIaioCACIJlJM4AgAgBCAGIAmUIAggB5SSOAIQIAQgBiACQQRqKgIAIAFBDGoqAgCTIgeUIAggAioCACABQQhqKgIAkyIJlJM4AgwgBCAJIAaUIAcgCJSSOAIIIARBGGogACAFIANBARCnASAEKAIgIQAgBEEwaiQAIABBA0cLtgECAn8EfSMAQTBrIgQkACAEQQhqIgVBDGogASoCACIGIAJBDGoqAgAiB5QgAUEEaioCACIIIAJBCGoqAgAiCZSTOAIAIAQgBiAJlCAIIAeUkjgCECAEIAYgAkEEaioCACABQQxqKgIAkyIHlCAIIAIqAgAgAUEIaioCAJMiCZSTOAIMIAQgCSAGlCAHIAiUkjgCCCAEQRhqIAAgBSADQQEQywEgBCgCICEAIARBMGokACAAQQNHC7YBAgJ/BH0jAEEwayIEJAAgBEEIaiIFQQxqIAEqAgAiBiACQQxqKgIAIgeUIAFBBGoqAgAiCCACQQhqKgIAIgmUkzgCACAEIAYgCZQgCCAHlJI4AhAgBCAGIAJBBGoqAgAgAUEMaioCAJMiB5QgCCACKgIAIAFBCGoqAgCTIgmUkzgCDCAEIAkgBpQgByAIlJI4AgggBEEYaiAAIAUgA0EBEKkBIAQoAiAhACAEQTBqJAAgAEEDRwu1AQICfwR9IwBBIGsiBCQAIARBEGoiBUEMaiABKgIAIgYgAkEMaioCACIHlCABQQRqKgIAIgggAkEIaioCACIJlJM4AgAgBCAGIAmUIAggB5SSOAIYIAQgBiACQQRqKgIAIAFBDGoqAgCTIgeUIAggAioCACABQQhqKgIAkyIJlJM4AhQgBCAJIAaUIAcgCJSSOAIQIARBCGogACAFIANBARA8IAQoAgghACAEQSBqJAAgAEEBRgu1AQICfwR9IwBBMGsiBCQAIARBCGoiBUEMaiABKgIAIgYgAkEMaioCACIHlCABQQRqKgIAIgggAkEIaioCACIJlJM4AgAgBCAGIAmUIAggB5SSOAIQIAQgBiACQQRqKgIAIAFBDGoqAgCTIgeUIAggAioCACABQQhqKgIAkyIJlJM4AgwgBCAJIAaUIAcgCJSSOAIIIARBGGogACAFIANBARB7IAQoAiAhACAEQTBqJAAgAEEDRwu1AQICfwR9IwBBIGsiBCQAIARBEGoiBUEMaiABKgIAIgYgAkEMaioCACIHlCABQQRqKgIAIgggAkEIaioCACIJlJM4AgAgBCAGIAmUIAggB5SSOAIYIAQgBiACQQRqKgIAIAFBDGoqAgCTIgeUIAggAioCACABQQhqKgIAkyIJlJM4AhQgBCAJIAaUIAcgCJSSOAIQIARBCGogACAFIANBARA0IAQoAgghACAEQSBqJAAgAEEBRgu2AQICfwR9IwBBMGsiBCQAIARBCGoiBUEMaiABKgIAIgYgAkEMaioCACIHlCABQQRqKgIAIgggAkEIaioCACIJlJM4AgAgBCAGIAmUIAggB5SSOAIQIAQgBiACQQRqKgIAIAFBDGoqAgCTIgeUIAggAioCACABQQhqKgIAkyIJlJM4AgwgBCAJIAaUIAcgCJSSOAIIIARBGGogACAFIANBARDxASAEKAIgIQAgBEEwaiQAIABBA0cLtQECAn8EfSMAQSBrIgQkACAEQRBqIgVBDGogASoCACIGIAJBDGoqAgAiB5QgAUEEaioCACIIIAJBCGoqAgAiCZSTOAIAIAQgBiAJlCAIIAeUkjgCGCAEIAYgAkEEaioCACABQQxqKgIAkyIHlCAIIAIqAgAgAUEIaioCAJMiCZSTOAIUIAQgCSAGlCAHIAiUkjgCECAEQQhqIAAgBSADQQEQMSAEKAIIIQAgBEEgaiQAIABBAUYLugEAAkAgAgRAAkACQAJ/AkACQCABQQBOBEAgAygCCA0BIAENAkEBIQIMBAsMBgsgAygCBCICRQRAIAFFBEBBASECDAQLIAFBARDQCgwCCyADKAIAIAJBASABEL8KDAELIAFBARDQCgsiAkUNAQsgACACNgIEIABBCGogATYCACAAQQA2AgAPCyAAIAE2AgQgAEEIakEBNgIAIABBATYCAA8LIAAgATYCBAsgAEEIakEANgIAIABBATYCAAu7AQIBfwR9IwBBIGsiBCQAIAQgASoCACIFIAJBBGoqAgAgAUEMaioCAJMiBpQgAioCACABQQhqKgIAkyIHIAFBBGoqAgAiCJSTOAIEIAQgByAFlCAGIAiUkjgCACAEQQhqIAApAgAgAEEIaikCACAEEI8CIAQtABAhACAEKgIIIAQqAgCTIgUgBZQgBCoCDCAEKgIEkyIFIAWUkkMAAAAAkhB2IQUgBEEgaiQAIAUgBSAFjCAAQQFHGyADGwvMAQIBfwJ9IwBBMGsiBSQAIAEqAgAhBiABKgIEIQcgBSABKQIANwMIIAUgB4w4AgQgBSAGjDgCACAFQRBqIgEgBSACIAMQlgIgBS0AGCEDIAUgBSkDEDcDKCABIAM6AAggASAFQShqKQIANwIAAkAgAioCACAFKgIQkyIGIAaUIAJBBGoqAgAgBSoCFJMiBiAGlJJDAAAAAJIQdiAEXkUEQCAAIAUpAxA3AgAgAEEIaiAFQRhqKAIANgIADAELIABBAjoACAsgBUEwaiQAC9wBAwJ/AX4CfSMAQRBrIgMkAAJAIAAEQCAAKAIAIgJBf0cNARCnCwALEKYLAAsgACACQQFqNgIAIANBCGoiAiABvSIEQiCIPgIEIAIgBD4CAAJAIABBBGogAygCCCADKAIMEIcHIgIEQCACQQRqKgIAIQUgAioCACEGIAAgACgCAEEBazYCAEEMQQQQ0AoiAEUNASAAIAU4AgggACAGOAIEIABBADYCACADQRBqJAAgAA8LQaiywABB0ABBqLPAABCaCwALQQxBBEHAw8MAKAIAIgBBpAYgABsRAAAAC9wBAwJ/AX4CfSMAQRBrIgMkAAJAIAAEQCAAKAIAIgJBf0cNARCnCwALEKYLAAsgACACQQFqNgIAIANBCGoiAiABvSIEQiCIPgIEIAIgBD4CAAJAIABBBGogAygCCCADKAIMEKMIIgIEQCACQQRqKgIAIQUgAioCACEGIAAgACgCAEEBazYCAEEMQQQQ0AoiAEUNASAAIAU4AgggACAGOAIEIABBADYCACADQRBqJAAgAA8LQYC1wABBzQBB+LXAABCaCwALQQxBBEHAw8MAKAIAIgBBpAYgABsRAAAAC94BAwJ/AX4CfSMAQRBrIgMkAAJAIAAEQCAAKAIAIgJBf0cNARCnCwALEKYLAAsgACACQQFqNgIAIANBCGoiAiABvSIEQiCIPgIEIAIgBD4CAAJAIABBBGogAygCCCADKAIMEKMIIgIEQCACQRBqIgIqAgQhBSACKgIAIQYgACAAKAIAQQFrNgIAQQxBBBDQCiIARQ0BIAAgBTgCCCAAIAY4AgQgAEEANgIAIANBEGokACAADwtBgLXAAEHNAEH4tcAAEJoLAAtBDEEEQcDDwwAoAgAiAEGkBiAAGxEAAAAL2QEDAn8BfgJ9IwBBEGsiAyQAAkAgAARAIAAoAgAiAkF/Rw0BEKcLAAsQpgsACyAAIAJBAWo2AgAgA0EIaiICIAG9IgRCIIg+AgQgAiAEPgIAAkAgAEEEaiADKAIIIAMoAgwQpAgiAgRAIAIqAgQhBSACKgIAIQYgACAAKAIAQQFrNgIAQQxBBBDQCiIARQ0BIAAgBTgCCCAAIAY4AgQgAEEANgIAIANBEGokACAADwtBmLbAAEHMAEGMt8AAEJoLAAtBDEEEQcDDwwAoAgAiAEGkBiAAGxEAAAAL9gECA38BfiMAQSBrIgMkAAJAIAEEQCABKAIAIgRBf0cNARCnCwALEKYLAAsgASAEQQFqNgIAIANBCGoiBCACvSIGQiCIPgIEIAQgBj4CACABQQRqIAMoAgggAygCDBCkCCIEBEAgA0EQaiEFAkAgBCgCZEUEQCAFQQA2AgAMAQsgBSAEQfgAaikDADcCBCAFQQE2AgALIAMoAhAiBARAIAMoAhQhBSADIANBGGooAgA2AgQgAyAFNgIAIAMrAwAhAgsgASABKAIAQQFrNgIAIAAgAjkDCCAAIAQ2AgAgA0EgaiQADwtBmLbAAEHMAEGMt8AAEJoLAAu5AQEGfSMAQSBrIgQkACAEIAIqAgAiByADQQRqKgIAIAJBDGoqAgAiCZMiBZQgAyoCACACQQhqKgIAIgqTIgYgAkEEaioCACIIlJM4AgQgBCAGIAeUIAUgCJSSOAIAIARBCGogASkCACABQQhqKQIAIAQQoAIgBCoCCCEFIAQqAgwhBiAAIAQtABA6AAggACAJIAggBZQgByAGlJKSOAIEIAAgCiAHIAWUIAggBpSTkjgCACAEQSBqJAALuwECAX8EfSMAQSBrIgQkACAEIAEqAgAiBSACQQRqKgIAIAFBDGoqAgCTIgaUIAIqAgAgAUEIaioCAJMiByABQQRqKgIAIgiUkzgCBCAEIAcgBZQgBiAIlJI4AgAgBEEIaiAAKQIAIABBCGopAgAgBBCgAiAELQAQIQAgBCoCCCAEKgIAkyIFIAWUIAQqAgwgBCoCBJMiBSAFlJJDAAAAAJIQdiEFIARBIGokACAFIAUgBYwgAEEBRxsgAxsLsQEBCX0gASoCACEEIAMqAgAgAkEIaioCACIKkyIFIAIqAgAiBpQgA0EEaioCACACQQxqKgIAIguTIgcgAkEEaioCACIIlJIiCSAJlCAGIAeUIAUgCJSTIgUgBZSSQwAAAACSIgcQdiEMIABCATcCDCAAIAcgBCAElF86AAggACALIAYgBSAEIAyVIgSUIgWUIAggCSAElCIElJKSOAIEIAAgCiAGIASUIAggBZSTkjgCAAvHAQIBfwF9IwBBMGsiBSQAIAVBCGogASACIAJBCGoQoAFBACECAkAgBSgCCEUNAAJAIAVBFGoqAgAiBkMAAAAAXUUEQCADIAZgRQ0CIAVBGGooAgAhASAAIAUpAgw3AgQMAQsgBUEoaigCACEBIARFBEAgBUEkaioCACIGIANfRQ0CIAAgBUEcaikCADcCBAwBCyAAQgA3AgRDAAAAACEGCyAAQRBqIAE2AgAgAEEMaiAGOAIAQQEhAgsgACACNgIAIAVBMGokAAutAQIGfQF/QQEhCiAAQQRqKgIAIgggASoCACIEIAJBBGoqAgAgAUEMaioCAJMiBZQgAioCACABQQhqKgIAkyIGIAFBBGoqAgAiB5STjJQgACoCACIJIAYgBJQgBSAHlJKUkyIFQwAAAABeBH9BAQUgBSAJIAcgAkEMaioCACIFlCAEIAJBCGoqAgAiBpSSlCAIIAQgBZQgByAGlJOUkpUiBEMAAAAAYCADIARgcQsLzwECAX8CfSMAQSBrIgMkACABKgIAIgQgBJQgAUEEaioCACIEIASUkkMAAAAAkhB2IQQgASoCCCIFQwAAAABgRQRAIANBFGpBATYCACADQRxqQQA2AgAgA0Hg+sEANgIQIANB5PDBADYCGCADQQA2AgggA0EIakHU/cEAELwJAAsgACAEIAWSOAIIIAAgAioCAEMAAAAAlCIEIAJBBGoqAgBDAAAAAJQiBZIgAkEMaioCAJI4AgQgACACQQhqKgIAIAQgBZOSOAIAIANBIGokAAu0AQIBfwR9IwBBMGsiBCQAIAQgASoCACIFIAJBBGoqAgAgAUEMaioCAJMiBpQgAioCACABQQhqKgIAkyIHIAFBBGoqAgAiCJSTOAIMIAQgByAFlCAGIAiUkjgCCCAEQRBqIAAgBEEIaiADEGkgBC0AGCEAIAQqAhAgBCoCCJMiBSAFlCAEKgIUIAQqAgyTIgUgBZSSQwAAAACSEHYhBSAEQTBqJAAgBSAFIAWMIABBAUcbIAMbC78BAgN/AX4jAEEQayIDJAACQCAABEAgACgCACICQX9HDQEQpwsACxCmCwALIAAgAkEBajYCACADQQhqIgIgAb0iBUIgiD4CBCACIAU+AgAgAEEEaiADKAIIIAMoAgwQhwciBARAQQMhAiAEQZgBai0AAEEDayIEQf8BcUEETQRAIARBGHRBGHVBAnRB7LvAAGooAgAhAgsgACAAKAIAQQFrNgIAIANBEGokACACDwtBqLLAAEHQAEGos8AAEJoLAAuvEQMWfwF+BH0jAEEQayIOJAACQAJAIABFDQAgACgCACIGQX9GDQEgACAGQQFqNgIAIAFFDQAgASgCACIGQX9GDQEgASAGQQFqNgIAIAJFDQAgAigCACIGQX9GDQEgAiAGQQFqNgIAIA4gAzYCDCMAQdABayIDJAAgAyAOQQxqNgJIIAFBBGopAgAhGiACQQRqIgYqAgQhGyAGKgIAIRwgAyADQcgAajYCTCADIBwgGqe+Ih2SvK0gGyAaQiCIp74iHpK8rUIghoQ3A7gBIAMgHSAck7ytIB4gG5O8rUIghoQ3A7ABIANB0ABqIANBsAFqEPkFIAMgA0HMAGo2ApABIANBADYCqAEgA0KAgICAwAA3A6ABAkAgAEEEaiIEQRhqKAIAIgpFDQAgA0GgAWpBABC9BCADKAKkASIJIAMoAqgBIgZBAnRqQQA2AgAgBkEBaiIGRQ0AIARBFGohFSAEQThqIRYgBEE8aiEXA0AgAyAGQQFrIgY2AqgBAkACQAJAAkACQCAJIAZBAnRqKAIAIgQgCkkEQCAVKAIAIARB4ABsaiIILQBYQQFxBEAgCCgCQCEEIAhBxABqKAIAIQsgCEHIAGooAgAhECAWKAIAIQwgFygCACENIAhBzABqKAIAIREgA0GwAWogCCADQdAAahDhAiADLQCzASISQQN0QQhxIAMtALIBIhNBAnRBBHEgAy0AsQEiFEEBdEECcSADLQCwASIPQQFxcnJyIhitIhpCAYNQDQUgDCAEQQR0akEAIAQgDUkbIgRFDQUgBEEMaigCACEFIARBCGooAgAhBCADKAKQASgCACgCACEHIANBITYCyAEgA0FAayIZIAU2AgQgGSAENgIAIAMgAysDQBABNgLMASADQThqIAcgA0HIAWogA0HMAWoQzAggAygCPCEEIAMoAjgNAkEBIQVBACEHAkACQAJAIAQQAw4CAAECC0EAIQUMAQtBASEHQQAhBQsgBSAHciEFIARBJEkNBAwDCyADQbABaiAIIANB0ABqEOECIAMtALMBIRIgAy0AsgEhEyADLQCxASEUIAMtALABIQ8MBQsgBCAKQcCVwAAQowcAC0EBIQUgBEEjTQ0BCyAEEAALIAMoAswBIgRBJE8EQCAEEAALIAMoAsgBIgRBJE8EQCAEEAALIAVFDQMLAkAgGkICg1ANACAMIAtBBHRqQQAgCyANSRsiBEUNACAEQQhqQQAgBBsiBEEEaigCACEFIAMoApABKAIAKAIAIQcgBCgCACEEIANBITYCyAEgA0EwaiILIAU2AgQgCyAENgIAIAMgAysDMBABNgLMASADQShqIAcgA0HIAWogA0HMAWoQzAggAygCLCEHAkACQCADKAIoBEBBASEEIAdBI0sNAQwCC0EBIQRBACEFAkACQAJAIAcQAw4CAQACC0EBIQVBACEEDAELQQAhBAsgBCAFciEEIAdBJEkNAQsgBxAACyADKALMASIFQSRPBEAgBRAACyADKALIASIFQSRPBEAgBRAACyAERQ0DCwJAIBpCBINQDQAgDCAQQQR0akEAIA0gEEsbIgRFDQAgBEEIakEAIAQbIgRBBGooAgAhBSADKAKQASgCACgCACEHIAQoAgAhBCADQSE2AsgBIANBIGoiCyAFNgIEIAsgBDYCACADIAMrAyAQATYCzAEgA0EYaiAHIANByAFqIANBzAFqEMwIIAMoAhwhBQJAAkAgAygCGARAQQEhBCAFQSNLDQEMAgtBASEEQQAhBwJAAkACQCAFEAMOAgEAAgtBASEHQQAhBAwBC0EAIQQLIAQgB3IhBCAF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EEYCQAJAAkAgAy0AzAciFEECaw4CAQACCyADKALwBiECDAILQQJByIvAAEG0gcAAELsGIQIMAQsgAygC8AYhAiADQZgGaiAQQdgAEK4LGiADQdUFaiAfQcMAEK4LGiADQfAGaiADQcgFahC8AgJAAkACQCADKALwBg4DAQIAAgsgAygC9AYhAgwCC0EDQciLwABBtIHAABC7BiECDAELIANBmAhqIh0gEEEIaigCADYCACADIBApAgA3A5AIAkAgAygCyAUEQCADKALMBSIBKAIEIh5BA00EQCADQoHKADcD8AYgA0HwBmoQ6wkhAgwDCyABIB5BBGsiKjYCBCABIAEoAgAiBEEEajYCACAqQQNLDQEgA0KBygA3A/AGIANB8AZqEOsJIQIMAgtBBEHIi8AAQbSBwAAQuwYhAgwBCyAEKAAAISogASAeQQhrNgIEIAEgBEEIajYCACAEKAAEIR4gA0GtBGogA0HVBWpBwwAQrgsaIANBqARqIgEgHSgCADYCACADIAMpA5AINwOgBCADQfAEaiADQZgGakHYABCuCxogFEECRg0AIANByANqIANB8ARqQdgAEK4LGiADQYUDaiADQa0EakHDABCuCxogA0GAA2oiBCABKAIANgIAIAMgAykDoAQ3A/gCIBRBA0YNACADQaACaiADQcgDakHYABCuCxogA0HdAWogA0GFA2pBwwAQrgsaIANB2AFqIh0gBCgCADYCACADIAMpA/gCNwPQASAMKAIEIgRBA00EQCADQoHKADcD8AYgA0HwBmoQ6wkhAgwBCyAMIARBBGsiJzYCBCAMIAwoAgAiAUEEajYCACAnQQNNBEAgA0KBygA3A/AGIANB8AZqEOsJIQIMAQsgASgAACEnIAwgBEEIayIhNgIEIAwgAUEIajYCACAhQQNNBEAgA0KBygA3A/AGIANB8AZqEOsJIQIMAQsgASgABCEhIAwgBEEMayIoNgIEIAwgAUEMajYCACAoQQNLDQEgA0KBygA3A/AGIANB8AZqEOsJIQILIAMoAhhFDQwgCxCHAQwMCyAGQQFrIQYgASgACCEoIAwgBEEQazYCBCAMIAFBEGo2AgAgASgADCEEIANB+ABqIgEgA0GgAmpB2AAQrgsaIANBNWoiJiADQd0BakHDABCuCxogA0EwaiIsIB0oAgA2AgAgAyADKQPQATcD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IgQgAUFAayoCACIFkyIDIAOUIAFBzABqKgIAIgMgAUHEAGoqAgAiB5MiBiAGlJJDAAAAAJIQdkMAAAA/lDgCCCAAIAIqAgAiBiAHIAOSQwAAAD+UIgOUIAUgBJJDAAAAP5QiBCACQQRqKgIAIgWUkiACQQxqKgIAkjgCBCAAIAJBCGoqAgAgBCAGlCADIAWUk5I4AgALpgEDAX8DfQF+IwBBIGsiAiQAIAEqAggiA0MAAAAAYEUEQCACQRRqQQE2AgAgAkEcakEANgIAIAJB4PrBADYCECACQeTwwQA2AhggAkEANgIIIAJBCGpB6PrBABC8CQALIAAgAyABKQIAIganviIEkjgCCCAAQQxqIAMgBkIgiKe+IgWSOAIAIAAgBIwgA5O8rSAFjCADk7ytQiCGhDcCACACQSBqJAALoQQBBX8jAEFAaiICJAAgAkEIaiEDIwBBQGoiACQAIABBFGpCCDcCACAAQgA3AgwgAEEANgIIIABBADYCACAAQQA2AjggAEEgakHABEEIIABBMGoQzwUgACgCJCEBAkACQAJAAkAgACgCIARAIABBKGooAgAiBEGBgICAeEYNASAERQ0DIAEgBEHAw8MAKAIAIgBBpAYgABsRAAAACyAAQQQ2AhAgACABNgIUDAELIABBEGpBAEEEELMEIAAoAhQhASAAKAIYIQQLIANCATcCGCADQgA3AgggA0KAgICAwAA3AgAgA0EwaiAEQQRqNgIAIANBEGpCBDcCACABIARBkAFsaiIBQQE2AgggAUKAgICAEDcDACADQSBqIABBCGopAwA3AgAgA0EoaiAAQRBqKQMANwIAIAFBmAFqQQI2AgAgAUGQAWpCgICAgBA3AwAgAUGoAmpBAzYCACABQaACakKAgICAEDcDACABQbADakIANwMAIABBQGskAAwBCxCKCQALQThBBBDQCiIARQRAQThBBEHAw8MAKAIAIgBBpAYgABsRAAAACyAAQQA2AgAgACACKQMINwIEIABBDGogAkEQaikDADcCACAAQRRqIAJBGGopAwA3AgAgAEEcaiACQSBqKQMANwIAIABBJGogAkEoaikDADcCACAAQSxqIAJBMGopAwA3AgAgAEE0aiACQThqKAIANgIAIAJBQGskACAAC9wBAgJ/AX4jAEEQayIFJAACQCAABEAgACgCAEUNARCnCwALEKYLAAsgAEF/NgIAAkAgAkEDSQRAIAUgAb0iB0IgiD4CBCAFIAc+AgAgAEEEaiAFKAIAIAUoAgQQhwciBkUNASAFIAQ4AgwgBSADOAIIIAYgBi0AmQFBASACQf8BcSICdHI6AJkBIAYgAkEMbGoiAkEgaiAFQQhqIgYqAgA4AgAgAkEkaiAGKgIEOAIAIABBADYCACAFQRBqJAAPC0HCt8AAQRkQpQsAC0GossAAQdAAQbizwAAQmgsAC68BAQF/IwBBEGsiBiQAAkAgAQRAIAYgASADIAQgBSACKAIQEQgAIAYoAgQhAQJAIAYoAgAiAyAGKAIIIgJNBEAgASEEDAELIANBAnQhAyACRQRAQQQhBCABEIcBDAELIAEgA0EEIAJBAnQiARC/CiIERQ0CCyAAIAI2AgQgACAENgIAIAZBEGokAA8LQcy8wABBMBClCwALIAFBBEHAw8MAKAIAIgBBpAYgABsRAAAAC6cBAgF/An4gAEEsaiABKQIIIgOnIgI2AgAgAEEoaiACNgIAIABBJGogAjYCACAAIAI2AiAgACABKQIAIgSnIgE2AgwgACABNgIIIAAgATYCBCAAIAE2AgAgAEE8aiADQiCIpyIBNgIAIABBOGogATYCACAAQTRqIAE2AgAgAEEwaiABNgIAIAAgBEIgiKciATYCHCAAIAE2AhggACABNgIUIAAgATYCEAueAQEFfSAAIAFBCGoqAgAiBCABKgIAIgWTIgMgA5QgAUEMaioCACIDIAFBBGoqAgAiB5MiBiAGlJJDAAAAAJIQdkMAAAA/lDgCCCAAIAIqAgAiBiAHIAOSQwAAAD+UIgOUIAUgBJJDAAAAP5QiBCACQQRqKgIAIgWUkiACQQxqKgIAkjgCBCAAIAJBCGoqAgAgBCAGlCADIAWUk5I4AgALngEBBX0gACABQTBqKgIAIgQgASoCKCIFkyIDIAOUIAFBNGoqAgAiAyABQSxqKgIAIgeTIgYgBpSSQwAAAACSEHZDAAAAP5Q4AgggACACKgIAIgYgByADkkMAAAA/lCIDlCAFIASSQwAAAD+UIgQgAkEEaioCACIFlJIgAkEMaioCAJI4AgQgACACQQhqKgIAIAQgBpQgAyAFlJOSOAIAC2UAIAAoAhgEQCAAQRxqKAIAEIcBCyAAQUBrKAIABEAgAEHEAGooAgAQhwELIAAoAgAEQCAAQQRqKAIAEIcBCyAAKAIMBEAgAEEQaigCABCHAQsgACgCJARAIABBKGooAgAQhwELC7QBAgN/AX4jAEEQayICJAACQCAABEAgACgCACIDQX9HDQEQpwsACxCmCwALIAAgA0EBajYCACACQQhqIgMgAb0iBUIgiD4CBCADIAU+AgAgAEEEaiACKAIIIAIoAgwQhwciA0UEQEGossAAQdAAQaizwAAQmgsACyADQaABaigCACEEIAIgA0GkAWooAgA2AgQgAiAENgIAIAIrAwAhASAAIAAoAgBBAWs2AgAgAkEQaiQAIAELtAECA38BfiMAQRBrIgIkAAJAIAAEQCAAKAIAIgNBf0cNARCnCwALEKYLAAsgACADQQFqNgIAIAJBCGoiAyABvSIFQiCIPgIEIAMgBT4CACAAQQRqIAIoAgggAigCDBCHByIDRQRAQaiywABB0ABBqLPAABCaCwALIANBqAFqKAIAIQQgAiADQawBaigCADYCBCACIAQ2AgAgAisDACEBIAAgACgCAEEBazYCACACQRBqJAAgAQurAQIDfwF+IwBBEGsiAiQAAkAgAARAIAAoAgAiA0F/Rw0BEKcLAAsQpgsACyAAIANBAWo2AgAgAkEIaiIDIAG9IgVCIIg+AgQgAyAFPgIAIABBBGogAigCCCACKAIMEKQIIgNFBEBBmLbAAEHMAEGMt8AAEJoLAAsgAiADKQNINwMAIAIoAgQhAyACKAIAIQQgACAAKAIAQQFrNgIAIAJBEGokACADIARBEHRyC68BAgN/AX4jAEEQayICJAACQCAABEAgACgCACIDQX9HDQEQpwsACxCmCwALIAAgA0EBajYCACACQQhqIgMgAb0iBUIgiD4CBCADIAU+AgAgAEEEaiACKAIIIAIoAgwQpAgiA0UEQEGYtsAAQcwAQYy3wAAQmgsACyACIANB0ABqKQMANwMAIAIoAgQhAyACKAIAIQQgACAAKAIAQQFrNgIAIAJBEGokACADIARBEHRyC88DAgp/AX4jAEEQayIEJAACQCAABEAgACgCACIDQX9HDQEQpwsACxCmCwALIAAgA0EBajYCACAEQQhqIgMgAb0iDUIgiD4CBCADIA0+AgAgBCgCDCEDIAQoAgghBSAEIAK9Ig1CIIg+AgQgBCANPgIAIAQoAgAhByAEKAIEIQlBAiEMAkAgAEEEaiIKQUBrKAIAIgsgBU0NACADIApBPGooAgAiCCAFQQxsaigCAEcNACAHIAtPDQAgCSAIIAdBDGxqIgMoAgBHDQAgCkEoaigCACIJIAggBUEMbGpBCGooAgAiBU0NACADQQhqKAIAIQsgCkEwaigCACEHAkAgCkEkaigCACAFQQR0akEAIAUgCUkbIgUoAggiBiAKQTRqKAIAIghJBEADQCAHIAZBFGxqIgNBDGooAgAgC0YNAiAIIAMoAgAiBksNAAsLIAggBUEMaigCACIGTQ0BA0AgByAGQRRsaiIDKAIIIAtGDQEgCCADKAIEIgZLDQALDAELIAYgCE8NACAHIAZBFGxqIgNBCGooAgAgCU8NACADQQxqKAIAIAlPDQAgByAGQRRsai0AECEMCyAAIAAoAgBBAWs2AgAgBEEQaiQAIAxB/QFxC5gBAgF/BH0jAEEQayIEJAAgBCACKgIAIgUgA0EEaioCACIGlCACQQRqKgIAIgcgAyoCACIIlJM4AgQgBCAFIAiUIAcgBpSSOAIAIARBCGogASAEELUCIAAgByAEKgIIIgaUIAUgBCoCDCIIlJIgAkEMaioCAJI4AgQgACAFIAaUIAcgCJSTIAJBCGoqAgCSOAIAIARBEGokAAuXAQEDfyMAQRBrIgIkACACQQhqIABByABqIgEgABC1CCAAQdgAaiACKQMINwMAIABB5ABqIABB0ABqKAIAIgM2AgAgAEHgAGogAzYCACAAQewAaiABKgIMOAIAIABB8ABqLQAAIgFBAXEEQCAAQQA2AmALIAFBAnEEQCAAQQA2AmQLIAFBIHEEQCAAQQA2AmwLIAJBEGokAAumAQIBfQF+IABBLGogASoCCCICOAIAIABBKGogAjgCACAAQSRqIAI4AgAgACACOAIgIABBPGogAUEMaioCACICOAIAIABBOGogAjgCACAAQTRqIAI4AgAgAEEwaiACOAIAIAAgASkCACIDpyIBNgIMIAAgATYCCCAAIAE2AgQgACABNgIAIAAgA0IgiKciATYCHCAAIAE2AhggACABNgIUIAAgATYCEAthACAAKAIEBEAgAEEIaigCABCHAQsgACgCEARAIABBFGooAgAQhwELIAAoAhwEQCAAQSBqKAIAEIcBCyAAKAIoBEAgAEEsaigCABCHAQsgACgCNARAIABBOGoo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QQFrIgVFBEBBBCELQQAhBUEADAILIAVB/////wBLDQIgBUEDdCICQQBIDQIgBUGAgICAAUlBAnQhASACBH8gAiABENAKBSABCyILBEAgBa0iGkIDgyEbIBpCAX1CA1oEQCAaQvz///8PgyEcIAshAUKAgICAICEaA0AgAUEYaiAaQoCAgIAgfCAZQgN8hDcCACABQRBqIBpCgICAgBB8IBlCAnyENwIAIAFBCGogGiAZQgF8hDcCACABIBpCgICAgBB9IBmENwIAIAFBIGohASAaQoCAgIBAfSEaIARBBGohBCAcIBlCBHwiGVINAAsLIBtQRQRAIAsgBEEDdGohASAZQiCGQoCAgIAQfCEaA0AgASAZIBqENwIAIAFBCGohASAaQoCAgIAQfCEaIBlCAXwhGSAbQgF9IhtCAFINAAsLIAUMAgsgAiABQcDDwwAoAgAiAEGkBiAAGxEAAAALIAEoAgghBSABKAIACyEVIANBIGpCBDcDACADQRhqQgA3AwBBACEBIANBMGpBADYCACADQoCAgIDAADcDKCADQoCAgICAAjcDECADQv////v///+/fzcDCCADQv////v3//+//wA3AwAgA0EBOgBHIAVFDQMgBUECdCIBQQQQ0AoiAkUNByADQQA2AlAgAyACNgJMIAMgBTYCSCAFQf///z9LDQAgBUEEdCIHQQBIDQAgBUGAgIDAAElBAnQhAiAHBH8gByACENAKBSACCyIBRQ0EIAMgATYCXCADIAU2AlggBUECSQ0BIAVBAWsiBkEHcSEEIAVBAmtBB08EQCAGQXhxIQYDQCABQv////v///+/fzcCCCABQv////v3//+//wA3AgAgAUH4AGpC////+////79/NwIAIAFB8ABqQv////v3//+//wA3AgAgAUHoAGpC////+////79/NwIAIAFB4ABqQv////v3//+//wA3AgAgAUHYAGpC////+////79/NwIAIAFB0ABqQv////v3//+//wA3AgAgAUHIAGpC////+////79/NwIAIAFBQGtC////+/f//7//ADcCACABQThqQv////v///+/fzcCACABQTBqQv////v3//+//wA3AgAgAUEoakL////7////v383AgAgAUEgakL////79///v/8ANwIAIAFBGGpC////+////79/NwIAIAFBEGpC////+/f//7//ADcCACABQYABaiEBIAZBCGsiBg0ACyABQRBrIQYLIAQEQANAIAFC////+////79/NwIIIAFC////+/f//7//ADcCACABQRBqIQEgBEEBayIEDQALIAFBEGshBgsgAUL////79///v/8ANwIAIAZBGGpC////+////79/NwIAIAMgBTYCYCAFQarVqtUASw0AIAVBDGwMAgsQigkACyABQv////v///+/fzcCCCABQv////v3//+//wA3AgAgAyAFNgJgQQwLIgFBBBDQCiIPBEAgBUEDdCECIA8hAQJAIAVBAkkNACAFQQFrIgdBA3EhBCAFQQJrQQNPBEAgB0F8cSEGA0AgAUJ/NwIIIAFBADoABCABQX82AgAgAUEsakF/NgIAIAFBKGpBADoAACABQSBqQn83AgAgAUEcakEAOgAAIAFBFGpCfzcCACABQRBqQQA6AAAgAUEwaiEBIAZBBGsiBg0ACwsgBEUNAANAIAFBfzYCCCABQQA6AAQgAUF/NgIAIAFBDGohASAEQQFrIgQNAAsLIAIgC2ohFiABQX82AgggAUEAOgAEIAFBfzYCACADIAU2AjwgAyAPNgI4IAMgBTYCNCADQTRqIRcgBSEHQQAhBCALIRACQAJAA0ACQAJAIA5BCGooAgAiASAQKAIAIgJLBEAgEEEEaigCACIIIAFPDQEgBEEBaiEMIA5BBGooAgAiASAIQQN0aiIIKAIAIRMgCCgCBCEUIAEgAkEDdGopAgAhGSAEIAdJDQIgDCAHIgJrIQggCCADKAI0IAJrSwRAIBcgByAIELUEIAMoAjghDyADKAI8IQILIA8gAkEMbGohASAIQQJPBEAgBCAHayIGQQNxIQ0gBCAHQX9zakEDTwRAIAZBfHEhBgNAIAFCfzcCCCABQQA6AAQgAUF/NgIAIAFBLGpBfzYCACABQShqQQA6AAAgAUEgakJ/NwIAIAFBHGpBADoAACABQRRqQn83AgAgAUEQakEAOgAAIAFBMGohASAGQQRrIgYNAAsLIA0EQCARIAdrQQNxIQYDQCABQX82AgggAUEAOgAEIAFBfzYCACABQQxqIQEgBkEBayIGDQALCyACIAhqQQFrIQILIAMgByAMRwR/IAFBfzYCCCABQQA6AAQgAUF/NgIAIAJBAWoFIAILIgc2AjwgAwJ/IAwgAygCYCIIIARLDQAaIAwgCCICayENIA0gAygCWCACa0sEQCADQdgAaiAIIA0QuQQgAygCYCECCyADKAJcIAJBBHRqIQEgDUECTwRAIAQgCGsiBkEHcSEYIAQgCEF/c2pBB08EQCAGQXhxIQYDQCABQv////v///+/fzcCCCABQv////v3//+//wA3AgAgAUH4AGpC////+////79/NwIAIAFB8ABqQv////v3//+//wA3AgAgAUHoAGpC////+////79/NwIAIAFB4ABqQv////v3//+//wA3AgAgAUHYAGpC////+////79/NwIAIAFB0ABqQv////v3//+//wA3AgAgAUHIAGpC////+////79/NwIAIAFBQGtC////+/f//7//ADcCACABQThqQv////v///+/fzcCACABQTBqQv////v3//+//wA3AgAgAUEoakL////7////v383AgAgAUEgakL////79///v/8ANwIAIAFBGGpC////+////79/NwIAIAFBEGpC////+/f//7//ADcCACABQYABaiEBIAZBCGsiBg0ACwsgGARAIBIgCGtBB3EhBgNAIAFC////+////79/NwIIIAFC////+/f//7//ADcCACABQRBqIQEgBkEBayIGDQALCyACIA1qQQFrIQILIAIgCCAMRg0AGiABQv////v///+/fzcCCCABQv////v3//+//wA3AgAgAkEBags2AmAMAgsgAiABQYyuwgAQowcACyAIIAFBnK7CABCjBwALIAQgB08NASAPIARBDGxqIAQ2AgggAygCYCIBIARNDQIgEEEIaiEQIAMoAlwgBEEEdGoiASAZIBStQiCGIhogGae+Ih1DAAAAAJQiISAZQiCIp74iHpIgE74iH0MAAAAAlCIiIBS+IiCSXhtCIIg+AgwgASAZIBOtIhsgHkMAAAAAlCIjIB2SICBDAAAAAJQiJCAfkl4bPgIIIAEgGSAaICEgHpMgIiAgk14bQiCIPgIEIAEgGSAbICMgHZMgJCAfk14bPgIAIAMoAlAiASADKAJIRgRAIANByABqIAEQvQQgAygCUCEBCyADKAJMIAFBAnRqIAQ2AgAgAyABQQFqNgJQIBJBAWohEiARQQFqIREgDCEEIBAgFkcNAAsgAygCECIBIAMoAhgiBEcNBgwFCyAEIAdB6IPCABCjBwALIAQgAUH4g8IAEKMHAAsMBAsgA0EANgJQIANCgICAgMAANwNIIANBADYCPCADQoCAgIDAADcCNCADQQA2AmAgA0KAgICAwAA3A1gMAQsgByACQcDDwwAoAgAiAEGkBiAAGxEAAAALIANBEGogARDFBCADKAIYIQQLIAMoAhQgBEHgAGxqIgFCfzcCRCABQQE2AkAgAUL////7////v383AzggAUL////7////v383AzAgAUL////7////v383AyggAUL////7////v383AyAgAUL////79///v/8ANwMYIAFC////+/f//7//ADcDECABQv////v3//+//wA3AwggAUL////79///v/8ANwMAIAFBADoAVCABQQA6AFggAUHMAGpCfzcCACADIARBAWo2AhggA0HoAGogAyADQccAaiADKAJMIgIgAygCUCADQdgAakEAQQAQOCADIANB9ABqKQIAIhk3AwggAyADKQJsIho3AwAgAygCGARAIAMoAhQiASAaPgIAIAFB////ezYCPCABQv////v///+/fzcCNCABQf///3s2AiwgAUL////7////v383AiQgASAZPgIgIAFC////+/f//7//ADcDGCABQf////sHNgIUIAFB////+wc2AgwgAUL////79///v/8ANwIEIAEgGUIgiD4CMCABIBpCIIg+AhAgAygCWARAIAMoAlwQhwELIAMoAkgEQCACEIcBCyAJIAMpAwA3AgAgCUE4aiADQThqKQMANwIAIAlBMGogA0EwaikDADcCACAJQShqIANBKGopAwA3AgAgCUEgaiADQSBqKQMANwIAIAlBGGogA0EYaikDADcCACAJQRBqIANBEGopAwA3AgAgCUEIaiADQQhqKQMANwIAIAkgDikCADcCQCAJQcgAaiAOQQhqKAIANgIAIAlB1ABqIAU2AgAgCUHQAGogCzYCACAJIBU2AkwgA0GAAWokAAwCC0EAQQBB2IPCABCjBwALIAFBBEHAw8MAKAIAIgBBpAYgABsRAAAAC0HgAEEEENAKIgFFBEBB4ABBBEHAw8MAKAIAIgBBpAYgABsRAAAACyABQoGAgIAQNwIAIAFBCGogCkEIakHYABCuCxogAEGcvcIANgIEIAAgATYCACAKQYABaiQAC+EBAgR/AX4jAEEQayIDJAACQCAABEAgACgCAEUNARCnCwAL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AEEQayIEJAACQCAABEAgACgCAEUNARCnCwALEKYLAAsgAEF/NgIAIARBCGoiAyABvSIFQiCIPgIEIAMgBT4CACAAQQRqIAQoAgggBCgCDBDzBSIDRQRAQZi2wABBzABBnLfAABCaCwALIAJBAEciAiADLQCAAUEAR3MEQCADIAI6AIABIAMgAygCMEHAAHI2AjALIABBADYCACAEQRBqJAALoAECBH8BfiMAQRBrIgAkABC4CiECIAAQuAo2AgwgAEEMaigCAEEYaikDACEEQSBBCBDQCiIBBEAgASACNgIYIAFCADcDECABIAQ3AwggAUKBgICAEDcDACAAKAIMIgMoAgAhAiADIAJBAWs2AgAgAkEBRgRAIAAoAgwQmAgLIABBEGokACABDwtBIEEIQcDDwwAoAgAiAEGkBiAAGxEAAAALgAEBAX8jAEEwayIDJAAgAyACNgIEIAMgATYCACADQQhqIgFBDGpBAjYCACADQRxqQQI2AgAgA0EgaiICQQxqQQI2AgAgA0GQlMAANgIQIANBADYCCCADQQM2AiQgAyAANgIgIAMgAjYCGCADIAM2AiggARDrBSEAIANBMGokACAAC4kFAQh/IwBBIGsiBSQAIAUgATYCGCAFIAA2AhQgBSABNgIQIAVBCGohCiMAQRBrIgckAEEEIQACQAJAAkACQCAFQRBqIglBCGooAgAiAwRAIAlBBGooAgAhCCADQQFxIANBAXZqIgYEQCAGQf////8ASw0CIAZBA3QiBEEASA0CIAZBgICAgAFJQQJ0IQEgBAR/IAQgARDQCgUgAQsiAEUNAwtBACEBQQAhBANAIANBAU0NBCAAIAFqIAEgCGopAgA3AgAgAUEIaiEBIARBAWohBCADQQJrIgMNAAsLIAdBCGohCCMAQUBqIgEkACABQSBqIgMgACAEEMkDIAFBMGoiBEEIaiADQQhqKAIANgIAIAEgASkDIDcDMCABQQhqIAQQiwECQAJAAkAgASgCDEUEQEEAIQMMAQtBJEEEENAKIgNFDQEgA0KBgICAEDcCACADIAEpAwg3AgggAyACOAIgIANBEGogAUEQaikDADcCACADQRhqIAFBGGopAwA3AgALIAhB6NnCADYCBCAIIAM2AgAgAUFAayQADAELQSRBBEHAw8MAKAIAIgBBpAYgABsRAAAACyAHKAIMIQEg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IAAgAiACIAQgBhsgBCAEXBsiAiACIAMgAiADXRsgAyADXBs4AgAgAEEMaiABQRRqKgIAIgMgAyABQQxqKgIAIgQgBCABKgIEIgIgAiAEXRsgAiACXBsiBSADIAVeGyAFIAVcGzgCACAAIAIgAiAEIAIgBF0bIAQgBFwbIgIgAiADIAIgA10bIAMgA1wbOAIEC2sBAX8jAEEgayICJAAgAkGA8sIANgIEIAIgADYCACACQQhqIgBBEGogAUEQaikCADcDACAAQQhqIAFBCGopAgA3AwAgAiABKQIANwMIQQAgAkH88sIAIAJBBGpB/PLCACAAQaT7wgAQuwIAC2gBAX8jAEEgayIDJAAgA0G0+8IANgIEIAMgADYCACADQQhqIgBBEGogAUEQaikCADcDACAAQQhqIAFBCGopAgA3AwAgAyABKQIANwMIQQAgA0GM88IAIANBBGpBjPPCACAAIAIQuwIAC2ABAX8jAEEgayICJAAgAiAAKAIANgIEIAJBCGoiAEEQaiABQRBqKQIANwMAIABBCGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakGoksAAIAAQ4AEhACACQSBqJAAgAAtpAgF/An0jAEEgayIFJAAgASoCACEGIAEqAgQhByAFIAEpAgA3AxggBSAHjDgCFCAFIAaMOAIQIAVBCGogBUEQaiACIAMgBBCIAyAFKAIIIQEgACAFKgIMOAIEIAAgATYCACAFQSBqJAAL5AIBAn8jAEGwAmsiAiQAAkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBADYCACACQZgBaiIBIABBmAEQrgsaIAIgAUEEckGUARCuCyEBIAAQhwEgASgCQCIAKAIAIQIgACACQQFrNgIAIAJBAUYEQCABQUBrKAIAIAFBxABqKAIAEJ0HCyABKAIQBEAgAUEUaigCABCHAQsgASgCHARAIAFBIGooAgAQhwELIAEoAigEQCABQSxqKAIAEIcBCyABKAI0BEAgAUE4aigCABCHAQsgASgCSARAIAFBzABqKAIAEIcBCyABQdQAaigCAARAIAFB2ABqKAIAEIcBCyABQeAAaigCAARAIAFB5ABqKAIAEIcBCyABQewAaigCAARAIAFB8ABqKAIAEIcBCyABQfgAaigCAARAIAFB/ABqKAIAEIcBCyABQYQBaigCAARAIAFBiAFqKAIAEIcBCyABQbACaiQAC18BAn8jAEGgAWsiASQAAkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBADYCACABQdAAaiICIABB0AAQrgsaIAEgAkEEckHMABCuCyEBIAAQhwEgARD8BSABQaABaiQAC18BAn8jAEGgAWsiASQAAkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBADYCACABQdAAaiICIABB0AAQrgsaIAEgAkEEckHMABCuCyEBIAAQhwEgARCiBCABQaABaiQAC18BAn8jAEHQAWsiASQAAkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBADYCACABQegAaiICIABB6AAQrgsaIAEgAkEEckHkABCuCyEBIAAQhwEgARCYAiABQdABaiQAC/oCAgV/AX4CQAJAIABFDQAgACgCAA0BIABBfzYCACACRQ0AIAIoAgAiA0F/Rg0BIAIgA0EBajYCACACQQRqIQYjAEEgayIDJAAgA0EYaiIEIAG9IghCIIg+AgQgBCAIPgIAAkAgAEEEaiADKAIYIAMoAhwQ8wUiBARAIANBEGogBBCxCQJAAkACQAJAIAMoAhAgAygCFCgClAERBABB/wFxQQFrDgsAAwMDAwMDAwMDAQMLIAMgBBDsCCADKAIAIQUgAygCBCEHIwBBEGsiBCQAIARBCGogBSAHKAJkEQAAIAQoAggiBSAEKAIMQQxqKAIAEQYAIQggBEEQaiQAIAVBACAIQq+wnvDdjZiavH9RGyIEDQEMAgsgA0EIaiAEEOwIIAMoAgggAygCDBD6CCIERQ0BCyAEIAYpAgA3AgALIANBIGokAAwBC0GYtsAAQcwAQZy3wAAQmgsACyACIAIoAgBBAWs2AgAgAEEANgIADwsQpgsACxCnCwALXwECfyMAQZABayIBJAACQCAABEAgACgCAEUNARCnCwALEKYLAAsgAEEANgIAIAFByABqIgIgAEHIABCuCxogASACQQRyQcQAEK4LIQEgABCHASABEOIDIAFBkAFqJAAL7goBIX8jAEHACGsiAiQAIwBBgANrIgEkACABQZABaiIAQQhqIgNCADcDACAAQRBqIgRCADcDACABQfgAaiIAQQhqIgVCADcDACAAQRBqIgZCADcDACABQeAAaiIAQQhqIgdCADcDACAAQRBqIghCADcDACABQcgAaiIAQQhqIglCADcDACAAQRBqIgpCADcDACABQagBaiIAQRBqIgtCADcDACAAQQhqIgxCADcDACABQaACaiIAQQhqIg1CADcDACAAQRBqIg5CADcDACABQYgCaiIAQQhqIg9CADcDACAAQRBqIhBCADcDACABQfABaiIAQQhqIhFCADcDACAAQRBqIhJCADcDACABQdgBaiIAQQhqIhNCADcDACAAQRBqIhRCADcDACABQcABaiIAQQhqIhVCADcDACAAQRBqIhZCADcDACABQegCaiIAQQhqIhdCADcDACAAQRBqIhhCADcDACABQdACaiIAQQhqIhlCADcDACAAQRBqIhpCADcDACABQbgCaiIAQQhqIhtCADcDACAAQRBqIhxCADcDACABQTBqIgBBEGoiHUIANwMAIABBCGoiHkIANwMAIAFBGGoiAEEQaiIfQgA3AwAgAEEIaiIgQgA3AwAgAkEIaiIAIAEpA5ABNwO4ASAAQcABaiADKQMANwMAIABByAFqIAQpAwA3AwAgAEHgAWogBikDADcDACAAQdgBaiAFKQMANwMAIAAgASkDeDcD0AEgAEH4AWogCCkDADcDACAAQfABaiAHKQMANwMAIAAgASkDYDcD6AEgAEGQAmogCikDADcDACAAQYgCaiAJKQMANwMAIAAgASkDSDcDgAIgAUEQaiIDQgA3AwAgAUEIaiIEQgA3AwAgAEHAAmogCykDADcDACAAQbgCaiAMKQMANwMAIAAgASkDqAE3A7ACIABBGGogDikDADcDACAAQRBqIA0pAwA3AwAgACABKQOgAjcDCCAAQTBqIBApAwA3AwAgAEEoaiAPKQMANwMAIAAgASkDiAI3AyAgAEHIAGogEikDADcDACAAQUBrIBEpAwA3AwAgACABKQPwATcDOCAAQeAAaiAUKQMANwMAIABB2ABqIBMpAwA3AwAgACABKQPYATcDUCAAQfgAaiAWKQMANwMAIABB8ABqIBUpAwA3AwAgACABKQPAATcDaCAAQfgCaiAYKQMANwMAIABB8AJqIBcpAwA3AwAgACABKQPoAjcD6AIgAEGQA2ogGikDADcDACAAQYgDaiAZKQMANwMAIAAgASkD0AI3A4ADIABBqANqIBwpAwA3AwAgAEGgA2ogGykDADcDACAAIAEpA7gCNwOYAyAAQgA3A4ABIABCADcDACAAIAEpAzA3A4gBIABBkAFqIB4pAwA3AwAgAEGYAWogHSkDADcDACAAIAEpAxg3A6ABIABBqAFqICApAwA3AwAgAEGwAWogHykDADcDACAAIAEpAwA3A5gCIABBoAJqIAQpAwA3AwAgAEGoAmogAykDADcDACAAQZAEakIENwMAIABBiARqQgA3AwAgAEKAgICAwAA3A4AEIABB+ANqQgQ3AwAgAEHwA2pCADcDACAAQoCAgIDAADcD6AMgAEHgA2pCBDcDACAAQdgDakIANwMAIABCgICAgMAANwPQAyAAQQE6AMgDIABBADYCwAMgAEIANwO4AyAAQgA3A+ACIABBADYC2AIgAEIANwPQAiABQYADaiQAIAJBqARqIABBmAQQrgsaQaAEQQgQ0AoiAEUEQEGgBEEIQcDDwwAoAgAiAEGkBiAAGxEAAAALIABBADYCACAAQQRqIAJBpARqQZwEEK4LGiACQcAIaiQAIAALaQECfyMAQYABayICJAAgAkHwAGpCAjcDACACQQA2AnggAkKAgICAEDcDaCACQRBqIgNBAEHYABCtCxogAiAAQQRqKAIAIABBCGooAgAgAyABKQIAQQEQGSACLQAIIQAgAkGAAWokACAAC1wBBH0gACoCACACKgIAIAFBCGoqAgCTIgMgASoCACIElCACQQRqKgIAIAFBDGoqAgCTIgUgAUEEaioCACIGlJKUIABBBGoqAgAgBCAFlCADIAaUk5SSQwAAAABfC2ABAX8jAEEgayICJAAgAiAAKAIANgIEIAJBCGoiAEEQaiABQRBqKQIANwMAIABBCGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakHI8cIAIAAQ4AEhACACQSBqJAAgAAtgAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQQhqIgBBEGogAUEQaikCADcDACAAQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBlP/CACAAEOABIQAgAkEgaiQAIAALXgEDfyMAQSBrIgIkACABKAIEIQMgASgCACEEIAJBCGoiAUEQaiAAQRBqKQIANwMAIAFBCGogAEEIaikCADcDACACIAApAgA3AwggBCADIAEQ4AEhACACQSBqJAAgAAtgAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQQhqIgBBEGogAUEQaikCADcDACAAQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBqKHDACAAEOABIQAgAkEgaiQAIAALXgEDfyMAQSBrIgIkACAAKAIEIQMgACgCACEEIAJBCGoiAEEQaiABQRBqKQIANwMAIABBCGogAUEIaikCADcDACACIAEpAgA3AwggBCADIAAQ4AEhACACQSBqJAAgAAtdAQF/IwBBIGsiAiQAIAIgADYCBCACQQhqIgBBEGogAUEQaikCADcDACAAQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBqJLAACAAEOABIQAgAkEgaiQAIAALiAgCDn8BfiMAQRBrIgkkAAJAIAAEQCAAKAIAIgRBf0cNARCnCwALEKYLAAsgACAEQQFqNgIAIAkgAjYCDCAJQQxqIQpBACEEIwBB0AFrIgMkACADQSE2AhwgA0EQaiICIAG9IhFCIIg+AgQgAiARPgIAIANBIGohAiADKAIUIQggAygCECIGIABBBGoiBUEgaigCAEkEQCAFQRxqKAIAIAZBA3RqIgRBBGpBACAEKAIAIAhGGyEECyACQQI6ADggAkECOgAcIAIgBTYCBCACIAQ2AgAgA0HgAGoiBEE4aiACQThqKQMANwMAIARBMGogAkEwaikDADcDACAEQShqIAJBKGopAwA3AwAgBEEgaiACQSBqKQMANwMAIARBGGogAkEYaikDADcDACAEQRBqIAJBEGopAwA3AwAgBEEIaiILIAJBCGopAwA3AwAgAyADKQMgNwNgIARBJGohDANAAkAgA0G4AWogCxDnAgJAAkAgAygCyAENAAJAAkACQANAAkAgAygCZCIFRQ0AIAMoAmAhByADQQA2AmAgB0UNACAFQRRqIg0oAgAhBiAFQRBqIg4oAgAhCEF/IQRBfyECIAcoAgAiByAFQQhqIg8oAgBJBEAgBUEEaigCACAHQQR0aiIEKAIIIQIgBEEMaigCACEECyADIAU2AoABIANBADoAfCADIAc2AnggAyAINgJwIAMgBDYCbCADIAY2AnQgAyACNgJoAkACQCACIAZJBEAgAyAIIAJB1AFsaigCADYCaAwBCwNAIAYgBCICTQ0CIAMgCCACQdQBbGoiECgCBCIENgJsIBAoAgggB0YNAAsLIA0oAgAgAk0NAyACQdQBbCIHIA4oAgBqIgZB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NwIEIABBADYCACAAC+8CAQN/IwBBoAFrIgEkACABQQhqIQBBCEEEENAKIgJFBEBBCEEEQcDDwwAoAgAiAEGkBiAAGxEAAAALIAAgAjYCQCACQoGAgIAQNwIAIABBiq6P4QM2ApABIABCBDcCOCAAQgA3AjAgAEKAgICAwAA3AiggAEIENwIgIABCADcCGCAAQoCAgICAAjcCECAAQv////v///+/fzcCCCAAQv////v3//+//wA3AgAgAEKAgICAwAA3AkggAEHEAGpBsNHBADYCACAAQdAAakIANwIAIABB2ABqQgQ3AgAgAEHgAGpCgICAgMAANwIAIABB6ABqQgA3AgAgAEHwAGpCBDcCACAAQfgAakKAgICAEDcCACAAQYABakIANwIAIABBiAFqQgQ3AgBBmAFBBBDQCiIARQRAQZgBQQRBwMPDACgCACIAQaQGIAAbEQAAAAsgAEEANgIAIABBBGogAUEIakGUARCuCxogAUGgAWokACAAC2QBAX9BFEEEENAKIgJFBEBBFEEEQcDDwwAoAgAiAEGkBiAAGxEAAAALIAIgASkCADcCACACQRBqIAFBEGooAgA2AgAgAkEIaiABQQhqKQIANwIAIABBlLTCADYCBCAAIAI2AgALZAEBf0EYQQQQ0AoiAkUEQEEYQQRBwMPDACgCACIAQaQGIAAbEQAAAAsgAiABKQIANwIAIAJBEGogAUEQaikCADcCACACQQhqIAFBCGopAgA3AgAgAEGct8IANgIEIAAgAjYCAAtOACAAIAEtAAMgAi0AA3FBAXE6AAMgACABLQACIAItAAJxQQFxOgACIAAgAS0AASACLQABcUEBcToAASAAIAEtAAAgAi0AAHFBAXE6AAALUgEBfyMAQSBrIgMkACADQQxqQQE2AgAgA0EUakEANgIAIANB6ILDADYCECADQQA2AgAgAyABNgIcIAMgADYCGCADIANBGGo2AgggAyACELwJAAv2AQIDfwF+AkAgAARAIAAoAgAiAkF/Rw0BEKcLAAsQpgsACyAAIAJBAWo2AgAjAEEQayICJAAgAkEIaiIDIAG9IgVCIIg+AgQgAyAFPgIAIAIgAEEEaiACKAIIIAIoAgwQ0AUCQAJAIAIoAgAiAwRAIAIoAgQiBCADQaABaigCAE8NASADQZwBaigCACAEQYQCbGpB6AFqMQAA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akIENwIAIABCADcCDCAAQQA2AgggAEEANgIAIABBADYCOCAAQSBqQTBBBCAAQTBqEM8FIAAoAiQhAgJAAkACQAJAAkACQCAAKAIgBEAgAEEoaigCACIDQYGAgIB4Rg0BIANFDQMgAiADQcDDwwAoAgAiAEGkBiAAGxEAAAALIABBBDYCECAAIAI2AhQMAQsgAEEQakEAQQQQtQQgACgCFCECIAAoAhghAwsgAiADQQxsaiICQQE2AgggAkKAgICAEDcCACACQRRqQQI2AgAgAkEMakKAgICAEDcCACACQSBqQQM2AgAgAkEYakKAgICAEDcCACACQSRqQgA3AgAgAEIBNwMAIAAgA0EEajYCGEGgAUEEENAKIgJFDQFByBBBBBDQCiIDRQ0CIAFCADcCFCABIAApAwA3AjAgAUKAgICAwAA3AiQgASADNgIQIAFCgICAgKABNwIIIAEgAjYCBCABQQo2AgAgAUEcakIENwIAIAFBLGpBADYCACABQThqIABBCGopAwA3AgAgAUFAayAAQRBqKQMANwIAIAFByABqIABBGGooAgA2AgAgAEFAayQADAMLEIoJAAtBoAFBBEHAw8MAKAIAIgBBpAYgABsRAAAAC0HIEEEEQcDDwwAoAgAiAEGkBiAAGxEAAAALQdAAQQQQ0AoiAEUEQEHQAEEEQcDDwwAoAgAiAEGkBiAAGxEAAAALIABBADYCACAAQQRqIAFBzAAQrgsaIAFB0ABqJAAgAAtDAQF/AkAgAARAIAAoAgAiAUF/Rw0BEKcLAAsQpgsACyAAIAFBAWo2AgAgAEEYaigCACEBIAAgACgCAEEBazYCACABC8sCAQR/IwBB0ABrIgAkACMAQSBrIgEkACABQRRqQgQ3AgAgAUIANwIMIAFBADYCCCABQQA2AgAgAUEEEPMBAkACQEGgAUEEENAKIgIEQEGgAUEEENAKIgNFDQIgACABKQMANwIwIABCgICAgMAANwIkIABCADcCFCAAIAM2AhAgAEKAgICAoAE3AgggACACNgIEIABBCjYCACAAQRxqQgQ3AgAgAEEsakEANgIAIABByABqIAFBGGooAgA2AgAgAEFAayABQRBqKQMANwIAIABBOGogAUEIaikDADcCACABQSBqJAAMAQsMAQtB0ABBBBDQCiIBRQRAQdAAQQRBwMPDACgCACIAQaQG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BCAOKAIAIgJPDQQgBUEMaigCACIFIAJPDQUgBkEkaigCACECIAMgByAIakEQai0AADoA6AEgAyACIAVBBHRqKQIANwPgASADIAIgBEEEdGopAgA3A9gBDAYLIANBAjoAjAEgAygCsAEiAkECRw0ACwsgA0HAAWogCxDlAgwEC0HQhcAAQStBwKbAABDJCAALIAQgAkGgpsAAEKMHAAsgBSACQbCmwAAQowcACyADQcABaiICQRBqIANB2AFqIgRBEGooAgA2AgAgAkEIaiAEQQhqKQMANwMAIAMgAykD2AE3A8ABCyADLQDQASICQQJGBEAgAygCLCICQSRPBEAgAhAACyADKAIoIgJBJE8EQCACEAALIANB8AFqJAAMAQsgAkUNAQJ/IAMoAsABIgIgCUYgAygCxAEiBCAKRnFFBEAgA0EYaiIGIAQ2AgQgBiACNgIAIAMoAhghBCADKAIcDAELIAMoAsgBIQIgA0EQaiIEIAMoAswBNgIEIAQgAjYCACADKAIQIQQgAygCFAshAiADIAStIAKtQiCGhL8QATYC2AEgA0EIaiADQShqIANBLGogA0HYAWoQzAggAygCDCICQSRPBEAgAhAACyADKALYASICQSRJDQEgAhAADAELCyAAIAAoAgBBAWs2AgALQwAgASgCDCACQQJ0a0EEaygCACIBIAAoAgAiAEEEaigCACICTwRAIAEgAkGo98AAEKMHAAsgACgCACABQQR0ajUCCAtDACABKAIMIAJBAnRrQQRrKAIAIgEgACgCACIAQQRqKAIAIgJPBEAgASACQaj3wAAQowcACyAAKAIAIAFBDGxqNQIIC0MAIAEoAgwgAkECdGtBBGsoAgAiASAAKAIAIgBBBGooAgAiAk8EQCABIAJBqPfAABCjBwALIAAoAgAgAUEUbGo1AhALngQBDH8jAEEQayIFJAAgASABKAIwQSByNgIwIAVBCGohBiMAQSBrIgMkACABQSBqIgEoAgAiBCgCBCECIARBfyACIAJBAUYbNgIEAkACQCACQQFHDQAgASgCACICQQE2AgQgAigCAEEBRw0AIAEoAgAiAiABKAIEKAIIQQdqQXhxag0BCyADQRhqIAEoAgAiByABQQRqKAIAIgIoAghBB2pBeHFqIAIoAoQBEQAAIAMoAhghCCADQRBqIAMoAhwiCUEEaigCACIEIAlBCGooAgAiChDaBiADKAIUIQsgAygCECEMIANBCGogBCAKENoGIAMoAgwhAiADKAIIIg0EQCANIAIQ0AohAgsgAgRAIAJCgYCAgBA3AgAgAiAKQQdqQXhxaiAIIAQQrgsaIAQEQCAIEIcBCyAHIAcoAgAiBEEBazYCACAEQQFGBEAgASgCACABQQRqKAIAEJ0HCyABIAI2AgAgAUEEaiAJNgIADAELIAwgC0HAw8MAKAIAIgBBpAYgABsRAAAACyACQX8gAigCBCICIAJBAUYbNgIEAkACQCACQQFHDQAgASgCACICQQE2AgQgAigCAEEBRw0AIAEoAgAgASgCBCIBKAIIQQdqQXhxaiICDQELQYD5wQBBK0GQ3MIAEMkIAAsgBiABNgIEIAYgAjYCACADQSBqJAAgBSgCDCEBIAAgBSgCCDYCACAAIAE2AgQgBUEQaiQAC0MAIAEoAgwgAkECdGtBBGsoAgAiASAAKAIAIgBBBGooAgAiAk8EQCABIAJB8PbBABCjBwALIAAoAgAgAUEEdGo1AggLPgEBfiAAIAIpAgA3AhAgACABKQIAIgM3AgggACADp74gAioCAJO8rSADQiCIp74gAioCBJO8rUIghoQ3AgALPQIBfQJ+IAAgASoCACIEIAMpAgAiBae+lCACKQIIIganvpI4AgAgACAEIAVCIIinvpQgBkIgiKe+kjgCBAtOAgF/AX4jAEEQayICJAAgAkEIaiAAIAEoAmARAAAgAigCCCIAIAIoAgxBDGooAgARBgAhAyACQRBqJAAgAEEAIANC3NrvqcaA+cQPURsLTwIBfwF+IwBBEGsiAiQAIAJBCGogACABKAJgEQAAIAIoAggiACACKAIMQQxqKAIAEQYAIQMgAkEQaiQAIABBACADQq+wnvDdjZiavH9RGwtOAgF/AX4jAEEQayICJAAgAkEIaiAAIAEoAmARAAAgAigCCCIAIAIoAgxBDGooAgARBgAhAyACQRBqJAAgAEEAIANC7fmwytqr/r0OURsLTgIBfwF+IwBBEGsiAiQAIAJBCGogACABKAJgEQAAIAIoAggiACACKAIMQQxqKAIAEQYAIQMgAkEQaiQAIABBACADQoqn7c/lxYupS1EbC04CAX8BfiMAQRBrIgIkACACQQhqIAAgASgCZBEAACACKAIIIgAgAigCDEEMaigCABEGACEDIAJBEGokACAAQQAgA0KKp+3P5cWLqUtRGwtOAgF/AX4jAEEQayICJAAgAkEIaiAAIAEoAmARAAAgAigCCCIAIAIoAgxBDGooAgARBgAhAyACQRBqJAAgAEEAIANC4O2c+JSZ5qBUURsLTgIBfwF+IwBBEGsiAiQAIAJBCGogACABKAJgEQAAIAIoAggiACACKAIMQQxqKAIAEQYAIQMgAkEQaiQAIABBACADQtzu1a/owbCje1EbC04CAX8BfiMAQRBrIgIkACACQQhqIAAgASgCYBEAACACKAIIIgAgAigCDEEMaigCABEGACEDIAJBEGokACAAQQAgA0KSgfXh1pKmyGZRGwtPAgF/AX4jAEEQayICJAAgAkEIaiAAIAEoAmARAAAgAigCCCIAIAIoAgxBDGooAgARBgAhAyACQRBqJAAgAEEAIANC68HJuoa29uX5AFEbC08CAX8BfiMAQRBrIgIkACACQQhqIAAgASgCYBEAACACKAIIIgAgAigCDEEMaigCABEGACEDIAJBEGokACAAQQAgA0K1vOqW9qvlmYp/URsLTwIBfwF+IwBBEGsiAiQAIAJBCGogACABKAJkEQAAIAIoAggiACACKAIMQQxqKAIAEQYAIQMgAkEQaiQAIABBACADQrW86pb2q+WZin9RGwtOAgF/AX4jAEEQayICJAAgAkEIaiAAIAEoAmARAAAgAigCCCIAIAIoAgxBDGooAgARBgAhAyACQRBqJAAgAEEAIANC1ZGu7POCm4UrURsLTgIBfwF+IwBBEGsiAiQAIAJBCGogACABKAJgEQAAIAIoAggiACACKAIMQQxqKAIAEQYAIQMgAkEQaiQAIABBACADQsCBuKve2cK9K1EbC0MBAX8gAiAAKAIAIAAoAggiA2tLBEAgACADIAIQ7gQgACgCCCEDCyAAKAIEIANqIAEgAhCuCxogACACIANqNgIIQQALTAEBfyMAQfAAayIEJAAgBEHgAGpCAjcDACAEQQA2AmggBEKAgICAEDcDWCAAIAEgBEEAQdgAEK0LIgAgAikCACADEBogAEHwAGokAAtMAQF/IwBB8ABrIgQkACAEQeAAakICNwMAIARBADYCaCAEQoCAgIAQNwNYIAAgASAEQQBB2AAQrQsiACACKQIAIAMQHCAAQfAAaiQAC0wBAX8jAEHwAGsiBCQAIARB4ABqQgI3AwAgBEEANgJoIARCgICAgBA3A1ggACABIARBAEHYABCtCyIAIAIpAgAgAxAbIABB8ABqJAALQgEDfSACKgIAIgQgBJQgAioCBCIDIAOUkkMAAAAAkhB2IQUgACADIAWVIAEqAgAiA5Q4AgQgACADIAQgBZWUOAIAC/wBAgJ/AX4CQCAABEAgACgCAEUNARCnCwALEKYLAAsgAEF/NgIAIAJBAEchBCADQQBHIQUjAEEQayIDJAAgA0EIaiICIAG9IgZCIIg+AgQgAiAGPgIAAkACQAJAIABBBGogAygCCCADKAIMEPIFIgIEQCACQfAAai0AAEEHcUEHRg0DIAItANkBDQIgBQ0BDAILQYC1wABBzQBBiLbAABCaCwALIAJB1AFqLQAABEAgAiACKAKoAUEEcjYCqAELIAJBADoA1AEgAkHQAWpBADYCAAsgAiACLQBwQfgBcUEHQQAgBBtyOgBwIAIQgwYLIANBEGokACAAQQA2AgAL/AECAn8BfgJAIAAEQCAAKAIARQ0BEKcLAAsQpgsACyAAQX82AgAgAkEARyEEIANBAEchBSMAQRBrIgMkACADQQhqIgIgAb0iBkIgiD4CBCACIAY+AgACQAJAAkAgAEEEaiADKAIIIAMoAgwQ8gUiAgRAIAJB8ABqLQAAQThxQThGDQMgAi0A2QENAiAFDQEMAgtBgLXAAEHNAEGItsAAEJoLAAsgAkHUAWotAAAEQCACIAIoAqgBQQRyNgKoAQsgAkEAOgDUASACQdABakEANgIACyACIAItAHBBxwFxQThBACAEG3I6AHAgAhCDBgsgA0EQaiQAIABBADYCAAtAAQJ/AkAgAARAIAAoAgAiAUF/Rw0BEKcLAAsQpgsACyAAIAFBAWo2AgAgACgCBEEgaigCACECIAAgATYCACACC0EBAn8CQCAABEAgACgCACIBQX9HDQEQpwsACxCmCwALIAAgAUEBajYCACAAKAIEQZABaigCACECIAAgATYCACACC0ABAn8CQCAABEAgACgCACIBQX9HDQEQpwsACxCmCwALIAAgAUEBajYCACAAKAIEQShqKAIAIQIgACABNgIAIAILKAAgACgCAARAIABBBGooAgAQhwELIAAoAgwEQCAAQRBqKAIAEIcBCwuHAQAgAEL////7////v383AyAgAEL////79///v/8ANwMYIABC////+/f//7//ADcDECAAQv////v3//+//wA3AwggAEL////79///v/8ANwMAIABBOGpC////+////79/NwMAIABBMGpC////+////79/NwMAIABBKGpC////+////79/NwMAC0oBAX8jAEEgayIAJAAgAEEUakEBNgIAIABBHGpBADYCACAAQYD5wgA2AhAgAEHg8cIANgIYIABBADYCCCAAQQhqQbj5wgAQvAkAC0oBAX8jAEEgayIAJAAgAEEUakEBNgIAIABBHGpBADYCACAAQdz/wgA2AhAgAEGs/8IANgIYIABBADYCCCAAQQhqQeT/wgAQvAkACz8BAX8jAEEgayIFJAAgBUEIaiABIAIgAyAEEKgBIAUoAhAhASAAIAUqAhg4AgQgACABQQNHNgIAIAVBIGokAAs/AQF/IwBBIGsiBSQAIAVBCGogASACIAMgBBDlASAFKAIQIQEgACAFKgIYOAIEIAAgAUEDRzYCACAFQSBqJAALtAICAn8BfgJAIAAEQCAAKAIARQ0BEKcLAAsQpgsACyAAQX82AgAgBEEARyEGIwBBEGsiBSQAIAVBCGoiBCABvSIHQiCIPgIEIAQgBz4CAAJAIABBBGogBSgCCCAFKAIMEPIFIgQEQAJAAkAgBCoCCCACXA0AIARBDGoqAgAgA1wNACAEQRhqKgIAIAJcDQAgBEEcaioCACADWw0BCyAEIAI4AgggBEEcaiADOAIAIARBGGogAjgCACAEQQxqIAM4AgAgBCAEKAKoAUECcjYCqAEgBBCDBiAGRQ0AIAQtANkBDQAgBEHUAWotAAAEQCAEIAQoAqgBQQRyNgKoAQsgBEEAOgDUASAEQdABakEANgIACyAFQRBqJAAMAQtBgLXAAEHNAEGItsAAEJoLAAsgAEEANgIACz8BAX8jAEEgayIFJAAgBUEIaiABIAIgAyAEEKkBIAUoAhAhASAAIAUqAhg4AgQgACABQQNHNgIAIAVBIGokAAs/AQF/IwBBIGsiBSQAIAVBCGogASACIAMgBBDRASAFKAIQIQEgACAFKgIYOAIEIAAgAUEDRzYCACAFQSBqJAALPAAjAEEgayIEJAAgBEEIaiABIAIgA0EAEGYgBCgCECEBIAAgBCoCGDgCBCAAIAFBA0c2AgAgBEEgaiQACz8BAX8jAEEg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aiAAKQIAIABBCGopAgAgARCPAiACLQAQIQAgAkEgaiQAIABBAEcLOAEBfyMAQSBrIgQkACAEIAEgAiADEGkgAEEIaiAEQQhqKAIANgIAIAAgBCkDADcCACAEQSBqJAALVAEBf0EGQQEQ0AoiAUUEQEEGQQFBwMPDACgCACIAQaQGIAAbEQAAAAsgAUEEakHAt8AALwAAOwAAIAFBvLfAACgAADYAACAAIAE2AgAgAEEGNgIECzUAAkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBADYCACAAQRhqIAE4AgAgAEEUakEBNgIACzUAAkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBADYCACAAQRBqIAE4AgAgAEEMakEBNgIACzsBAX8gAEEANgIMIAAgAUEgaigCACICNgIIIAAgAUEYaigCADYCACAAIAIgAUEkaigCAEHoAWxqNgIEC1gBA38jAEEQayICJAAgAkEIaiIDIAFBIGoiASgCBCIENgIEIAMgASgCACAEKAIIQQdqQXhxajYCACACKAIMIQEgACACKAIINgIAIAAgATYCBCACQRBqJAALOwEBfyAAQQA2AgwgACABQSxqKAIAIgI2AgggACABQSRqKAIANgIAIAAgAiABQTBqKAIAQZABbGo2AgQLOAEBfyMAQSBrIgQkACAEIAEgAiADEDAgAEEIaiAEQQhqKAIANgIAIAAgBCkDADcCACAEQSBqJAALNwEBfyMAQSBrIgIkACACQQhqIAApAgAgAEEIaikCACABEKACIAItABAhACACQSBqJAAgAEEARws4AQF/IwBBIGsiBCQAIAQgASACIAMQdSAAQQhqIARBCGooAgA2AgAgACAEKQMANwIAIARBIGokAAvAAgIEfwF+AkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBfzYCACMAQSBrIgQkACAEQRhqIgMgAb0iB0IgiD4CBCADIAc+AgACQCAAQQRqIAQoAhggBCgCHBDzBSIDBEAgBEEQaiADELEJAkACQAJAAkAgBCgCECAEKAIUKAKUAREEAEH/AXEOAwADAQMLIAQgAxDsCCAEKAIAIQUgBCgCBCEGIwBBEGsiAyQAIANBCGogBSAGKAJkEQAAIAMoAggiBSADKAIMQQxqKAIAEQYAIQcgA0EQaiQAIAVBACAHQtza76nGgPnED1EbIgMNAQwCCyAEQQhqIAMQ7AggBCgCCCAEKAIMEPQIIgNFDQEgA0EQaiEDCyADIAI4AgALIARBIGokAAwBC0GYtsAAQcwAQZy3wAAQmgsACyAAQQA2AgAL8AEDAn8BfgF9AkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBfzYCACMAQSBrIgMkACADQRhqIgQgAb0iBUIgiD4CBCAEIAU+AgACQCAAQQRqIAMoAhggAygCHBDzBSIEBEAgA0EQaiAEELEJAkAgAygCECADKAIUKAKUAREEAEH/AXFBAkcNACADQQhqIAQQ7AggAygCCCADKAIMEPQIIgRFDQAgBCACjDgCBCAEIAJDAAAAAJQiBow4AgAgBCAGvK0gArytQiCGhDcCCAsgA0EgaiQADAELQZi2wABBzABBnLfAABCaCwALIABBADYCAAu3AwIEfwF+AkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBfzYCACMAQTBrIgQkACAEQShqIgMgAb0iB0IgiD4CBCADIAc+AgACQCAAQQRqIAQoAiggBCgCLBDzBSIDBEAgBEEgaiADELEJAkACfwJAAkACQCAEKAIgIAQoAiQoApQBEQQAQf8BcUELaw4DAAECBAsgBEEIaiADEOwIIAQoAgggBCgCDBD6CCIDRQ0DIANBCGoMAgsgBEEQaiADEOwIIAQoAhAhBSAEKAIUIQYjAEEQayIDJAAgA0EIaiAFIAYoAmQRAAAgAygCCCIFIAMoAgxBDGooAgARBgAhByADQRBqJAAgBUEAIAdC1ZGu7POCm4UrURsiA0UNAiADQRhqDAELIARBGGogAxDsCCAEKAIYIQUgBCgCHCEGIwBBEGsiAyQAIANBCGogBSAGKAJkEQAAIAMoAggiBSADKAIMQQxqKAIAEQYAIQcgA0EQaiQAIAVBACAHQsCBuKve2cK9K1EbIgNFDQEgA0EYagsgAjgCAAsgBEEwaiQADAELQZi2wABBzABBnLfAABCaCwALIABBADYCAAtDAQF/QQxBBBDQCiICRQRAQQxBBEHAw8MAKAIAIgJBpAYgAhsRAAAACyACQQA2AgAgAiAAvK0gAbytQiCGhDcCBCACCzcAIABCADcCECAAIAEpAgA3AgAgAEEYakIANwIAIABBIGpBADYCACAAQQhqIAFBCGopAgA3AgALPwAgACABKAIAQf////8HcSACKAIAQYCAgIB4cXKtIAEoAgRB/////wdxIAIoAgRBgICAgHhxcq1CIIaENwIAC+QCAQJ/IwBBIGsiAiQAIAJBAToAGCACIAE2AhQgAiAANgIQIAJBqJ3DADYCDCACQeiCwwA2AggjAEEQayIBJAACQCACQQhqIgAoAgwiAgRAIAAoAggiA0UNASABIAI2AgggASAANgIEIAEgAzYCACMAQRBrIgAkACAAQQhqIAFBCGooAgA2AgAgACABKQIANwMAIwBBEGsiASQAIAAoAgAiAkEUaigCACEDAkACfwJAAkAgAkEMaigCAA4CAAEDCyADDQJBACECQeDxwgAMAQsgAw0BIAIoAggiAygCBCECIAMoAgALIQMgASACNgIEIAEgAzYCACABQbT4wgAgACgCBCIBKAIIIAAoAgggAS0AEBD+BAALIAFBADYCBCABIAI2AgwgAUGg+MIAIAAoAgQiASgCCCAAKAIIIAEtABAQ/gQAC0Gc88IAQStB8PfCABDJCAALQZzzwgBBK0Hg98IAEMkIAAszAAJAIABB/P///wdLDQAgAEUEQEEEDwsgACAAQf3///8HSUECdBDQCiIARQ0AIAAPCwALNgEBfUMAAAAAIAAqAgAgASoCAJQgAEEEaioCACABQQRqKgIAlJIiAyACGyADIANDAAAAAF0bC0MBAX8gACgCACEBAkAgAEEEai0AAA0AQdTDwwAoAgBB/////wdxRQ0AQcTHwwAoAgBFDQAgAUEBOgABCyABQQA6AAALMAEBfyMAQSBrIgMkACADQQhqIAAgASACQQEQqAEgAygCECEAIANBIGokACAAQQNHCzABAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBEOUBIAMoAhAhACADQSBqJAAgAEEDRwsuAAJAIAAEQCAAKAIARQ0BEKcLAAsQpgsACyAAQQA2AgAgAEE4aiABQQBHOgAACzABAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBEKkBIAMoAhAhACADQSBqJAAgAEEDRws0AQF/IAAgATYCDCAAQQA2AgggACABQRxqKAIAIgI2AgQgACACIAFBIGooAgBBFGxqNgIACzcAIAAgBDgCICAAIAEpAgA3AgAgACADKQIANwIYIAAgAikCADcCECAAQQhqIAFBCGopAgA3AgALMAEBfyMAQSBrIgMkACADQQhqIAAgASACQQEQ8QEgAygCECEAIANBIGokACAAQQNHCzABAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBEMsBIAMoAhAhACADQSBqJAAgAEEDRwsvAQF/IwBBIGsiAyQAIANBCGogACABIAJBABBmIAMoAhAhACADQSBqJAAgAEEDRwsvAQF/IwBBIGsiAyQAIANBCGogACABIAJBARB7IAMoAhAhACADQSBqJAAgAEEDRwswAQF/IwBBIGsiAyQAIANBCGogACABIAJBARCnASADKAIQIQAgA0EgaiQAIABBA0cLLwEBfyMAQRBrIgMkACADQQhqIAAgASACQQEQMSADKAIIIQAgA0EQaiQAIABBAUYLLwEBfyMAQRBrIgMkACADQQhqIAAgASACQQEQPCADKAIIIQAgA0EQaiQAIABBAUYLMAEBfyMAQSBrIgMkACADQQhqIAAgASACQQAQqAEgAygCECEAIANBIGokACAAQQNHCy8BAX8jAEEQayIDJAAgA0EIaiAAIAEgAkEBEDQgAygCCCEAIANBEGokACAAQQFGCz4AIAAoAgAhACABLQAYQRBxQQR2RQRAIAEtABhBIHFBBXZFBEAgACABEJkLDwsgACABEJMGDwsgACABEJIGCy4AIwBBEGsiAyQAIAMgACgCADYCDCADQQxqIAEgAiADEOIEIQAgA0EQaiQAIAALUAECfyMAQRBrIgAkACABKAIAQcCUwABBCyABKAIEKAIMEQUAIQMgAEEIaiICQQA6AAUgAiADOgAEIAIgATYCACACEOoFIQEgAEEQaiQAIAEL5AIBA38gACgCACEAIAEtABhBEHFBBHZFBEAgAS0AGEEgcUEFdkUEQCAAMQAAQQEgARCJAw8LIwBBgAFrIgMkACAALQAAIQJBACEAA0AgACADakH/AGpBMEE3IAJBD3EiBEEKSRsgBGo6AAAgAEEBayEAIAJB/wFxIgRBBHYhAiAEQQ9LDQALIABBgAFqIgJBgQFPBEAgAkGAAUHMn8MAEJYLAAsgAUEBQdyfwwBBAiAAIANqQYABakEAIABrELkBIQAgA0GAAWokACAADwsjAEGAAWsiAyQAIAAtAAAhAkEAIQADQCAAIANqQf8AakEwQdcAIAJBD3EiBEEKSRsgBGo6AAAgAEEBayEAIAJB/wFxIgRBBHYhAiAEQQ9LDQALIABBgAFqIgJBgQFPBEAgAkGAAUHMn8MAEJYLAAsgAUEBQdyfwwBBAiAAIANqQYABakEAIABrELkBIQAgA0GAAWokACAAC4UDAgN/AX4gACgCACEAIAEtABhBEHFBBHZFBEAgAS0AGEEgcUEFdkUEQCAALgEAIgCtIgVC//8Dg0IAIAVCMIZCMId9IABBAE4iABsgACABEIkDDwsjAEGAAWsiAyQAIAAvAQAhAkEAIQADQCAAIANqQf8AakEwQTcgAkEPcSIEQQpJGyAEajoAACAAQQFrIQAgAkH//wNxIgRBBHYhAiAEQQ9LDQALIABBgAFqIgJBgQFPBEAgAkGAAUHMn8MAEJYLAAsgAUEBQdyfwwBBAiAAIANqQYABakEAIABrELkBIQAgA0GAAWokACAADwsjAEGAAWsiAyQAIAAvAQAhAkEAIQADQCAAIANqQf8AakEwQdcAIAJBD3EiBEEKSRsgBGo6AAAgAEEBayEAIAJB//8DcSIEQQR2IQIgBEEPSw0ACyAAQYABaiICQYEBTwRAIAJBgAFBzJ/DABCWCwALIAFBAUHcn8MAQQIgACADakGAAWpBACAAaxC5ASEAIANBgAFqJAAgAAtQAQJ/IwBBEGsiACQAIAEoAgBBsdDAAEELIAEoAgQoAgwRBQAhAyAAQQhqIgJBADoABSACIAM6AAQgAiABNgIAIAIQ6gUhASAAQRBqJAAgAQtIAQF9IAEqAgAhAkEEQQQQ0AoiAUUEQEEEQQRBwMPDACgCACIAQaQGIAAbEQAAAAsgASACOAIAIABByKHCADYCBCAAIAE2AgALSAEBfiABKQIAIQJBCEEEENAKIgFFBEBBCEEEQcDDwwAoAgAiAEGkBiAAGxEAAAALIAEgAjcCACAAQYyxwgA2AgQgACABNgIAC0gBAX4gASkCACECQQhBBBDQCiIBRQRAQQhBBEHAw8MAKAIAIgBBpAYgABsRAAAACyABIAI3AgAgAEGkyMIANgIEIAAgATYCAAtQAQJ/IwBBEGsiACQAIAEoAgBBz/XCAEELIAEoAgQoAgwRBQAhAyAAQQhqIgJBADoABSACIAM6AAQgAiABNgIAIAIQ6gUhASAAQRBqJAAgAQsrAAJAIAAEQCAAKAIARQ0BEKcLAAsQpgsACyAAQQA2AgAgAEEkakECNgIACysAAkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBADYCACAAQSBqIAE4AgALKwACQCAABEAgACgCAEUNARCnCwALEKYLAAsgAEEANgIAIABBDGpBAjYCAAsrAAJAIAAEQCAAKAIARQ0BEKcLAAsQpgsACyAAQQA2AgAgAEEMaiABOAIACysAAkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBADYCACAAQRxqIAE4AgALKwACQCAABEAgACgCAEUNARCnCwALEKYLAAsgAEEANgIAIABBJGogATgCAAsrAAJAIAAEQCAAKAIARQ0BEKcLAAsQpgsACyAAQQA2AgAgAEEoaiABNgIACysAAkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBADYCACAAQSxqIAE2AgALKwACQCAABEAgACgCAEUNARCnCwALEKYLAAsgAEEANgIAIABBMGogATYCAAsrAAJAIAAEQCAAKAIARQ0BEKcLAAsQpgsACyAAQQA2AgAgAEE0aiABNgIACysAAkAgAARAIAAoAgBFDQEQpwsACxCmCwALIABBADYCACAAQThqIAE2AgALKwACQCAABEAgACgCAEUNARCnCwALEKYLAAsgAEEANgIAIABBCGogATgCAAstAQF9IAEqAgAiAiAClCABQQRqKgIAIgIgApSSQwAAAACSIAAqAgAiAiAClF8LMAEBfSAAIAEqAgAiAiAClCABQQRqKgIAIgIgApSSQwAAAACSEHY4AgggAEIANwIACykBAX8CQCAAQX9GDQAgACAAKAIEIgFBAWs2AgQgAUEBRw0AIAAQhwELCyoBAX8jAEEgayICJAAgAiAAIAFBARBpIAItAAghACACQSBqJAAgAEEARwsnAAJAIAAEQCAAKAIAQX9HDQEQpwsACxCmCwALIABBJGooAgBBAkcLJwACQCAABEAgACgCAEF/Rw0BEKcLAAsQpgsACyAAQQxqKAIAQQJHC0ABAX4gACkCACEBQRBBBBDQCiIARQRAQRBBBEHAw8MAKAIAIgBBpAYgABsRAAAACyAAIAE3AgQgAEEAOgAAIAALKAAgACgCACgCACIAKQMAIABBCGopAwAgASgCDCACQXRsakEMaxCRAgsoACAAKAIAKAIAIgApAwAgAEEIaikDACABKAIMIAJBaGxqQRhrEKQCCygAIAAoAgAoAgAi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BEHAw8MAKAIAIgBBpAYgABsRAAAACyAAQgA3AgQgAEEANgIAIAALHwACQCAABEAgACgCAA0BIAAQhwEPCxCmCwALEKcLAAtvAQF/IwBBEGsiAyQAIAMgAjYCCCADIAE2AgQgAyAANgIAIwBBEGsiACQAIABBCGogA0EIaigCADYCACAAIAMpAgA3AwAjAEEQayIBJAAgASAAKQIANwMIIAFBCGpBzMzAAEEAIAAoAghBARD+BAALcgEBfyMAQRBrIgEkACABIAA2AgggAUEbNgIEIAFBgPfBADYCACMAQRBrIgAkACAAQQhqIAFBCGooAgA2AgAgACABKQIANwMAIwBBEGsiASQAIAEgACkCADcDCCABQQhqQdzxwQBBACAAKAIIQQEQ/gQACyUAIAAqAgAgASoCAJQgAEEEaioCACABQQRqKgIAlJJDAAAAAF8LKgECfSAAIAEqAgAiAowiAzgCBCAAIAM4AgAgACACvK1CgYCAgBB+NwIICyEBAX8CQCAAQQRqKAIAIgFFDQAgACgCAEUNACABEIcBCwshAAJAIAAEQCAAKAIAQX9HDQEQpwsACxCmCwALIAAqAgQLIAAgAUEBTQRAIAAgAUECdGoPC0Hc/MAAQRsgAhCSCgALKgAgAEEANgJoIABCgICAgBA3AlggAEHgAGpCAjcCACAAQQBB2AAQrQsaCyUAIABFBEBBzLzAAEEwEKULAAsgACACIAMgBCAFIAEoAhARIwALIgECfiAAKQMAIgJCP4chAyACIAOFIAN9IAJCAFkgARCJAwsyAQF/QQRBBBDQCiIARQRAQQRBBEHAw8MAKAIAIgBBpAYgABsRAAAACyAAQQA2AgAgAAsjACAARQRAQcy8wABBMBClCwALIAAgAiADIAQgASgCEBEBAAsjACAARQRAQcy8wABBMBClCwALIAAgAiADIAQgASgCEBEdAAsjACAARQRAQcy8wABBMBClCwALIAAgAiADIAQgASgCEBEYAAskACAARQRAQcy8wABBMBClCwALIAAgAiADIAQgASgCEBGRAQALJAAgAEUEQEHMvMAAQTAQpQsACyAAIAIgAyAEIAEoAhARkwEACzEAIAJCgYCAgCw3AhggAkKAgICApICAgMAANwIQIAIgACkCCDcCCCACIAApAgA3AgALFQAgACgCAARAIABBBGooAgAQhwELCyEAIABFBEBBzLzAAEEwEKULAAsgACACIAMgASgCEBECAAseAQJ9IAAqAgggACoCACIBIAAqAgQiAiABIAJfG5ILJAAgAC0AAEUEQCABQcCiwwBBBRCaAQ8LIAFBvKLDAEEEEJoBCx0AIAEoAgBFBEAACyAAQaCxwAA2AgQgACABNgIACx8AIABFBEBBzLzAAEEwEKULAAsgACACIAEoAhARAwALHQAgASgCAEUEQAALIABB4IvBADYCBCAAIAE2AgALHQAgASgCAEUEQAALIABBrPnBADYCBCAAIAE2AgALHQAgACABKQJANwIAIABBCGogAUHIAGopAgA3AgALHAAgACABKQIANwIAIABBCGogAUEIaikCADcCAAscACAAIAEpAig3AgAgAEEIaiABQTBqKQIANwIACx0AIAEoAgBFBEAACyAAQaTqwgA2AgQgACABNgIACxoAIAFBGGogAikCADcCACAAIAFBoAEQrgsaC4sFAwd/CH0BfiAAIQUgAUHUAGooAgAhCCABQdgAaigCACEBQQAhACMAQSBrIgMkACADQQA2AgggA0KAgICAwAA3AwACQCABRQ0AIAFBGGwhCUEEIQYDQCAEIAhqIgFBFGooAgAhByADQRBqIAFBEGooAgAgBygCCEEHakF4cWogAiAHKAKQAREVACADKgIUIg4gASoCACIPlCADKgIQIhAgAUEEaioCACIRlJIgAUEMaioCAJIhCiABQQhqKgIAIBAgD5QgDiARlJOSIg+8rSAKvK1CIIaEIRIgAyoCHCEQIAsgCkMAAAAAQwAAgD8gAyoCGCIKlSAKQwAAAABbGyIOlJIhCyANIA8gDpSSIQ0gDCAOkiEMIAAgAygCAEYEQCADIAAQvgQgAygCBCEGIAMoAgghAAsgACIBQQR0IAZqIgAgEDgCDCAAIAo4AgggACASNwIAIAMgAUEBaiIANgIIIAkgBEEYaiIERw0AC0MAAAAAIQogDEMAAAAAXgRAIA0gDJUhDSALIAyVIQsLIAMoAgQhBCADKAIAIQYgAARAIAFBBHRBEGohACAEIQEDQEMAAAAAQwAAgD8gASoCDCICIAKUIgKVIAJDAAAAAFsbIQIgASoCCCIOQwAAAABcBEAgAkMAAIA/IA6VIA0gASkCACISp76TIgIgApQgCyASQiCIp76TIgIgApSSQwAAAACS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IAQQvAkACyAAIAIgAyAFGzYCKCAAQTBqIgJBDGpBAzYCACACQRRqQQM2AgAgAEHIAGoiAUEUakG9BjYCACABQQxqQb0GNgIAIABB2KTDADYCOCAAQQA2AjAgAEEBNgJMIAAgATYCQCAAIABBGGo2AlggACAAQRBqNgJQIAAgAEEoajYCSCACIAQQvAkACyADIAVBrKbDABCYCwALIAYgAUEAIAcgBBDLCgALQd2XwwBBKyAEEMkIAAsgBiABIAUgASAEEMsKAAsTACAAQbyQwAA2AgQgACABNgIACxMAIABBzJDAADYCBCAAIAE2AgALEwAgAEHckMAANgIEIAAgATYCAAsPACAAKAIAIAEQhAMaQQALCQAgACABEMACCxYAQYi9wwAgADYCAEGEvcMAQQE6AAALEwAgAEHgzMAANgIEIAAgATYCAAsTACAAQfDMwAA2AgQgACABNgIACxEAIAAoAgAgACgCBCABEKsLCxMAIABB8PHBADYCBCAAIAE2AgALEwAgAEGA8sEANgIEIAAgATYCAAsTACAAQZDywQA2AgQgACABNgIACxMAIABBoPLBADYCBCAAIAE2AgALEwAgAEGw8sEANgIEIAAgATYCAAsTACAAQcDywQA2AgQgACABNgIACxMAIABB0PLBADYCBCAAIAE2AgALEwAgAEHg8sEANgIEIAAgATYCAAsTACAAQfDywQA2AgQgACABNgIACxMAIABBgPPBADYCBCAAIAE2AgALEwAgAEGQ88EANgIEIAAgATYCAAsTACAAQaDzwQA2AgQgACABNgIACxMAIABBsPPBADYCBCAAIAE2AgALEwAgAEHA88EANgIEIAAgATYCAAsTACAAQdDzwQA2AgQgACABNgIACxMAIABB4PPBADYCBCAAIAE2AgALEwAgAEHw88EANgIEIAAgATYCAAsTACAAQYD0wQA2AgQgACABNgIACxMAIABBkPTBADYCBCAAIAE2AgALEAAgAEEDNgIAIAAgATYCBAsQACAAQQQ2AgAgACABNgIECxAAIABBAjYCACAAIAE2AgQLEAAgAEEBNgIAIAAgATYCBAsQACAAQQA2AgAgACABNgIECyEAIABC////9/f////+ADcCCCAAQv////f/////fjcCAAsTACAAQfCvwgA2AgQgACABNgIACxMAIABByLLCADYCBCAAIAE2AgALEwAgAEHQtcIANgIEIAAgATYCAAsTACAAQdi4wgA2AgQgACABNgIACxMAIABBmLnCADYCBCAAIAE2AgALEAAgAEEJNgIAIAAgATYCBAsTACAAQfy7wgA2AgQgACABNgIACxAAIABBBjYCACAAIAE2AgQLEwAgAEHYvsIANgIEIAAgATYCAAsQACAAQQU2AgAgACABNgIECxMAIABBtMHCADYCBCAAIAE2AgALEAAgAEEINgIAIAAgATYCBAsQACAAQQo2AgAgACABNgIECxMAIABB2MbCADYCBCAAIAE2AgALIQAgAEL////39/////4ANwIIIABC////9/////9+NwIACxQAIABB////+wc2AgggAEIANwIACyEAIABC////9/f////+ADcCCCAAQv////f/////fjcCAAsQACAAQQc2AgAgACABNgIECxAAIABBCzYCACAAIAE2AgQLEwAgAEGI6MIANgIEIAAgATYCAAsQACAAQQw2AgAgACABNgIECxMAIABBpOjCADYCBCAAIAE2AgALEAAgAEENNgIAIAAgATYCBAsTACAAQcDowgA2AgQgACABNgIAC6MHAQ5/IAAoAgAhByAAKAIEIQUCQAJAAkAgASgCACILQSIgASgCBCIMKAIQIg0RAwBFBEACQCAFRQRADAELIAUgB2ohDyAHIQgCQANAAkAgCCIJLAAAIgNBAE4EQCAJQQFqIQggA0H/AXEhBAwBCyAJLQABQT9xIQAgA0EfcSEBIANBX00EQCABQQZ0IAByIQQgCUECaiEIDAELIAktAAJBP3EgAEEGdHIhACAJQQNqIQggA0FwSQRAIAAgAUEMdHIhBAwBCyABQRJ0QYCA8ABxIAgtAABBP3EgAEEGdHJyIgRBgIDEAEYNAiAJQQRqIQgLQYKAxAAhAEEwIQMCQAJAAkACQAJAAkACQAJAAkAgBA4jBgEBAQEBAQEBAgQBAQMBAQEBAQEBAQEBAQEBAQEBAQEBAQUACyAEQdwARg0ECyAEEOICRQRAIAQQiwQNBgsgBEGBgMQARg0FIARBAXJnQQJ2QQdzIQMgBCEADAQLQfQAIQMMAwtB8gAhAwwCC0HuACEDDAELIAQhAwsgAiAGSw0BAkAgAkUNACACIAVPBEAgAiAFRg0BDAMLIAIgB2osAABBQEgNAgsCQCAGRQ0AIAUg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aiIBQQxqQQE2AgAgA0GgpMMANgIQIANBADYCCCADQQE2AiQgAyABNgIYIAMgA0EEajYCKCADIAM2AiAgACACELwJAAsOACAANQIAQQEgARCJAwttAQF/IwBBEGsiAyQAIAMgATYCDCADIAA2AggjAEEgayIAJAAgAEEMakEBNgIAIABBFGpBATYCACAAQbidwwA2AgggAEEANgIAIABBvQY2AhwgACADQQhqNgIYIAAgAEEYajYCECAAIAIQvAkAC88CAgR/An4jAEFAaiICJABBASEEAkAgAC0ABA0AIAAtAAUhBAJAAkACQCAAKAIAIgMoAhgiBUEEcUUEQCAEDQEMAwsgBA0BQQEhBCADKAIAQa2fwwBBASADKAIEKAIMEQUADQMgAygCGCEFDAELQQEhBCADKAIAQZGfwwBBAiADKAIEKAIMEQUARQ0BDAILQQEhBCACQQE6ABcgAkHwnsMANgIcIAIgAykCADcDCCACIAJBF2o2AhAgAykCCCEGIAMpAhAhByACIAMtACA6ADggAiADKAIcNgI0IAIgBTYCMCACIAc3AyggAiAGNwMgIAIgAkEIajYCGCABIAJBGGpBoPXBACgCABEDAA0BIAIoAhhBj5/DAEECIAIoAhwoAgwRBQAhBAwBCyABIANBoPXBACgCABEDACEECyAAQQE6AAUgACAEOgAEIAJBQGskAAsOACAAKAIAIAEgAhCnAgsOACAAKQMAQQEgARCJAwvSAwIBfgR/IAAoAgApAwAhAiMAQYABayIFJAACQAJAAkACQCABKAIYIgBBEHFFBEAgAEEgcQ0BIAJBASABEIkDIQAMBAtBgAEhACAFQYABaiEEAkACQANAIABFBEBBACEADAMLIARBAWtBMEHXACACpyIDQQ9xIgZBCkkbIAZqOgAAIAJCEFoEQCAEQQJrIgQgA0H/AXEiA0EEdkEwQdcAIANBoAFJG2o6AAAgAEECayEAIAJCgAJUIQMgAkIIiCECIANFDQEMAgsLIABBAWshAAsgAEGBAU8NAgsgAUEBQdyfwwBBAiAAIAVqQYABIABrELkBIQAMAwtBgAEhACAFQYABaiEEAkACQANAIABFBEBBACEADAMLIARBAWtBMEE3IAKnIgNBD3EiBkEKSRsgBmo6AAAgAkIQWgRAIARBAmsiBCADQf8BcSIDQQR2QTBBNyADQaABSRtqOgAAIABBAmshACACQoACVCEDIAJCCIghAiADRQ0BDAILCyAAQQFrIQALIABBgQFPDQILIAFBAUHcn8MAQQIgACAFakGAASAAaxC5ASEADAILIABBgAFBzJ/DABCWCwALIABBgAFBzJ/DABCWCwALIAVBgAFqJAAgAAsLACAAIwBqJAAjAAsZACABKAIAQeCxwABBFCABKAIEKAIMEQUACxkAIAEoAgBBjILAAEERIAEoAgQoAgwRBQALGQAgASgCAEGAgMAAQQ4gASgCBCgCDBEFAAsZACABKAIAQYSywABBFCABKAIEKAIMEQUACwwAIAAoAgAgARCmCgsJACAAIAEQFAALDQBB+L3AAEEbEKULAAsOAEGTvsAAQc8AEKULAAsOACABQYDNwABBAhCaAQuwCQMIfwJ9A34gACgCACECIAEoAhhBAXEhAAJAIAEoAhBBAUYEQCABIAIqAgAgACABQRRqKAIAEKsBIQAMAQsgAigCACICviEKAkAgAkH/////B3G+IgtDyhsOWmANACALQwAAAABcIAtDF7fROF1xDQAgASAKIABBARDOASEADAELIwBBoAFrIgIkACAKvCEEQQMhAwJAIApDAACAf1sNACAKQwAAgP9bDQAgCiAKXARAQQIhAwwBCyAEQf///wNxQYCAgARyIARBAXRB/v//B3EgBEEXdkH/AXEiBRsiB60iDEIBgyEOQQQhAwJAAkBBBEEDIARBgICA/AdxG0ECIARB/////wdxG0EDaw4CAAECCyAFQZYBayEGIA5QIQNCASENDAELQoCAgBAgDEIBhiAHQYCAgARGIgYbIQxCAkIBIAYbIQ0gDlAhA0HofkHpfiAGGyAFaiEGCyACIAY7AZgBIAIgDTcDkAEgAkIBNwOIASACIAw3A4ABIAIgAzoAmgECfyADQQJGBEBB6ILDACEGQQAMAQsgAEUEQEGInMMAQeiCwwAgBEEASBshBiAEQR92DAELQYicwwBBiZzDACAEQQBIGyEGQQELIQBBASEFAn8CQAJAAkACQCADQQJrQQMgA0EBSxtB/wFxQQFrDgMCAQADCyACQShqIAJBgAFqIAJBF2oQVQJAIAIoAihFBEAgAkHwAGogAkGAAWogAkEXahAfDAELIAJB+ABqIAJBMGooAgA2AgAgAiACKQMoNwNwCyACQQhqIQgg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dCBpbmRleCAwIDw9IGkgPCAyLAMQABgAAAB2YXJpYW50IGluZGV4IDAgPD0gaSA8IDE1AAAATAMQABkAAABzdHJ1Y3QgQ29udmV4UG9seWdvbiB3aXRoIDIgZWxlbWVudHNwAxAAJAAAAHN0cnVjdCBHcmFwaCB3aXRoIDIgZWxlbWVudHOcAxAAHAAAAHN0cnVjdCBMVSB3aXRoIDIgZWxlbWVudHMAAADAAxAAGQAAAHN0cnVjdCBSaWdpZEJvZHlTZXQgd2l0aCAyIGVsZW1lbnRzAOQDEAAjAAAAc3RydWN0IElzbGFuZE1hbmFnZXIgd2l0aCA0IGVsZW1lbnRzEAQQACQAAABzdHJ1Y3QgQ29udGFjdE1hbmlmb2xkRGF0YSB3aXRoIDcgZWxlbWVudHMAADwEEAAqAAAAc3RydWN0IEdlbmVyaWNUcmlNZXNoIHdpdGggNiBlbGVtZW50cwAAAHAEEAAlAAAAdmFyaWFudCBpbmRleCAwIDw9IGkgPCAzoAQQABgAAAB2YXJpYW50IGluZGV4IDAgPD0gaSA8IDTABBAAGAAAAHN0cnVjdCBUcmlNZXNoQ29ubmVjdGVkQ29tcG9uZW50cyB3aXRoIDMgZWxlbWVudHMAAADgBBAAMQAAAHN0cnVjdCBHZW5lcmljSGVpZ2h0RmllbGQgd2l0aCA0IGVsZW1lbnRzAAAAHAUQACkAAABzdHJ1Y3QgTXVsdGlib2R5IHdpdGggMTYgZWxlbWVudHMAAABQBRAAIQAAAHN0cnVjdCBTQVBSZWdpb24gd2l0aCA3IGVsZW1lbnRzfAUQACAAAABzdHJ1Y3QgSW1wdWxzZUpvaW50IHdpdGggNSBlbGVtZW50cwCkBRAAIwAAAHN0cnVjdCBJbnRlcm5hbEVkZ2VzRml4ZXIgd2l0aCAyIGVsZW1lbnRzAAAA0AUQACkAAABzdHJ1Y3QgR2VuZXJpY1Fidmggd2l0aCA1IGVsZW1lbnRzAAAEBhAAIgAAAHN0cnVjdCBNdWx0aWJvZHlKb2ludCB3aXRoIDMgZWxlbWVudHMAAAAwBhAAJQAAAHN0cnVjdCBJbXB1bHNlSm9pbnRTZXQgd2l0aCA0IGVsZW1lbnRzAABgBhAAJgAAAHN0cnVjdCBNdWx0aWJvZHlKb2ludFNldCB3aXRoIDQgZWxlbWVudHOQBhAAKAAAAHN0cnVjdCBNdWx0aWJvZHlXb3Jrc3BhY2Ugd2l0aCAyIGVsZW1lbnRzAAAAwAYQACkAAAB2YXJpYW50IGluZGV4IDAgPD0gaSA8IDb0BhAAGAAAAHN0cnVjdCBUcmlNZXNoU2hhcGVDb250YWN0TWFuaWZvbGRzV29ya3NwYWNlIHdpdGggNCBlbGVtZW50cxQHEAA8AAAAc3RydWN0IENvbnRhY3RNYW5pZm9sZCB3aXRoIDggZWxlbWVudHMAAFgHEAAmAAAAY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXiIBxAAIAAAAC9ydXN0Yy8wNDY4YTAwYWUzZmQ2ZWYxYTZhMGY5ZWFmNjM3ZDdhYTllNjA0YWNjL2xpYnJhcnkvc3RkL3NyYy9zeXMvd2FzbS8uLi91bnN1cHBvcnRlZC9sb2Nrcy9tdXRleC5ycwAAsAcQAGYAAAAUAAAACQAAAAkAAAAIAAAABAAAABIAAAATAAAACQAAABgAAAAEAAAAFAAAAAkAAAAQAAAABAAAABUAAAAJAAAACAAAAAQAAAAWAAAAFwAAAAwAAAAEAAAAGAAAABkAAAAaAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQAJAAAAAAAAAAEAAAAbAAAAL3J1c3RjLzA0NjhhMDBhZTNmZDZlZjFhNmEwZjllYWY2MzdkN2FhOWU2MDRhY2MvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAMwIEABLAAAA6AkAAAkAAAAJAAAABAAAAAQAAAAcAAAAHQAAAB4AAABjYW5ub3QgdHJhbnNtdXRlX2NvcHkgaWYgRHN0IGlzIGxhcmdlciB0aGFuIFNyYwBACRAALwAAAC9ydXN0Yy8wNDY4YTAwYWUzZmQ2ZWYxYTZhMGY5ZWFmNjM3ZDdhYTllNjA0YWNjL2xpYnJhcnkvY29yZS9zcmMvbWVtL21vZC5ycwB4CRAASwAAABgEAAAFAAAACQAAAAQAAAAEAAAAHwAAAAkAAAAEAAAABAAAACAAAABpbnZhbGlkIHZhbHVlOiAsIGV4cGVjdGVkIAAA9AkQAA8AAAADChAACwAAAGludmFsaWQgbGVuZ3RoIAAgChAADwAAAAMKEAALAAAAUG9pc29uRXJyb3IvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy9wYXJ0aXRpb25pbmcvcWJ2aC90cmF2ZXJzYWwucnMAAABLChAAcgAAAE0AAAAZAAAAYXNzZXJ0aW9uIGZhaWxlZDogc3FuYWIgIT0gMC4wL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvcXVlcnkvcG9pbnQvcG9pbnRfc2VnbWVudC5ycwAA7goQAHAAAABIAAAADQAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkyZC0wLjEzLjEvc3JjL3NoYXBlL2hlaWdodGZpZWxkMi5ycwAAAHALEABpAAAAGwEAABIAAABwCxAAaQAAABwBAAASAAAAcAsQAGkAAAAvAQAACgAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkyZC0wLjEzLjEvc3JjL3NoYXBlL3RyaW1lc2gucnMMDBAAZAAAAOgDAAARAAAADAwQAGQAAADpAwAAEQAAAAwMEABkAAAA6gMAABEAAAD//////////y9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvaW5kZXhtYXAtMS45LjEvc3JjL21hcC9jb3JlLnJzAKgMEABfAAAAKgAAACMAAACoDBAAXwAAACIAAAAPAAAATWF0cml4IGluaXQuIGVycm9yOiB0aGUgc2xpY2UgZGlkIG5vdCBjb250YWluIHRoZSByaWdodCBudW1iZXIgb2YgZWxlbWVudHMuL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9uYWxnZWJyYS0wLjMyLjEvc3JjL2Jhc2UvY29uc3RydWN0aW9uLnJzcw0QAGkAAABrAAAACQAAAE1hdHJpeCBpbmRleCBvdXQgb2YgYm91bmRzLi9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9kYXRhL2FyZW5hLnJzAAAABw4QAGIAAAAKAQAAHgAAAGNvcnJ1cHQgZnJlZSBsaXN0AAAAfA4QABEAAAAHDhAAYgAAAAsBAAArAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL2RhdGEvZ3JhcGgucnMAAKgOEABiAAAAkgAAABgAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmVkZ2VzLmxlbigpICE9IGNyYXRlOjpJTlZBTElEX1VTSVpFAACoDhAAYgAAANwAAAAJAAAAR3JhcGg6OmFkZF9lZGdlOiBub2RlIGluZGljZXMgb3V0IG9mIGJvdW5kcwBoDxAAKwAAAKgOEABiAAAA5AAAABsAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLm5vZGVzLmxlbigpICE9IGNyYXRlOjpJTlZBTElEX1VTSVpFAACoDhAAYgAAALMAAAAJAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL2RhdGEvY29hcmVuYS5yc/gPEABkAAAAXQAAABkAAAD4DxAAZAAAAE4AAAAJAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL2R5bmFtaWNzL2pvaW50L2ltcHVsc2Vfam9pbnQvaW1wdWxzZV9qb2ludF9zZXQucnMAAHwQEACGAAAADAEAAAkAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjJkLTAuMTcuMi9zcmMvZHluYW1pY3Mvam9pbnQvbXVsdGlib2R5X2pvaW50L211bHRpYm9keV9qb2ludF9zZXQucnMAABQREACKAAAAaQAAABsAAAAUERAAigAAAGoAAAAvAAAAFBEQAIoAAACVAAAAHwAAABQREACKAAAAmAAAABgAAAAUERAAigAAAJQAAAATAAAAUGFyZW50IHJpZ2lkIGJvZHkgbm90IGZvdW5kLi9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9nZW9tZXRyeS9jb2xsaWRlcl9zZXQucnMAAAAMEhAAbQAAAIAAAAANAAAADBIQAG0AAAB9AAAAFAAAAAwSEABtAAAAdwAAABYAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjJkLTAuMTcuMi9zcmMvZ2VvbWV0cnkvaW50ZXJhY3Rpb25fZ3JhcGgucnMAAKwSEAByAAAAgwAAAA4AAACsEhAAcgAAAIMAAAAnAAAArBIQAHIAAACCAAAAHQAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9waXBlbGluZS9kZWJ1Z19yZW5kZXJfcGlwZWxpbmUvZGVidWdfcmVuZGVyX2JhY2tlbmQucnMAUBMQAIsAAAA1AAAAOAAAAFATEACLAAAANgAAADgAAAAJAAAAGAAAAAQAAAAhAAAAIgAAACMAAAAkAAAAJQAAACYAAAAnAAAAKAAAACkAAAAqAAAACQAAABgAAAAEAAAAFAAAACsAAAAsAAAALQAAAC4AAAAJAAAAGAAAAAQAAAAJAAAAGAAAAAQAAAAUAAAAKwAAACwAAAAtAAAALgAAAFAUEABQFBAALAAAAAkAAAAYAAAABAAAAC8AAAAwAAAAMQAAADIAAAAzAAAANAAAACEAAAAiAAAAIwAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAD8ExAAFAAAADwIEAArAAAALAAAAC0AAAAuAAAAMBQQAFAUEABQFBAALAAAAFwUEAA1AAAANgAAADcAAAA4AAAAOQAAADoAAAA7AAAAPAAAAD0AAAA+AAAAPwAAAEAAAABBAAAAQgAAAEMAAABEAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL3BpcGVsaW5lL2RlYnVnX3JlbmRlcl9waXBlbGluZS9kZWJ1Z19yZW5kZXJfcGlwZWxpbmUucnMJAAAAEAAAAAQAAABFAAAARgAAAEcAAABIAAAASQAAAEoAAABLAAAATAAAAE0AAABOAAAACQAAABAAAAAEAAAAFQAAAE8AAABQAAAAUQAAAFIAAAAJAAAAEAAAAAQAAAAJAAAAEAAAAAQAAAAVAAAATwAAAFAAAABRAAAAUgAAACQWEAAkFhAAUAAAAAkAAAAQAAAABAAAAFMAAABUAAAAVQAAAFYAAABXAAAAWAAAAEUAAABGAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAATQAAAE4AAADQFRAAFQAAAEwIEABPAAAAUAAAAFEAAABSAAAABBYQACQWEAAkFhAAUAAAADAWEABZAAAAWgAAAFsAAABcAAAAXQAAAF4AAABfAAAAYAAAAD0AAAA+AAAAPwAAAGEAAABBAAAAYgAAAGMAAABkAAAARBUQAIwAAABLAQAAHAAAAEQVEACMAAAAQAEAABwAAABEFRAAjAAAANAAAAAeAAAARBUQAIwAAADQAAAALQAAAAkAAAAIAAAABAAAAGUAAABmAAAAZwAAAGgAAABpAAAAagAAAGsAAABsAAAAbQAAAG4AAAAJAAAACAAAAAQAAAAWAAAAbwAAAHAAAABxAAAAcgAAAAkAAAAIAAAABAAAAAkAAAAIAAAABAAAABYAAABvAAAAcAAAAHEAAAByAAAArBcQAKwXEABwAAAACQAAAAgAAAAEAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAZQAAAGYAAABnAAAAaAAAAGkAAABqAAAAawAAAGwAAABtAAAAbgAAAFgXEAAWAAAAXAgQAG8AAABwAAAAcQAAAHIAAACMFxAArBcQAKwXEABwAAAAuBcQAHkAAAB6AAAAewAAAHwAAAB9AAAAfgAAAH8AAACAAAAAgQAAAD4AAAA/AAAAggAAAEEAAACDAAAAhAAAAIUAAAAJAAAACAAAAAQAAACGAAAAAQAAAEV4cGVjdGVkICBjb21wb25lbnRzLCBmb3VuZCC0GBAACQAAAL0YEAATAAAAYW4gYXJyYXkgb2YgbGVuZ3RoIDIJAAAAAAAAAAEAAACHAAAAYW4gYXJyYXkgb2YgbGVuZ3RoIDMJAAAAAAAAAAEAAACIAAAASW52YWxpZCBJbXB1bHNlSm9pbnQgcmVmZXJlbmNlLiBJdCBtYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGh5c2ljcyBXb3JsZC5yYXBpZXIyZC8uLi9zcmMvZHluYW1pY3MvaW1wdWxzZV9qb2ludF9zZXQucnMAAAB4GRAALQAAAAsAAAAUAAAAeBkQAC0AAAAWAAAAFAAAAEludmFsaWQgSm9pbnQgcmVmZXJlbmNlLiBJdCBtYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGh5c2ljcyBXb3JsZC5yYXBpZXIyZC8uLi9zcmMvZHluYW1pY3MvbXVsdGlib2R5X2pvaW50X3NldC5ycxEaEAAvAAAADwAAAAsAAAARGhAALwAAAAsAAAAfAAAAERoQAC8AAAAbAAAAEAAAABEaEAAvAAAAFwAAAB8AAABJbnZhbGlkIFJpZ2lkQm9keSByZWZlcmVuY2UuIEl0IG1heSBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwaHlzaWNzIFdvcmxkLnJhcGllcjJkLy4uL3NyYy9keW5hbWljcy9yaWdpZF9ib2R5X3NldC5ycwDNGhAAKgAAACsAAAAUAAAAzRoQACoAAAA2AAAAFAAAAEludmFsaWQgQ29sbGlkZXIgcmVmZXJlbmNlLiBJdCBtYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGh5c2ljcyBXb3JsZC5yYXBpZXIyZC8uLi9zcmMvZ2VvbWV0cnkvY29sbGlkZXJfc2V0LnJzZBsQACgAAAAUAAAAGAAAAGQbEAAoAAAAIAAAABgAAABkGxAAKAAAAGgAAAANAAAAMC4xMS4yaW52YWxpZCBlbnVtIHZhbHVlIHBhc3NlZHJhcGllcjJkLy4uL3NyYy9keW5hbWljcy9yaWdpZF9ib2R5LnJzAAAA2xsQACYAAAD7AQAAMgAAAE5vdCB5ZXQgaW1wbGVtZW50ZWQucmFwaWVyMmQvLi4vc3JjL2dlb21ldHJ5L2NvbGxpZGVyLnJzKBwQACQAAACTAAAAIgAAACgcEAAkAAAALAIAABMAAAAoHBAAJAAAAGsCAAATAAAAcmFwaWVyMmQvLi4vc3JjL2dlb21ldHJ5L25hcnJvd19waGFzZS5yc3wcEAAoAAAA1gAAABIAAAB8HBAAKAAAANoAAAASAAAAfBwQACgAAADeAAAAEgAAAHJhcGllcjJkLy4uL3NyYy9nZW9tZXRyeS9zaGFwZS5ycwAAANQcEAAhAAAAHAEAAEAAAADUHBAAIQAAACYBAAA4AAAA1BwQACEAAAAmAQAAPgAAAAkAAAAAAAAAAQAAAIkAAACKAAAAiwAAAAkAAAAAAAAAAQAAAAkAAAAAAAAAAQAAAEAdEACMAAAAjQAAAI4AAAAMAAAABAAAAI8AAACQAAAAkQAAAJIAAAAQAAAABAAAAJIAAAAQAAAABAAAAHwdEACTAAAAlAAAAAkAAAAEAAAABAAAAJUAAACWAAAAlgAAAHN0cnVjdCBEZXNlcmlhbGl6YWJsZVdvcmxkIHdpdGggOSBlbGVtZW50cwAAuB0QACoAAAAAAAAAAwAAAAMAAAACAAAAAQAAAEludmFsaWQgc2l6ZSA6IHNpemVzIG11c3QgZml0IGluIGEgdXNpemUgKDAgdG8gKQAeEAANAAAADR4QACIAAAAvHhAAAQAAAP////9jbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgZGVzdHJveWVkIGFscmVhZHmkAAAABAAAAAQAAAClAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9qcy1zeXMtMC4zLjYwL3NyYy9saWIucnMAAACMHhAAWQAAAMMWAAABAAAAbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdGNhcGFjaXR5IG92ZXJmbG93AFRoZSBsb29zZW5pbmcgbWFyZ2luIG11c3QgYmUgcG9zaXRpdmUuAAB0HxAAJgAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkyZC0wLjEzLjEvc3JjL2JvdW5kaW5nX3ZvbHVtZS9hYWJiLnJzAKQfEABrAAAAIQIAAAkAAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvcXVlcnkvZGVmYXVsdF9xdWVyeV9kaXNwYXRjaGVyLnJzAAAhIBAAdQAAABECAAAeAAAAtAAAAAAAAAABAAAAtAAAAAAAAAABAAAAqCAQALUAAAC2AAAAtwAAALgAAAC5AAAAugAAALsAAAC8AAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQAhIBAAdQAAAOoBAAAZAAAAISAQAHUAAADXAQAAGQAAACEgEAB1AAAAQQIAABkAAAAhIBAAdQAAAFACAAAZAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9jcm9zc2JlYW0tY2hhbm5lbC0wLjUuNi9zcmMvd2FrZXIucnMAAABQIRAAZQAAAGgAAAArAAAAUCEQAGUAAABGAAAAKAAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAUCEQAGUAAADRAAAAGQAAAFAhEABlAAAA3gAAAB0AAABQIRAAZQAAAMYAAAAZAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZS9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvY3Jvc3NiZWFtLWNoYW5uZWwtMC41LjYvc3JjL2NoYW5uZWwucnMAXCIQAGcAAACzAQAALQAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvY3Jvc3NiZWFtLWNoYW5uZWwtMC41LjYvc3JjL2NvbnRleHQucnMA1CIQAGcAAAAzAAAAFQAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvY3Jvc3NiZWFtLWNoYW5uZWwtMC41LjYvc3JjL2ZsYXZvcnMvbGlzdC5yc0wjEABsAAAABQEAADgAAAC9AAAACAAAAAQAAAC+AAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9jcm9zc2JlYW0tY2hhbm5lbC0wLjUuNi9zcmMvZmxhdm9ycy96ZXJvLnJz2CMQAGwAAADhAAAAGQAAANgjEABsAAAA6AAAABEAAADYIxAAbAAAAAYBAAAVAAAA2CMQAGwAAAAHAQAAKAAAANgjEABsAAAAAQEAABUAAADYIxAAbAAAAAIBAAAoAAAA2CMQAGwAAAD/AAAAJgAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvY3Jvc3NiZWFtLWNoYW5uZWwtMC41LjYvc3JjL2ZsYXZvcnMvYXJyYXkucnMAAAC0JBAAbQAAAHgBAAAZAAAAtCQQAG0AAAB2AQAAKgAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbmFsZ2VicmEtMC4zMi4xL3NyYy9iYXNlL3ZlY19zdG9yYWdlLnJzY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXisJRAAIAAAAC9ydXN0Yy8wNDY4YTAwYWUzZmQ2ZWYxYTZhMGY5ZWFmNjM3ZDdhYTllNjA0YWNjL2xpYnJhcnkvc3RkL3NyYy9zeXMvd2FzbS8uLi91bnN1cHBvcnRlZC9sb2Nrcy9tdXRleC5ycwAA1CUQAGYAAAAUAAAACQAAALQAAAAIAAAABAAAAL8A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AAAUAAAABAAAAMEAAADrAAAA7AAAAO0AAADuAAAAtAAAABQAAAAEAAAAtAAAABQAAAAEAAAAwQAAAOsAAADsAAAA7QAAAO4AAAAEMRAABDEQAOwAAAC0AAAAFAAAAAQAAADvAAAA8AAAAPEAAADyAAAA8wAAAPQAAADhAAAA4gAAAOMAAADkAAAA5QAAAOYAAADnAAAA6AAAAOkAAADqAAAAsDAQAMEAAABgJhAA6wAAAOwAAADtAAAA7gAAAOQwEAAEMRAABDEQAOwAAAAQMRAA9QAAAPYAAAD3AAAA+AAAAPkAAAD6AAAA+wAAAPwAAAD9AAAAPgAAAD8AAAD+AAAA3wAAAP8AAAAAAQAAAQEAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkyZC0wLjEzLjEvc3JjL3F1ZXJ5L2NvbnRhY3RfbWFuaWZvbGRzL2NvbnRhY3RfbWFuaWZvbGRzX2NvbXBvc2l0ZV9zaGFwZV9zaGFwZS5ycwAA+DEQAJYAAABJAAAACQAAALQAAAA0AAAABAAAAAIBAAADAQAA+DEQAJYAAABdAAAAJAAAAPgxEACWAAAAegAAACEAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy9xdWVyeS9jb250YWN0X21hbmlmb2xkcy9jb250YWN0X21hbmlmb2xkc19oZWlnaHRmaWVsZF9jb21wb3NpdGVfc2hhcGUucnPUMhAAnAAAAFMAAAAJAAAAtAAAADQAAAAEAAAABAEAAAUBAADUMhAAnAAAAGsAAAAoAAAA1DIQAJwAAACIAAAAJQAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkyZC0wLjEzLjEvc3JjL3F1ZXJ5L2NvbnRhY3RfbWFuaWZvbGRzL2NvbnRhY3RfbWFuaWZvbGRzX2NvbXBvc2l0ZV9zaGFwZV9jb21wb3NpdGVfc2hhcGUucnO0MxAAoAAAAEgAAAAJAAAAtAAAADgAAAAEAAAABgEAAAcBAAC0AAAAOAAAAAQAAAAIAQAACQEAALQzEACgAAAAdgAAACwAAAC0MxAAoAAAAJUAAAApAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvcXVlcnkvZXBhL2VwYTIucnMAAACsNBAAZQAAABIBAAAZAAAArDQQAGUAAAASAQAAMwAAAKw0EABlAAAAEwEAABkAAACsNBAAZQAAABMBAAAzAAAArDQQAGUAAADgAAAAFwAAAKw0EABlAAAA4QAAABcAAACsNBAAZQAAAPQAAAAdAAAArDQQAGUAAAD0AAAANwAAAKw0EABlAAAA+QAAAB0AAACsNBAAZQAAAPkAAAA3AAAArDQQAGUAAAD+AAAAHQAAAKw0EABlAAAA/gAAADcAAACsNBAAZQAAAFsBAAAaAAAArDQQAGUAAAAiAQAAGAAAAKw0EABlAAAANgEAACIAAACsNBAAZQAAABsBAAAhAAAArDQQAGUAAADBAAAAGQAAAKw0EABlAAAA0AAAABkAAABhc3NlcnRpb24gZmFpbGVkOiBtaW5fYm91bmQgPT0gbWluX2JvdW5kL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvcXVlcnkvZ2prL2dqay5yc1w2EABkAAAAjAAAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBzcW5hYiAhPSAwLjAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy9xdWVyeS9wb2ludC9wb2ludF9zZWdtZW50LnJzAADuNhAAcAAAAEgAAAANAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvc2hhcGUvaGVpZ2h0ZmllbGQyLnJzAAAAcDcQAGkAAAAvAQAACgAAAHA3EABpAAAAVQEAABYAAABwNxAAaQAAAFYBAAAWAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvc2hhcGUvcG9seWdvbmFsX2ZlYXR1cmUyZC5ycww4EABwAAAAhgAAABUAAAAMOBAAcAAAAIcAAAAVAAAADDgQAHAAAACUAAAAFQAAAAw4EABwAAAAlQAAABUAAABub3QgaW1wbGVtZW50ZWQADDgQAHAAAABIAAAAHwAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkyZC0wLjEzLjEvc3JjL3NoYXBlL3RyaW1lc2gucnPcOBAAZAAAABUEAAATAAAA3DgQAGQAAAAXBAAADQAAANw4EABkAAAAGAQAAA0AAADcOBAAZAAAABkEAAANAAAAaW5kZXggb3V0IG9mIGJvdW5kcwC0AAAAJAAAAAQAAAAKAQAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9hcnJheXZlYy0wLjcuMi9zcmMvYXJyYXl2ZWNfaW1wbC5yc6Q5EABkAAAAJwAAAAkAAAD//////////y9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvaW5kZXhtYXAtMS45LjEvc3JjL21hcC9jb3JlLnJzACA6EABfAAAAKgAAACMAAABpbmRleCBub3QgZm91bmQAIDoQAF8AAAA1AAAAEQAAACA6EABfAAAAqwIAAA4AAAAgOhAAXwAAAMoBAAAiAAAAIDoQAF8AAADQAQAAHgAAAGFzc2VydGlvbiBmYWlsZWQ6IGluZGljZXMuY2FwYWNpdHkoKSAtIGluZGljZXMubGVuKCkgPj0gZW50cmllcy5sZW4oKS9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvaW5kZXhtYXAtMS45LjEvc3JjL21hcC9jb3JlL3Jhdy5ycyU7EABjAAAAEAAAAAUAAAAlOxAAYwAAAIMAAAAKAAAAIDoQAF8AAAAiAAAADwAAAE1hdHJpeCBzbGljaW5nIG91dCBvZiBib3VuZHMuL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9uYWxnZWJyYS0wLjMyLjEvc3JjL2Jhc2UvbWF0cml4X3ZpZXcucnMAAADVOxAAaAAAABYBAAAJAAAA1TsQAGgAAAAaAQAACQAAAFJvd3MgcmFuZ2UgcGFpcjogdGhlIHJhbmdlcyBtdXN0IG5vdCBvdmVybGFwLgAAANU7EABoAAAAEgMAAAUAAABSb3dzIHJhbmdlIHBhaXI6IGluZGV4IG91dCBvZiByYW5nZS5EYXRhIHN0b3JhZ2UgYnVmZmVyIGRpbWVuc2lvbiBtaXNtYXRjaC4ARCUQAGgAAABUAAAACQAAAENvbXBvbmVudHdpc2UgbXVsL2RpdjogbWlzbWF0Y2hlZCBtYXRyaXggZGltZW5zaW9ucy78PBAANAAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbmFsZ2VicmEtMC4zMi4xL3NyYy9iYXNlL2NvbXBvbmVudHdpc2UucnMAADg9EABqAAAAlgAAAAUAAABNYXRyaXggdmlldzogaW5wdXQgZGF0YSBidWZmZXIgdG9vIHNtYWxsLi9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbmFsZ2VicmEtMC4zMi4xL3NyYy9iYXNlL2NvbnN0cnVjdGlvbl92aWV3LnJzAN09EABuAAAAMAAAAAkAAABNYXRyaXggaW5kZXggb3V0IG9mIGJvdW5kcy5NYXRyaXggYWRkaXRpb24vc3VidHJhY3Rpb24gZGltZW5zaW9ucyBtaXNtYXRjaC4Adz4QADAAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL25hbGdlYnJhLTAuMzIuMS9zcmMvYmFzZS9vcHMucnOwPhAAYAAAAGgBAAABAAAAZ2VtbTogZGltZW5zaW9ucyBtaXNtYXRjaCBmb3IgYWRkaXRpb24uACA/EAAnAAAAR2VtdjogZGltZW5zaW9ucyBtaXNtYXRjaC4gYW5kIDogbGVmdCByb3dzICE9IHJpZ2h0IHJvd3MuTWF0cml4IG11bHRpcGxpY2F0aW9uIG91dHB1dCBkaW1lbnNpb25zIG1pc21hdGNoIDogbGVmdCBjb2xzICE9IHJpZ2h0IHJvd3MuiT8QADEAAABqPxAABQAAALo/EAAaAAAAsD4QAGAAAADVAgAACQAAAEF4cHk6IG1pc21hdGNoZWQgdmVjdG9yIHNoYXBlcy4A/D8QAB8AAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL25hbGdlYnJhLTAuMzIuMS9zcmMvYmFzZS9ibGFzLnJzAAAAJEAQAGEAAABCAQAACQAAACRAEABhAAAACAIAAAkAAABEb3QgcHJvZHVjdCBkaW1lbnNpb25zIG1pc21hdGNoIGZvciBzaGFwZXMgAKhAEAArAAAAaj8QAAUAAABvPxAAGgAAACRAEABhAAAAIAAAAAkAAAAkQBAAYQAAABgDAAAJAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9uYWxnZWJyYS0wLjMyLjEvc3JjL2Jhc2UvbWF0cml4LnJzTWF0cml4IGVsZW1lbnRzIHN3YXAgaW5kZXggb3V0IG9mIGJvdW5kcy4MQRAAYwAAALYEAAAJAAAADEEQAGMAAAC6BAAACQAAAE1hdHJpeCBzaW11bHRhbmVvdXMgdHJhdmVyc2FsIGVycm9yOiBkaW1lbnNpb24gbWlzbWF0Y2guuEEQADgAAABVbmFibGUgdG8gY29weSBmcm9tIGEgbWF0cml4IHdpdGggYSBkaWZmZXJlbnQgc2hhcGUuDEEQAGMAAADjBAAACQAAAAxBEABjAAAA8QMAAAkAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL25hbGdlYnJhLTAuMzIuMS9zcmMvYmFzZS9lZGl0aW9uLnJzYXNzZXJ0aW9uIGZhaWxlZDogaXJvdzEgPCBzZWxmLm5yb3dzKCkgJiYgaXJvdzIgPCBzZWxmLm5yb3dzKCkAAExCEABkAAAAOAEAAAkAAABUaGUgaW5wdXQgdmVjdG9yIG11c3Qgbm90IGJlIGVtcHR5Li9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbmFsZ2VicmEtMC4zMi4xL3NyYy9iYXNlL21pbl9tYXgucnMAI0MQAGQAAADhAAAACQAAAEluZGV4IG91dCBvZiBib3VuZHMuL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9uYWxnZWJyYS0wLjMyLjEvc3JjL2Jhc2UvaW5kZXhpbmcucnMAAACsQxAAZQAAAFIBAAAJAAAATWF4aW11bSBudW1iZXIgb2YgcGVybXV0YXRpb25zIGV4Y2VlZGVkLi9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbmFsZ2VicmEtMC4zMi4xL3NyYy9saW5hbGcvcGVybXV0YXRpb25fc2VxdWVuY2UucnMATEQQAHMAAABVAAAADQAAAExEEABzAAAAWQAAAA0AAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL25hbGdlYnJhLTAuMzIuMS9zcmMvbGluYWxnL2x1LnJzAAAA4EQQAGEAAACAAQAAKwAAAExVIHNvbHZlIG1hdHJpeCBkaW1lbnNpb24gbWlzbWF0Y2guAFRFEAAjAAAA4EQQAGEAAAD2AAAACQAAAExVIHNvbHZlOiB1bmFibGUgdG8gc29sdmUgYSBub24tc3F1YXJlIHN5c3RlbS4AAOBEEABhAAAA+wAAAAkAAADgRBAAYQAAAGgAAAAYAAAAtAAAAAgAAAAEAAAACwEAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9jb250cm9sL2NoYXJhY3Rlcl9jb250cm9sbGVyLnJz8EUQAHQAAADLAgAAHQAAAPBFEAB0AAAAygIAAB8AAADwRRAAdAAAALsCAAAvAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL2RhdGEvYXJlbmEucnMAAJRGEABiAAAACgEAAB4AAABjb3JydXB0IGZyZWUgbGlzdAAAAAhHEAARAAAAlEYQAGIAAAALAQAAKwAAAGluc2VydGluZyB3aWxsIGFsd2F5cyBzdWNjZWVkIGFmdGVyIHJlc2VydmluZyBhZGRpdGlvbmFsIHNwYWNlAAC0AAAAAAAAAAEAAAAMAQAAlEYQAGIAAABKAQAACQAAAE5vIGVsZW1lbnQgYXQgaW5kZXgvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjJkLTAuMTcuMi9zcmMvZGF0YS9jb2FyZW5hLnJzAKdHEABkAAAATgAAAAkAAABDYW5ub3QgaW5kZXggdGhlIHNhbWUgb2JqZWN0IHR3aWNlLgAcSBAAIwAAAKdHEABkAAAAcAAAAAkAAACnRxAAZAAAAHgAAAArAAAAp0cQAGQAAAB5AAAAEwAAAKdHEABkAAAAeQAAACIAAACnRxAAZAAAAIEAAAArAAAAp0cQAGQAAACCAAAAEwAAAKdHEABkAAAAggAAACsAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjJkLTAuMTcuMi9zcmMvZGF0YS9ncmFwaC5ycwAAuEgQAGIAAACSAAAAGAAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYubm9kZXMubGVuKCkgIT0gY3JhdGU6OklOVkFMSURfVVNJWkUAALhIEABiAAAAswAAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmVkZ2VzLmxlbigpICE9IGNyYXRlOjpJTlZBTElEX1VTSVpFAAC4SBAAYgAAANwAAAAJAAAAR3JhcGg6OmFkZF9lZGdlOiBub2RlIGluZGljZXMgb3V0IG9mIGJvdW5kcwDESRAAKwAAALhIEABiAAAA5AAAABsAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjJkLTAuMTcuMi9zcmMvZHluYW1pY3MvY2NkL2NjZF9zb2x2ZXIucnMACEoQAG8AAACHAAAAGAAAAAhKEABvAAAAkgAAACAAAABDb3VsZCBub3QgZmluZCB0aGUgQ29sbGlkZXJQYXJlbnQgY29tcG9uZW50LghKEABvAAAAkwAAACYAAAAIShAAbwAAAK8AAAAsAAAACEoQAG8AAACwAAAALAAAAAhKEABvAAAAAwEAABgAAAAIShAAbwAAAA4BAAAgAAAACEoQAG8AAAAPAQAAJgAAAAhKEABvAAAA4AEAABgAAAAIShAAbwAAAOEBAAAYAAAACEoQAG8AAADwAQAAHAAAAAhKEABvAAAAAAIAABwAAAAIShAAbwAAAP8BAAAzAAAACEoQAG8AAADvAQAAMwAAAGFzc2VydGlvbiBmYWlsZWQ6IHRvaS50b2kgPD0gZHQACEoQAG8AAABsAQAADQAAAAhKEABvAAAAdAEAACoAAAAIShAAbwAAAHcBAAAqAAAACEoQAG8AAACMAQAANwAAAAhKEABvAAAAiwEAACcAAAAIShAAbwAAAJEBAAA3AAAACEoQAG8AAACQAQAAJwAAAAhKEABvAAAAmQEAABwAAAAIShAAbwAAAJsBAAAcAAAACEoQAG8AAACaAQAAIgAAAAhKEABvAAAAJwEAACwAAAAIShAAbwAAACgBAAAsAAAACEoQAG8AAAA6AQAAOAAAAAhKEABvAAAAOwEAADgAAAAIShAAbwAAAKIBAAAkAAAAYXNzZXJ0aW9uIGZhaWxlZDogc3RhcnRfdGltZSA8PSBlbmRfdGltZS9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9keW5hbWljcy9jY2QvdG9pX2VudHJ5LnJzAAC8TBAAbgAAADYAAAAJAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL2R5bmFtaWNzL2lzbGFuZF9tYW5hZ2VyLnJzADxNEABvAAAAfgAAABwAAAA8TRAAbwAAAH4AAAA8AAAAPE0QAG8AAAB/AAAACgAAAFRoZSBtaW5pbXVtIGlzbGFuZCBzaXplIG11c3QgYmUgYXQgbGVhc3QgMS4A3E0QACsAAAA8TRAAbwAAAJkAAAAJAAAAPE0QAG8AAADbAAAAFwAAADxNEABvAAAAzgAAADcAAAA8TRAAbwAAAPsAAAA1AAAAPE0QAG8AAAAWAQAAKAAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9keW5hbWljcy9qb2ludC9pbXB1bHNlX2pvaW50L2ltcHVsc2Vfam9pbnRfc2V0LnJzAABgThAAhgAAAB4BAAAgAAAAYE4QAIYAAAAlAQAAGAAAAGBOEACGAAAAJgEAABgAAABgThAAhgAAADMBAAARAAAAYE4QAIYAAABMAQAADQAAAGBOEACGAAAAcgEAABkAAABgThAAhgAAAG0BAAAtAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL2R5bmFtaWNzL2pvaW50L211bHRpYm9keV9qb2ludC9tdWx0aWJvZHkucnNYTxAAgAAAAIsAAAARAAAAWE8QAIAAAACOAAAAHgAAAFhPEACAAAAAjgAAABEAAABYTxAAgAAAAJEAAAAnAAAAWE8QAIAAAACRAAAAIAAAAFhPEACAAAAAsgAAACsAAABYTxAAgAAAALsAAAAeAAAAWE8QAIAAAADMAAAADQAAAFhPEACAAAAAZAEAAA4AAABYTxAAgAAAAHkBAAAXAAAAWE8QAIAAAAB/AQAAJAAAAFhPEACAAAAAgAEAACIAAABYTxAAgAAAAIIBAAAYAAAAWE8QAIAAAACTAQAAGwAAAFhPEACAAAAArAEAABIAAABYTxAAgAAAAL8BAAAZAAAAWE8QAIAAAADCAQAAKAAAAFhPEACAAAAAyQEAABcAAABYTxAAgAAAAMoBAAAeAAAAWE8QAIAAAADOAQAALAAAAFhPEACAAAAA5AEAABAAAABYTxAAgAAAAO0BAAAkAAAAWE8QAIAAAAAuAgAAGQAAAFhPEACAAAAALwIAABcAAABYTxAAgAAAADMCAAAiAAAAWE8QAIAAAABPAgAAGQAAAFhPEACAAAAAVgIAACQAAABYTxAAgAAAAFcCAAAiAAAAWE8QAIAAAABYAgAAIQAAAFhPEACAAAAAkgIAABEAAABYTxAAgAAAAJMCAAARAAAAWE8QAIAAAACWAgAAIwAAAFhPEACAAAAAlwIAACMAAABYTxAAgAAAAKsCAAAjAAAAWE8QAIAAAACsAgAAIwAAAFhPEACAAAAAzQIAADAAAABYTxAAgAAAAM0CAAANAAAAWE8QAIAAAADOAgAALAAAAFhPEACAAAAAzgIAAA0AAABYTxAAgAAAAN4CAAAOAAAAWE8QAIAAAAD5AgAAIQAAAFhPEACAAAAABQMAACYAAABYTxAAgAAAAAsDAAAVAAAAWE8QAIAAAAATAwAAJgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYudmVsb2NpdGllcy5sZW4oKSA+PSBTUEFUSUFMX0RJTQAAWE8QAIAAAAAXAwAAFQAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuZGFtcGluZy5sZW4oKSA+PSBTUEFUSUFMX0RJTQBYTxAAgAAAABgDAAAVAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5hY2NlbGVyYXRpb25zLmxlbigpID49IFNQQVRJQUxfRElNAAAAWE8QAIAAAAAZAwAAFQAAAFhPEACAAAAAHgMAABUAAABYTxAAgAAAAC8DAAAmAAAAWE8QAIAAAAA4AwAAEAAAAFhPEACAAAAARAMAAB0AAABYTxAAgAAAAFgDAAAiAAAAWE8QAIAAAABZAwAAIAAAAEEgcmlnaWQtYm9keSB0aGF0IGlzIG5vdCBhdCB0aGUgcm9vdCBvZiBhIG11bHRpYm9keSBtdXN0IGJlIGR5bmFtaWMu0FMQAEQAAABYTxAAgAAAAGYDAAANAAAAWE8QAIAAAACUAwAAFQAAAFhPEACAAAAAlgMAAAkAAABYTxAAgAAAAJoDAAAkAAAAWE8QAIAAAACaAwAADQAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9keW5hbWljcy9qb2ludC9tdWx0aWJvZHlfam9pbnQvbXVsdGlib2R5X2pvaW50X3NldC5ycwAAbFQQAIoAAADKAAAAJQAAAGxUEACKAAAAywAAACcAAABsVBAAigAAAMYAAAAdAAAAbFQQAIoAAACzAAAAFQAAAGxUEACKAAAAsQAAACEAAABsVBAAigAAALAAAAAoAAAAbFQQAIoAAACtAAAAHQAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9keW5hbWljcy9qb2ludC9tdWx0aWJvZHlfam9pbnQvbXVsdGlib2R5X2xpbmsucnMAAABoVRAAhQAAAHEAAAAZAAAASW50ZXJuYWwgZXJyb3I6IGNpcmN1bGFyIHJpZ2lkIGJvZHkgZGVwZW5kZW5jeS4AAFYQAC8AAABoVRAAhQAAAHMAAAAJAAAASW52YWxpZCBwYXJlbnQgaW5kZXguAAAASFYQABUAAABoVRAAhQAAAHcAAAAJAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL2R5bmFtaWNzL2pvaW50L211bHRpYm9keV9qb2ludC9tdWx0aWJvZHlfam9pbnQucnMAAHhWEACGAAAAVgAAACMAAAB4VhAAhgAAAHcAAAASAAAAbm90IHlldCBpbXBsZW1lbnRlZAB4VhAAhgAAAGEAAAAuAAAAeFYQAIYAAABhAAAAEQAAAHhWEACGAAAAqQAAABIAAAB4VhAAhgAAAJUAAAAVAAAAeFYQAIYAAAC2AAAAMQAAAHhWEACGAAAA0gAAABIAAAB4VhAAhgAAAMIAAAAmAAAAeFYQAIYAAADgAAAAEQAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9keW5hbWljcy9qb2ludC9tdWx0aWJvZHlfam9pbnQvdW5pdF9tdWx0aWJvZHlfam9pbnQucnMAtFcQAIsAAAAhAAAAFwAAALRXEACLAAAAJQAAAAUAAAC0VxAAiwAAACYAAAAFAAAAtFcQAIsAAABBAAAACQAAALRXEACLAAAAYgAAAAUAAAC0VxAAiwAAAGMAAAAFAAAAtFcQAIsAAAB4AAAAEAAAALRXEACLAAAAiwAAAAkAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjJkLTAuMTcuMi9zcmMvZHluYW1pY3MvcmlnaWRfYm9keV9jb21wb25lbnRzLnJzAADAWBAAdgAAAKYDAAAoAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL2R5bmFtaWNzL3NvbHZlci9jYXRlZ29yaXphdGlvbi5ycwAASFkQAHYAAAAPAAAAGQAAAEhZEAB2AAAANAAAABYAAABIWRAAdgAAADUAAAAUAAAASFkQAHYAAAA2AAAAFAAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9keW5hbWljcy9zb2x2ZXIvZ2VuZXJpY192ZWxvY2l0eV9jb25zdHJhaW50LnJzAABaEACDAAAALAAAABQAAAAAWhAAgwAAAC0AAAAUAAAAAFoQAIMAAAAqAAAAFwAAAABaEACDAAAAKQAAABcAAAAAWhAAgwAAADUAAAAYAAAAAFoQAIMAAAA4AAAAGAAAAABaEACDAAAASQEAACIAAAAAWhAAgwAAAE8BAAAiAAAAAFoQAIMAAABUAQAAHQAAAABa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EACAAAAAawAAAB8AAABsbxAAgAAAAHcAAAAaAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL2dlb21ldHJ5L2Jyb2FkX3BoYXNlX211bHRpX3NhcC9zYXBfcmVnaW9uLnJzAAAATHAQAIEAAABGAAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IG9sZC50b19pbnNlcnQuaXNfZW1wdHkoKQAATHAQAIEAAABHAAAACQAAAExwEACBAAAAgQAAAA0AAABMcBAAgQAAAIkAAAAJAAAATHAQAIEAAACpAAAADQAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9nZW9tZXRyeS9icm9hZF9waGFzZV9tdWx0aV9zYXAvc2FwX3V0aWxzLnJzTHEQAIAAAAANAAAABQAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9nZW9tZXRyeS9pbnRlcmFjdGlvbl9ncmFwaC5ycwAA3HEQAHIAAACDAAAADgAAANxxEAByAAAAgwAAACcAAADccRAAcgAAAIIAAAAdAAAA3HEQAHIAAADxAAAAGwAAANxxEAByAAAA8QAAADQAAADccRAAcgAAAPAAAAAZAAAA3HEQAHIAAADpAAAAHwAAANxxEAByAAAA6QAAADgAAADccRAAcgAAAOgAAAAdAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL2dlb21ldHJ5L25hcnJvd19waGFzZS5ycwAAAOByEABtAAAAqwAAAAoAAADgchAAbQAAAIEBAAARAAAA4HIQAG0AAACNAQAAEQAAAOByEABtAAAA1wEAACYAAADgchAAbQAAANcBAABFAAAA4HIQAG0AAAC4AgAAGwAAAOByEABtAAAAuQIAABsAAADgchAAbQAAALsCAAAYAAAA4HIQAG0AAAC8AgAAGAAAAOByEABtAAAAzAIAACAAAADgchAAbQAAANACAAAgAAAA4HIQAG0AAAAgAwAAGAAAAOByEABtAAAAIQMAABgAAADgchAAbQAAADEDAAAgAAAA4HIQAG0AAAA1AwAAIAAAAEEgY29udGFjdCBtYW5pZm9sZCBjYW5ub3QgY29udGFpbiBtb3JlIHRoYW4gMjU1IGNvbnRhY3RzIGN1cnJlbnRseS4AQHQQAEMAAADgchAAbQAAAKwDAAAZAAAA4HIQAG0AAACXAwAAHwAAAOByEABtAAAAmwMAAB8AAADgchAAbQAAAPoDAAAgAAAA4HIQAG0AAAALBAAAKAAAAOByEABtAAAAFwQAACgAAADgchAAbQAAACsEAAAZAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL2dlb21ldHJ5L2NvbGxpZGVyX3NldC5ycwAAAPx0EABtAAAArAAAAB0AAAD8dBAAbQAAABcBAAAOAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIyZC0wLjE3LjIvc3JjL3BpcGVsaW5lL3BoeXNpY3NfcGlwZWxpbmUucnMAAACMdRAAcQAAAOsAAAARAAAAjHUQAHEAAADyAAAAFgAAAIx1EABxAAAA9AAAABYAAACMdRAAcQAAAC8BAAAYAAAAjHUQAHEAAAAwAQAAGAAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy9waXBlbGluZS9xdWVyeV9waXBlbGluZS5ycwBQdhAAbwAAAF4BAAARAAAAUHYQAG8AAACRAQAAKwAAAFB2EABvAAAAhgEAADQAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjJkLTAuMTcuMi9zcmMvcGlwZWxpbmUvdXNlcl9jaGFuZ2VzLnJzAAAA8HYQAG0AAAAUAAAAJgAAAFVuYWJsZSB0byBpbmRleCB0aGUgc2FtZSBlbGVtZW50IHR3aWNlLgBwdxAAJwAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyMmQtMC4xNy4yL3NyYy91dGlscy5ycwAAAKB3EABdAAAADwMAAAkAAACYQxAAFAAAAKB3EABdAAAAEAMAAAkAAABLaW5lbWF0aWNWZWxvY2l0eUJhc2VkS2luZW1hdGljUG9zaXRpb25CYXNlZEZpeGVkRHluYW1pYwEAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3NpbWJhLTAuOC4wL3NyYy9zaW1kL2F1dG9fc2ltZF9pbXBsLnJzAGR4EABnAAAAvwUAAAEAAAASAQAACAAAAAQAAAATAQAAFAEAABUBAAAgAAAABAAAABYBAAAXAQAAGAAAAAQAAAAYAQAAEgEAABQAAAAEAAAAGQEAABIBAAAYAAAABAAAABoBAAASAQAAEAAAAAQAAAAbAQAAFwEAABwAAAAEAAAAHAEAAB0BAACkAAAABAAAAB4BAAASAQAABAAAAAQAAAAfAQAAIAEAACAAAAAEAAAAIQEAABIBAAAIAAAABAAAACIBAAASAQAAHAAAAAQAAAAjAQAAJAEAADgAAAAEAAAAJQEAACYBAABoAAAABAAAACcBAAAVAQAAIAAAAAQAAAAoAQAAIAEAACAAAAAEAAAAKQEAACoBAABQAAAABAAAACsBAAASAQAADAAAAAQAAAAsAQAAEgEAAAgAAAAEAAAALQEAAC4BAABYAAAABAAAAC8BAABhc3NlcnRpb24gZmFpbGVkOiBtaW4gPD0gbWF4L3J1c3RjLzA0NjhhMDBhZTNmZDZlZjFhNmEwZjllYWY2MzdkN2FhOWU2MDRhY2MvbGlicmFyeS9jb3JlL3NyYy9jbXAucnMAPHoQAEcAAABfAwAACQAAABIBAAAEAAAABAAAADABAAASAQAABAAAAAQAAAAxAQAAEgEAAAQAAAAEAAAAMgEAAGFzc2VydGlvbiBmYWlsZWQ6IG1pZCA8PSBzZWxmLmxlbigpAP//////////L1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9pbmRleG1hcC0xLjkuMS9zcmMvbWFwL2NvcmUucnMA8HoQAF8AAAAqAAAAIwAAAPB6EABfAAAAqwIAAA4AAADwehAAXwAAACIAAAAPAAAATWF0cml4IGluZGV4IG91dCBvZiBib3VuZHMuL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9uYWxnZWJyYS0wLjMyLjEvc3JjL2Jhc2UvbWF0cml4LnJzVmVjdG9yIGNyb3NzIHByb2R1Y3QgZGltZW5zaW9uIG1pc21hdGNoOiBtdXN0IGJlICgzLCAxKSBvciAoMSwgMykgYnV0IGZvdW5kIC4A/nsQAEwAAABKfBAAAQAAAJt7EABjAAAA/wcAAAkAAABJbmRleCBvdXQgb2YgYm91bmRzLmNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUAEgEAAAgAAAAEAAAAMwEAABIBAAAEAAAABAAAADQBAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy9ib3VuZGluZ192b2x1bWUvYWFiYi5yc1RoZSBsb29zZW5pbmcgbWFyZ2luIG11c3QgYmUgcG9zaXRpdmUuAAAAN30QACYAAADMfBAAawAAACECAAAJAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvYm91bmRpbmdfdm9sdW1lL2FhYmJfdXRpbHMucnNQb2ludCBjbG91ZCBBYWJiIGNvbnN0cnVjdGlvbjogdGhlIGlucHV0IGl0ZXJhdG9yIHNob3VsZCB5aWVsZCBhdCBsZWFzdCBvbmUgcG9pbnQuAHh9EABxAAAAQAAAAA4AAAB4fRAAcQAAAFcAAAAOAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvYm91bmRpbmdfdm9sdW1lL2JvdW5kaW5nX3NwaGVyZS5ycwAAXH4QAHYAAAB6AAAACQAAAHR3byBhcnJheXMgY29udGFpbmluZyBhdCBsZWFzdCAgZmxvYXRzAADkfhAAHwAAAAN/EAAHAAAAEAAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkyZC0wLjEzLjEvc3JjL21hc3NfcHJvcGVydGllcy9tYXNzX3Byb3BlcnRpZXNfY29udmV4X3BvbHlnb24ucnMAAAAgfxAAhQAAABMAAAAeAAAAIH8QAIUAAAArAAAAGgAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkyZC0wLjEzLjEvc3JjL21hc3NfcHJvcGVydGllcy9tYXNzX3Byb3BlcnRpZXNfdHJpbWVzaDJkLnJzyH8QAIAAAAAWAAAAEQAAAMh/EACAAAAAFwAAABEAAADIfxAAgAAAABgAAAARAAAAyH8QAIAAAAAvAAAADQAAAMh/EACAAAAAMAAAAA0AAADIfxAAgAAAADEAAAANAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvcGFydGl0aW9uaW5nL3FidmgvdXRpbHMucnMAAKiAEABuAAAAEgAAABEAAACogBAAbgAAABMAAAAWAAAAqIAQAG4AAAAVAAAADAAAAKiAEABuAAAAFwAAABUAAACogBAAbgAAACUAAAARAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvcGFydGl0aW9uaW5nL3FidmgvYnVpbGQucnMAAGiBEABuAAAARAEAAAkAAABogRAAbgAAACwBAAANAAAAaIEQAG4AAAAtAQAADQAAAGiBEABuAAAAWwEAACEAAABogRAAbgAAAF0BAAARAAAAaIEQAG4AAAB5AQAAGgAAAGiBEABuAAAAswEAAAkAAABogRAAbgAAALUBAAAJAAAAaIEQAG4AAAC3AQAACQAAAGiBEABuAAAAuwEAABcAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy9wYXJ0aXRpb25pbmcvcWJ2aC90cmF2ZXJzYWwucnMAAHiCEAByAAAATQAAABkAAAB4ghAAcgAAAJoAAAAZAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvcXVlcnkvY2xpcC9jbGlwX2FhYmJfbGluZS5ycwyDEABwAAAAjQAAAA0AAAAMgxAAcAAAAJsAAAANAAAAVGhlIHByb3hpbWl0eSBtYXJnaW4gbXVzdCBiZSBwb3NpdGl2ZSBvciBudWxsLgAAnIMQAC4AAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy9xdWVyeS9jbG9zZXN0X3BvaW50cy9jbG9zZXN0X3BvaW50c19iYWxsX2JhbGwucnPUgxAAhAAAAA8AAAAFAAAAVGhlIGNvbXBvc2l0ZSBzaGFwZSBtdXN0IG5vdCBiZSBlbXB0eS4vVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy9xdWVyeS9jbG9zZXN0X3BvaW50cy9jbG9zZXN0X3BvaW50c19jb21wb3NpdGVfc2hhcGVfc2hhcGUucnMAAI6EEACQAAAAGQAAAAUAAACOhBAAkAAAAIEAAAAhAAAAjoQQAJAAAACCAAAAIQAAAI6EEACQAAAAgwAAACEAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvcXVlcnkvY2xvc2VzdF9wb2ludHMvY2xvc2VzdF9wb2ludHNfY3Vib2lkX2N1Ym9pZC5yc4iFEACIAAAAUgAAAAUAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy9xdWVyeS9jbG9zZXN0X3BvaW50cy9jbG9zZXN0X3BvaW50c19jdWJvaWRfdHJpYW5nbGUucnMAACCGEACKAAAATQAAAAUAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy9xdWVyeS9jbG9zZXN0X3BvaW50cy9jbG9zZXN0X3BvaW50c19oYWxmc3BhY2Vfc3VwcG9ydF9tYXAucnO8hhAAkAAAAA0AAAAFAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvcXVlcnkvY2xvc2VzdF9wb2ludHMvY2xvc2VzdF9wb2ludHNfc3VwcG9ydF9tYXBfc3VwcG9ydF9tYXAucnMAAFyHEACSAAAAIAAAACQAAAASAQAAGAAAAAQAAAA1AQAANgEAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkyZC0wLjEzLjEvc3JjL3F1ZXJ5L2NvbnRhY3QvY29udGFjdF9zdXBwb3J0X21hcF9zdXBwb3J0X21hcC5ycxSIEACEAAAAHgAAACQAAAAVAQAAIAAAAAQAAAAWAQAANwEAADgBAAA5AQAAOgEAABCJEAAQiRAAOAEAADsBAAA8AQAAIAEAACAAAAAEAAAAKQEAAD0BAAA+AQAAPwEAAEABAABQiRAAUIkQAD4BAABBAQAAQgEAABUBAAAgAAAABAAAABUBAAAgAAAABAAAACgBAABDAQAARAEAAEUBAABGAQAAEIkQABCJEABEAQAARwEAAEgBAAAgAQAAIAAAAAQAAAAgAQAAIAAAAAQAAAAhAQAASQEAAEoBAABLAQAATAEAAFCJEABQiRAASgEAAE0BAABOAQAAKgEAAFAAAAAEAAAAKgEAAFAAAAAEAAAAKwEAAE8BAABQAQAAUQEAAFIBAACQiRAAkIkQAFABAABTAQAAVAEAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkyZC0wLjEzLjEvc3JjL3F1ZXJ5L2Rpc3RhbmNlL2Rpc3RhbmNlX2NvbXBvc2l0ZV9zaGFwZV9zaGFwZS5yc9CJEACEAAAAFQAAAAUAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy9xdWVyeS9kaXN0YW5jZS9kaXN0YW5jZV9zdXBwb3J0X21hcF9zdXBwb3J0X21hcC5ycwAAZIoQAIYAAAA0AAAAJAAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkyZC0wLjEzLjEvc3JjL3F1ZXJ5L2VwYS9lcGEyLnJzAAAA/IoQAGUAAABAAAAAHQAAAPyKEABlAAAAQAAAADYAAAD8ihAAZQAAAFQAAAAzAAAA/IoQAGUAAABUAAAATAAAAPyKEABlAAAAaAAAAA0AAAD8ihAAZQAAAGkAAAATAAAA/IoQAGUAAAASAQAAGQAAAPyKEABlAAAAEgEAADMAAAD8ihAAZQAAABMBAAAZAAAA/IoQAGUAAAATAQAAMwAAAPyKEABlAAAA4AAAABcAAAD8ihAAZQAAAOEAAAAXAAAA/IoQAGUAAAD0AAAAHQAAAPyKEABlAAAA9AAAADcAAAD8ihAAZQAAAPkAAAAdAAAA/IoQAGUAAAD5AAAANwAAAPyKEABlAAAA/gAAAB0AAAD8ihAAZQAAAP4AAAA3AAAA/IoQAGUAAABbAQAAGgAAAPyKEABlAAAAIgEAABgAAAD8ihAAZQAAADYBAAAiAAAA/IoQAGUAAAAbAQAAIQAAAPyKEABlAAAAwQAAABkAAAD8ihAAZQAAANAAAAAZAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvcXVlcnkvZ2prL2dqay5yc+SMEABkAAAAQwAAAA4AAABhc3NlcnRpb24gZmFpbGVkOiBtaW5fYm91bmQgPT0gbWluX2JvdW5k5IwQAGQAAACMAAAACQAAAAAAAADkjBAAZAAAAE8BAAAJAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvcXVlcnkvZ2prL3Zvcm9ub2lfc2ltcGxleDIucnMAAACkjRAAcQAAACEAAAAXAAAApI0QAHEAAAAzAAAAEQAAAKSNEABxAAAAOQAAAAkAAABsfBAAFAAAAKSNEABxAAAAQAAAAAkAAACkjRAAcQAAAEUAAAAJAAAApI0QAHEAAABGAAAACgAAAKSNEABxAAAATAAAAAkAAACkjRAAcQAAAFIAAAAKAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5kaW0gPT0gMgCkjRAAcQAAAHcAAAANAAAApI0QAHEAAAByAAAAFgAAAKSNEABxAAAA2QAAABQAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy9xdWVyeS9pbnRlcnNlY3Rpb25fdGVzdC9pbnRlcnNlY3Rpb25fdGVzdF9zdXBwb3J0X21hcF9zdXBwb3J0X21hcC5yc/COEACYAAAAOQAAACkAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRi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AAAgrhAAcgAAAGoAAAAFAAAAIK4QAHIAAABbAAAADgAAACCuEAByAAAAkwAAABMAAAAgrhAAcgAAAJQAAAATAAAAIK4QAHIAAACuAAAAJgAAACCuEAByAAAAzwAAABQAAAAgrhAAcgAAAM8AAAAhAAAAIK4QAHIAAADgAAAAEwAAACCuEAByAAAA4QAAABMAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy90cmFuc2Zvcm1hdGlvbi9jb252ZXhfaHVsbF91dGlscy5ycwAIsBAAdwAAACkAAAAiAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvdHJhbnNmb3JtYXRpb24vdG9fcG9seWxpbmUvY2Fwc3VsZV90b19wb2x5bGluZS5ycwAAAJCwEACFAAAAEwAAAB0AAACQsBAAhQAAABYAAAANAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvdHJhbnNmb3JtYXRpb24vdG9fcG9seWxpbmUvcm91bmRfY29udmV4X3BvbHlnb25fdG9fcG9seWxpbmUucnMAADixEACSAAAADgAAABYAAAA4sRAAkgAAABQAAAAbAAAAOLEQAJIAAAAUAAAAJgAAADixEACSAAAAEwAAAB4AAAA4sRAAkgAAABsAAAAaAAAAOLEQAJIAAAAOAAAAIQAAAC9Vc2Vycy9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkyZC0wLjEzLjEvc3JjL3RyYW5zZm9ybWF0aW9uL3V0aWxzLnJzYXNzZXJ0aW9uIGZhaWxlZDogbnN1YmRpdnMgPiAwAAAALLIQAGsAAADWAAAABQAAAENhbm5vdCBjb21wdXRlIHRoZSBjZW50ZXIgb2YgbGVzcyB0aGFuIDEgcG9pbnQuAMiyEAAvAAAAL1VzZXJzL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTJkLTAuMTMuMS9zcmMvdXRpbHMvY2VudGVyLnJzAACzEABjAAAABwAAAAUAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5MmQtMC4xMy4xL3NyYy91dGlscy9wb2ludF9jbG91ZF9zdXBwb3J0X3BvaW50LnJzAAB0sxAAdgAAAAcAAAAYAAAAQWFiYm1pbnNtYXhzEgEAAAwAAAAEAAAADwMAABADAAARAwAAEgMAABIBAAAcAAAABAAAABMDAAAUAwAAFQMAABYDAAAXAQAAHAAAAAQAAAAXAwAAGAMAABkDAAAaAwAAAACAPwAAgD8AAIC/AACAvwAAgD8AAIC/AACAPwAAgL9IYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93fLQQABwAAAAvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2hhc2hicm93bi0wLjEyLjMvc3JjL3Jhdy9tb2QucnOgtBAAYAAAAFoAAAAoAAAAGwMAAAgAAAAEAAAAHAMAAB0DAAAbAwAACAAAAAQAAAAeAwAAQXJyYXlWZWM6IGNhcGFjaXR5IGV4Y2VlZGVkIGluIGV4dGVuZC9mcm9tX2l0ZXIvVXNlcnMvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2FycmF5dmVjLTAuNy4yL3NyYy9hcnJheXZlYy5ycwAAY7UQAF8AAAABBAAABQAAADhj7T7aD0k/Xph7P9oPyT9pN6wxaCEiM7QPFDNoIaIzAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAAAAAAAAAAABA+yH5PwAAAAAtRHQ+AAAAgJhG+DwAAABgUcx4OwAAAICDG/A5AAAAQCAlejgAAACAIoLjNgAAAAAd82k12w9JP9sPSb/kyxZAAAAAAAAAAIDbD0lAYnl0ZSBhcnJheXN0cnVjdCB2YXJpYW50crcQAA4AAAB0dXBsZSB2YXJpYW50AAAAiLcQAA0AAABuZXd0eXBlIHZhcmlhbnQAoLcQAA8AAAB1bml0IHZhcmlhbnS4txAADAAAAGVudW3MtxAABAAAAG1hcADYtxAAAwAAAHNlcXVlbmNl5LcQAAgAAABuZXd0eXBlIHN0cnVjdAAA9LcQAA4AAABPcHRpb24gdmFsdWUMuBAADAAAAHVuaXQgdmFsdWUAACC4EAAKAAAAaLcQAAoAAABzdHJpbmcgADy4EAAHAAAAY2hhcmFjdGVyIGBgTLgQAAsAAABXuBAAAQAAAGZsb2F0aW5nIHBvaW50IGBouBAAEAAAAFe4EAABAAAAaW50ZWdlciBgAAAAiLgQAAkAAABXuBAAAQAAAGJvb2xlYW4gYAAAAKS4EAAJAAAAV7gQAAEAAAB1c2l6ZQAAACUDAAAEAAAABAAAACYDAAAnAwAAKAMAAGFscmVhZHkgYm9ycm93ZWQlAwAAAAAAAAEAAAApAwAAAG92ZXJmbG93IGluIER1cmF0aW9uOjpuZXcAAAG5EAAZAAAAL3J1c3RjLzA0NjhhMDBhZTNmZDZlZjFhNmEwZjllYWY2MzdkN2FhOWU2MDRhY2MvbGlicmFyeS9jb3JlL3NyYy90aW1lLnJzJLkQAEgAAADKAAAAFQAAACUDAAAEAAAABAAAACoDAAAlAwAABAAAAAQAAAArAwAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZXVzZSBvZiBzdGQ6OnRocmVhZDo6Y3VycmVudCgpIGlzIG5vdCBwb3NzaWJsZSBhZnRlciB0aGUgdGhyZWFkJ3MgbG9jYWwgZGF0YSBoYXMgYmVlbiBkZXN0cm95ZWRsaWJyYXJ5L3N0ZC9zcmMvdGhyZWFkL21vZC5ycwAAJboQAB0AAADcAgAABQAAAGZhaWxlZCB0byBnZW5lcmF0ZSB1bmlxdWUgdGhyZWFkIElEOiBiaXRzcGFjZSBleGhhdXN0ZWQAVLoQADcAAAAluhAAHQAAAFUEAAANAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZVBvaXNvbkVycm9yb3ZlcmZsb3cgd2hlbiBhZGRpbmcgZHVyYXRpb24gdG8gaW5zdGFudGxpYnJhcnkvc3RkL3NyYy90aW1lLnJzAAAAArsQABcAAACYAQAACQAAAGxpYnJhcnkvc3RkL3NyYy9zeXNfY29tbW9uL3RocmVhZF9pbmZvLnJzAAAALLsQACkAAAAWAAAAMwAAAG1lbW9yeSBhbGxvY2F0aW9uIG9mICBieXRlcyBmYWlsZWQKAGi7EAAVAAAAfbsQAA4AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnOcuxAAGAAAAFUBAAAJAAAAbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5yc8S7EAAcAAAAPgIAAA8AAADEuxAAHAAAAD0CAAAPAAAALAMAAAwAAAAEAAAALQMAACUDAAAIAAAABAAAAC4DAAAvAwAAEAAAAAQAAAAwAwAAMQMAACUDAAAIAAAABAAAADIDAAAzAwAAJQMAAAAAAAABAAAANAMAAHRpbWUgbm90IGltcGxlbWVudGVkIG9uIHRoaXMgcGxhdGZvcm0AAABYvBAAJQAAAGxpYnJhcnkvc3RkL3NyYy9zeXMvd2FzbS8uLi91bnN1cHBvcnRlZC90aW1lLnJzAIi8EAAvAAAADQAAAAkAAABjb25kdmFyIHdhaXQgbm90IHN1cHBvcnRlZAAAyLwQABoAAABsaWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5zdXBwb3J0ZWQvbG9ja3MvY29uZHZhci5yc+y8EAA4AAAAFAAAAAkAAADsvBAAOAAAABgAAAAJAAAAY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXhEvRAAIAAAAGxpYnJhcnkvc3RkL3NyYy9zeXMvd2FzbS8uLi91bnN1cHBvcnRlZC9sb2Nrcy9tdXRleC5ycwAAbL0QADYAAAAUAAAACQAAAAIAAAA1AwAACAAAAAQAAAA2AwAAbGlicmFyeS9zdGQvc3JjL3N5c19jb21tb24vdGhyZWFkX3Bhcmtlci9nZW5lcmljLnJzAMi9EAAzAAAAJwAAABUAAABpbmNvbnNpc3RlbnQgcGFyayBzdGF0ZQAMvhAAFwAAAMi9EAAzAAAANQAAABcAAABwYXJrIHN0YXRlIGNoYW5nZWQgdW5leHBlY3RlZGx5ADy+EAAfAAAAyL0QADMAAAAyAAAAEQAAAMi9EAAzAAAASAAAABEAAABpbmNvbnNpc3RlbnQgcGFya190aW1lb3V0IHN0YXRlAIS+EAAfAAAAyL0QADMAAABRAAAAFwAAAMi9EAAzAAAATgAAABEAAABpbmNvbnNpc3RlbnQgc3RhdGUgaW4gdW5wYXJrzL4QABwAAADIvRAAMwAAAGwAAAASAAAAyL0QADMAAAB6AAAADgAAAEhhc2ggdGFibGUgY2FwYWNpdHkgb3ZlcmZsb3cQvxAAHAAAAC9jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2hhc2hicm93bi0wLjEyLjMvc3JjL3Jhdy9tb2QucnMANL8QAE8AAABaAAAAKAAAADcDAAAEAAAABAAAADgDAAA5AwAAOgMAAGxpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnNjYXBhY2l0eSBvdmVyZmxvdwAAAMi/EAARAAAArL8QABwAAAAGAgAABQAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvcgA3AwAAAAAAAAEAAAAbAAAAbGlicmFyeS9hbGxvYy9zcmMvZm10LnJzOMAQABgAAABkAgAACQAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUANwMAAAAAAAABAAAAOwMAAGxpYnJhcnkvYWxsb2Mvc3JjL3N5bmMucnMAAACcwBAAGQAAAFYBAAAFAAAAc3dhcF9yZW1vdmUgaW5kZXggKGlzICkgc2hvdWxkIGJlIDwgbGVuIChpcyApAAAAyMAQABYAAADewBAAFgAAAPTA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").buffer);
  });
};
var TI = function() {
  return function() {
    try {
      const C = A.__wbindgen_add_to_stack_pointer(-16);
      A.version(C);
      var I = G()[C / 4 + 0], g2 = G()[C / 4 + 1];
      return h(I, g2);
    } finally {
      A.__wbindgen_add_to_stack_pointer(16), A.__wbindgen_free(I, g2);
    }
  }();
};
var A;
var I = new Array(32).fill(undefined);
I.push(undefined, null, true, false);
var C = I.length;
var i = new Float64Array;
var D = new Int32Array;
var w = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
w.decode();
var a = new Uint8Array;
var K = new Float32Array;
var N = 32;
var R = new Uint32Array;
var M = 0;
Object.freeze({ Revolute: 0, 0: "Revolute", Fixed: 1, 1: "Fixed", Prismatic: 2, 2: "Prismatic", Generic: 3, 3: "Generic" }), Object.freeze({ AccelerationBased: 0, 0: "AccelerationBased", ForceBased: 1, 1: "ForceBased" });
var c = Object.freeze({ X: 0, 0: "X", Y: 1, 1: "Y", AngX: 2, 2: "AngX" });
Object.freeze({ Dynamic: 0, 0: "Dynamic", Fixed: 1, 1: "Fixed", KinematicPositionBased: 2, 2: "KinematicPositionBased", KinematicVelocityBased: 3, 3: "KinematicVelocityBased" }), Object.freeze({ Vertex: 0, 0: "Vertex", Face: 1, 1: "Face", Unknown: 2, 2: "Unknown" }), Object.freeze({ Ball: 0, 0: "Ball", Cuboid: 1, 1: "Cuboid", Capsule: 2, 2: "Capsule", Segment: 3, 3: "Segment", Polyline: 4, 4: "Polyline", Triangle: 5, 5: "Triangle", TriMesh: 6, 6: "TriMesh", HeightField: 7, 7: "HeightField", Compound: 8, 8: "Compound", ConvexPolygon: 9, 9: "ConvexPolygon", RoundCuboid: 10, 10: "RoundCuboid", RoundTriangle: 11, 11: "RoundTriangle", RoundConvexPolygon: 12, 12: "RoundConvexPolygon", HalfSpace: 13, 13: "HalfSpace" });

class Y {
  static __wrap(A2) {
    const I2 = Object.create(Y.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawbroadphase_free(I2);
  }
  constructor() {
    const I2 = A.rawbroadphase_new();
    return Y.__wrap(I2);
  }
}

class L {
  static __wrap(A2) {
    const I2 = Object.create(L.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawccdsolver_free(I2);
  }
  constructor() {
    const I2 = A.rawccdsolver_new();
    return L.__wrap(I2);
  }
}

class t {
  static __wrap(A2) {
    const I2 = Object.create(t.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawcharactercollision_free(I2);
  }
  constructor() {
    const I2 = A.rawcharactercollision_new();
    return t.__wrap(I2);
  }
  handle() {
    return A.rawcharactercollision_handle(this.ptr);
  }
  translationApplied() {
    const I2 = A.rawcharactercollision_translationApplied(this.ptr);
    return BA.__wrap(I2);
  }
  translationRemaining() {
    const I2 = A.rawcharactercollision_translationRemaining(this.ptr);
    return BA.__wrap(I2);
  }
  toi() {
    return A.rawcharactercollision_toi(this.ptr);
  }
  worldWitness1() {
    const I2 = A.rawcharactercollision_worldWitness1(this.ptr);
    return BA.__wrap(I2);
  }
  worldWitness2() {
    const I2 = A.rawcharactercollision_worldWitness2(this.ptr);
    return BA.__wrap(I2);
  }
  worldNormal1() {
    const I2 = A.rawcharactercollision_worldNormal1(this.ptr);
    return BA.__wrap(I2);
  }
  worldNormal2() {
    const I2 = A.rawcharactercollision_worldNormal2(this.ptr);
    return BA.__wrap(I2);
  }
}

class H {
  static __wrap(A2) {
    const I2 = Object.create(H.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawcolliderset_free(I2);
  }
  coTranslation(I2) {
    const g2 = A.rawcolliderset_coTranslation(this.ptr, I2);
    return BA.__wrap(g2);
  }
  coRotation(I2) {
    const g2 = A.rawcolliderset_coRotation(this.ptr, I2);
    return _.__wrap(g2);
  }
  coSetTranslation(I2, g2, C2) {
    A.rawcolliderset_coSetTranslation(this.ptr, I2, g2, C2);
  }
  coSetTranslationWrtParent(I2, g2, C2) {
    A.rawcolliderset_coSetTranslationWrtParent(this.ptr, I2, g2, C2);
  }
  coSetRotation(I2, g2) {
    A.rawcolliderset_coSetRotation(this.ptr, I2, g2);
  }
  coSetRotationWrtParent(I2, g2) {
    A.rawcolliderset_coSetRotationWrtParent(this.ptr, I2, g2);
  }
  coIsSensor(I2) {
    return A.rawcolliderset_coIsSensor(this.ptr, I2) !== 0;
  }
  coShapeType(I2) {
    return A.rawcolliderset_coShapeType(this.ptr, I2) >>> 0;
  }
  coHalfspaceNormal(I2) {
    const g2 = A.rawcolliderset_coHalfspaceNormal(this.ptr, I2);
    return g2 === 0 ? undefined : BA.__wrap(g2);
  }
  coHalfExtents(I2) {
    const g2 = A.rawcolliderset_coHalfExtents(this.ptr, I2);
    return g2 === 0 ? undefined : BA.__wrap(g2);
  }
  coSetHalfExtents(I2, g2) {
    k(g2, BA), A.rawcolliderset_coSetHalfExtents(this.ptr, I2, g2.ptr);
  }
  coRadius(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coRadius(B2, this.ptr, I2);
      var g2 = G()[B2 / 4 + 0], C2 = S()[B2 / 4 + 1];
      return g2 === 0 ? undefined : C2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coSetRadius(I2, g2) {
    A.rawcolliderset_coSetRadius(this.ptr, I2, g2);
  }
  coHalfHeight(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coHalfHeight(B2, this.ptr, I2);
      var g2 = G()[B2 / 4 + 0], C2 = S()[B2 / 4 + 1];
      return g2 === 0 ? undefined : C2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coSetHalfHeight(I2, g2) {
    A.rawcolliderset_coSetHalfHeight(this.ptr, I2, g2);
  }
  coRoundRadius(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coRoundRadius(B2, this.ptr, I2);
      var g2 = G()[B2 / 4 + 0], C2 = S()[B2 / 4 + 1];
      return g2 === 0 ? undefined : C2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coSetRoundRadius(I2, g2) {
    A.rawcolliderset_coSetRoundRadius(this.ptr, I2, g2);
  }
  coVertices(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coVertices(B2, this.ptr, I2);
      var g2 = G()[B2 / 4 + 0], C2 = G()[B2 / 4 + 1];
      let Q2;
      return g2 !== 0 && (Q2 = y(g2, C2).slice(), A.__wbindgen_free(g2, 4 * C2)), Q2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coIndices(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coIndices(B2, this.ptr, I2);
      var g2 = G()[B2 / 4 + 0], C2 = G()[B2 / 4 + 1];
      let Q2;
      return g2 !== 0 && (Q2 = function(A2, I3) {
        return J().subarray(A2 / 4, A2 / 4 + I3);
      }(g2, C2).slice(), A.__wbindgen_free(g2, 4 * C2)), Q2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coHeightfieldHeights(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coHeightfieldHeights(B2, this.ptr, I2);
      var g2 = G()[B2 / 4 + 0], C2 = G()[B2 / 4 + 1];
      let Q2;
      return g2 !== 0 && (Q2 = y(g2, C2).slice(), A.__wbindgen_free(g2, 4 * C2)), Q2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coHeightfieldScale(I2) {
    const g2 = A.rawcolliderset_coHeightfieldScale(this.ptr, I2);
    return g2 === 0 ? undefined : BA.__wrap(g2);
  }
  coParent(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coParent(B2, this.ptr, I2);
      var g2 = G()[B2 / 4 + 0], C2 = o()[B2 / 8 + 1];
      return g2 === 0 ? undefined : C2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coSetEnabled(I2, g2) {
    A.rawcolliderset_coSetEnabled(this.ptr, I2, g2);
  }
  coIsEnabled(I2) {
    return A.rawcolliderset_coIsEnabled(this.ptr, I2) !== 0;
  }
  coFriction(I2) {
    return A.rawcolliderset_coFriction(this.ptr, I2);
  }
  coRestitution(I2) {
    return A.rawcolliderset_coRestitution(this.ptr, I2);
  }
  coDensity(I2) {
    return A.rawcolliderset_coDensity(this.ptr, I2);
  }
  coMass(I2) {
    return A.rawcolliderset_coMass(this.ptr, I2);
  }
  coVolume(I2) {
    return A.rawcolliderset_coVolume(this.ptr, I2);
  }
  coCollisionGroups(I2) {
    return A.rawcolliderset_coCollisionGroups(this.ptr, I2) >>> 0;
  }
  coSolverGroups(I2) {
    return A.rawcolliderset_coSolverGroups(this.ptr, I2) >>> 0;
  }
  coActiveHooks(I2) {
    return A.rawcolliderset_coActiveHooks(this.ptr, I2) >>> 0;
  }
  coActiveCollisionTypes(I2) {
    return A.rawcolliderset_coActiveCollisionTypes(this.ptr, I2);
  }
  coActiveEvents(I2) {
    return A.rawcolliderset_coActiveEvents(this.ptr, I2) >>> 0;
  }
  coContactForceEventThreshold(I2) {
    return A.rawcolliderset_coContactForceEventThreshold(this.ptr, I2);
  }
  coContainsPoint(I2, g2) {
    k(g2, BA);
    return A.rawcolliderset_coContainsPoint(this.ptr, I2, g2.ptr) !== 0;
  }
  coCastShape(I2, g2, C2, B2, Q2, E2, i2, o2) {
    k(g2, BA), k(C2, AA), k(B2, BA), k(Q2, _), k(E2, BA);
    const D2 = A.rawcolliderset_coCastShape(this.ptr, I2, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, E2.ptr, i2, o2);
    return D2 === 0 ? undefined : CA.__wrap(D2);
  }
  coCastCollider(I2, g2, C2, B2, Q2, E2) {
    k(g2, BA), k(B2, BA);
    const i2 = A.rawcolliderset_coCastCollider(this.ptr, I2, g2.ptr, C2, B2.ptr, Q2, E2);
    return i2 === 0 ? undefined : IA.__wrap(i2);
  }
  coIntersectsShape(I2, g2, C2, B2) {
    k(g2, AA), k(C2, BA), k(B2, _);
    return A.rawcolliderset_coIntersectsShape(this.ptr, I2, g2.ptr, C2.ptr, B2.ptr) !== 0;
  }
  coContactShape(I2, g2, C2, B2, Q2) {
    k(g2, AA), k(C2, BA), k(B2, _);
    const E2 = A.rawcolliderset_coContactShape(this.ptr, I2, g2.ptr, C2.ptr, B2.ptr, Q2);
    return E2 === 0 ? undefined : gA.__wrap(E2);
  }
  coContactCollider(I2, g2, C2) {
    const B2 = A.rawcolliderset_coContactCollider(this.ptr, I2, g2, C2);
    return B2 === 0 ? undefined : gA.__wrap(B2);
  }
  coProjectPoint(I2, g2, C2) {
    k(g2, BA);
    const B2 = A.rawcolliderset_coProjectPoint(this.ptr, I2, g2.ptr, C2);
    return V.__wrap(B2);
  }
  coIntersectsRay(I2, g2, C2, B2) {
    k(g2, BA), k(C2, BA);
    return A.rawcolliderset_coIntersectsRay(this.ptr, I2, g2.ptr, C2.ptr, B2) !== 0;
  }
  coCastRay(I2, g2, C2, B2, Q2) {
    k(g2, BA), k(C2, BA);
    return A.rawcolliderset_coCastRay(this.ptr, I2, g2.ptr, C2.ptr, B2, Q2);
  }
  coCastRayAndGetNormal(I2, g2, C2, B2, Q2) {
    k(g2, BA), k(C2, BA);
    const E2 = A.rawcolliderset_coCastRayAndGetNormal(this.ptr, I2, g2.ptr, C2.ptr, B2, Q2);
    return E2 === 0 ? undefined : u.__wrap(E2);
  }
  coSetSensor(I2, g2) {
    A.rawcolliderset_coSetSensor(this.ptr, I2, g2);
  }
  coSetRestitution(I2, g2) {
    A.rawcolliderset_coSetRestitution(this.ptr, I2, g2);
  }
  coSetFriction(I2, g2) {
    A.rawcolliderset_coSetFriction(this.ptr, I2, g2);
  }
  coFrictionCombineRule(I2) {
    return A.rawcolliderset_coFrictionCombineRule(this.ptr, I2) >>> 0;
  }
  coSetFrictionCombineRule(I2, g2) {
    A.rawcolliderset_coSetFrictionCombineRule(this.ptr, I2, g2);
  }
  coRestitutionCombineRule(I2) {
    return A.rawcolliderset_coRestitutionCombineRule(this.ptr, I2) >>> 0;
  }
  coSetRestitutionCombineRule(I2, g2) {
    A.rawcolliderset_coSetRestitutionCombineRule(this.ptr, I2, g2);
  }
  coSetCollisionGroups(I2, g2) {
    A.rawcolliderset_coSetCollisionGroups(this.ptr, I2, g2);
  }
  coSetSolverGroups(I2, g2) {
    A.rawcolliderset_coSetSolverGroups(this.ptr, I2, g2);
  }
  coSetActiveHooks(I2, g2) {
    A.rawcolliderset_coSetActiveHooks(this.ptr, I2, g2);
  }
  coSetActiveEvents(I2, g2) {
    A.rawcolliderset_coSetActiveEvents(this.ptr, I2, g2);
  }
  coSetActiveCollisionTypes(I2, g2) {
    A.rawcolliderset_coSetActiveCollisionTypes(this.ptr, I2, g2);
  }
  coSetShape(I2, g2) {
    k(g2, AA), A.rawcolliderset_coSetShape(this.ptr, I2, g2.ptr);
  }
  coSetContactForceEventThreshold(I2, g2) {
    A.rawcolliderset_coSetContactForceEventThreshold(this.ptr, I2, g2);
  }
  coSetDensity(I2, g2) {
    A.rawcolliderset_coSetDensity(this.ptr, I2, g2);
  }
  coSetMass(I2, g2) {
    A.rawcolliderset_coSetMass(this.ptr, I2, g2);
  }
  coSetMassProperties(I2, g2, C2, B2) {
    k(C2, BA), A.rawcolliderset_coSetMassProperties(this.ptr, I2, g2, C2.ptr, B2);
  }
  constructor() {
    const I2 = A.rawcolliderset_new();
    return H.__wrap(I2);
  }
  len() {
    return A.rawcolliderset_len(this.ptr) >>> 0;
  }
  contains(I2) {
    return A.rawcolliderset_contains(this.ptr, I2) !== 0;
  }
  createCollider(I2, g2, C2, B2, Q2, E2, i2, D2, w2, a2, h2, K2, S2, N2, F2, y2, R2, J2, M2, s2, U2, q2, c2) {
    try {
      const t2 = A.__wbindgen_add_to_stack_pointer(-16);
      k(g2, AA), k(C2, BA), k(B2, _), k(i2, BA), k(c2, z), A.rawcolliderset_createCollider(t2, this.ptr, I2, g2.ptr, C2.ptr, B2.ptr, Q2, E2, i2.ptr, D2, w2, a2, h2, K2, S2, N2, F2, y2, R2, J2, M2, s2, U2, q2, c2.ptr);
      var Y2 = G()[t2 / 4 + 0], L2 = o()[t2 / 8 + 1];
      return Y2 === 0 ? undefined : L2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  remove(I2, g2, C2, B2) {
    k(g2, b), k(C2, z), A.rawcolliderset_remove(this.ptr, I2, g2.ptr, C2.ptr, B2);
  }
  isHandleValid(I2) {
    return A.rawcolliderset_contains(this.ptr, I2) !== 0;
  }
  forEachColliderHandle(g2) {
    try {
      A.rawcolliderset_forEachColliderHandle(this.ptr, F(g2));
    } finally {
      I[N++] = undefined;
    }
  }
}

class r {
  static __wrap(A2) {
    const I2 = Object.create(r.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawcontactforceevent_free(I2);
  }
  collider1() {
    return A.rawcontactforceevent_collider1(this.ptr);
  }
  collider2() {
    return A.rawcontactforceevent_collider2(this.ptr);
  }
  total_force() {
    const I2 = A.rawcontactforceevent_total_force(this.ptr);
    return BA.__wrap(I2);
  }
  total_force_magnitude() {
    return A.rawcontactforceevent_total_force_magnitude(this.ptr);
  }
  max_force_direction() {
    const I2 = A.rawcharactercollision_translationApplied(this.ptr);
    return BA.__wrap(I2);
  }
  max_force_magnitude() {
    return A.rawcontactforceevent_max_force_magnitude(this.ptr);
  }
}

class l {
  static __wrap(A2) {
    const I2 = Object.create(l.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawcontactmanifold_free(I2);
  }
  normal() {
    const I2 = A.rawcontactmanifold_normal(this.ptr);
    return BA.__wrap(I2);
  }
  local_n1() {
    const I2 = A.rawcontactmanifold_local_n1(this.ptr);
    return BA.__wrap(I2);
  }
  local_n2() {
    const I2 = A.rawcontactmanifold_local_n2(this.ptr);
    return BA.__wrap(I2);
  }
  subshape1() {
    return A.rawcontactmanifold_subshape1(this.ptr) >>> 0;
  }
  subshape2() {
    return A.rawcontactmanifold_subshape2(this.ptr) >>> 0;
  }
  num_contacts() {
    return A.rawcontactmanifold_num_contacts(this.ptr) >>> 0;
  }
  contact_local_p1(I2) {
    const g2 = A.rawcontactmanifold_contact_local_p1(this.ptr, I2);
    return g2 === 0 ? undefined : BA.__wrap(g2);
  }
  contact_local_p2(I2) {
    const g2 = A.rawcontactmanifold_contact_local_p2(this.ptr, I2);
    return g2 === 0 ? undefined : BA.__wrap(g2);
  }
  contact_dist(I2) {
    return A.rawcontactmanifold_contact_dist(this.ptr, I2);
  }
  contact_fid1(I2) {
    return A.rawcontactmanifold_contact_fid1(this.ptr, I2) >>> 0;
  }
  contact_fid2(I2) {
    return A.rawcontactmanifold_contact_fid2(this.ptr, I2) >>> 0;
  }
  contact_impulse(I2) {
    return A.rawcontactmanifold_contact_impulse(this.ptr, I2);
  }
  contact_tangent_impulse(I2) {
    return A.rawcontactmanifold_contact_tangent_impulse(this.ptr, I2);
  }
  num_solver_contacts() {
    return A.rawcontactmanifold_num_solver_contacts(this.ptr) >>> 0;
  }
  solver_contact_point(I2) {
    const g2 = A.rawcontactmanifold_solver_contact_point(this.ptr, I2);
    return g2 === 0 ? undefined : BA.__wrap(g2);
  }
  solver_contact_dist(I2) {
    return A.rawcontactmanifold_solver_contact_dist(this.ptr, I2);
  }
  solver_contact_friction(I2) {
    return A.rawcontactmanifold_solver_contact_friction(this.ptr, I2);
  }
  solver_contact_restitution(I2) {
    return A.rawcontactmanifold_solver_contact_restitution(this.ptr, I2);
  }
  solver_contact_tangent_velocity(I2) {
    const g2 = A.rawcontactmanifold_solver_contact_tangent_velocity(this.ptr, I2);
    return BA.__wrap(g2);
  }
}

class p {
  static __wrap(A2) {
    const I2 = Object.create(p.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawcontactpair_free(I2);
  }
  collider1() {
    return A.rawcontactpair_collider1(this.ptr);
  }
  collider2() {
    return A.rawcontactpair_collider2(this.ptr);
  }
  numContactManifolds() {
    return A.rawcontactpair_numContactManifolds(this.ptr) >>> 0;
  }
  contactManifold(I2) {
    const g2 = A.rawcontactpair_contactManifold(this.ptr, I2);
    return g2 === 0 ? undefined : l.__wrap(g2);
  }
}

class e {
  static __wrap(A2) {
    const I2 = Object.create(e.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawdebugrenderpipeline_free(I2);
  }
  constructor() {
    const I2 = A.rawdebugrenderpipeline_new();
    return e.__wrap(I2);
  }
  vertices() {
    return B(A.rawdebugrenderpipeline_vertices(this.ptr));
  }
  colors() {
    return B(A.rawdebugrenderpipeline_colors(this.ptr));
  }
  render(I2, g2, C2, B2, Q2) {
    k(I2, z), k(g2, H), k(C2, x), k(B2, j), k(Q2, O), A.rawdebugrenderpipeline_render(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr);
  }
}

class n {
  static __wrap(A2) {
    const I2 = Object.create(n.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawdeserializedworld_free(I2);
  }
  takeGravity() {
    const I2 = A.rawdeserializedworld_takeGravity(this.ptr);
    return I2 === 0 ? undefined : BA.__wrap(I2);
  }
  takeIntegrationParameters() {
    const I2 = A.rawdeserializedworld_takeIntegrationParameters(this.ptr);
    return I2 === 0 ? undefined : Z.__wrap(I2);
  }
  takeIslandManager() {
    const I2 = A.rawdeserializedworld_takeIslandManager(this.ptr);
    return I2 === 0 ? undefined : b.__wrap(I2);
  }
  takeBroadPhase() {
    const I2 = A.rawdeserializedworld_takeBroadPhase(this.ptr);
    return I2 === 0 ? undefined : Y.__wrap(I2);
  }
  takeNarrowPhase() {
    const I2 = A.rawdeserializedworld_takeNarrowPhase(this.ptr);
    return I2 === 0 ? undefined : O.__wrap(I2);
  }
  takeBodies() {
    const I2 = A.rawdeserializedworld_takeBodies(this.ptr);
    return I2 === 0 ? undefined : z.__wrap(I2);
  }
  takeColliders() {
    const I2 = A.rawdeserializedworld_takeColliders(this.ptr);
    return I2 === 0 ? undefined : H.__wrap(I2);
  }
  takeImpulseJoints() {
    const I2 = A.rawdeserializedworld_takeImpulseJoints(this.ptr);
    return I2 === 0 ? undefined : x.__wrap(I2);
  }
  takeMultibodyJoints() {
    const I2 = A.rawdeserializedworld_takeMultibodyJoints(this.ptr);
    return I2 === 0 ? undefined : j.__wrap(I2);
  }
}

class d {
  static __wrap(A2) {
    const I2 = Object.create(d.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_raweventqueue_free(I2);
  }
  constructor(I2) {
    const g2 = A.raweventqueue_new(I2);
    return d.__wrap(g2);
  }
  drainCollisionEvents(g2) {
    try {
      A.raweventqueue_drainCollisionEvents(this.ptr, F(g2));
    } finally {
      I[N++] = undefined;
    }
  }
  drainContactForceEvents(g2) {
    try {
      A.raweventqueue_drainContactForceEvents(this.ptr, F(g2));
    } finally {
      I[N++] = undefined;
    }
  }
  clear() {
    A.raweventqueue_clear(this.ptr);
  }
}

class T {
  static __wrap(A2) {
    const I2 = Object.create(T.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawgenericjoint_free(I2);
  }
  static prismatic(I2, g2, C2, B2, Q2, E2) {
    k(I2, BA), k(g2, BA), k(C2, BA);
    const i2 = A.rawgenericjoint_prismatic(I2.ptr, g2.ptr, C2.ptr, B2, Q2, E2);
    return i2 === 0 ? undefined : T.__wrap(i2);
  }
  static fixed(I2, g2, C2, B2) {
    k(I2, BA), k(g2, _), k(C2, BA), k(B2, _);
    const Q2 = A.rawgenericjoint_fixed(I2.ptr, g2.ptr, C2.ptr, B2.ptr);
    return T.__wrap(Q2);
  }
  static revolute(I2, g2) {
    k(I2, BA), k(g2, BA);
    const C2 = A.rawgenericjoint_revolute(I2.ptr, g2.ptr);
    return C2 === 0 ? undefined : T.__wrap(C2);
  }
}

class x {
  static __wrap(A2) {
    const I2 = Object.create(x.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawimpulsejointset_free(I2);
  }
  jointType(I2) {
    return A.rawimpulsejointset_jointType(this.ptr, I2) >>> 0;
  }
  jointBodyHandle1(I2) {
    return A.rawimpulsejointset_jointBodyHandle1(this.ptr, I2);
  }
  jointBodyHandle2(I2) {
    return A.rawimpulsejointset_jointBodyHandle2(this.ptr, I2);
  }
  jointFrameX1(I2) {
    const g2 = A.rawimpulsejointset_jointFrameX1(this.ptr, I2);
    return _.__wrap(g2);
  }
  jointFrameX2(I2) {
    const g2 = A.rawimpulsejointset_jointFrameX2(this.ptr, I2);
    return _.__wrap(g2);
  }
  jointAnchor1(I2) {
    const g2 = A.rawimpulsejointset_jointAnchor1(this.ptr, I2);
    return BA.__wrap(g2);
  }
  jointAnchor2(I2) {
    const g2 = A.rawimpulsejointset_jointAnchor2(this.ptr, I2);
    return BA.__wrap(g2);
  }
  jointSetAnchor1(I2, g2) {
    k(g2, BA), A.rawimpulsejointset_jointSetAnchor1(this.ptr, I2, g2.ptr);
  }
  jointSetAnchor2(I2, g2) {
    k(g2, BA), A.rawimpulsejointset_jointSetAnchor2(this.ptr, I2, g2.ptr);
  }
  jointContactsEnabled(I2) {
    return A.rawimpulsejointset_jointContactsEnabled(this.ptr, I2) !== 0;
  }
  jointSetContactsEnabled(I2, g2) {
    A.rawimpulsejointset_jointSetContactsEnabled(this.ptr, I2, g2);
  }
  jointLimitsEnabled(I2, g2) {
    return A.rawimpulsejointset_jointLimitsEnabled(this.ptr, I2, g2) !== 0;
  }
  jointLimitsMin(I2, g2) {
    return A.rawimpulsejointset_jointLimitsMin(this.ptr, I2, g2);
  }
  jointLimitsMax(I2, g2) {
    return A.rawimpulsejointset_jointLimitsMax(this.ptr, I2, g2);
  }
  jointSetLimits(I2, g2, C2, B2) {
    A.rawimpulsejointset_jointSetLimits(this.ptr, I2, g2, C2, B2);
  }
  jointConfigureMotorModel(I2, g2, C2) {
    A.rawimpulsejointset_jointConfigureMotorModel(this.ptr, I2, g2, C2);
  }
  jointConfigureMotorVelocity(I2, g2, C2, B2) {
    A.rawimpulsejointset_jointConfigureMotorVelocity(this.ptr, I2, g2, C2, B2);
  }
  jointConfigureMotorPosition(I2, g2, C2, B2, Q2) {
    A.rawimpulsejointset_jointConfigureMotorPosition(this.ptr, I2, g2, C2, B2, Q2);
  }
  jointConfigureMotor(I2, g2, C2, B2, Q2, E2) {
    A.rawimpulsejointset_jointConfigureMotor(this.ptr, I2, g2, C2, B2, Q2, E2);
  }
  constructor() {
    const I2 = A.rawimpulsejointset_new();
    return x.__wrap(I2);
  }
  createJoint(I2, g2, C2, B2) {
    k(I2, T);
    return A.rawimpulsejointset_createJoint(this.ptr, I2.ptr, g2, C2, B2);
  }
  remove(I2, g2) {
    A.rawimpulsejointset_remove(this.ptr, I2, g2);
  }
  len() {
    return A.rawimpulsejointset_len(this.ptr) >>> 0;
  }
  contains(I2) {
    return A.rawimpulsejointset_contains(this.ptr, I2) !== 0;
  }
  forEachJointHandle(g2) {
    try {
      A.rawimpulsejointset_forEachJointHandle(this.ptr, F(g2));
    } finally {
      I[N++] = undefined;
    }
  }
  forEachJointAttachedToRigidBody(g2, C2) {
    try {
      A.rawimpulsejointset_forEachJointAttachedToRigidBody(this.ptr, g2, F(C2));
    } finally {
      I[N++] = undefined;
    }
  }
}

class Z {
  static __wrap(A2) {
    const I2 = Object.create(Z.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawintegrationparameters_free(I2);
  }
  constructor() {
    const I2 = A.rawintegrationparameters_new();
    return Z.__wrap(I2);
  }
  get dt() {
    return A.rawintegrationparameters_dt(this.ptr);
  }
  get erp() {
    return A.rawintegrationparameters_erp(this.ptr);
  }
  get allowedLinearError() {
    return A.rawintegrationparameters_allowedLinearError(this.ptr);
  }
  get predictionDistance() {
    return A.rawcontactforceevent_total_force_magnitude(this.ptr);
  }
  get maxVelocityIterations() {
    return A.rawintegrationparameters_maxVelocityIterations(this.ptr) >>> 0;
  }
  get maxVelocityFrictionIterations() {
    return A.rawintegrationparameters_maxVelocityFrictionIterations(this.ptr) >>> 0;
  }
  get maxStabilizationIterations() {
    return A.rawintegrationparameters_maxStabilizationIterations(this.ptr) >>> 0;
  }
  get minIslandSize() {
    return A.rawintegrationparameters_minIslandSize(this.ptr) >>> 0;
  }
  get maxCcdSubsteps() {
    return A.rawintegrationparameters_maxCcdSubsteps(this.ptr) >>> 0;
  }
  set dt(I2) {
    A.rawintegrationparameters_set_dt(this.ptr, I2);
  }
  set erp(I2) {
    A.rawintegrationparameters_set_erp(this.ptr, I2);
  }
  set allowedLinearError(I2) {
    A.rawintegrationparameters_set_allowedLinearError(this.ptr, I2);
  }
  set predictionDistance(I2) {
    A.rawintegrationparameters_set_predictionDistance(this.ptr, I2);
  }
  set maxVelocityIterations(I2) {
    A.rawintegrationparameters_set_maxVelocityIterations(this.ptr, I2);
  }
  set maxVelocityFrictionIterations(I2) {
    A.rawintegrationparameters_set_maxVelocityFrictionIterations(this.ptr, I2);
  }
  set maxStabilizationIterations(I2) {
    A.rawintegrationparameters_set_maxStabilizationIterations(this.ptr, I2);
  }
  set minIslandSize(I2) {
    A.rawintegrationparameters_set_minIslandSize(this.ptr, I2);
  }
  set maxCcdSubsteps(I2) {
    A.rawintegrationparameters_set_maxCcdSubsteps(this.ptr, I2);
  }
}

class b {
  static __wrap(A2) {
    const I2 = Object.create(b.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawislandmanager_free(I2);
  }
  constructor() {
    const I2 = A.rawislandmanager_new();
    return b.__wrap(I2);
  }
  forEachActiveRigidBodyHandle(g2) {
    try {
      A.rawislandmanager_forEachActiveRigidBodyHandle(this.ptr, F(g2));
    } finally {
      I[N++] = undefined;
    }
  }
}

class W {
  static __wrap(A2) {
    const I2 = Object.create(W.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawkinematiccharactercontroller_free(I2);
  }
  constructor(I2) {
    const g2 = A.rawkinematiccharactercontroller_new(I2);
    return W.__wrap(g2);
  }
  up() {
    const I2 = A.rawkinematiccharactercontroller_up(this.ptr);
    return BA.__wrap(I2);
  }
  setUp(I2) {
    k(I2, BA), A.rawkinematiccharactercontroller_setUp(this.ptr, I2.ptr);
  }
  offset() {
    return A.rawkinematiccharactercontroller_offset(this.ptr);
  }
  setOffset(I2) {
    A.rawkinematiccharactercontroller_setOffset(this.ptr, I2);
  }
  slideEnabled() {
    return A.rawkinematiccharactercontroller_slideEnabled(this.ptr) !== 0;
  }
  setSlideEnabled(I2) {
    A.rawkinematiccharactercontroller_setSlideEnabled(this.ptr, I2);
  }
  autostepMaxHeight() {
    try {
      const C2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawkinematiccharactercontroller_autostepMaxHeight(C2, this.ptr);
      var I2 = G()[C2 / 4 + 0], g2 = S()[C2 / 4 + 1];
      return I2 === 0 ? undefined : g2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  autostepMinWidth() {
    try {
      const C2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawkinematiccharactercontroller_autostepMinWidth(C2, this.ptr);
      var I2 = G()[C2 / 4 + 0], g2 = S()[C2 / 4 + 1];
      return I2 === 0 ? undefined : g2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  autostepIncludesDynamicBodies() {
    const I2 = A.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.ptr);
    return I2 === 16777215 ? undefined : I2 !== 0;
  }
  autostepEnabled() {
    return A.rawkinematiccharactercontroller_autostepEnabled(this.ptr) !== 0;
  }
  enableAutostep(I2, g2, C2) {
    A.rawkinematiccharactercontroller_enableAutostep(this.ptr, I2, g2, C2);
  }
  disableAutostep() {
    A.rawkinematiccharactercontroller_disableAutostep(this.ptr);
  }
  maxSlopeClimbAngle() {
    return A.rawintegrationparameters_allowedLinearError(this.ptr);
  }
  setMaxSlopeClimbAngle(I2) {
    A.rawintegrationparameters_set_allowedLinearError(this.ptr, I2);
  }
  minSlopeSlideAngle() {
    return A.rawkinematiccharactercontroller_minSlopeSlideAngle(this.ptr);
  }
  setMinSlopeSlideAngle(I2) {
    A.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.ptr, I2);
  }
  snapToGroundDistance() {
    try {
      const C2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawkinematiccharactercontroller_snapToGroundDistance(C2, this.ptr);
      var I2 = G()[C2 / 4 + 0], g2 = S()[C2 / 4 + 1];
      return I2 === 0 ? undefined : g2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  enableSnapToGround(I2) {
    A.rawkinematiccharactercontroller_enableSnapToGround(this.ptr, I2);
  }
  disableSnapToGround() {
    A.rawkinematiccharactercontroller_disableSnapToGround(this.ptr);
  }
  snapToGroundEnabled() {
    return A.rawkinematiccharactercontroller_snapToGroundEnabled(this.ptr) !== 0;
  }
  computeColliderMovement(g2, C2, B2, Q2, i2, o2, D2, G2, w2, a2, h2) {
    try {
      k(C2, z), k(B2, H), k(Q2, m), k(o2, BA), A.rawkinematiccharactercontroller_computeColliderMovement(this.ptr, g2, C2.ptr, B2.ptr, Q2.ptr, i2, o2.ptr, D2, !E(G2), E(G2) ? 0 : G2, w2, !E(a2), E(a2) ? 0 : a2, F(h2));
    } finally {
      I[N++] = undefined;
    }
  }
  computedMovement() {
    const I2 = A.rawkinematiccharactercontroller_computedMovement(this.ptr);
    return BA.__wrap(I2);
  }
  computedGrounded() {
    return A.rawkinematiccharactercontroller_computedGrounded(this.ptr) !== 0;
  }
  numComputedCollisions() {
    return A.rawkinematiccharactercontroller_numComputedCollisions(this.ptr) >>> 0;
  }
  computedCollision(I2, g2) {
    k(g2, t);
    return A.rawkinematiccharactercontroller_computedCollision(this.ptr, I2, g2.ptr) !== 0;
  }
}

class j {
  static __wrap(A2) {
    const I2 = Object.create(j.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawmultibodyjointset_free(I2);
  }
  jointType(I2) {
    return A.rawmultibodyjointset_jointType(this.ptr, I2) >>> 0;
  }
  jointFrameX1(I2) {
    const g2 = A.rawmultibodyjointset_jointFrameX1(this.ptr, I2);
    return _.__wrap(g2);
  }
  jointFrameX2(I2) {
    const g2 = A.rawmultibodyjointset_jointFrameX2(this.ptr, I2);
    return _.__wrap(g2);
  }
  jointAnchor1(I2) {
    const g2 = A.rawmultibodyjointset_jointAnchor1(this.ptr, I2);
    return BA.__wrap(g2);
  }
  jointAnchor2(I2) {
    const g2 = A.rawmultibodyjointset_jointAnchor2(this.ptr, I2);
    return BA.__wrap(g2);
  }
  jointContactsEnabled(I2) {
    return A.rawmultibodyjointset_jointContactsEnabled(this.ptr, I2) !== 0;
  }
  jointSetContactsEnabled(I2, g2) {
    A.rawmultibodyjointset_jointSetContactsEnabled(this.ptr, I2, g2);
  }
  jointLimitsEnabled(I2, g2) {
    return A.rawmultibodyjointset_jointLimitsEnabled(this.ptr, I2, g2) !== 0;
  }
  jointLimitsMin(I2, g2) {
    return A.rawmultibodyjointset_jointLimitsMin(this.ptr, I2, g2);
  }
  jointLimitsMax(I2, g2) {
    return A.rawmultibodyjointset_jointLimitsMax(this.ptr, I2, g2);
  }
  constructor() {
    const I2 = A.rawmultibodyjointset_new();
    return j.__wrap(I2);
  }
  createJoint(I2, g2, C2, B2) {
    k(I2, T);
    return A.rawmultibodyjointset_createJoint(this.ptr, I2.ptr, g2, C2, B2);
  }
  remove(I2, g2) {
    A.rawmultibodyjointset_remove(this.ptr, I2, g2);
  }
  contains(I2) {
    return A.rawmultibodyjointset_contains(this.ptr, I2) !== 0;
  }
  forEachJointHandle(g2) {
    try {
      A.rawmultibodyjointset_forEachJointHandle(this.ptr, F(g2));
    } finally {
      I[N++] = undefined;
    }
  }
  forEachJointAttachedToRigidBody(g2, C2) {
    try {
      A.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.ptr, g2, F(C2));
    } finally {
      I[N++] = undefined;
    }
  }
}

class O {
  static __wrap(A2) {
    const I2 = Object.create(O.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawnarrowphase_free(I2);
  }
  constructor() {
    const I2 = A.rawnarrowphase_new();
    return O.__wrap(I2);
  }
  contacts_with(I2, g2) {
    A.rawnarrowphase_contacts_with(this.ptr, I2, Q(g2));
  }
  contact_pair(I2, g2) {
    const C2 = A.rawnarrowphase_contact_pair(this.ptr, I2, g2);
    return C2 === 0 ? undefined : p.__wrap(C2);
  }
  intersections_with(I2, g2) {
    A.rawnarrowphase_intersections_with(this.ptr, I2, Q(g2));
  }
  intersection_pair(I2, g2) {
    return A.rawnarrowphase_intersection_pair(this.ptr, I2, g2) !== 0;
  }
}

class f {
  static __wrap(A2) {
    const I2 = Object.create(f.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawphysicspipeline_free(I2);
  }
  constructor() {
    const I2 = A.rawphysicspipeline_new();
    return f.__wrap(I2);
  }
  step(I2, g2, C2, B2, Q2, E2, i2, o2, D2, G2) {
    k(I2, BA), k(g2, Z), k(C2, b), k(B2, Y), k(Q2, O), k(E2, z), k(i2, H), k(o2, x), k(D2, j), k(G2, L), A.rawphysicspipeline_step(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, E2.ptr, i2.ptr, o2.ptr, D2.ptr, G2.ptr);
  }
  stepWithEvents(I2, g2, C2, B2, E2, i2, o2, D2, G2, w2, a2, h2, K2, S2) {
    k(I2, BA), k(g2, Z), k(C2, b), k(B2, Y), k(E2, O), k(i2, z), k(o2, H), k(D2, x), k(G2, j), k(w2, L), k(a2, d), A.rawphysicspipeline_stepWithEvents(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, E2.ptr, i2.ptr, o2.ptr, D2.ptr, G2.ptr, w2.ptr, a2.ptr, Q(h2), Q(K2), Q(S2));
  }
}

class X {
  static __wrap(A2) {
    const I2 = Object.create(X.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawpointcolliderprojection_free(I2);
  }
  colliderHandle() {
    return A.rawcontactforceevent_collider1(this.ptr);
  }
  point() {
    const I2 = A.rawcontactforceevent_total_force(this.ptr);
    return BA.__wrap(I2);
  }
  isInside() {
    return A.rawpointcolliderprojection_isInside(this.ptr) !== 0;
  }
  featureType() {
    return A.rawpointcolliderprojection_featureType(this.ptr) >>> 0;
  }
  featureId() {
    try {
      const C2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawpointcolliderprojection_featureId(C2, this.ptr);
      var I2 = G()[C2 / 4 + 0], g2 = G()[C2 / 4 + 1];
      return I2 === 0 ? undefined : g2 >>> 0;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

class V {
  static __wrap(A2) {
    const I2 = Object.create(V.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawpointprojection_free(I2);
  }
  point() {
    const I2 = A.rawkinematiccharactercontroller_up(this.ptr);
    return BA.__wrap(I2);
  }
  isInside() {
    return A.rawpointprojection_isInside(this.ptr) !== 0;
  }
}

class m {
  static __wrap(A2) {
    const I2 = Object.create(m.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawquerypipeline_free(I2);
  }
  constructor() {
    const I2 = A.rawquerypipeline_new();
    return m.__wrap(I2);
  }
  update(I2, g2) {
    k(I2, z), k(g2, H), A.rawquerypipeline_update(this.ptr, I2.ptr, g2.ptr);
  }
  castRay(g2, C2, B2, Q2, i2, o2, D2, G2, w2, a2, h2) {
    try {
      k(g2, z), k(C2, H), k(B2, BA), k(Q2, BA);
      const K2 = A.rawquerypipeline_castRay(this.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, i2, o2, D2, !E(G2), E(G2) ? 0 : G2, !E(w2), E(w2) ? 0 : w2, !E(a2), E(a2) ? 0 : a2, F(h2));
      return K2 === 0 ? undefined : P.__wrap(K2);
    } finally {
      I[N++] = undefined;
    }
  }
  castRayAndGetNormal(g2, C2, B2, Q2, i2, o2, D2, G2, w2, a2, h2) {
    try {
      k(g2, z), k(C2, H), k(B2, BA), k(Q2, BA);
      const K2 = A.rawquerypipeline_castRayAndGetNormal(this.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, i2, o2, D2, !E(G2), E(G2) ? 0 : G2, !E(w2), E(w2) ? 0 : w2, !E(a2), E(a2) ? 0 : a2, F(h2));
      return K2 === 0 ? undefined : v.__wrap(K2);
    } finally {
      I[N++] = undefined;
    }
  }
  intersectionsWithRay(g2, C2, B2, Q2, i2, o2, D2, G2, w2, a2, h2, K2) {
    try {
      k(g2, z), k(C2, H), k(B2, BA), k(Q2, BA), A.rawquerypipeline_intersectionsWithRay(this.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, i2, o2, F(D2), G2, !E(w2), E(w2) ? 0 : w2, !E(a2), E(a2) ? 0 : a2, !E(h2), E(h2) ? 0 : h2, F(K2));
    } finally {
      I[N++] = undefined, I[N++] = undefined;
    }
  }
  intersectionWithShape(g2, C2, B2, Q2, i2, D2, w2, a2, h2, K2) {
    try {
      const R2 = A.__wbindgen_add_to_stack_pointer(-16);
      k(g2, z), k(C2, H), k(B2, BA), k(Q2, _), k(i2, AA), A.rawquerypipeline_intersectionWithShape(R2, this.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, i2.ptr, D2, !E(w2), E(w2) ? 0 : w2, !E(a2), E(a2) ? 0 : a2, !E(h2), E(h2) ? 0 : h2, F(K2));
      var S2 = G()[R2 / 4 + 0], y2 = o()[R2 / 8 + 1];
      return S2 === 0 ? undefined : y2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16), I[N++] = undefined;
    }
  }
  projectPoint(g2, C2, B2, Q2, i2, o2, D2, G2, w2) {
    try {
      k(g2, z), k(C2, H), k(B2, BA);
      const a2 = A.rawquerypipeline_projectPoint(this.ptr, g2.ptr, C2.ptr, B2.ptr, Q2, i2, !E(o2), E(o2) ? 0 : o2, !E(D2), E(D2) ? 0 : D2, !E(G2), E(G2) ? 0 : G2, F(w2));
      return a2 === 0 ? undefined : X.__wrap(a2);
    } finally {
      I[N++] = undefined;
    }
  }
  projectPointAndGetFeature(g2, C2, B2, Q2, i2, o2, D2, G2) {
    try {
      k(g2, z), k(C2, H), k(B2, BA);
      const w2 = A.rawquerypipeline_projectPointAndGetFeature(this.ptr, g2.ptr, C2.ptr, B2.ptr, Q2, !E(i2), E(i2) ? 0 : i2, !E(o2), E(o2) ? 0 : o2, !E(D2), E(D2) ? 0 : D2, F(G2));
      return w2 === 0 ? undefined : X.__wrap(w2);
    } finally {
      I[N++] = undefined;
    }
  }
  intersectionsWithPoint(g2, C2, B2, Q2, i2, o2, D2, G2, w2) {
    try {
      k(g2, z), k(C2, H), k(B2, BA), A.rawquerypipeline_intersectionsWithPoint(this.ptr, g2.ptr, C2.ptr, B2.ptr, F(Q2), i2, !E(o2), E(o2) ? 0 : o2, !E(D2), E(D2) ? 0 : D2, !E(G2), E(G2) ? 0 : G2, F(w2));
    } finally {
      I[N++] = undefined, I[N++] = undefined;
    }
  }
  castShape(g2, C2, B2, Q2, i2, o2, D2, G2, w2, a2, h2, K2, S2) {
    try {
      k(g2, z), k(C2, H), k(B2, BA), k(Q2, _), k(i2, BA), k(o2, AA);
      const y2 = A.rawquerypipeline_castShape(this.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, i2.ptr, o2.ptr, D2, G2, w2, !E(a2), E(a2) ? 0 : a2, !E(h2), E(h2) ? 0 : h2, !E(K2), E(K2) ? 0 : K2, F(S2));
      return y2 === 0 ? undefined : IA.__wrap(y2);
    } finally {
      I[N++] = undefined;
    }
  }
  intersectionsWithShape(g2, C2, B2, Q2, i2, o2, D2, G2, w2, a2, h2) {
    try {
      k(g2, z), k(C2, H), k(B2, BA), k(Q2, _), k(i2, AA), A.rawquerypipeline_intersectionsWithShape(this.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, i2.ptr, F(o2), D2, !E(G2), E(G2) ? 0 : G2, !E(w2), E(w2) ? 0 : w2, !E(a2), E(a2) ? 0 : a2, F(h2));
    } finally {
      I[N++] = undefined, I[N++] = undefined;
    }
  }
  collidersWithAabbIntersectingAabb(g2, C2, B2) {
    try {
      k(g2, BA), k(C2, BA), A.rawquerypipeline_collidersWithAabbIntersectingAabb(this.ptr, g2.ptr, C2.ptr, F(B2));
    } finally {
      I[N++] = undefined;
    }
  }
}

class v {
  static __wrap(A2) {
    const I2 = Object.create(v.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawraycolliderintersection_free(I2);
  }
  colliderHandle() {
    return A.rawcontactforceevent_collider1(this.ptr);
  }
  normal() {
    const I2 = A.rawraycolliderintersection_normal(this.ptr);
    return BA.__wrap(I2);
  }
  toi() {
    return A.rawintegrationparameters_allowedLinearError(this.ptr);
  }
  featureType() {
    return A.rawraycolliderintersection_featureType(this.ptr) >>> 0;
  }
  featureId() {
    try {
      const C2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawraycolliderintersection_featureId(C2, this.ptr);
      var I2 = G()[C2 / 4 + 0], g2 = G()[C2 / 4 + 1];
      return I2 === 0 ? undefined : g2 >>> 0;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

class P {
  static __wrap(A2) {
    const I2 = Object.create(P.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawraycollidertoi_free(I2);
  }
  colliderHandle() {
    return A.rawcontactforceevent_collider1(this.ptr);
  }
  toi() {
    return A.rawintegrationparameters_erp(this.ptr);
  }
}

class u {
  static __wrap(A2) {
    const I2 = Object.create(u.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawrayintersection_free(I2);
  }
  normal() {
    const I2 = A.rawkinematiccharactercontroller_up(this.ptr);
    return BA.__wrap(I2);
  }
  toi() {
    return A.rawrayintersection_toi(this.ptr);
  }
  featureType() {
    return A.rawpointcolliderprojection_featureType(this.ptr) >>> 0;
  }
  featureId() {
    try {
      const C2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawpointcolliderprojection_featureId(C2, this.ptr);
      var I2 = G()[C2 / 4 + 0], g2 = G()[C2 / 4 + 1];
      return I2 === 0 ? undefined : g2 >>> 0;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

class z {
  static __wrap(A2) {
    const I2 = Object.create(z.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawrigidbodyset_free(I2);
  }
  rbTranslation(I2) {
    const g2 = A.rawrigidbodyset_rbTranslation(this.ptr, I2);
    return BA.__wrap(g2);
  }
  rbRotation(I2) {
    const g2 = A.rawrigidbodyset_rbRotation(this.ptr, I2);
    return _.__wrap(g2);
  }
  rbSleep(I2) {
    A.rawrigidbodyset_rbSleep(this.ptr, I2);
  }
  rbIsSleeping(I2) {
    return A.rawrigidbodyset_rbIsSleeping(this.ptr, I2) !== 0;
  }
  rbIsMoving(I2) {
    return A.rawrigidbodyset_rbIsMoving(this.ptr, I2) !== 0;
  }
  rbNextTranslation(I2) {
    const g2 = A.rawrigidbodyset_rbNextTranslation(this.ptr, I2);
    return BA.__wrap(g2);
  }
  rbNextRotation(I2) {
    const g2 = A.rawrigidbodyset_rbNextRotation(this.ptr, I2);
    return _.__wrap(g2);
  }
  rbSetTranslation(I2, g2, C2, B2) {
    A.rawrigidbodyset_rbSetTranslation(this.ptr, I2, g2, C2, B2);
  }
  rbSetRotation(I2, g2, C2) {
    A.rawrigidbodyset_rbSetRotation(this.ptr, I2, g2, C2);
  }
  rbSetLinvel(I2, g2, C2) {
    k(g2, BA), A.rawrigidbodyset_rbSetLinvel(this.ptr, I2, g2.ptr, C2);
  }
  rbSetAngvel(I2, g2, C2) {
    A.rawrigidbodyset_rbSetAngvel(this.ptr, I2, g2, C2);
  }
  rbSetNextKinematicTranslation(I2, g2, C2) {
    A.rawrigidbodyset_rbSetNextKinematicTranslation(this.ptr, I2, g2, C2);
  }
  rbSetNextKinematicRotation(I2, g2) {
    A.rawrigidbodyset_rbSetNextKinematicRotation(this.ptr, I2, g2);
  }
  rbRecomputeMassPropertiesFromColliders(I2, g2) {
    k(g2, H), A.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.ptr, I2, g2.ptr);
  }
  rbSetAdditionalMass(I2, g2, C2) {
    A.rawrigidbodyset_rbSetAdditionalMass(this.ptr, I2, g2, C2);
  }
  rbSetAdditionalMassProperties(I2, g2, C2, B2, Q2) {
    k(C2, BA), A.rawrigidbodyset_rbSetAdditionalMassProperties(this.ptr, I2, g2, C2.ptr, B2, Q2);
  }
  rbLinvel(I2) {
    const g2 = A.rawrigidbodyset_rbLinvel(this.ptr, I2);
    return BA.__wrap(g2);
  }
  rbAngvel(I2) {
    return A.rawrigidbodyset_rbAngvel(this.ptr, I2);
  }
  rbLockTranslations(I2, g2, C2) {
    A.rawrigidbodyset_rbLockTranslations(this.ptr, I2, g2, C2);
  }
  rbSetEnabledTranslations(I2, g2, C2, B2) {
    A.rawrigidbodyset_rbSetEnabledTranslations(this.ptr, I2, g2, C2, B2);
  }
  rbLockRotations(I2, g2, C2) {
    A.rawrigidbodyset_rbLockRotations(this.ptr, I2, g2, C2);
  }
  rbDominanceGroup(I2) {
    return A.rawrigidbodyset_rbDominanceGroup(this.ptr, I2);
  }
  rbSetDominanceGroup(I2, g2) {
    A.rawrigidbodyset_rbSetDominanceGroup(this.ptr, I2, g2);
  }
  rbEnableCcd(I2, g2) {
    A.rawrigidbodyset_rbEnableCcd(this.ptr, I2, g2);
  }
  rbMass(I2) {
    return A.rawrigidbodyset_rbMass(this.ptr, I2);
  }
  rbInvMass(I2) {
    return A.rawrigidbodyset_rbInvMass(this.ptr, I2);
  }
  rbEffectiveInvMass(I2) {
    const g2 = A.rawrigidbodyset_rbEffectiveInvMass(this.ptr, I2);
    return BA.__wrap(g2);
  }
  rbLocalCom(I2) {
    const g2 = A.rawrigidbodyset_rbLocalCom(this.ptr, I2);
    return BA.__wrap(g2);
  }
  rbWorldCom(I2) {
    const g2 = A.rawrigidbodyset_rbWorldCom(this.ptr, I2);
    return BA.__wrap(g2);
  }
  rbInvPrincipalInertiaSqrt(I2) {
    return A.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.ptr, I2);
  }
  rbPrincipalInertia(I2) {
    return A.rawrigidbodyset_rbPrincipalInertia(this.ptr, I2);
  }
  rbEffectiveWorldInvInertiaSqrt(I2) {
    return A.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.ptr, I2);
  }
  rbEffectiveAngularInertia(I2) {
    return A.rawrigidbodyset_rbEffectiveAngularInertia(this.ptr, I2);
  }
  rbWakeUp(I2) {
    A.rawrigidbodyset_rbWakeUp(this.ptr, I2);
  }
  rbIsCcdEnabled(I2) {
    return A.rawrigidbodyset_rbIsCcdEnabled(this.ptr, I2) !== 0;
  }
  rbNumColliders(I2) {
    return A.rawrigidbodyset_rbNumColliders(this.ptr, I2) >>> 0;
  }
  rbCollider(I2, g2) {
    return A.rawrigidbodyset_rbCollider(this.ptr, I2, g2);
  }
  rbBodyType(I2) {
    return A.rawrigidbodyset_rbBodyType(this.ptr, I2) >>> 0;
  }
  rbSetBodyType(I2, g2, C2) {
    A.rawrigidbodyset_rbSetBodyType(this.ptr, I2, g2, C2);
  }
  rbIsFixed(I2) {
    return A.rawrigidbodyset_rbIsFixed(this.ptr, I2) !== 0;
  }
  rbIsKinematic(I2) {
    return A.rawrigidbodyset_rbIsKinematic(this.ptr, I2) !== 0;
  }
  rbIsDynamic(I2) {
    return A.rawrigidbodyset_rbIsDynamic(this.ptr, I2) !== 0;
  }
  rbLinearDamping(I2) {
    return A.rawrigidbodyset_rbLinearDamping(this.ptr, I2);
  }
  rbAngularDamping(I2) {
    return A.rawrigidbodyset_rbAngularDamping(this.ptr, I2);
  }
  rbSetLinearDamping(I2, g2) {
    A.rawrigidbodyset_rbSetLinearDamping(this.ptr, I2, g2);
  }
  rbSetAngularDamping(I2, g2) {
    A.rawrigidbodyset_rbSetAngularDamping(this.ptr, I2, g2);
  }
  rbSetEnabled(I2, g2) {
    A.rawrigidbodyset_rbSetEnabled(this.ptr, I2, g2);
  }
  rbIsEnabled(I2) {
    return A.rawrigidbodyset_rbIsEnabled(this.ptr, I2) !== 0;
  }
  rbGravityScale(I2) {
    return A.rawrigidbodyset_rbGravityScale(this.ptr, I2);
  }
  rbSetGravityScale(I2, g2, C2) {
    A.rawrigidbodyset_rbSetGravityScale(this.ptr, I2, g2, C2);
  }
  rbResetForces(I2, g2) {
    A.rawrigidbodyset_rbResetForces(this.ptr, I2, g2);
  }
  rbResetTorques(I2, g2) {
    A.rawrigidbodyset_rbResetTorques(this.ptr, I2, g2);
  }
  rbAddForce(I2, g2, C2) {
    k(g2, BA), A.rawrigidbodyset_rbAddForce(this.ptr, I2, g2.ptr, C2);
  }
  rbApplyImpulse(I2, g2, C2) {
    k(g2, BA), A.rawrigidbodyset_rbApplyImpulse(this.ptr, I2, g2.ptr, C2);
  }
  rbAddTorque(I2, g2, C2) {
    A.rawrigidbodyset_rbAddTorque(this.ptr, I2, g2, C2);
  }
  rbApplyTorqueImpulse(I2, g2, C2) {
    A.rawrigidbodyset_rbApplyTorqueImpulse(this.ptr, I2, g2, C2);
  }
  rbAddForceAtPoint(I2, g2, C2, B2) {
    k(g2, BA), k(C2, BA), A.rawrigidbodyset_rbAddForceAtPoint(this.ptr, I2, g2.ptr, C2.ptr, B2);
  }
  rbApplyImpulseAtPoint(I2, g2, C2, B2) {
    k(g2, BA), k(C2, BA), A.rawrigidbodyset_rbApplyImpulseAtPoint(this.ptr, I2, g2.ptr, C2.ptr, B2);
  }
  rbUserData(I2) {
    return A.rawrigidbodyset_rbUserData(this.ptr, I2) >>> 0;
  }
  rbSetUserData(I2, g2) {
    A.rawrigidbodyset_rbSetUserData(this.ptr, I2, g2);
  }
  constructor() {
    const I2 = A.rawrigidbodyset_new();
    return z.__wrap(I2);
  }
  createRigidBody(I2, g2, C2, B2, Q2, E2, i2, o2, D2, G2, w2, a2, h2, K2, S2, N2, F2, y2, R2, J2) {
    k(g2, BA), k(C2, _), k(i2, BA), k(o2, BA);
    return A.rawrigidbodyset_createRigidBody(this.ptr, I2, g2.ptr, C2.ptr, B2, Q2, E2, i2.ptr, o2.ptr, D2, G2, w2, a2, h2, K2, S2, N2, F2, y2, R2, J2);
  }
  remove(I2, g2, C2, B2, Q2) {
    k(g2, b), k(C2, H), k(B2, x), k(Q2, j), A.rawrigidbodyset_remove(this.ptr, I2, g2.ptr, C2.ptr, B2.ptr, Q2.ptr);
  }
  len() {
    return A.rawrigidbodyset_len(this.ptr) >>> 0;
  }
  contains(I2) {
    return A.rawrigidbodyset_contains(this.ptr, I2) !== 0;
  }
  forEachRigidBodyHandle(g2) {
    try {
      A.rawrigidbodyset_forEachRigidBodyHandle(this.ptr, F(g2));
    } finally {
      I[N++] = undefined;
    }
  }
  propagateModifiedBodyPositionsToColliders(I2) {
    k(I2, H), A.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.ptr, I2.ptr);
  }
}

class _ {
  static __wrap(A2) {
    const I2 = Object.create(_.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawrotation_free(I2);
  }
  static identity() {
    const I2 = A.rawrotation_identity();
    return _.__wrap(I2);
  }
  static fromAngle(I2) {
    const g2 = A.rawrotation_fromAngle(I2);
    return _.__wrap(g2);
  }
  get im() {
    return A.rawrotation_im(this.ptr);
  }
  get re() {
    return A.rawintegrationparameters_dt(this.ptr);
  }
  get angle() {
    return A.rawrotation_angle(this.ptr);
  }
}

class $ {
  static __wrap(A2) {
    const I2 = Object.create($.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawserializationpipeline_free(I2);
  }
  constructor() {
    const I2 = A.rawserializationpipeline_new();
    return $.__wrap(I2);
  }
  serializeAll(I2, g2, C2, Q2, E2, i2, o2, D2, G2) {
    k(I2, BA), k(g2, Z), k(C2, b), k(Q2, Y), k(E2, O), k(i2, z), k(o2, H), k(D2, x), k(G2, j);
    return B(A.rawserializationpipeline_serializeAll(this.ptr, I2.ptr, g2.ptr, C2.ptr, Q2.ptr, E2.ptr, i2.ptr, o2.ptr, D2.ptr, G2.ptr));
  }
  deserializeAll(I2) {
    const g2 = A.rawserializationpipeline_deserializeAll(this.ptr, Q(I2));
    return g2 === 0 ? undefined : n.__wrap(g2);
  }
}

class AA {
  static __wrap(A2) {
    const I2 = Object.create(AA.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawshape_free(I2);
  }
  static cuboid(I2, g2) {
    const C2 = A.rawshape_cuboid(I2, g2);
    return AA.__wrap(C2);
  }
  static roundCuboid(I2, g2, C2) {
    const B2 = A.rawshape_roundCuboid(I2, g2, C2);
    return AA.__wrap(B2);
  }
  static ball(I2) {
    const g2 = A.rawshape_ball(I2);
    return AA.__wrap(g2);
  }
  static halfspace(I2) {
    k(I2, BA);
    const g2 = A.rawshape_halfspace(I2.ptr);
    return AA.__wrap(g2);
  }
  static capsule(I2, g2) {
    const C2 = A.rawshape_capsule(I2, g2);
    return AA.__wrap(C2);
  }
  static polyline(I2, g2) {
    const C2 = s(I2, A.__wbindgen_malloc), B2 = M, Q2 = U(g2, A.__wbindgen_malloc), E2 = M, i2 = A.rawshape_polyline(C2, B2, Q2, E2);
    return AA.__wrap(i2);
  }
  static trimesh(I2, g2) {
    const C2 = s(I2, A.__wbindgen_malloc), B2 = M, Q2 = U(g2, A.__wbindgen_malloc), E2 = M, i2 = A.rawshape_trimesh(C2, B2, Q2, E2);
    return AA.__wrap(i2);
  }
  static heightfield(I2, g2) {
    const C2 = s(I2, A.__wbindgen_malloc), B2 = M;
    k(g2, BA);
    const Q2 = A.rawshape_heightfield(C2, B2, g2.ptr);
    return AA.__wrap(Q2);
  }
  static segment(I2, g2) {
    k(I2, BA), k(g2, BA);
    const C2 = A.rawshape_segment(I2.ptr, g2.ptr);
    return AA.__wrap(C2);
  }
  static triangle(I2, g2, C2) {
    k(I2, BA), k(g2, BA), k(C2, BA);
    const B2 = A.rawshape_triangle(I2.ptr, g2.ptr, C2.ptr);
    return AA.__wrap(B2);
  }
  static roundTriangle(I2, g2, C2, B2) {
    k(I2, BA), k(g2, BA), k(C2, BA);
    const Q2 = A.rawshape_roundTriangle(I2.ptr, g2.ptr, C2.ptr, B2);
    return AA.__wrap(Q2);
  }
  static convexHull(I2) {
    const g2 = s(I2, A.__wbindgen_malloc), C2 = M, B2 = A.rawshape_convexHull(g2, C2);
    return B2 === 0 ? undefined : AA.__wrap(B2);
  }
  static roundConvexHull(I2, g2) {
    const C2 = s(I2, A.__wbindgen_malloc), B2 = M, Q2 = A.rawshape_roundConvexHull(C2, B2, g2);
    return Q2 === 0 ? undefined : AA.__wrap(Q2);
  }
  static convexPolyline(I2) {
    const g2 = s(I2, A.__wbindgen_malloc), C2 = M, B2 = A.rawshape_convexPolyline(g2, C2);
    return B2 === 0 ? undefined : AA.__wrap(B2);
  }
  static roundConvexPolyline(I2, g2) {
    const C2 = s(I2, A.__wbindgen_malloc), B2 = M, Q2 = A.rawshape_roundConvexPolyline(C2, B2, g2);
    return Q2 === 0 ? undefined : AA.__wrap(Q2);
  }
  castShape(I2, g2, C2, B2, Q2, E2, i2, o2, D2) {
    k(I2, BA), k(g2, _), k(C2, BA), k(B2, AA), k(Q2, BA), k(E2, _), k(i2, BA);
    const G2 = A.rawshape_castShape(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, E2.ptr, i2.ptr, o2, D2);
    return G2 === 0 ? undefined : CA.__wrap(G2);
  }
  intersectsShape(I2, g2, C2, B2, Q2) {
    k(I2, BA), k(g2, _), k(C2, AA), k(B2, BA), k(Q2, _);
    return A.rawshape_intersectsShape(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr) !== 0;
  }
  contactShape(I2, g2, C2, B2, Q2, E2) {
    k(I2, BA), k(g2, _), k(C2, AA), k(B2, BA), k(Q2, _);
    const i2 = A.rawshape_contactShape(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, E2);
    return i2 === 0 ? undefined : gA.__wrap(i2);
  }
  containsPoint(I2, g2, C2) {
    k(I2, BA), k(g2, _), k(C2, BA);
    return A.rawshape_containsPoint(this.ptr, I2.ptr, g2.ptr, C2.ptr) !== 0;
  }
  projectPoint(I2, g2, C2, B2) {
    k(I2, BA), k(g2, _), k(C2, BA);
    const Q2 = A.rawshape_projectPoint(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2);
    return V.__wrap(Q2);
  }
  intersectsRay(I2, g2, C2, B2, Q2) {
    k(I2, BA), k(g2, _), k(C2, BA), k(B2, BA);
    return A.rawshape_intersectsRay(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2) !== 0;
  }
  castRay(I2, g2, C2, B2, Q2, E2) {
    k(I2, BA), k(g2, _), k(C2, BA), k(B2, BA);
    return A.rawshape_castRay(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2, E2);
  }
  castRayAndGetNormal(I2, g2, C2, B2, Q2, E2) {
    k(I2, BA), k(g2, _), k(C2, BA), k(B2, BA);
    const i2 = A.rawshape_castRayAndGetNormal(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2, E2);
    return i2 === 0 ? undefined : u.__wrap(i2);
  }
}

class IA {
  static __wrap(A2) {
    const I2 = Object.create(IA.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawshapecollidertoi_free(I2);
  }
  colliderHandle() {
    return A.rawcontactforceevent_collider1(this.ptr);
  }
  toi() {
    return A.rawshapecollidertoi_toi(this.ptr);
  }
  witness1() {
    const I2 = A.rawraycolliderintersection_normal(this.ptr);
    return BA.__wrap(I2);
  }
  witness2() {
    const I2 = A.rawcontactforceevent_total_force(this.ptr);
    return BA.__wrap(I2);
  }
  normal1() {
    const I2 = A.rawcharactercollision_translationApplied(this.ptr);
    return BA.__wrap(I2);
  }
  normal2() {
    const I2 = A.rawcharactercollision_translationRemaining(this.ptr);
    return BA.__wrap(I2);
  }
}

class gA {
  static __wrap(A2) {
    const I2 = Object.create(gA.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawshapecontact_free(I2);
  }
  distance() {
    return A.rawcontactforceevent_total_force_magnitude(this.ptr);
  }
  point1() {
    const I2 = A.rawkinematiccharactercontroller_up(this.ptr);
    return BA.__wrap(I2);
  }
  point2() {
    const I2 = A.rawraycolliderintersection_normal(this.ptr);
    return BA.__wrap(I2);
  }
  normal1() {
    const I2 = A.rawcontactforceevent_total_force(this.ptr);
    return BA.__wrap(I2);
  }
  normal2() {
    const I2 = A.rawcharactercollision_translationApplied(this.ptr);
    return BA.__wrap(I2);
  }
}

class CA {
  static __wrap(A2) {
    const I2 = Object.create(CA.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawshapetoi_free(I2);
  }
  toi() {
    return A.rawcontactforceevent_total_force_magnitude(this.ptr);
  }
  witness1() {
    const I2 = A.rawkinematiccharactercontroller_up(this.ptr);
    return BA.__wrap(I2);
  }
  witness2() {
    const I2 = A.rawraycolliderintersection_normal(this.ptr);
    return BA.__wrap(I2);
  }
  normal1() {
    const I2 = A.rawcontactforceevent_total_force(this.ptr);
    return BA.__wrap(I2);
  }
  normal2() {
    const I2 = A.rawcharactercollision_translationApplied(this.ptr);
    return BA.__wrap(I2);
  }
}

class BA {
  static __wrap(A2) {
    const I2 = Object.create(BA.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawvector_free(I2);
  }
  static zero() {
    const I2 = A.rawvector_zero();
    return BA.__wrap(I2);
  }
  constructor(I2, g2) {
    const C2 = A.rawvector_new(I2, g2);
    return BA.__wrap(C2);
  }
  get x() {
    return A.rawintegrationparameters_dt(this.ptr);
  }
  set x(I2) {
    A.rawintegrationparameters_set_dt(this.ptr, I2);
  }
  get y() {
    return A.rawrotation_im(this.ptr);
  }
  set y(I2) {
    A.rawvector_set_y(this.ptr, I2);
  }
  xy() {
    const I2 = A.rawvector_xy(this.ptr);
    return BA.__wrap(I2);
  }
  yx() {
    const I2 = A.rawvector_yx(this.ptr);
    return BA.__wrap(I2);
  }
}

class EA {
  constructor(A2, I2) {
    this.x = A2, this.y = I2;
  }
}

class iA {
  static new(A2, I2) {
    return new EA(A2, I2);
  }
  static zeros() {
    return iA.new(0, 0);
  }
  static fromRaw(A2) {
    if (!A2)
      return null;
    let I2 = iA.new(A2.x, A2.y);
    return A2.free(), I2;
  }
  static intoRaw(A2) {
    return new BA(A2.x, A2.y);
  }
  static copy(A2, I2) {
    A2.x = I2.x, A2.y = I2.y;
  }
}

class oA {
  static identity() {
    return 0;
  }
  static fromRaw(A2) {
    if (!A2)
      return null;
    let I2 = A2.angle;
    return A2.free(), I2;
  }
  static intoRaw(A2) {
    return _.fromAngle(A2);
  }
}
var DA;
var GA;
var wA;
var aA;
var hA;
var kA;
var KA;
var SA;
var NA;
var FA;
var yA;
var RA;
(function(A2) {
  A2[A2.Dynamic = 0] = "Dynamic", A2[A2.Fixed = 1] = "Fixed", A2[A2.KinematicPositionBased = 2] = "KinematicPositionBased", A2[A2.KinematicVelocityBased = 3] = "KinematicVelocityBased";
})(DA || (DA = {}));

class JA {
  constructor(A2, I2, g2) {
    this.rawSet = A2, this.colliderSet = I2, this.handle = g2;
  }
  finalizeDeserialization(A2) {
    this.colliderSet = A2;
  }
  isValid() {
    return this.rawSet.contains(this.handle);
  }
  lockTranslations(A2, I2) {
    return this.rawSet.rbLockTranslations(this.handle, A2, I2);
  }
  lockRotations(A2, I2) {
    return this.rawSet.rbLockRotations(this.handle, A2, I2);
  }
  setEnabledTranslations(A2, I2, g2) {
    return this.rawSet.rbSetEnabledTranslations(this.handle, A2, I2, g2);
  }
  restrictTranslations(A2, I2, g2) {
    this.setEnabledTranslations(A2, A2, g2);
  }
  dominanceGroup() {
    return this.rawSet.rbDominanceGroup(this.handle);
  }
  setDominanceGroup(A2) {
    this.rawSet.rbSetDominanceGroup(this.handle, A2);
  }
  enableCcd(A2) {
    this.rawSet.rbEnableCcd(this.handle, A2);
  }
  translation() {
    let A2 = this.rawSet.rbTranslation(this.handle);
    return iA.fromRaw(A2);
  }
  rotation() {
    let A2 = this.rawSet.rbRotation(this.handle);
    return oA.fromRaw(A2);
  }
  nextTranslation() {
    let A2 = this.rawSet.rbNextTranslation(this.handle);
    return iA.fromRaw(A2);
  }
  nextRotation() {
    let A2 = this.rawSet.rbNextRotation(this.handle);
    return oA.fromRaw(A2);
  }
  setTranslation(A2, I2) {
    this.rawSet.rbSetTranslation(this.handle, A2.x, A2.y, I2);
  }
  setLinvel(A2, I2) {
    let g2 = iA.intoRaw(A2);
    this.rawSet.rbSetLinvel(this.handle, g2, I2), g2.free();
  }
  gravityScale() {
    return this.rawSet.rbGravityScale(this.handle);
  }
  setGravityScale(A2, I2) {
    this.rawSet.rbSetGravityScale(this.handle, A2, I2);
  }
  setRotation(A2, I2) {
    this.rawSet.rbSetRotation(this.handle, A2, I2);
  }
  setAngvel(A2, I2) {
    this.rawSet.rbSetAngvel(this.handle, A2, I2);
  }
  setNextKinematicTranslation(A2) {
    this.rawSet.rbSetNextKinematicTranslation(this.handle, A2.x, A2.y);
  }
  setNextKinematicRotation(A2) {
    this.rawSet.rbSetNextKinematicRotation(this.handle, A2);
  }
  linvel() {
    return iA.fromRaw(this.rawSet.rbLinvel(this.handle));
  }
  angvel() {
    return this.rawSet.rbAngvel(this.handle);
  }
  mass() {
    return this.rawSet.rbMass(this.handle);
  }
  effectiveInvMass() {
    return iA.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));
  }
  invMass() {
    return this.rawSet.rbInvMass(this.handle);
  }
  localCom() {
    return iA.fromRaw(this.rawSet.rbLocalCom(this.handle));
  }
  worldCom() {
    return iA.fromRaw(this.rawSet.rbWorldCom(this.handle));
  }
  invPrincipalInertiaSqrt() {
    return this.rawSet.rbInvPrincipalInertiaSqrt(this.handle);
  }
  principalInertia() {
    return this.rawSet.rbPrincipalInertia(this.handle);
  }
  effectiveWorldInvInertiaSqrt() {
    return this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle);
  }
  effectiveAngularInertia() {
    return this.rawSet.rbEffectiveAngularInertia(this.handle);
  }
  sleep() {
    this.rawSet.rbSleep(this.handle);
  }
  wakeUp() {
    this.rawSet.rbWakeUp(this.handle);
  }
  isCcdEnabled() {
    return this.rawSet.rbIsCcdEnabled(this.handle);
  }
  numColliders() {
    return this.rawSet.rbNumColliders(this.handle);
  }
  collider(A2) {
    return this.colliderSet.get(this.rawSet.rbCollider(this.handle, A2));
  }
  setEnabled(A2) {
    this.rawSet.rbSetEnabled(this.handle, A2);
  }
  isEnabled() {
    return this.rawSet.rbIsEnabled(this.handle);
  }
  bodyType() {
    return this.rawSet.rbBodyType(this.handle);
  }
  setBodyType(A2, I2) {
    return this.rawSet.rbSetBodyType(this.handle, A2, I2);
  }
  isSleeping() {
    return this.rawSet.rbIsSleeping(this.handle);
  }
  isMoving() {
    return this.rawSet.rbIsMoving(this.handle);
  }
  isFixed() {
    return this.rawSet.rbIsFixed(this.handle);
  }
  isKinematic() {
    return this.rawSet.rbIsKinematic(this.handle);
  }
  isDynamic() {
    return this.rawSet.rbIsDynamic(this.handle);
  }
  linearDamping() {
    return this.rawSet.rbLinearDamping(this.handle);
  }
  angularDamping() {
    return this.rawSet.rbAngularDamping(this.handle);
  }
  setLinearDamping(A2) {
    this.rawSet.rbSetLinearDamping(this.handle, A2);
  }
  recomputeMassPropertiesFromColliders() {
    this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);
  }
  setAdditionalMass(A2, I2) {
    this.rawSet.rbSetAdditionalMass(this.handle, A2, I2);
  }
  setAdditionalMassProperties(A2, I2, g2, C2) {
    let B2 = iA.intoRaw(I2);
    this.rawSet.rbSetAdditionalMassProperties(this.handle, A2, B2, g2, C2), B2.free();
  }
  setAngularDamping(A2) {
    this.rawSet.rbSetAngularDamping(this.handle, A2);
  }
  resetForces(A2) {
    this.rawSet.rbResetForces(this.handle, A2);
  }
  resetTorques(A2) {
    this.rawSet.rbResetTorques(this.handle, A2);
  }
  addForce(A2, I2) {
    const g2 = iA.intoRaw(A2);
    this.rawSet.rbAddForce(this.handle, g2, I2), g2.free();
  }
  applyImpulse(A2, I2) {
    const g2 = iA.intoRaw(A2);
    this.rawSet.rbApplyImpulse(this.handle, g2, I2), g2.free();
  }
  addTorque(A2, I2) {
    this.rawSet.rbAddTorque(this.handle, A2, I2);
  }
  applyTorqueImpulse(A2, I2) {
    this.rawSet.rbApplyTorqueImpulse(this.handle, A2, I2);
  }
  addForceAtPoint(A2, I2, g2) {
    const C2 = iA.intoRaw(A2), B2 = iA.intoRaw(I2);
    this.rawSet.rbAddForceAtPoint(this.handle, C2, B2, g2), C2.free(), B2.free();
  }
  applyImpulseAtPoint(A2, I2, g2) {
    const C2 = iA.intoRaw(A2), B2 = iA.intoRaw(I2);
    this.rawSet.rbApplyImpulseAtPoint(this.handle, C2, B2, g2), C2.free(), B2.free();
  }
}

class MA {
  constructor(A2) {
    this.enabled = true, this.status = A2, this.translation = iA.zeros(), this.rotation = oA.identity(), this.gravityScale = 1, this.linvel = iA.zeros(), this.mass = 0, this.massOnly = false, this.centerOfMass = iA.zeros(), this.translationsEnabledX = true, this.translationsEnabledY = true, this.angvel = 0, this.principalAngularInertia = 0, this.rotationsEnabled = true, this.linearDamping = 0, this.angularDamping = 0, this.canSleep = true, this.sleeping = false, this.ccdEnabled = false, this.dominanceGroup = 0;
  }
  static dynamic() {
    return new MA(DA.Dynamic);
  }
  static kinematicPositionBased() {
    return new MA(DA.KinematicPositionBased);
  }
  static kinematicVelocityBased() {
    return new MA(DA.KinematicVelocityBased);
  }
  static fixed() {
    return new MA(DA.Fixed);
  }
  static newDynamic() {
    return new MA(DA.Dynamic);
  }
  static newKinematicPositionBased() {
    return new MA(DA.KinematicPositionBased);
  }
  static newKinematicVelocityBased() {
    return new MA(DA.KinematicVelocityBased);
  }
  static newStatic() {
    return new MA(DA.Fixed);
  }
  setDominanceGroup(A2) {
    return this.dominanceGroup = A2, this;
  }
  setEnabled(A2) {
    return this.enabled = A2, this;
  }
  setTranslation(A2, I2) {
    if (typeof A2 != "number" || typeof I2 != "number")
      throw TypeError("The translation components must be numbers.");
    return this.translation = { x: A2, y: I2 }, this;
  }
  setRotation(A2) {
    return this.rotation = A2, this;
  }
  setGravityScale(A2) {
    return this.gravityScale = A2, this;
  }
  setAdditionalMass(A2) {
    return this.mass = A2, this.massOnly = true, this;
  }
  setLinvel(A2, I2) {
    if (typeof A2 != "number" || typeof I2 != "number")
      throw TypeError("The linvel components must be numbers.");
    return this.linvel = { x: A2, y: I2 }, this;
  }
  setAngvel(A2) {
    return this.angvel = A2, this;
  }
  setAdditionalMassProperties(A2, I2, g2) {
    return this.mass = A2, iA.copy(this.centerOfMass, I2), this.principalAngularInertia = g2, this.massOnly = false, this;
  }
  enabledTranslations(A2, I2) {
    return this.translationsEnabledX = A2, this.translationsEnabledY = I2, this;
  }
  restrictTranslations(A2, I2) {
    return this.enabledTranslations(A2, I2);
  }
  lockTranslations() {
    return this.restrictTranslations(false, false);
  }
  lockRotations() {
    return this.rotationsEnabled = false, this;
  }
  setLinearDamping(A2) {
    return this.linearDamping = A2, this;
  }
  setAngularDamping(A2) {
    return this.angularDamping = A2, this;
  }
  setCanSleep(A2) {
    return this.canSleep = A2, this;
  }
  setSleeping(A2) {
    return this.sleeping = A2, this;
  }
  setCcdEnabled(A2) {
    return this.ccdEnabled = A2, this;
  }
  setUserData(A2) {
    return this.userData = A2, this;
  }
}

class sA {
  constructor() {
    this.fconv = new Float64Array(1), this.uconv = new Uint32Array(this.fconv.buffer), this.data = new Array, this.size = 0;
  }
  set(A2, I2) {
    let g2 = this.index(A2);
    for (;this.data.length <= g2; )
      this.data.push(null);
    this.data[g2] == null && (this.size += 1), this.data[g2] = I2;
  }
  len() {
    return this.size;
  }
  delete(A2) {
    let I2 = this.index(A2);
    I2 < this.data.length && (this.data[I2] != null && (this.size -= 1), this.data[I2] = null);
  }
  clear() {
    this.data = new Array;
  }
  get(A2) {
    let I2 = this.index(A2);
    return I2 < this.data.length ? this.data[I2] : null;
  }
  forEach(A2) {
    for (const I2 of this.data)
      I2 != null && A2(I2);
  }
  getAll() {
    return this.data.filter((A2) => A2 != null);
  }
  index(A2) {
    return this.fconv[0] = A2, this.uconv[0];
  }
}

class UA {
  constructor(A2) {
    this.raw = A2 || new z, this.map = new sA, A2 && A2.forEachRigidBodyHandle((I2) => {
      this.map.set(I2, new JA(A2, null, I2));
    });
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined, this.map && this.map.clear(), this.map = undefined;
  }
  finalizeDeserialization(A2) {
    this.map.forEach((I2) => I2.finalizeDeserialization(A2));
  }
  createRigidBody(A2, I2) {
    let g2 = iA.intoRaw(I2.translation), C2 = oA.intoRaw(I2.rotation), B2 = iA.intoRaw(I2.linvel), Q2 = iA.intoRaw(I2.centerOfMass), E2 = this.raw.createRigidBody(I2.enabled, g2, C2, I2.gravityScale, I2.mass, I2.massOnly, Q2, B2, I2.angvel, I2.principalAngularInertia, I2.translationsEnabledX, I2.translationsEnabledY, I2.rotationsEnabled, I2.linearDamping, I2.angularDamping, I2.status, I2.canSleep, I2.sleeping, I2.ccdEnabled, I2.dominanceGroup);
    g2.free(), C2.free(), B2.free(), Q2.free();
    const i2 = new JA(this.raw, A2, E2);
    return i2.userData = I2.userData, this.map.set(E2, i2), i2;
  }
  remove(A2, I2, g2, C2, B2) {
    for (let I3 = 0;I3 < this.raw.rbNumColliders(A2); I3 += 1)
      g2.unmap(this.raw.rbCollider(A2, I3));
    C2.forEachJointHandleAttachedToRigidBody(A2, (A3) => C2.unmap(A3)), B2.forEachJointHandleAttachedToRigidBody(A2, (A3) => B2.unmap(A3)), this.raw.remove(A2, I2.raw, g2.raw, C2.raw, B2.raw), this.map.delete(A2);
  }
  len() {
    return this.map.len();
  }
  contains(A2) {
    return this.get(A2) != null;
  }
  get(A2) {
    return this.map.get(A2);
  }
  forEach(A2) {
    this.map.forEach(A2);
  }
  forEachActiveRigidBody(A2, I2) {
    A2.forEachActiveRigidBodyHandle((A3) => {
      I2(this.get(A3));
    });
  }
  getAll() {
    return this.map.getAll();
  }
}

class qA {
  constructor(A2) {
    this.raw = A2 || new Z;
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined;
  }
  get dt() {
    return this.raw.dt;
  }
  get erp() {
    return this.raw.erp;
  }
  get allowedLinearError() {
    return this.raw.allowedLinearError;
  }
  get predictionDistance() {
    return this.raw.predictionDistance;
  }
  get maxVelocityIterations() {
    return this.raw.maxVelocityIterations;
  }
  get maxVelocityFrictionIterations() {
    return this.raw.maxVelocityFrictionIterations;
  }
  get maxStabilizationIterations() {
    return this.raw.maxStabilizationIterations;
  }
  get minIslandSize() {
    return this.raw.minIslandSize;
  }
  get maxCcdSubsteps() {
    return this.raw.maxCcdSubsteps;
  }
  set dt(A2) {
    this.raw.dt = A2;
  }
  set erp(A2) {
    this.raw.erp = A2;
  }
  set allowedLinearError(A2) {
    this.raw.allowedLinearError = A2;
  }
  set predictionDistance(A2) {
    this.raw.predictionDistance = A2;
  }
  set maxVelocityIterations(A2) {
    this.raw.maxVelocityIterations = A2;
  }
  set maxVelocityFrictionIterations(A2) {
    this.raw.maxVelocityFrictionIterations = A2;
  }
  set maxStabilizationIterations(A2) {
    this.raw.maxStabilizationIterations = A2;
  }
  set minIslandSize(A2) {
    this.raw.minIslandSize = A2;
  }
  set maxCcdSubsteps(A2) {
    this.raw.maxCcdSubsteps = A2;
  }
}
(function(A2) {
  A2[A2.Revolute = 0] = "Revolute", A2[A2.Fixed = 1] = "Fixed", A2[A2.Prismatic = 2] = "Prismatic";
})(GA || (GA = {})), function(A2) {
  A2[A2.AccelerationBased = 0] = "AccelerationBased", A2[A2.ForceBased = 1] = "ForceBased";
}(wA || (wA = {}));

class cA {
  constructor(A2, I2, g2) {
    this.rawSet = A2, this.bodySet = I2, this.handle = g2;
  }
  static newTyped(A2, I2, g2) {
    switch (A2.jointType(g2)) {
      case GA.Revolute:
        return new HA(A2, I2, g2);
      case GA.Prismatic:
        return new tA(A2, I2, g2);
      case GA.Fixed:
        return new LA(A2, I2, g2);
      default:
        return new cA(A2, I2, g2);
    }
  }
  finalizeDeserialization(A2) {
    this.bodySet = A2;
  }
  isValid() {
    return this.rawSet.contains(this.handle);
  }
  body1() {
    return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));
  }
  body2() {
    return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));
  }
  type() {
    return this.rawSet.jointType(this.handle);
  }
  anchor1() {
    return iA.fromRaw(this.rawSet.jointAnchor1(this.handle));
  }
  anchor2() {
    return iA.fromRaw(this.rawSet.jointAnchor2(this.handle));
  }
  setAnchor1(A2) {
    const I2 = iA.intoRaw(A2);
    this.rawSet.jointSetAnchor1(this.handle, I2), I2.free();
  }
  setAnchor2(A2) {
    const I2 = iA.intoRaw(A2);
    this.rawSet.jointSetAnchor2(this.handle, I2), I2.free();
  }
  setContactsEnabled(A2) {
    this.rawSet.jointSetContactsEnabled(this.handle, A2);
  }
  contactsEnabled() {
    return this.rawSet.jointContactsEnabled(this.handle);
  }
}

class YA extends cA {
  limitsEnabled() {
    return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());
  }
  limitsMin() {
    return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());
  }
  limitsMax() {
    return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());
  }
  setLimits(A2, I2) {
    this.rawSet.jointSetLimits(this.handle, this.rawAxis(), A2, I2);
  }
  configureMotorModel(A2) {
    this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), A2);
  }
  configureMotorVelocity(A2, I2) {
    this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), A2, I2);
  }
  configureMotorPosition(A2, I2, g2) {
    this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), A2, I2, g2);
  }
  configureMotor(A2, I2, g2, C2) {
    this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), A2, I2, g2, C2);
  }
}

class LA extends cA {
}

class tA extends YA {
  rawAxis() {
    return c.X;
  }
}

class HA extends YA {
  rawAxis() {
    return c.AngX;
  }
}

class rA {
  constructor() {
  }
  static fixed(A2, I2, g2, C2) {
    let B2 = new rA;
    return B2.anchor1 = A2, B2.anchor2 = g2, B2.frame1 = I2, B2.frame2 = C2, B2.jointType = GA.Fixed, B2;
  }
  static revolute(A2, I2) {
    let g2 = new rA;
    return g2.anchor1 = A2, g2.anchor2 = I2, g2.jointType = GA.Revolute, g2;
  }
  static prismatic(A2, I2, g2) {
    let C2 = new rA;
    return C2.anchor1 = A2, C2.anchor2 = I2, C2.axis = g2, C2.jointType = GA.Prismatic, C2;
  }
  intoRaw() {
    let A2, I2, g2 = iA.intoRaw(this.anchor1), C2 = iA.intoRaw(this.anchor2), B2 = false, Q2 = 0, E2 = 0;
    switch (this.jointType) {
      case GA.Fixed:
        let i2 = oA.intoRaw(this.frame1), o2 = oA.intoRaw(this.frame2);
        I2 = T.fixed(g2, i2, C2, o2), i2.free(), o2.free();
        break;
      case GA.Prismatic:
        A2 = iA.intoRaw(this.axis), this.limitsEnabled && (B2 = true, Q2 = this.limits[0], E2 = this.limits[1]), I2 = T.prismatic(g2, C2, A2, B2, Q2, E2), A2.free();
        break;
      case GA.Revolute:
        I2 = T.revolute(g2, C2);
    }
    return g2.free(), C2.free(), I2;
  }
}

class lA {
  constructor(A2) {
    this.raw = A2 || new x, this.map = new sA, A2 && A2.forEachJointHandle((I2) => {
      this.map.set(I2, cA.newTyped(A2, null, I2));
    });
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined, this.map && this.map.clear(), this.map = undefined;
  }
  finalizeDeserialization(A2) {
    this.map.forEach((I2) => I2.finalizeDeserialization(A2));
  }
  createJoint(A2, I2, g2, C2, B2) {
    const Q2 = I2.intoRaw(), E2 = this.raw.createJoint(Q2, g2, C2, B2);
    Q2.free();
    let i2 = cA.newTyped(this.raw, A2, E2);
    return this.map.set(E2, i2), i2;
  }
  remove(A2, I2) {
    this.raw.remove(A2, I2), this.unmap(A2);
  }
  forEachJointHandleAttachedToRigidBody(A2, I2) {
    this.raw.forEachJointAttachedToRigidBody(A2, I2);
  }
  unmap(A2) {
    this.map.delete(A2);
  }
  len() {
    return this.map.len();
  }
  contains(A2) {
    return this.get(A2) != null;
  }
  get(A2) {
    return this.map.get(A2);
  }
  forEach(A2) {
    this.map.forEach(A2);
  }
  getAll() {
    return this.map.getAll();
  }
}

class pA {
  constructor(A2, I2) {
    this.rawSet = A2, this.handle = I2;
  }
  static newTyped(A2, I2) {
    switch (A2.jointType(I2)) {
      case GA.Revolute:
        return new TA(A2, I2);
      case GA.Prismatic:
        return new dA(A2, I2);
      case GA.Fixed:
        return new nA(A2, I2);
      default:
        return new pA(A2, I2);
    }
  }
  isValid() {
    return this.rawSet.contains(this.handle);
  }
  setContactsEnabled(A2) {
    this.rawSet.jointSetContactsEnabled(this.handle, A2);
  }
  contactsEnabled() {
    return this.rawSet.jointContactsEnabled(this.handle);
  }
}

class eA extends pA {
}

class nA extends pA {
}

class dA extends eA {
  rawAxis() {
    return c.X;
  }
}

class TA extends eA {
  rawAxis() {
    return c.AngX;
  }
}

class xA {
  constructor(A2) {
    this.raw = A2 || new j, this.map = new sA, A2 && A2.forEachJointHandle((A3) => {
      this.map.set(A3, pA.newTyped(this.raw, A3));
    });
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined, this.map && this.map.clear(), this.map = undefined;
  }
  createJoint(A2, I2, g2, C2) {
    const B2 = A2.intoRaw(), Q2 = this.raw.createJoint(B2, I2, g2, C2);
    B2.free();
    let E2 = pA.newTyped(this.raw, Q2);
    return this.map.set(Q2, E2), E2;
  }
  remove(A2, I2) {
    this.raw.remove(A2, I2), this.map.delete(A2);
  }
  unmap(A2) {
    this.map.delete(A2);
  }
  len() {
    return this.map.len();
  }
  contains(A2) {
    return this.get(A2) != null;
  }
  get(A2) {
    return this.map.get(A2);
  }
  forEach(A2) {
    this.map.forEach(A2);
  }
  forEachJointHandleAttachedToRigidBody(A2, I2) {
    this.raw.forEachJointAttachedToRigidBody(A2, I2);
  }
  getAll() {
    return this.map.getAll();
  }
}
(function(A2) {
  A2[A2.Average = 0] = "Average", A2[A2.Min = 1] = "Min", A2[A2.Multiply = 2] = "Multiply", A2[A2.Max = 3] = "Max";
})(aA || (aA = {}));

class ZA {
  constructor(A2) {
    this.raw = A2 || new L;
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined;
  }
}

class bA {
  constructor(A2) {
    this.raw = A2 || new b;
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined;
  }
  forEachActiveRigidBodyHandle(A2) {
    this.raw.forEachActiveRigidBodyHandle(A2);
  }
}

class WA {
  constructor(A2) {
    this.raw = A2 || new Y;
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined;
  }
}

class jA {
  constructor(A2) {
    this.raw = A2 || new O, this.tempManifold = new OA(null);
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined;
  }
  contactsWith(A2, I2) {
    this.raw.contacts_with(A2, I2);
  }
  intersectionsWith(A2, I2) {
    this.raw.intersections_with(A2, I2);
  }
  contactPair(A2, I2, g2) {
    const C2 = this.raw.contact_pair(A2, I2);
    if (C2) {
      const I3 = C2.collider1() != A2;
      let B2;
      for (B2 = 0;B2 < C2.numContactManifolds(); ++B2)
        this.tempManifold.raw = C2.contactManifold(B2), this.tempManifold.raw && g2(this.tempManifold, I3), this.tempManifold.free();
      C2.free();
    }
  }
  intersectionPair(A2, I2) {
    return this.raw.intersection_pair(A2, I2);
  }
}

class OA {
  constructor(A2) {
    this.raw = A2;
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined;
  }
  normal() {
    return iA.fromRaw(this.raw.normal());
  }
  localNormal1() {
    return iA.fromRaw(this.raw.local_n1());
  }
  localNormal2() {
    return iA.fromRaw(this.raw.local_n2());
  }
  subshape1() {
    return this.raw.subshape1();
  }
  subshape2() {
    return this.raw.subshape2();
  }
  numContacts() {
    return this.raw.num_contacts();
  }
  localContactPoint1(A2) {
    return iA.fromRaw(this.raw.contact_local_p1(A2));
  }
  localContactPoint2(A2) {
    return iA.fromRaw(this.raw.contact_local_p2(A2));
  }
  contactDist(A2) {
    return this.raw.contact_dist(A2);
  }
  contactFid1(A2) {
    return this.raw.contact_fid1(A2);
  }
  contactFid2(A2) {
    return this.raw.contact_fid2(A2);
  }
  contactImpulse(A2) {
    return this.raw.contact_impulse(A2);
  }
  contactTangentImpulse(A2) {
    return this.raw.contact_tangent_impulse(A2);
  }
  numSolverContacts() {
    return this.raw.num_solver_contacts();
  }
  solverContactPoint(A2) {
    return iA.fromRaw(this.raw.solver_contact_point(A2));
  }
  solverContactDist(A2) {
    return this.raw.solver_contact_dist(A2);
  }
  solverContactFriction(A2) {
    return this.raw.solver_contact_friction(A2);
  }
  solverContactRestitution(A2) {
    return this.raw.solver_contact_restitution(A2);
  }
  solverContactTangentVelocity(A2) {
    return iA.fromRaw(this.raw.solver_contact_tangent_velocity(A2));
  }
}

class fA {
  constructor(A2, I2, g2, C2, B2) {
    this.distance = A2, this.point1 = I2, this.point2 = g2, this.normal1 = C2, this.normal2 = B2;
  }
  static fromRaw(A2) {
    if (!A2)
      return null;
    const I2 = new fA(A2.distance(), iA.fromRaw(A2.point1()), iA.fromRaw(A2.point2()), iA.fromRaw(A2.normal1()), iA.fromRaw(A2.normal2()));
    return A2.free(), I2;
  }
}
(function(A2) {
  A2[A2.Vertex = 0] = "Vertex", A2[A2.Face = 1] = "Face", A2[A2.Unknown = 2] = "Unknown";
})(hA || (hA = {}));

class XA {
  constructor(A2, I2) {
    this.point = A2, this.isInside = I2;
  }
  static fromRaw(A2) {
    if (!A2)
      return null;
    const I2 = new XA(iA.fromRaw(A2.point()), A2.isInside());
    return A2.free(), I2;
  }
}

class VA {
  constructor(A2, I2, g2, C2, B2) {
    this.featureType = hA.Unknown, this.featureId = undefined, this.collider = A2, this.point = I2, this.isInside = g2, B2 !== undefined && (this.featureId = B2), C2 !== undefined && (this.featureType = C2);
  }
  static fromRaw(A2, I2) {
    if (!I2)
      return null;
    const g2 = new VA(A2.get(I2.colliderHandle()), iA.fromRaw(I2.point()), I2.isInside(), I2.featureType(), I2.featureId());
    return I2.free(), g2;
  }
}

class mA {
  constructor(A2, I2) {
    this.origin = A2, this.dir = I2;
  }
  pointAt(A2) {
    return { x: this.origin.x + this.dir.x * A2, y: this.origin.y + this.dir.y * A2 };
  }
}

class vA {
  constructor(A2, I2, g2, C2) {
    this.featureType = hA.Unknown, this.featureId = undefined, this.toi = A2, this.normal = I2, C2 !== undefined && (this.featureId = C2), g2 !== undefined && (this.featureType = g2);
  }
  static fromRaw(A2) {
    if (!A2)
      return null;
    const I2 = new vA(A2.toi(), iA.fromRaw(A2.normal()), A2.featureType(), A2.featureId());
    return A2.free(), I2;
  }
}

class PA {
  constructor(A2, I2, g2, C2, B2) {
    this.featureType = hA.Unknown, this.featureId = undefined, this.collider = A2, this.toi = I2, this.normal = g2, B2 !== undefined && (this.featureId = B2), C2 !== undefined && (this.featureType = C2);
  }
  static fromRaw(A2, I2) {
    if (!I2)
      return null;
    const g2 = new PA(A2.get(I2.colliderHandle()), I2.toi(), iA.fromRaw(I2.normal()), I2.featureType(), I2.featureId());
    return I2.free(), g2;
  }
}

class uA {
  constructor(A2, I2) {
    this.collider = A2, this.toi = I2;
  }
  static fromRaw(A2, I2) {
    if (!I2)
      return null;
    const g2 = new uA(A2.get(I2.colliderHandle()), I2.toi());
    return I2.free(), g2;
  }
}

class zA {
  constructor(A2, I2, g2, C2, B2) {
    this.toi = A2, this.witness1 = I2, this.witness2 = g2, this.normal1 = C2, this.normal2 = B2;
  }
  static fromRaw(A2, I2) {
    if (!I2)
      return null;
    const g2 = new zA(I2.toi(), iA.fromRaw(I2.witness1()), iA.fromRaw(I2.witness2()), iA.fromRaw(I2.normal1()), iA.fromRaw(I2.normal2()));
    return I2.free(), g2;
  }
}

class _A extends zA {
  constructor(A2, I2, g2, C2, B2, Q2) {
    super(I2, g2, C2, B2, Q2), this.collider = A2;
  }
  static fromRaw(A2, I2) {
    if (!I2)
      return null;
    const g2 = new _A(A2.get(I2.colliderHandle()), I2.toi(), iA.fromRaw(I2.witness1()), iA.fromRaw(I2.witness2()), iA.fromRaw(I2.normal1()), iA.fromRaw(I2.normal2()));
    return I2.free(), g2;
  }
}

class $A {
  static fromRaw(A2, I2) {
    const g2 = A2.coShapeType(I2);
    let C2, B2, Q2, E2, i2, o2, D2;
    switch (g2) {
      case kA.Ball:
        return new AI(A2.coRadius(I2));
      case kA.Cuboid:
        return C2 = A2.coHalfExtents(I2), new gI(C2.x, C2.y);
      case kA.RoundCuboid:
        return C2 = A2.coHalfExtents(I2), B2 = A2.coRoundRadius(I2), new CI(C2.x, C2.y, B2);
      case kA.Capsule:
        return i2 = A2.coHalfHeight(I2), o2 = A2.coRadius(I2), new BI(i2, o2);
      case kA.Segment:
        return Q2 = A2.coVertices(I2), new QI(iA.new(Q2[0], Q2[1]), iA.new(Q2[2], Q2[3]));
      case kA.Polyline:
        return Q2 = A2.coVertices(I2), E2 = A2.coIndices(I2), new oI(Q2, E2);
      case kA.Triangle:
        return Q2 = A2.coVertices(I2), new EI(iA.new(Q2[0], Q2[1]), iA.new(Q2[2], Q2[3]), iA.new(Q2[4], Q2[5]));
      case kA.RoundTriangle:
        return Q2 = A2.coVertices(I2), B2 = A2.coRoundRadius(I2), new iI(iA.new(Q2[0], Q2[1]), iA.new(Q2[2], Q2[3]), iA.new(Q2[4], Q2[5]), B2);
      case kA.HalfSpace:
        return D2 = iA.fromRaw(A2.coHalfspaceNormal(I2)), new II(D2);
      case kA.TriMesh:
        return Q2 = A2.coVertices(I2), E2 = A2.coIndices(I2), new DI(Q2, E2);
      case kA.HeightField:
        const G2 = A2.coHeightfieldScale(I2), w2 = A2.coHeightfieldHeights(I2);
        return new aI(w2, G2);
      case kA.ConvexPolygon:
        return Q2 = A2.coVertices(I2), new GI(Q2, false);
      case kA.RoundConvexPolygon:
        return Q2 = A2.coVertices(I2), B2 = A2.coRoundRadius(I2), new wI(Q2, B2, false);
      default:
        throw new Error("unknown shape type: " + g2);
    }
  }
  castShape(A2, I2, g2, C2, B2, Q2, E2, i2, o2) {
    let D2 = iA.intoRaw(A2), G2 = oA.intoRaw(I2), w2 = iA.intoRaw(g2), a2 = iA.intoRaw(B2), h2 = oA.intoRaw(Q2), k2 = iA.intoRaw(E2), K2 = this.intoRaw(), S2 = C2.intoRaw(), N2 = zA.fromRaw(null, K2.castShape(D2, G2, w2, S2, a2, h2, k2, i2, o2));
    return D2.free(), G2.free(), w2.free(), a2.free(), h2.free(), k2.free(), K2.free(), S2.free(), N2;
  }
  intersectsShape(A2, I2, g2, C2, B2) {
    let Q2 = iA.intoRaw(A2), E2 = oA.intoRaw(I2), i2 = iA.intoRaw(C2), o2 = oA.intoRaw(B2), D2 = this.intoRaw(), G2 = g2.intoRaw(), w2 = D2.intersectsShape(Q2, E2, G2, i2, o2);
    return Q2.free(), E2.free(), i2.free(), o2.free(), D2.free(), G2.free(), w2;
  }
  contactShape(A2, I2, g2, C2, B2, Q2) {
    let E2 = iA.intoRaw(A2), i2 = oA.intoRaw(I2), o2 = iA.intoRaw(C2), D2 = oA.intoRaw(B2), G2 = this.intoRaw(), w2 = g2.intoRaw(), a2 = fA.fromRaw(G2.contactShape(E2, i2, w2, o2, D2, Q2));
    return E2.free(), i2.free(), o2.free(), D2.free(), G2.free(), w2.free(), a2;
  }
  containsPoint(A2, I2, g2) {
    let C2 = iA.intoRaw(A2), B2 = oA.intoRaw(I2), Q2 = iA.intoRaw(g2), E2 = this.intoRaw(), i2 = E2.containsPoint(C2, B2, Q2);
    return C2.free(), B2.free(), Q2.free(), E2.free(), i2;
  }
  projectPoint(A2, I2, g2, C2) {
    let B2 = iA.intoRaw(A2), Q2 = oA.intoRaw(I2), E2 = iA.intoRaw(g2), i2 = this.intoRaw(), o2 = XA.fromRaw(i2.projectPoint(B2, Q2, E2, C2));
    return B2.free(), Q2.free(), E2.free(), i2.free(), o2;
  }
  intersectsRay(A2, I2, g2, C2) {
    let B2 = iA.intoRaw(I2), Q2 = oA.intoRaw(g2), E2 = iA.intoRaw(A2.origin), i2 = iA.intoRaw(A2.dir), o2 = this.intoRaw(), D2 = o2.intersectsRay(B2, Q2, E2, i2, C2);
    return B2.free(), Q2.free(), E2.free(), i2.free(), o2.free(), D2;
  }
  castRay(A2, I2, g2, C2, B2) {
    let Q2 = iA.intoRaw(I2), E2 = oA.intoRaw(g2), i2 = iA.intoRaw(A2.origin), o2 = iA.intoRaw(A2.dir), D2 = this.intoRaw(), G2 = D2.castRay(Q2, E2, i2, o2, C2, B2);
    return Q2.free(), E2.free(), i2.free(), o2.free(), D2.free(), G2;
  }
  castRayAndGetNormal(A2, I2, g2, C2, B2) {
    let Q2 = iA.intoRaw(I2), E2 = oA.intoRaw(g2), i2 = iA.intoRaw(A2.origin), o2 = iA.intoRaw(A2.dir), D2 = this.intoRaw(), G2 = vA.fromRaw(D2.castRayAndGetNormal(Q2, E2, i2, o2, C2, B2));
    return Q2.free(), E2.free(), i2.free(), o2.free(), D2.free(), G2;
  }
}
(function(A2) {
  A2[A2.Ball = 0] = "Ball", A2[A2.Cuboid = 1] = "Cuboid", A2[A2.Capsule = 2] = "Capsule", A2[A2.Segment = 3] = "Segment", A2[A2.Polyline = 4] = "Polyline", A2[A2.Triangle = 5] = "Triangle", A2[A2.TriMesh = 6] = "TriMesh", A2[A2.HeightField = 7] = "HeightField", A2[A2.ConvexPolygon = 9] = "ConvexPolygon", A2[A2.RoundCuboid = 10] = "RoundCuboid", A2[A2.RoundTriangle = 11] = "RoundTriangle", A2[A2.RoundConvexPolygon = 12] = "RoundConvexPolygon", A2[A2.HalfSpace = 13] = "HalfSpace";
})(kA || (kA = {}));

class AI extends $A {
  constructor(A2) {
    super(), this.type = kA.Ball, this.radius = A2;
  }
  intoRaw() {
    return AA.ball(this.radius);
  }
}

class II extends $A {
  constructor(A2) {
    super(), this.type = kA.HalfSpace, this.normal = A2;
  }
  intoRaw() {
    let A2 = iA.intoRaw(this.normal), I2 = AA.halfspace(A2);
    return A2.free(), I2;
  }
}

class gI extends $A {
  constructor(A2, I2) {
    super(), this.type = kA.Cuboid, this.halfExtents = iA.new(A2, I2);
  }
  intoRaw() {
    return AA.cuboid(this.halfExtents.x, this.halfExtents.y);
  }
}

class CI extends $A {
  constructor(A2, I2, g2) {
    super(), this.type = kA.RoundCuboid, this.halfExtents = iA.new(A2, I2), this.borderRadius = g2;
  }
  intoRaw() {
    return AA.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.borderRadius);
  }
}

class BI extends $A {
  constructor(A2, I2) {
    super(), this.type = kA.Capsule, this.halfHeight = A2, this.radius = I2;
  }
  intoRaw() {
    return AA.capsule(this.halfHeight, this.radius);
  }
}

class QI extends $A {
  constructor(A2, I2) {
    super(), this.type = kA.Segment, this.a = A2, this.b = I2;
  }
  intoRaw() {
    let A2 = iA.intoRaw(this.a), I2 = iA.intoRaw(this.b), g2 = AA.segment(A2, I2);
    return A2.free(), I2.free(), g2;
  }
}

class EI extends $A {
  constructor(A2, I2, g2) {
    super(), this.type = kA.Triangle, this.a = A2, this.b = I2, this.c = g2;
  }
  intoRaw() {
    let A2 = iA.intoRaw(this.a), I2 = iA.intoRaw(this.b), g2 = iA.intoRaw(this.c), C2 = AA.triangle(A2, I2, g2);
    return A2.free(), I2.free(), g2.free(), C2;
  }
}

class iI extends $A {
  constructor(A2, I2, g2, C2) {
    super(), this.type = kA.RoundTriangle, this.a = A2, this.b = I2, this.c = g2, this.borderRadius = C2;
  }
  intoRaw() {
    let A2 = iA.intoRaw(this.a), I2 = iA.intoRaw(this.b), g2 = iA.intoRaw(this.c), C2 = AA.roundTriangle(A2, I2, g2, this.borderRadius);
    return A2.free(), I2.free(), g2.free(), C2;
  }
}

class oI extends $A {
  constructor(A2, I2) {
    super(), this.type = kA.Polyline, this.vertices = A2, this.indices = I2 != null ? I2 : new Uint32Array(0);
  }
  intoRaw() {
    return AA.polyline(this.vertices, this.indices);
  }
}

class DI extends $A {
  constructor(A2, I2) {
    super(), this.type = kA.TriMesh, this.vertices = A2, this.indices = I2;
  }
  intoRaw() {
    return AA.trimesh(this.vertices, this.indices);
  }
}

class GI extends $A {
  constructor(A2, I2) {
    super(), this.type = kA.ConvexPolygon, this.vertices = A2, this.skipConvexHullComputation = !!I2;
  }
  intoRaw() {
    return this.skipConvexHullComputation ? AA.convexPolyline(this.vertices) : AA.convexHull(this.vertices);
  }
}

class wI extends $A {
  constructor(A2, I2, g2) {
    super(), this.type = kA.RoundConvexPolygon, this.vertices = A2, this.borderRadius = I2, this.skipConvexHullComputation = !!g2;
  }
  intoRaw() {
    return this.skipConvexHullComputation ? AA.roundConvexPolyline(this.vertices, this.borderRadius) : AA.roundConvexHull(this.vertices, this.borderRadius);
  }
}

class aI extends $A {
  constructor(A2, I2) {
    super(), this.type = kA.HeightField, this.heights = A2, this.scale = I2;
  }
  intoRaw() {
    let A2 = iA.intoRaw(this.scale), I2 = AA.heightfield(this.heights, A2);
    return A2.free(), I2;
  }
}
(function(A2) {
  A2[A2.DYNAMIC_DYNAMIC = 1] = "DYNAMIC_DYNAMIC", A2[A2.DYNAMIC_KINEMATIC = 12] = "DYNAMIC_KINEMATIC", A2[A2.DYNAMIC_FIXED = 2] = "DYNAMIC_FIXED", A2[A2.KINEMATIC_KINEMATIC = 52224] = "KINEMATIC_KINEMATIC", A2[A2.KINEMATIC_FIXED = 8704] = "KINEMATIC_FIXED", A2[A2.FIXED_FIXED = 32] = "FIXED_FIXED", A2[A2.DEFAULT = 15] = "DEFAULT", A2[A2.ALL = 60943] = "ALL";
})(KA || (KA = {}));

class hI {
  constructor(A2, I2, g2, C2) {
    this.colliderSet = A2, this.handle = I2, this._parent = g2, this._shape = C2;
  }
  finalizeDeserialization(A2) {
    this.handle != null && (this._parent = A2.get(this.colliderSet.raw.coParent(this.handle)));
  }
  ensureShapeIsCached() {
    this._shape || (this._shape = $A.fromRaw(this.colliderSet.raw, this.handle));
  }
  get shape() {
    return this.ensureShapeIsCached(), this._shape;
  }
  isValid() {
    return this.colliderSet.raw.contains(this.handle);
  }
  translation() {
    return iA.fromRaw(this.colliderSet.raw.coTranslation(this.handle));
  }
  rotation() {
    return oA.fromRaw(this.colliderSet.raw.coRotation(this.handle));
  }
  isSensor() {
    return this.colliderSet.raw.coIsSensor(this.handle);
  }
  setSensor(A2) {
    this.colliderSet.raw.coSetSensor(this.handle, A2);
  }
  setShape(A2) {
    let I2 = A2.intoRaw();
    this.colliderSet.raw.coSetShape(this.handle, I2), I2.free(), this._shape = A2;
  }
  setEnabled(A2) {
    this.colliderSet.raw.coSetEnabled(this.handle, A2);
  }
  isEnabled() {
    return this.colliderSet.raw.coIsEnabled(this.handle);
  }
  setRestitution(A2) {
    this.colliderSet.raw.coSetRestitution(this.handle, A2);
  }
  setFriction(A2) {
    this.colliderSet.raw.coSetFriction(this.handle, A2);
  }
  frictionCombineRule() {
    return this.colliderSet.raw.coFrictionCombineRule(this.handle);
  }
  setFrictionCombineRule(A2) {
    this.colliderSet.raw.coSetFrictionCombineRule(this.handle, A2);
  }
  restitutionCombineRule() {
    return this.colliderSet.raw.coRestitutionCombineRule(this.handle);
  }
  setRestitutionCombineRule(A2) {
    this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, A2);
  }
  setCollisionGroups(A2) {
    this.colliderSet.raw.coSetCollisionGroups(this.handle, A2);
  }
  setSolverGroups(A2) {
    this.colliderSet.raw.coSetSolverGroups(this.handle, A2);
  }
  activeHooks() {
    return this.colliderSet.raw.coActiveHooks(this.handle);
  }
  setActiveHooks(A2) {
    this.colliderSet.raw.coSetActiveHooks(this.handle, A2);
  }
  activeEvents() {
    return this.colliderSet.raw.coActiveEvents(this.handle);
  }
  setActiveEvents(A2) {
    this.colliderSet.raw.coSetActiveEvents(this.handle, A2);
  }
  activeCollisionTypes() {
    return this.colliderSet.raw.coActiveCollisionTypes(this.handle);
  }
  setContactForceEventThreshold(A2) {
    return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, A2);
  }
  contactForceEventThreshold() {
    return this.colliderSet.raw.coContactForceEventThreshold(this.handle);
  }
  setActiveCollisionTypes(A2) {
    this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, A2);
  }
  setDensity(A2) {
    this.colliderSet.raw.coSetDensity(this.handle, A2);
  }
  setMass(A2) {
    this.colliderSet.raw.coSetMass(this.handle, A2);
  }
  setMassProperties(A2, I2, g2) {
    let C2 = iA.intoRaw(I2);
    this.colliderSet.raw.coSetMassProperties(this.handle, A2, C2, g2), C2.free();
  }
  setTranslation(A2) {
    this.colliderSet.raw.coSetTranslation(this.handle, A2.x, A2.y);
  }
  setTranslationWrtParent(A2) {
    this.colliderSet.raw.coSetTranslationWrtParent(this.handle, A2.x, A2.y);
  }
  setRotation(A2) {
    this.colliderSet.raw.coSetRotation(this.handle, A2);
  }
  setRotationWrtParent(A2) {
    this.colliderSet.raw.coSetRotationWrtParent(this.handle, A2);
  }
  shapeType() {
    return this.colliderSet.raw.coShapeType(this.handle);
  }
  halfExtents() {
    return iA.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));
  }
  setHalfExtents(A2) {
    const I2 = iA.intoRaw(A2);
    this.colliderSet.raw.coSetHalfExtents(this.handle, I2);
  }
  radius() {
    return this.colliderSet.raw.coRadius(this.handle);
  }
  setRadius(A2) {
    this.colliderSet.raw.coSetRadius(this.handle, A2);
  }
  roundRadius() {
    return this.colliderSet.raw.coRoundRadius(this.handle);
  }
  setRoundRadius(A2) {
    this.colliderSet.raw.coSetRoundRadius(this.handle, A2);
  }
  halfHeight() {
    return this.colliderSet.raw.coHalfHeight(this.handle);
  }
  setHalfHeight(A2) {
    this.colliderSet.raw.coSetHalfHeight(this.handle, A2);
  }
  vertices() {
    return this.colliderSet.raw.coVertices(this.handle);
  }
  indices() {
    return this.colliderSet.raw.coIndices(this.handle);
  }
  heightfieldHeights() {
    return this.colliderSet.raw.coHeightfieldHeights(this.handle);
  }
  heightfieldScale() {
    let A2 = this.colliderSet.raw.coHeightfieldScale(this.handle);
    return iA.fromRaw(A2);
  }
  parent() {
    return this._parent;
  }
  friction() {
    return this.colliderSet.raw.coFriction(this.handle);
  }
  restitution() {
    return this.colliderSet.raw.coRestitution(this.handle);
  }
  density() {
    return this.colliderSet.raw.coDensity(this.handle);
  }
  mass() {
    return this.colliderSet.raw.coMass(this.handle);
  }
  volume() {
    return this.colliderSet.raw.coVolume(this.handle);
  }
  collisionGroups() {
    return this.colliderSet.raw.coCollisionGroups(this.handle);
  }
  solverGroups() {
    return this.colliderSet.raw.coSolverGroups(this.handle);
  }
  containsPoint(A2) {
    let I2 = iA.intoRaw(A2), g2 = this.colliderSet.raw.coContainsPoint(this.handle, I2);
    return I2.free(), g2;
  }
  projectPoint(A2, I2) {
    let g2 = iA.intoRaw(A2), C2 = XA.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, g2, I2));
    return g2.free(), C2;
  }
  intersectsRay(A2, I2) {
    let g2 = iA.intoRaw(A2.origin), C2 = iA.intoRaw(A2.dir), B2 = this.colliderSet.raw.coIntersectsRay(this.handle, g2, C2, I2);
    return g2.free(), C2.free(), B2;
  }
  castShape(A2, I2, g2, C2, B2, Q2, E2) {
    let i2 = iA.intoRaw(A2), o2 = iA.intoRaw(g2), D2 = oA.intoRaw(C2), G2 = iA.intoRaw(B2), w2 = I2.intoRaw(), a2 = zA.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, i2, w2, o2, D2, G2, Q2, E2));
    return i2.free(), o2.free(), D2.free(), G2.free(), w2.free(), a2;
  }
  castCollider(A2, I2, g2, C2, B2) {
    let Q2 = iA.intoRaw(A2), E2 = iA.intoRaw(g2), i2 = _A.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, Q2, I2.handle, E2, C2, B2));
    return Q2.free(), E2.free(), i2;
  }
  intersectsShape(A2, I2, g2) {
    let C2 = iA.intoRaw(I2), B2 = oA.intoRaw(g2), Q2 = A2.intoRaw(), E2 = this.colliderSet.raw.coIntersectsShape(this.handle, Q2, C2, B2);
    return C2.free(), B2.free(), Q2.free(), E2;
  }
  contactShape(A2, I2, g2, C2) {
    let B2 = iA.intoRaw(I2), Q2 = oA.intoRaw(g2), E2 = A2.intoRaw(), i2 = fA.fromRaw(this.colliderSet.raw.coContactShape(this.handle, E2, B2, Q2, C2));
    return B2.free(), Q2.free(), E2.free(), i2;
  }
  contactCollider(A2, I2) {
    return fA.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, A2.handle, I2));
  }
  castRay(A2, I2, g2) {
    let C2 = iA.intoRaw(A2.origin), B2 = iA.intoRaw(A2.dir), Q2 = this.colliderSet.raw.coCastRay(this.handle, C2, B2, I2, g2);
    return C2.free(), B2.free(), Q2;
  }
  castRayAndGetNormal(A2, I2, g2) {
    let C2 = iA.intoRaw(A2.origin), B2 = iA.intoRaw(A2.dir), Q2 = vA.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, C2, B2, I2, g2));
    return C2.free(), B2.free(), Q2;
  }
}
(function(A2) {
  A2[A2.Density = 0] = "Density", A2[A2.Mass = 1] = "Mass", A2[A2.MassProps = 2] = "MassProps";
})(SA || (SA = {}));

class kI {
  constructor(A2) {
    this.enabled = true, this.shape = A2, this.massPropsMode = SA.Density, this.density = 1, this.friction = 0.5, this.restitution = 0, this.rotation = oA.identity(), this.translation = iA.zeros(), this.isSensor = false, this.collisionGroups = 4294967295, this.solverGroups = 4294967295, this.frictionCombineRule = aA.Average, this.restitutionCombineRule = aA.Average, this.activeCollisionTypes = KA.DEFAULT, this.activeEvents = 0, this.activeHooks = 0, this.mass = 0, this.centerOfMass = iA.zeros(), this.contactForceEventThreshold = 0, this.principalAngularInertia = 0, this.rotationsEnabled = true;
  }
  static ball(A2) {
    const I2 = new AI(A2);
    return new kI(I2);
  }
  static capsule(A2, I2) {
    const g2 = new BI(A2, I2);
    return new kI(g2);
  }
  static segment(A2, I2) {
    const g2 = new QI(A2, I2);
    return new kI(g2);
  }
  static triangle(A2, I2, g2) {
    const C2 = new EI(A2, I2, g2);
    return new kI(C2);
  }
  static roundTriangle(A2, I2, g2, C2) {
    const B2 = new iI(A2, I2, g2, C2);
    return new kI(B2);
  }
  static polyline(A2, I2) {
    const g2 = new oI(A2, I2);
    return new kI(g2);
  }
  static trimesh(A2, I2) {
    const g2 = new DI(A2, I2);
    return new kI(g2);
  }
  static cuboid(A2, I2) {
    const g2 = new gI(A2, I2);
    return new kI(g2);
  }
  static roundCuboid(A2, I2, g2) {
    const C2 = new CI(A2, I2, g2);
    return new kI(C2);
  }
  static halfspace(A2) {
    const I2 = new II(A2);
    return new kI(I2);
  }
  static heightfield(A2, I2) {
    const g2 = new aI(A2, I2);
    return new kI(g2);
  }
  static convexHull(A2) {
    const I2 = new GI(A2, false);
    return new kI(I2);
  }
  static convexPolyline(A2) {
    const I2 = new GI(A2, true);
    return new kI(I2);
  }
  static roundConvexHull(A2, I2) {
    const g2 = new wI(A2, I2, false);
    return new kI(g2);
  }
  static roundConvexPolyline(A2, I2) {
    const g2 = new wI(A2, I2, true);
    return new kI(g2);
  }
  setTranslation(A2, I2) {
    if (typeof A2 != "number" || typeof I2 != "number")
      throw TypeError("The translation components must be numbers.");
    return this.translation = { x: A2, y: I2 }, this;
  }
  setRotation(A2) {
    return this.rotation = A2, this;
  }
  setSensor(A2) {
    return this.isSensor = A2, this;
  }
  setEnabled(A2) {
    return this.enabled = A2, this;
  }
  setDensity(A2) {
    return this.massPropsMode = SA.Density, this.density = A2, this;
  }
  setMass(A2) {
    return this.massPropsMode = SA.Mass, this.mass = A2, this;
  }
  setMassProperties(A2, I2, g2) {
    return this.massPropsMode = SA.MassProps, this.mass = A2, iA.copy(this.centerOfMass, I2), this.principalAngularInertia = g2, this;
  }
  setRestitution(A2) {
    return this.restitution = A2, this;
  }
  setFriction(A2) {
    return this.friction = A2, this;
  }
  setFrictionCombineRule(A2) {
    return this.frictionCombineRule = A2, this;
  }
  setRestitutionCombineRule(A2) {
    return this.restitutionCombineRule = A2, this;
  }
  setCollisionGroups(A2) {
    return this.collisionGroups = A2, this;
  }
  setSolverGroups(A2) {
    return this.solverGroups = A2, this;
  }
  setActiveHooks(A2) {
    return this.activeHooks = A2, this;
  }
  setActiveEvents(A2) {
    return this.activeEvents = A2, this;
  }
  setActiveCollisionTypes(A2) {
    return this.activeCollisionTypes = A2, this;
  }
  setContactForceEventThreshold(A2) {
    return this.contactForceEventThreshold = A2, this;
  }
}

class KI {
  constructor(A2) {
    this.raw = A2 || new H, this.map = new sA, A2 && A2.forEachColliderHandle((A3) => {
      this.map.set(A3, new hI(this, A3, null));
    });
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined, this.map && this.map.clear(), this.map = undefined;
  }
  castClosure(A2) {
    return (I2) => A2 ? A2(this.get(I2)) : undefined;
  }
  finalizeDeserialization(A2) {
    this.map.forEach((I2) => I2.finalizeDeserialization(A2));
  }
  createCollider(A2, I2, g2) {
    let C2 = g2 != null && g2 != null;
    if (C2 && isNaN(g2))
      throw Error("Cannot create a collider with a parent rigid-body handle that is not a number.");
    let B2 = I2.shape.intoRaw(), Q2 = iA.intoRaw(I2.translation), E2 = oA.intoRaw(I2.rotation), i2 = iA.intoRaw(I2.centerOfMass), o2 = this.raw.createCollider(I2.enabled, B2, Q2, E2, I2.massPropsMode, I2.mass, i2, I2.principalAngularInertia, I2.density, I2.friction, I2.restitution, I2.frictionCombineRule, I2.restitutionCombineRule, I2.isSensor, I2.collisionGroups, I2.solverGroups, I2.activeCollisionTypes, I2.activeHooks, I2.activeEvents, I2.contactForceEventThreshold, C2, C2 ? g2 : 0, A2.raw);
    B2.free(), Q2.free(), E2.free(), i2.free();
    let D2 = C2 ? A2.get(g2) : null, G2 = new hI(this, o2, D2, I2.shape);
    return this.map.set(o2, G2), G2;
  }
  remove(A2, I2, g2, C2) {
    this.raw.remove(A2, I2.raw, g2.raw, C2), this.unmap(A2);
  }
  unmap(A2) {
    this.map.delete(A2);
  }
  get(A2) {
    return this.map.get(A2);
  }
  len() {
    return this.map.len();
  }
  contains(A2) {
    return this.get(A2) != null;
  }
  forEach(A2) {
    this.map.forEach(A2);
  }
  getAll() {
    return this.map.getAll();
  }
}

class SI {
  constructor(A2) {
    this.raw = A2 || new f;
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined;
  }
  step(A2, I2, g2, C2, B2, Q2, E2, i2, o2, D2, G2, w2) {
    let a2 = iA.intoRaw(A2);
    G2 ? this.raw.stepWithEvents(a2, I2.raw, g2.raw, C2.raw, B2.raw, Q2.raw, E2.raw, i2.raw, o2.raw, D2.raw, G2.raw, w2, w2 ? w2.filterContactPair : null, w2 ? w2.filterIntersectionPair : null) : this.raw.step(a2, I2.raw, g2.raw, C2.raw, B2.raw, Q2.raw, E2.raw, i2.raw, o2.raw, D2.raw), a2.free();
  }
}
(function(A2) {
  A2[A2.EXCLUDE_FIXED = 1] = "EXCLUDE_FIXED", A2[A2.EXCLUDE_KINEMATIC = 2] = "EXCLUDE_KINEMATIC", A2[A2.EXCLUDE_DYNAMIC = 4] = "EXCLUDE_DYNAMIC", A2[A2.EXCLUDE_SENSORS = 8] = "EXCLUDE_SENSORS", A2[A2.EXCLUDE_SOLIDS = 16] = "EXCLUDE_SOLIDS", A2[A2.ONLY_DYNAMIC = 3] = "ONLY_DYNAMIC", A2[A2.ONLY_KINEMATIC = 5] = "ONLY_KINEMATIC", A2[A2.ONLY_FIXED = 6] = "ONLY_FIXED";
})(NA || (NA = {}));

class NI {
  constructor(A2) {
    this.raw = A2 || new m;
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined;
  }
  update(A2, I2) {
    this.raw.update(A2.raw, I2.raw);
  }
  castRay(A2, I2, g2, C2, B2, Q2, E2, i2, o2, D2) {
    let G2 = iA.intoRaw(g2.origin), w2 = iA.intoRaw(g2.dir), a2 = uA.fromRaw(I2, this.raw.castRay(A2.raw, I2.raw, G2, w2, C2, B2, Q2, E2, i2, o2, D2));
    return G2.free(), w2.free(), a2;
  }
  castRayAndGetNormal(A2, I2, g2, C2, B2, Q2, E2, i2, o2, D2) {
    let G2 = iA.intoRaw(g2.origin), w2 = iA.intoRaw(g2.dir), a2 = PA.fromRaw(I2, this.raw.castRayAndGetNormal(A2.raw, I2.raw, G2, w2, C2, B2, Q2, E2, i2, o2, D2));
    return G2.free(), w2.free(), a2;
  }
  intersectionsWithRay(A2, I2, g2, C2, B2, Q2, E2, i2, o2, D2, G2) {
    let w2 = iA.intoRaw(g2.origin), a2 = iA.intoRaw(g2.dir);
    this.raw.intersectionsWithRay(A2.raw, I2.raw, w2, a2, C2, B2, (A3) => Q2(PA.fromRaw(I2, A3)), E2, i2, o2, D2, G2), w2.free(), a2.free();
  }
  intersectionWithShape(A2, I2, g2, C2, B2, Q2, E2, i2, o2, D2) {
    let G2 = iA.intoRaw(g2), w2 = oA.intoRaw(C2), a2 = B2.intoRaw(), h2 = this.raw.intersectionWithShape(A2.raw, I2.raw, G2, w2, a2, Q2, E2, i2, o2, D2);
    return G2.free(), w2.free(), a2.free(), h2;
  }
  projectPoint(A2, I2, g2, C2, B2, Q2, E2, i2, o2) {
    let D2 = iA.intoRaw(g2), G2 = VA.fromRaw(I2, this.raw.projectPoint(A2.raw, I2.raw, D2, C2, B2, Q2, E2, i2, o2));
    return D2.free(), G2;
  }
  projectPointAndGetFeature(A2, I2, g2, C2, B2, Q2, E2, i2) {
    let o2 = iA.intoRaw(g2), D2 = VA.fromRaw(I2, this.raw.projectPointAndGetFeature(A2.raw, I2.raw, o2, C2, B2, Q2, E2, i2));
    return o2.free(), D2;
  }
  intersectionsWithPoint(A2, I2, g2, C2, B2, Q2, E2, i2, o2) {
    let D2 = iA.intoRaw(g2);
    this.raw.intersectionsWithPoint(A2.raw, I2.raw, D2, C2, B2, Q2, E2, i2, o2), D2.free();
  }
  castShape(A2, I2, g2, C2, B2, Q2, E2, i2, o2, D2, G2, w2, a2) {
    let h2 = iA.intoRaw(g2), k2 = oA.intoRaw(C2), K2 = iA.intoRaw(B2), S2 = Q2.intoRaw(), N2 = _A.fromRaw(I2, this.raw.castShape(A2.raw, I2.raw, h2, k2, K2, S2, E2, i2, o2, D2, G2, w2, a2));
    return h2.free(), k2.free(), K2.free(), S2.free(), N2;
  }
  intersectionsWithShape(A2, I2, g2, C2, B2, Q2, E2, i2, o2, D2, G2) {
    let w2 = iA.intoRaw(g2), a2 = oA.intoRaw(C2), h2 = B2.intoRaw();
    this.raw.intersectionsWithShape(A2.raw, I2.raw, w2, a2, h2, Q2, E2, i2, o2, D2, G2), w2.free(), a2.free(), h2.free();
  }
  collidersWithAabbIntersectingAabb(A2, I2, g2) {
    let C2 = iA.intoRaw(A2), B2 = iA.intoRaw(I2);
    this.raw.collidersWithAabbIntersectingAabb(C2, B2, g2), C2.free(), B2.free();
  }
}

class FI {
  constructor(A2) {
    this.raw = A2 || new $;
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined;
  }
  serializeAll(A2, I2, g2, C2, B2, Q2, E2, i2, o2) {
    let D2 = iA.intoRaw(A2);
    const G2 = this.raw.serializeAll(D2, I2.raw, g2.raw, C2.raw, B2.raw, Q2.raw, E2.raw, i2.raw, o2.raw);
    return D2.free(), G2;
  }
  deserializeAll(A2) {
    return sI.fromRaw(this.raw.deserializeAll(A2));
  }
}

class yI {
  constructor(A2, I2) {
    this.vertices = A2, this.colors = I2;
  }
}

class RI {
  constructor(A2) {
    this.raw = A2 || new e;
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined, this.vertices = undefined, this.colors = undefined;
  }
  render(A2, I2, g2, C2, B2) {
    this.raw.render(A2.raw, I2.raw, g2.raw, C2.raw, B2.raw), this.vertices = this.raw.vertices(), this.colors = this.raw.colors();
  }
}

class JI {
}

class MI {
  constructor(A2, I2, g2, C2, B2) {
    this.params = I2, this.bodies = g2, this.colliders = C2, this.queries = B2, this.raw = new W(A2), this.rawCharacterCollision = new t, this._applyImpulsesToDynamicBodies = false, this._characterMass = null;
  }
  free() {
    this.raw && (this.raw.free(), this.rawCharacterCollision.free()), this.raw = undefined, this.rawCharacterCollision = undefined;
  }
  up() {
    return this.raw.up();
  }
  setUp(A2) {
    let I2 = iA.intoRaw(A2);
    return this.raw.setUp(I2);
  }
  applyImpulsesToDynamicBodies() {
    return this._applyImpulsesToDynamicBodies;
  }
  setApplyImpulsesToDynamicBodies(A2) {
    this._applyImpulsesToDynamicBodies = A2;
  }
  characterMass() {
    return this._characterMass;
  }
  setCharacterMass(A2) {
    this._characterMass = A2;
  }
  offset() {
    return this.raw.offset();
  }
  setOffset(A2) {
    this.raw.setOffset(A2);
  }
  slideEnabled() {
    return this.raw.slideEnabled();
  }
  setSlideEnabled(A2) {
    this.raw.setSlideEnabled(A2);
  }
  autostepMaxHeight() {
    return this.raw.autostepMaxHeight();
  }
  autostepMinWidth() {
    return this.raw.autostepMinWidth();
  }
  autostepIncludesDynamicBodies() {
    return this.raw.autostepIncludesDynamicBodies();
  }
  autostepEnabled() {
    return this.raw.autostepEnabled();
  }
  enableAutostep(A2, I2, g2) {
    this.raw.enableAutostep(A2, I2, g2);
  }
  disableAutostep() {
    return this.raw.disableAutostep();
  }
  maxSlopeClimbAngle() {
    return this.raw.maxSlopeClimbAngle();
  }
  setMaxSlopeClimbAngle(A2) {
    this.raw.setMaxSlopeClimbAngle(A2);
  }
  minSlopeSlideAngle() {
    return this.raw.minSlopeSlideAngle();
  }
  setMinSlopeSlideAngle(A2) {
    this.raw.setMinSlopeSlideAngle(A2);
  }
  snapToGroundDistance() {
    return this.raw.snapToGroundDistance();
  }
  enableSnapToGround(A2) {
    this.raw.enableSnapToGround(A2);
  }
  disableSnapToGround() {
    this.raw.disableSnapToGround();
  }
  snapToGroundEnabled() {
    return this.raw.snapToGroundEnabled();
  }
  computeColliderMovement(A2, I2, g2, C2, B2) {
    let Q2 = iA.intoRaw(I2);
    this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, A2.handle, Q2, this._applyImpulsesToDynamicBodies, this._characterMass, g2, C2, this.colliders.castClosure(B2)), Q2.free();
  }
  computedMovement() {
    return iA.fromRaw(this.raw.computedMovement());
  }
  computedGrounded() {
    return this.raw.computedGrounded();
  }
  numComputedCollisions() {
    return this.raw.numComputedCollisions();
  }
  computedCollision(A2, I2) {
    if (this.raw.computedCollision(A2, this.rawCharacterCollision)) {
      let A3 = this.rawCharacterCollision;
      return (I2 = I2 != null ? I2 : new JI).translationApplied = iA.fromRaw(A3.translationApplied()), I2.translationRemaining = iA.fromRaw(A3.translationRemaining()), I2.toi = A3.toi(), I2.witness1 = iA.fromRaw(A3.worldWitness1()), I2.witness2 = iA.fromRaw(A3.worldWitness2()), I2.normal1 = iA.fromRaw(A3.worldNormal1()), I2.normal2 = iA.fromRaw(A3.worldNormal2()), I2.collider = this.colliders.get(A3.handle()), I2;
    }
    return null;
  }
}

class sI {
  constructor(A2, I2, g2, C2, B2, Q2, E2, i2, o2, D2, G2, w2, a2, h2) {
    this.gravity = A2, this.integrationParameters = new qA(I2), this.islands = new bA(g2), this.broadPhase = new WA(C2), this.narrowPhase = new jA(B2), this.bodies = new UA(Q2), this.colliders = new KI(E2), this.impulseJoints = new lA(i2), this.multibodyJoints = new xA(o2), this.ccdSolver = new ZA(D2), this.queryPipeline = new NI(G2), this.physicsPipeline = new SI(w2), this.serializationPipeline = new FI(a2), this.debugRenderPipeline = new RI(h2), this.characterControllers = new Set, this.impulseJoints.finalizeDeserialization(this.bodies), this.bodies.finalizeDeserialization(this.colliders), this.colliders.finalizeDeserialization(this.bodies);
  }
  free() {
    this.integrationParameters.free(), this.islands.free(), this.broadPhase.free(), this.narrowPhase.free(), this.bodies.free(), this.colliders.free(), this.impulseJoints.free(), this.multibodyJoints.free(), this.ccdSolver.free(), this.queryPipeline.free(), this.physicsPipeline.free(), this.serializationPipeline.free(), this.debugRenderPipeline.free(), this.characterControllers.forEach((A2) => A2.free()), this.integrationParameters = undefined, this.islands = undefined, this.broadPhase = undefined, this.narrowPhase = undefined, this.bodies = undefined, this.colliders = undefined, this.ccdSolver = undefined, this.impulseJoints = undefined, this.multibodyJoints = undefined, this.queryPipeline = undefined, this.physicsPipeline = undefined, this.serializationPipeline = undefined, this.debugRenderPipeline = undefined, this.characterControllers = undefined;
  }
  static fromRaw(A2) {
    return A2 ? new sI(iA.fromRaw(A2.takeGravity()), A2.takeIntegrationParameters(), A2.takeIslandManager(), A2.takeBroadPhase(), A2.takeNarrowPhase(), A2.takeBodies(), A2.takeColliders(), A2.takeImpulseJoints(), A2.takeMultibodyJoints()) : null;
  }
  takeSnapshot() {
    return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);
  }
  static restoreSnapshot(A2) {
    return new FI().deserializeAll(A2);
  }
  debugRender() {
    return this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase), new yI(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);
  }
  step(A2, I2) {
    this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, A2, I2), this.queryPipeline.update(this.bodies, this.colliders);
  }
  propagateModifiedBodyPositionsToColliders() {
    this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);
  }
  updateSceneQueries() {
    this.propagateModifiedBodyPositionsToColliders(), this.queryPipeline.update(this.bodies, this.colliders);
  }
  get timestep() {
    return this.integrationParameters.dt;
  }
  set timestep(A2) {
    this.integrationParameters.dt = A2;
  }
  get maxVelocityIterations() {
    return this.integrationParameters.maxVelocityIterations;
  }
  set maxVelocityIterations(A2) {
    this.integrationParameters.maxVelocityIterations = A2;
  }
  get maxVelocityFrictionIterations() {
    return this.integrationParameters.maxVelocityFrictionIterations;
  }
  set maxVelocityFrictionIterations(A2) {
    this.integrationParameters.maxVelocityFrictionIterations = A2;
  }
  get maxStabilizationIterations() {
    return this.integrationParameters.maxStabilizationIterations;
  }
  set maxStabilizationIterations(A2) {
    this.integrationParameters.maxStabilizationIterations = A2;
  }
  createRigidBody(A2) {
    return this.bodies.createRigidBody(this.colliders, A2);
  }
  createCharacterController(A2) {
    let I2 = new MI(A2, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);
    return this.characterControllers.add(I2), I2;
  }
  removeCharacterController(A2) {
    this.characterControllers.delete(A2), A2.free();
  }
  createCollider(A2, I2) {
    let g2 = I2 ? I2.handle : undefined;
    return this.colliders.createCollider(this.bodies, A2, g2);
  }
  createImpulseJoint(A2, I2, g2, C2) {
    return this.impulseJoints.createJoint(this.bodies, A2, I2.handle, g2.handle, C2);
  }
  createMultibodyJoint(A2, I2, g2, C2) {
    return this.multibodyJoints.createJoint(A2, I2.handle, g2.handle, C2);
  }
  getRigidBody(A2) {
    return this.bodies.get(A2);
  }
  getCollider(A2) {
    return this.colliders.get(A2);
  }
  getImpulseJoint(A2) {
    return this.impulseJoints.get(A2);
  }
  getMultibodyJoint(A2) {
    return this.multibodyJoints.get(A2);
  }
  removeRigidBody(A2) {
    this.bodies && this.bodies.remove(A2.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);
  }
  removeCollider(A2, I2) {
    this.colliders && this.colliders.remove(A2.handle, this.islands, this.bodies, I2);
  }
  removeImpulseJoint(A2, I2) {
    this.impulseJoints && this.impulseJoints.remove(A2.handle, I2);
  }
  removeMultibodyJoint(A2, I2) {
    this.impulseJoints && this.multibodyJoints.remove(A2.handle, I2);
  }
  forEachCollider(A2) {
    this.colliders.forEach(A2);
  }
  forEachRigidBody(A2) {
    this.bodies.forEach(A2);
  }
  forEachActiveRigidBody(A2) {
    this.bodies.forEachActiveRigidBody(this.islands, A2);
  }
  castRay(A2, I2, g2, C2, B2, Q2, E2, i2) {
    return this.queryPipeline.castRay(this.bodies, this.colliders, A2, I2, g2, C2, B2, Q2 ? Q2.handle : null, E2 ? E2.handle : null, this.colliders.castClosure(i2));
  }
  castRayAndGetNormal(A2, I2, g2, C2, B2, Q2, E2, i2) {
    return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, A2, I2, g2, C2, B2, Q2 ? Q2.handle : null, E2 ? E2.handle : null, this.colliders.castClosure(i2));
  }
  intersectionsWithRay(A2, I2, g2, C2, B2, Q2, E2, i2, o2) {
    this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, A2, I2, g2, C2, B2, Q2, E2 ? E2.handle : null, i2 ? i2.handle : null, this.colliders.castClosure(o2));
  }
  intersectionWithShape(A2, I2, g2, C2, B2, Q2, E2, i2) {
    let o2 = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, A2, I2, g2, C2, B2, Q2 ? Q2.handle : null, E2 ? E2.handle : null, this.colliders.castClosure(i2));
    return o2 != null ? this.colliders.get(o2) : null;
  }
  projectPoint(A2, I2, g2, C2, B2, Q2, E2) {
    return this.queryPipeline.projectPoint(this.bodies, this.colliders, A2, I2, g2, C2, B2 ? B2.handle : null, Q2 ? Q2.handle : null, this.colliders.castClosure(E2));
  }
  projectPointAndGetFeature(A2, I2, g2, C2, B2, Q2) {
    return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, A2, I2, g2, C2 ? C2.handle : null, B2 ? B2.handle : null, this.colliders.castClosure(Q2));
  }
  intersectionsWithPoint(A2, I2, g2, C2, B2, Q2, E2) {
    this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, A2, this.colliders.castClosure(I2), g2, C2, B2 ? B2.handle : null, Q2 ? Q2.handle : null, this.colliders.castClosure(E2));
  }
  castShape(A2, I2, g2, C2, B2, Q2, E2, i2, o2, D2, G2) {
    return this.queryPipeline.castShape(this.bodies, this.colliders, A2, I2, g2, C2, B2, Q2, E2, i2, o2 ? o2.handle : null, D2 ? D2.handle : null, this.colliders.castClosure(G2));
  }
  intersectionsWithShape(A2, I2, g2, C2, B2, Q2, E2, i2, o2) {
    this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, A2, I2, g2, this.colliders.castClosure(C2), B2, Q2, E2 ? E2.handle : null, i2 ? i2.handle : null, this.colliders.castClosure(o2));
  }
  collidersWithAabbIntersectingAabb(A2, I2, g2) {
    this.queryPipeline.collidersWithAabbIntersectingAabb(A2, I2, this.colliders.castClosure(g2));
  }
  contactsWith(A2, I2) {
    this.narrowPhase.contactsWith(A2.handle, this.colliders.castClosure(I2));
  }
  intersectionsWith(A2, I2) {
    this.narrowPhase.intersectionsWith(A2.handle, this.colliders.castClosure(I2));
  }
  contactPair(A2, I2, g2) {
    this.narrowPhase.contactPair(A2.handle, I2.handle, g2);
  }
  intersectionPair(A2, I2) {
    return this.narrowPhase.intersectionPair(A2.handle, I2.handle);
  }
}
(function(A2) {
  A2[A2.COLLISION_EVENTS = 1] = "COLLISION_EVENTS", A2[A2.CONTACT_FORCE_EVENTS = 2] = "CONTACT_FORCE_EVENTS";
})(FA || (FA = {}));

class UI {
  free() {
    this.raw && this.raw.free(), this.raw = undefined;
  }
  collider1() {
    return this.raw.collider1();
  }
  collider2() {
    return this.raw.collider2();
  }
  totalForce() {
    return iA.fromRaw(this.raw.total_force());
  }
  totalForceMagnitude() {
    return this.raw.total_force_magnitude();
  }
  maxForceDirection() {
    return iA.fromRaw(this.raw.max_force_direction());
  }
  maxForceMagnitude() {
    return this.raw.max_force_magnitude();
  }
}

class qI {
  constructor(A2, I2) {
    this.raw = I2 || new d(A2);
  }
  free() {
    this.raw && this.raw.free(), this.raw = undefined;
  }
  drainCollisionEvents(A2) {
    this.raw.drainCollisionEvents(A2);
  }
  drainContactForceEvents(A2) {
    let I2 = new UI;
    this.raw.drainContactForceEvents((g2) => {
      I2.raw = g2, A2(I2), I2.free();
    });
  }
  clear() {
    this.raw.clear();
  }
}
(function(A2) {
  A2[A2.FILTER_CONTACT_PAIRS = 1] = "FILTER_CONTACT_PAIRS", A2[A2.FILTER_INTERSECTION_PAIRS = 2] = "FILTER_INTERSECTION_PAIRS";
})(yA || (yA = {})), function(A2) {
  A2[A2.EMPTY = 0] = "EMPTY", A2[A2.COMPUTE_IMPULSE = 1] = "COMPUTE_IMPULSE";
}(RA || (RA = {}));
for (YI = { byteLength: function(A2) {
  var I2 = eI(A2), g2 = I2[0], C2 = I2[1];
  return 3 * (g2 + C2) / 4 - C2;
}, toByteArray: function(A2) {
  var I2, g2, C2 = eI(A2), B2 = C2[0], Q2 = C2[1], E2 = new HI(function(A3, I3, g3) {
    return 3 * (I3 + g3) / 4 - g3;
  }(0, B2, Q2)), i2 = 0, o2 = Q2 > 0 ? B2 - 4 : B2;
  for (g2 = 0;g2 < o2; g2 += 4)
    I2 = tI[A2.charCodeAt(g2)] << 18 | tI[A2.charCodeAt(g2 + 1)] << 12 | tI[A2.charCodeAt(g2 + 2)] << 6 | tI[A2.charCodeAt(g2 + 3)], E2[i2++] = I2 >> 16 & 255, E2[i2++] = I2 >> 8 & 255, E2[i2++] = 255 & I2;
  Q2 === 2 && (I2 = tI[A2.charCodeAt(g2)] << 2 | tI[A2.charCodeAt(g2 + 1)] >> 4, E2[i2++] = 255 & I2);
  Q2 === 1 && (I2 = tI[A2.charCodeAt(g2)] << 10 | tI[A2.charCodeAt(g2 + 1)] << 4 | tI[A2.charCodeAt(g2 + 2)] >> 2, E2[i2++] = I2 >> 8 & 255, E2[i2++] = 255 & I2);
  return E2;
}, fromByteArray: function(A2) {
  for (var I2, g2 = A2.length, C2 = g2 % 3, B2 = [], Q2 = 16383, E2 = 0, i2 = g2 - C2;E2 < i2; E2 += Q2)
    B2.push(nI(A2, E2, E2 + Q2 > i2 ? i2 : E2 + Q2));
  C2 === 1 ? (I2 = A2[g2 - 1], B2.push(LI[I2 >> 2] + LI[I2 << 4 & 63] + "==")) : C2 === 2 && (I2 = (A2[g2 - 2] << 8) + A2[g2 - 1], B2.push(LI[I2 >> 10] + LI[I2 >> 4 & 63] + LI[I2 << 2 & 63] + "="));
  return B2.join("");
} }, LI = [], tI = [], HI = typeof Uint8Array != "undefined" ? Uint8Array : Array, rI = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lI = 0, pI = rI.length;lI < pI; ++lI)
  LI[lI] = rI[lI], tI[rI.charCodeAt(lI)] = lI;
var YI;
var LI;
var tI;
var HI;
var rI;
var lI;
var pI;
tI["-".charCodeAt(0)] = 62, tI["_".charCodeAt(0)] = 63;
var xI = Object.freeze({ __proto__: null, version: TI, Vector2: EA, VectorOps: iA, RotationOps: oA, get RigidBodyType() {
  return DA;
}, RigidBody: JA, RigidBodyDesc: MA, RigidBodySet: UA, IntegrationParameters: qA, get JointType() {
  return GA;
}, get MotorModel() {
  return wA;
}, ImpulseJoint: cA, UnitImpulseJoint: YA, FixedImpulseJoint: LA, PrismaticImpulseJoint: tA, RevoluteImpulseJoint: HA, JointData: rA, ImpulseJointSet: lA, MultibodyJoint: pA, UnitMultibodyJoint: eA, FixedMultibodyJoint: nA, PrismaticMultibodyJoint: dA, RevoluteMultibodyJoint: TA, MultibodyJointSet: xA, get CoefficientCombineRule() {
  return aA;
}, CCDSolver: ZA, IslandManager: bA, BroadPhase: WA, NarrowPhase: jA, TempContactManifold: OA, Shape: $A, get ShapeType() {
  return kA;
}, Ball: AI, HalfSpace: II, Cuboid: gI, RoundCuboid: CI, Capsule: BI, Segment: QI, Triangle: EI, RoundTriangle: iI, Polyline: oI, TriMesh: DI, ConvexPolygon: GI, RoundConvexPolygon: wI, Heightfield: aI, get ActiveCollisionTypes() {
  return KA;
}, Collider: hI, get MassPropsMode() {
  return SA;
}, ColliderDesc: kI, ColliderSet: KI, get FeatureType() {
  return hA;
}, Ray: mA, RayIntersection: vA, RayColliderIntersection: PA, RayColliderToi: uA, PointProjection: XA, PointColliderProjection: VA, ShapeTOI: zA, ShapeColliderTOI: _A, ShapeContact: fA, World: sI, PhysicsPipeline: SI, SerializationPipeline: FI, get ActiveEvents() {
  return FA;
}, TempContactForceEvent: UI, EventQueue: qI, get ActiveHooks() {
  return yA;
}, get SolverFlags() {
  return RA;
}, DebugRenderBuffers: yI, DebugRenderPipeline: RI, get QueryFilterFlags() {
  return NA;
}, QueryPipeline: NI, init: dI, CharacterCollision: JI, KinematicCharacterController: MI });

// node_modules/colord/plugins/names.mjsiste
var clone = function(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  switch (geojson.type) {
    case "Feature":
      return cloneFeature(geojson);
    case "FeatureCollection":
      return cloneFeatureCollection(geojson);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cloneGeometry(geojson);
    default:
      throw new Error("unknown GeoJSON type");
  }
};
var cloneFeature = function(geojson) {
  var cloned = { type: "Feature" };
  Object.keys(geojson).forEach(function(key) {
    switch (key) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.properties = cloneProperties(geojson.properties);
  cloned.geometry = cloneGeometry(geojson.geometry);
  return cloned;
};
var cloneProperties = function(properties) {
  var cloned = {};
  if (!properties) {
    return cloned;
  }
  Object.keys(properties).forEach(function(key) {
    var value = properties[key];
    if (typeof value === "object") {
      if (value === null) {
        cloned[key] = null;
      } else if (Array.isArray(value)) {
        cloned[key] = value.map(function(item) {
          return item;
        });
      } else {
        cloned[key] = cloneProperties(value);
      }
    } else {
      cloned[key] = value;
    }
  });
  return cloned;
};
var cloneFeatureCollection = function(geojson) {
  var cloned = { type: "FeatureCollection" };
  Object.keys(geojson).forEach(function(key) {
    switch (key) {
      case "type":
      case "features":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.features = geojson.features.map(function(feature) {
    return cloneFeature(feature);
  });
  return cloned;
};
var cloneGeometry = function(geometry) {
  var geom = { type: geometry.type };
  if (geometry.bbox) {
    geom.bbox = geometry.bbox;
  }
  if (geometry.type === "GeometryCollection") {
    geom.geometries = geometry.geometries.map(function(g2) {
      return cloneGeometry(g2);
    });
    return geom;
  }
  geom.coordinates = deepSlice(geometry.coordinates);
  return geom;
};
var deepSlice = function(coords) {
  var cloned = coords;
  if (typeof cloned[0] !== "object") {
    return cloned.slice();
  }
  return cloned.map(function(coord) {
    return deepSlice(coord);
  });
};
var es_default = clone;

// node_modules/colord/plugins/names.mjsistene
function featureCollection(features, options) {
  if (options === undefined) {
    options = {};
  }
  var fc = { type: "FeatureCollection" };
  if (options.id) {
    fc.id = options.id;
  }
  if (options.bbox) {
    fc.bbox = options.bbox;
  }
  fc.features = features;
  return fc;
}
function isObject(input) {
  return !!input && input.constructor === Object;
}
var earthRadius = 6371008.8;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: earthRadius / 111325,
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1000,
  kilometres: earthRadius / 1000,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1000,
  millimetres: earthRadius * 1000,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
var unitsFactors = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.37,
  kilometers: 1 / 1000,
  kilometres: 1 / 1000,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1000,
  millimetres: 1000,
  nauticalmiles: 1 / 1852,
  radians: 1 / earthRadius,
  yards: 1.0936133
};

// node_modules/colord/plugins/names.mjsistener.
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.m
function booleanClockwise(line) {
  var ring = getCoords(line);
  var sum = 0;
  var i2 = 1;
  var prev;
  var cur;
  while (i2 < ring.length) {
    prev = cur || ring[0];
    cur = ring[i2];
    sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
    i2++;
  }
  return sum > 0;
}

// node_modules/colord/plugins/names.mjsist
var featureEach = function(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i2 = 0;i2 < geojson.features.length; i2++) {
      if (callback(geojson.features[i2], i2) === false)
        break;
    }
  }
};
var geomEach = function(geojson, callback) {
  var i2, j2, g2, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (i2 = 0;i2 < stop; i2++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i2].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i2].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i2].bbox : isFeature ? geojson.bbox : undefined;
    featureId = isFeatureCollection ? geojson.features[i2].id : isFeature ? geojson.id : undefined;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (g2 = 0;g2 < stopG; g2++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g2] : geometryMaybeCollection;
      if (geometry === null) {
        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false)
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j2 = 0;j2 < geometry.geometries.length; j2++) {
            if (callback(geometry.geometries[j2], featureIndex, featureProperties, featureBBox, featureId) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
};

// node_modules/colord/plugins/names.mjsisten
var rewind = function(geojson, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var reverse = options.reverse || false;
  var mutate = options.mutate || false;
  if (!geojson)
    throw new Error("<geojson> is required");
  if (typeof reverse !== "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof mutate !== "boolean")
    throw new Error("<mutate> must be a boolean");
  if (mutate === false)
    geojson = es_default(geojson);
  var results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry) {
        rewindFeature(geometry, reverse);
      });
      return geojson;
    case "FeatureCollection":
      featureEach(geojson, function(feature) {
        featureEach(rewindFeature(feature, reverse), function(result) {
          results.push(result);
        });
      });
      return featureCollection(results);
  }
  return rewindFeature(geojson, reverse);
};
var rewindFeature = function(geojson, reverse) {
  var type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
  switch (type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry) {
        rewindFeature(geometry, reverse);
      });
      return geojson;
    case "LineString":
      rewindLineString(getCoords(geojson), reverse);
      return geojson;
    case "Polygon":
      rewindPolygon(getCoords(geojson), reverse);
      return geojson;
    case "MultiLineString":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindLineString(lineCoords, reverse);
      });
      return geojson;
    case "MultiPolygon":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindPolygon(lineCoords, reverse);
      });
      return geojson;
    case "Point":
    case "MultiPoint":
      return geojson;
  }
};
var rewindLineString = function(coords, reverse) {
  if (booleanClockwise(coords) === reverse)
    coords.reverse();
};
var rewindPolygon = function(coords, reverse) {
  if (booleanClockwise(coords[0]) !== reverse) {
    coords[0].reverse();
  }
  for (var i2 = 1;i2 < coords.length; i2++) {
    if (booleanClockwise(coords[i2]) === reverse) {
      coords[i2].reverse();
    }
  }
};
var es_default2 = rewind;

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
var pointInPolygon = function(p2, polygon) {
  var i2 = 0;
  var ii = 0;
  var k2 = 0;
  var f2 = 0;
  var u1 = 0;
  var v1 = 0;
  var u2 = 0;
  var v2 = 0;
  var currentP = null;
  var nextP = null;
  var x2 = p2[0];
  var y2 = p2[1];
  var numContours = polygon.length;
  for (i2;i2 < numContours; i2++) {
    ii = 0;
    var contourLen = polygon[i2].length - 1;
    var contour = polygon[i2];
    currentP = contour[0];
    if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {
      throw new Error("First and last coordinates in a ring must be the same");
    }
    u1 = currentP[0] - x2;
    v1 = currentP[1] - y2;
    for (ii;ii < contourLen; ii++) {
      nextP = contour[ii + 1];
      v2 = nextP[1] - y2;
      if (v1 < 0 && v2 < 0 || v1 > 0 && v2 > 0) {
        currentP = nextP;
        v1 = v2;
        u1 = currentP[0] - x2;
        continue;
      }
      u2 = nextP[0] - p2[0];
      if (v2 > 0 && v1 <= 0) {
        f2 = u1 * v2 - u2 * v1;
        if (f2 > 0) {
          k2 = k2 + 1;
        } else if (f2 === 0) {
          return 0;
        }
      } else if (v1 > 0 && v2 <= 0) {
        f2 = u1 * v2 - u2 * v1;
        if (f2 < 0) {
          k2 = k2 + 1;
        } else if (f2 === 0) {
          return 0;
        }
      } else if (v2 === 0 && v1 < 0) {
        f2 = u1 * v2 - u2 * v1;
        if (f2 === 0) {
          return 0;
        }
      } else if (v1 === 0 && v2 < 0) {
        f2 = u1 * v2 - u2 * v1;
        if (f2 === 0) {
          return 0;
        }
      } else if (v1 === 0 && v2 === 0) {
        if (u2 <= 0 && u1 >= 0) {
          return 0;
        } else if (u1 <= 0 && u2 >= 0) {
          return 0;
        }
      }
      currentP = nextP;
      v1 = v2;
      u1 = u2;
    }
  }
  if (k2 % 2 === 0) {
    return false;
  }
  return true;
};
var pointInPolygon_default = pointInPolygon;

// node_modules/colord/plugins/names.mjsisten
function sum(elen, e2, flen, f2, h2) {
  let Q2, Qnew, hh, bvirt;
  let enow = e2[0];
  let fnow = f2[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q2 = enow;
    enow = e2[++eindex];
  } else {
    Q2 = fnow;
    fnow = f2[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q2;
      hh = Q2 - (Qnew - enow);
      enow = e2[++eindex];
    } else {
      Qnew = fnow + Q2;
      hh = Q2 - (Qnew - fnow);
      fnow = f2[++findex];
    }
    Q2 = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q2 + enow;
        bvirt = Qnew - Q2;
        hh = Q2 - (Qnew - bvirt) + (enow - bvirt);
        enow = e2[++eindex];
      } else {
        Qnew = Q2 + fnow;
        bvirt = Qnew - Q2;
        hh = Q2 - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f2[++findex];
      }
      Q2 = Qnew;
      if (hh !== 0) {
        h2[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q2 + enow;
    bvirt = Qnew - Q2;
    hh = Q2 - (Qnew - bvirt) + (enow - bvirt);
    enow = e2[++eindex];
    Q2 = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q2 + fnow;
    bvirt = Qnew - Q2;
    hh = Q2 - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f2[++findex];
    Q2 = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
  }
  if (Q2 !== 0 || hindex === 0) {
    h2[hindex++] = Q2;
  }
  return hindex;
}
function estimate(elen, e2) {
  let Q2 = e2[0];
  for (let i2 = 1;i2 < elen; i2++)
    Q2 += e2[i2];
  return Q2;
}
function vec(n2) {
  return new Float64Array(n2);
}
var epsilon = 0.00000000000000011102230246251566;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon) * epsilon;

// node_modules/colord/plugins/names.mjsistener.m
var orient2dadapt = function(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c2, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c2 = splitter * acx;
  ahi = c2 - (c2 - acx);
  alo = acx - ahi;
  c2 = splitter * bcy;
  bhi = c2 - (c2 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcx;
  c2 = splitter * acy;
  ahi = c2 - (c2 - acy);
  alo = acy - ahi;
  c2 = splitter * bcx;
  bhi = c2 - (c2 - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  B2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  B2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  B2[2] = _j - (u3 - bvirt) + (_i - bvirt);
  B2[3] = u3;
  let det = estimate(4, B2);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound)
    return det;
  s1 = acxtail * bcy;
  c2 = splitter * acxtail;
  ahi = c2 - (c2 - acxtail);
  alo = acxtail - ahi;
  c2 = splitter * bcy;
  bhi = c2 - (c2 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcx;
  c2 = splitter * acytail;
  ahi = c2 - (c2 - acytail);
  alo = acytail - ahi;
  c2 = splitter * bcx;
  bhi = c2 - (c2 - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u2[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u2[3] = u3;
  const C1len = sum(4, B2, 4, u2, C1);
  s1 = acx * bcytail;
  c2 = splitter * acx;
  ahi = c2 - (c2 - acx);
  alo = acx - ahi;
  c2 = splitter * bcytail;
  bhi = c2 - (c2 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcxtail;
  c2 = splitter * acy;
  ahi = c2 - (c2 - acy);
  alo = acy - ahi;
  c2 = splitter * bcxtail;
  bhi = c2 - (c2 - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u2[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u2[3] = u3;
  const C2len = sum(C1len, C1, 4, u2, C2);
  s1 = acxtail * bcytail;
  c2 = splitter * acxtail;
  ahi = c2 - (c2 - acxtail);
  alo = acxtail - ahi;
  c2 = splitter * bcytail;
  bhi = c2 - (c2 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcxtail;
  c2 = splitter * acytail;
  ahi = c2 - (c2 - acytail);
  alo = acytail - ahi;
  c2 = splitter * bcxtail;
  bhi = c2 - (c2 - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u2[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u2[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u2[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u2[3] = u3;
  const Dlen = sum(C2len, C2, 4, u2, D2);
  return D2[Dlen - 1];
};
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0)
    return det;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum)
    return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}
var ccwerrboundA = (3 + 16 * epsilon) * epsilon;
var ccwerrboundB = (2 + 12 * epsilon) * epsilon;
var ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
var B2 = vec(4);
var C1 = vec(8);
var C2 = vec(12);
var D2 = vec(16);
var u2 = vec(4);
// node_modules/colord/plugins/names.mjsistener.m
var o3derrboundA = (7 + 56 * epsilon) * epsilon;
var o3derrboundB = (3 + 28 * epsilon) * epsilon;
var o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u3 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);
// node_modules/colord/plugins/names.mjsistener.m
var iccerrboundA = (10 + 96 * epsilon) * epsilon;
var iccerrboundB = (4 + 48 * epsilon) * epsilon;
var iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u4 = vec(4);
var v2 = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);
// node_modules/colord/plugins/names.mjsistener.m
var isperrboundA = (16 + 224 * epsilon) * epsilon;
var isperrboundB = (5 + 72 * epsilon) * epsilon;
var isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin5 = vec(1152);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mj
var fillQueue = function(polygon, line, polyEdges, lineEdges, polylineBbox) {
  var numberOfRingsInPolygon = 0;
  var contours = [];
  var linegeom = line.type === "Feature" ? line.geometry : line;
  var linecoords = linegeom.type === "LineString" ? [linegeom.coordinates] : linegeom.coordinates;
  var edgeCount = 0;
  for (var i2 = 0;i2 < linecoords.length; i2++) {
    var lineLength = linecoords[i2].length - 1;
    var p1 = new Point(linecoords[i2][0]);
    var p2 = null;
    var prevEdge = { nextEdge: null };
    for (var ii = 0;ii < lineLength; ii++) {
      p2 = new Point(linecoords[i2][ii + 1]);
      p1.nextPoint = p2;
      p2.prevPoint = p1;
      var e2 = new Edge(p1, p2, "polyline", edgeCount, null);
      lineEdges.push(e2);
      prevEdge.nextEdge = e2;
      e2.prevEdge = prevEdge;
      polylineBbox[0] = Math.min(polylineBbox[0], p1.p[0]);
      polylineBbox[1] = Math.min(polylineBbox[1], p1.p[1]);
      polylineBbox[2] = Math.max(polylineBbox[2], p1.p[0]);
      polylineBbox[3] = Math.max(polylineBbox[3], p1.p[1]);
      p1 = p2;
      edgeCount = edgeCount + 1;
      prevEdge = e2;
    }
    polylineBbox[0] = Math.min(polylineBbox[0], linecoords[i2][lineLength][0]);
    polylineBbox[1] = Math.min(polylineBbox[1], linecoords[i2][lineLength][1]);
    polylineBbox[2] = Math.max(polylineBbox[2], linecoords[i2][lineLength][0]);
    polylineBbox[3] = Math.max(polylineBbox[3], linecoords[i2][lineLength][1]);
  }
  var polygeom = polygon.type === "Feature" ? polygon.geometry : polygon;
  var polycoords = polygeom.type === "Polygon" ? [polygeom.coordinates] : polygeom.coordinates;
  var polyLength = polycoords.length;
  for (var i$1 = 0;i$1 < polyLength; i$1++) {
    var polyLenth2 = polycoords[i$1].length;
    for (var ii$1 = 0;ii$1 < polyLenth2; ii$1++) {
      numberOfRingsInPolygon = numberOfRingsInPolygon + 1;
      var polygonSet = polycoords[i$1][ii$1];
      var polyLenth3 = polygonSet.length;
      contours.push(new Contour(numberOfRingsInPolygon, polygonSet));
      var firstPoint = new Point(polygonSet[0]);
      var p1$1 = firstPoint;
      var p2$1 = undefined, e$1 = null;
      var prevEdge$1 = { nextEdge: null, prevEdge: null };
      var firstEdge = null;
      for (var iii = 1;iii < polyLenth3; iii++) {
        p2$1 = new Point(polygonSet[iii]);
        p1$1.nextPoint = p2$1;
        p2$1.prevPoint = p1$1;
        e$1 = new Edge(p1$1, p2$1, "polygon", edgeCount, numberOfRingsInPolygon);
        prevEdge$1.nextEdge = e$1;
        e$1.prevEdge = prevEdge$1;
        if (iii === 1) {
          firstEdge = e$1;
        }
        if (ii$1 > 0) {
          e$1.interiorRing = true;
        }
        e$1.intersectPolylineBbox = edgeIntersectsBbox(e$1, polylineBbox);
        polyEdges.push(e$1);
        p1$1 = p2$1;
        edgeCount = edgeCount + 1;
        prevEdge$1 = e$1;
      }
      e$1.nextEdge = firstEdge;
      firstEdge.prevEdge = e$1;
      p2$1.nextPoint = firstPoint.nextPoint;
      firstPoint.prevPoint = p2$1.prevPoint;
    }
  }
  return contours;
};
var edgeIntersectsBbox = function(edge, bbox) {
  if (edge.maxX < bbox[0]) {
    return false;
  }
  if (edge.minX > bbox[2]) {
    return false;
  }
  if (edge.maxY < bbox[1]) {
    return false;
  }
  if (edge.minY > bbox[3]) {
    return false;
  }
  return true;
};
var distance = function(p1, p2) {
  var xs = p2[0] - p1[0];
  var ys = p2[1] - p1[1];
  xs *= xs;
  ys *= ys;
  return Math.sqrt(xs + ys);
};
var findIntersectionPoints = function(polygonEdges, lineEdges, intersectingPoints) {
  var i2, ii, iii;
  var count = lineEdges.length;
  var polyCount = polygonEdges.length;
  for (i2 = 0;i2 < count; i2++) {
    var lineEdge = lineEdges[i2];
    for (ii = 0;ii < polyCount; ii++) {
      var polygonEdge = polygonEdges[ii];
      if (!polygonEdge.intersectPolylineBbox) {
        continue;
      }
      if (polygonEdge.maxX < lineEdge.minX || polygonEdge.minX > lineEdge.maxX) {
        continue;
      }
      if (polygonEdge.maxY < lineEdge.minY || polygonEdge.minY > lineEdge.maxY) {
        continue;
      }
      var intersection = getEdgeIntersection(lineEdge, polygonEdge);
      if (intersection !== null) {
        for (iii = 0;iii < intersection.length; iii++) {
          var isHeadingIn = orient2d(polygonEdge.p1.p[0], polygonEdge.p1.p[1], polygonEdge.p2.p[0], polygonEdge.p2.p[1], lineEdge.p1.p[0], lineEdge.p1.p[1]);
          var ip = new IntersectionPoint(intersection[iii], lineEdge, polygonEdge, isHeadingIn > 0);
          intersectingPoints.push(ip);
        }
      }
    }
  }
  lineEdges.forEach(function(edge) {
    edge.intersectionPoints.sort(function(a2, b2) {
      return a2.distanceFromPolylineEdgeStart - b2.distanceFromPolylineEdgeStart;
    });
  });
  polygonEdges.forEach(function(edge) {
    edge.intersectionPoints.sort(function(a2, b2) {
      return a2.distanceFromPolygonEdgeStart - b2.distanceFromPolygonEdgeStart;
    });
  });
};
var crossProduct = function(a2, b2) {
  return a2[0] * b2[1] - a2[1] * b2[0];
};
var dotProduct = function(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1];
};
var toPoint = function(p2, s2, d2) {
  return [
    p2[0] + s2 * d2[0],
    p2[1] + s2 * d2[1]
  ];
};
var getEdgeIntersection = function(lineEdge, potentialEdge, noEndpointTouch) {
  var va = [lineEdge.p2.p[0] - lineEdge.p1.p[0], lineEdge.p2.p[1] - lineEdge.p1.p[1]];
  var vb = [potentialEdge.p2.p[0] - potentialEdge.p1.p[0], potentialEdge.p2.p[1] - potentialEdge.p1.p[1]];
  var e2 = [potentialEdge.p1.p[0] - lineEdge.p1.p[0], potentialEdge.p1.p[1] - lineEdge.p1.p[1]];
  var kross = crossProduct(va, vb);
  var sqrKross = kross * kross;
  var sqrLenA = dotProduct(va, va);
  if (sqrKross > 0) {
    var s2 = crossProduct(e2, vb) / kross;
    if (s2 < 0 || s2 > 1) {
      return null;
    }
    var t2 = crossProduct(e2, va) / kross;
    if (t2 < 0 || t2 > 1) {
      return null;
    }
    if (s2 === 0 || s2 === 1) {
      return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, s2, va)];
    }
    if (t2 === 0 || t2 === 1) {
      return noEndpointTouch ? null : [toPoint(potentialEdge.p1.p, t2, vb)];
    }
    return [toPoint(lineEdge.p1.p, s2, va)];
  }
  var sqrLenE = dotProduct(e2, e2);
  kross = crossProduct(e2, va);
  sqrKross = kross * kross;
  if (sqrKross > EPSILON * sqrLenA * sqrLenE) {
    return null;
  }
  var sa = dotProduct(va, e2) / sqrLenA;
  var sb = sa + dotProduct(va, vb) / sqrLenA;
  var smin = Math.min(sa, sb);
  var smax = Math.max(sa, sb);
  if (smin <= 1 && smax >= 0) {
    if (smin === 1) {
      return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, smin > 0 ? smin : 0, va)];
    }
    if (smax === 0) {
      return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, smax < 1 ? smax : 1, va)];
    }
    if (noEndpointTouch && smin === 0 && smax === 1) {
      return null;
    }
    return [
      toPoint(lineEdge.p1.p, smin > 0 ? smin : 0, va),
      toPoint(lineEdge.p1.p, smax < 1 ? smax : 1, va)
    ];
  }
  return null;
};
var index = function(polygon, line) {
  var poly = es_default2(polygon);
  var intersections = [];
  var polygonEdges = [];
  var polylineEdges = [];
  var polylineBbox = [Infinity, Infinity, Infinity, Infinity];
  var contours = fillQueue(poly, line, polygonEdges, polylineEdges, polylineBbox);
  findIntersectionPoints(polygonEdges, polylineEdges, intersections);
  if (intersections.length === 0) {
    return polygon;
  }
  var numberIntersectionsByRing = {};
  contours.forEach(function(c2) {
    return numberIntersectionsByRing[c2.id] = 0;
  });
  intersections.forEach(function(i2) {
    var id = i2.polygonEdge.polygonContourId;
    numberIntersectionsByRing[id] = numberIntersectionsByRing[id] + 1;
  });
  var infiniteLoopGuard = 0;
  var outPolys = [];
  var firstPolyStart = null;
  for (var index2 = 0;index2 < polylineEdges.length; index2++) {
    var pe = polylineEdges[index2];
    if (pe.intersectionPoints.length > 0) {
      firstPolyStart = pe.intersectionPoints[0];
      break;
    }
  }
  var polyStart = firstPolyStart;
  var nextPolyStart = { visitCount: 1 };
  while (firstPolyStart !== nextPolyStart) {
    if (infiniteLoopGuard > intersections.length * 2) {
      break;
    }
    infiniteLoopGuard = infiniteLoopGuard++;
    if (nextPolyStart.visitCount >= 2) {
      var unvisitedPolyFound = false;
      for (var index$1 = 0;index$1 < intersections.length; index$1++) {
        var intersection = intersections[index$1];
        if (intersection.visitCount < 2) {
          polyStart = intersection;
          unvisitedPolyFound = true;
          break;
        }
      }
      if (!unvisitedPolyFound) {
        break;
      }
    }
    polyStart.visitCount = polyStart.visitCount + 1;
    var outPoly = [];
    outPolys.push(outPoly);
    outPoly.push(polyStart.p);
    polyStart.visitCount = polyStart.visitCount + 1;
    var nextIntersection = walkPolygonForwards(polyStart, outPoly);
    nextPolyStart = nextIntersection;
    var override = false;
    if (nextIntersection === nextPolyStart && intersections.length === 2) {
      for (var index$2 = 0;index$2 < intersections.length; index$2++) {
        var intersection$1 = intersections[index$2];
        if (intersection$1.visitCount < 2) {
          override = true;
        }
      }
    }
    while (nextIntersection !== polyStart || override) {
      var methodForPolyline = nextIntersection.isHeadingIn ? walkPolylineForwards : walkPolylineBackwards;
      nextIntersection = methodForPolyline(nextIntersection, outPoly);
      if (nextIntersection !== polyStart) {
        nextIntersection = walkPolygonForwards(nextIntersection, outPoly);
      }
      override = false;
    }
    if (nextPolyStart.visitCount >= 2) {
      var unvisitedPolyFound$1 = false;
      for (var index$3 = 0;index$3 < intersections.length; index$3++) {
        var intersection$2 = intersections[index$3];
        if (intersection$2.visitCount < 2) {
          polyStart = intersection$2;
          unvisitedPolyFound$1 = true;
          break;
        }
      }
      if (unvisitedPolyFound$1) {
        nextPolyStart = polyStart;
      }
    }
    polyStart = nextPolyStart;
  }
  var outCoordinates = outPolys.map(function(poly2) {
    return [poly2];
  });
  var keys = Object.keys(numberIntersectionsByRing);
  for (var index$4 = 0;index$4 < keys.length; index$4++) {
    var key = keys[index$4];
    var value = numberIntersectionsByRing[key];
    if (value === 0) {
      var edge = findFirstPolygonEdge(polygonEdges, parseInt(key));
      var ring = findRingFromEdge(edge, contours);
      createAsHoleOrAddAsNewOuterRing(ring, outCoordinates);
    }
  }
  return {
    type: "Feature",
    properties: {},
    geometry: {
      type: "MultiPolygon",
      coordinates: outCoordinates
    }
  };
};
var findFirstPolygonEdge = function(polygonEdges, contourId) {
  for (var index2 = 0;index2 < polygonEdges.length; index2++) {
    var edge = polygonEdges[index2];
    if (edge.polygonContourId === contourId) {
      return edge;
    }
  }
};
var findRingFromEdge = function(edge, contours) {
  var contour = contours.find(function(c2) {
    return c2.id === edge.polygonContourId;
  });
  return contour.rawCoords;
};
var createAsHoleOrAddAsNewOuterRing = function(unusedRing, outCoordinates) {
  for (var index2 = 0;index2 < outCoordinates.length; index2++) {
    var existingRing = outCoordinates[index2];
    if (pointInPolygon_default(unusedRing[0], [existingRing[0]])) {
      existingRing.push(unusedRing);
      return;
    }
  }
  outCoordinates.push([unusedRing]);
};
var walkPolygonForwards = function(intersectionPoint, outPoly) {
  var nextEdge = intersectionPoint.polygonEdge;
  if (nextEdge.intersectionPoints.length > 1) {
    var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];
    if (lastPointOnEdge !== intersectionPoint) {
      var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);
      var nextIp = nextEdge.intersectionPoints[currentIndex + 1];
      outPoly.push(nextIp.p);
      nextIp.incrementVisitCount();
      return nextIp;
    }
  }
  var condition = true;
  while (condition) {
    outPoly.push(nextEdge.p2.p);
    nextEdge = nextEdge.nextEdge;
    if (nextEdge === null) {
      return intersectionPoint;
    } else if (nextEdge.intersectionPoints.length > 0) {
      condition = false;
    }
  }
  nextEdge.intersectionPoints[0].incrementVisitCount();
  outPoly.push(nextEdge.intersectionPoints[0].p);
  return nextEdge.intersectionPoints[0];
};
var findIndexOfIntersectionPoint = function(intersection, intersections) {
  for (var index2 = 0;index2 < intersections.length; index2++) {
    var int = intersections[index2];
    if (int === intersection) {
      return index2;
    }
  }
  return null;
};
var walkPolylineBackwards = function(intersectionPoint, outPoly) {
  var nextEdge = intersectionPoint.polylineEdge;
  if (nextEdge.intersectionPoints.length === 2) {
    var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];
    if (lastPointOnEdge === intersectionPoint) {
      var nextIntersection = nextEdge.intersectionPoints[0];
      outPoly.push(nextIntersection.p);
      nextIntersection.incrementVisitCount();
      return nextIntersection;
    } else {
      outPoly.push(lastPointOnEdge.p);
      lastPointOnEdge.incrementVisitCount();
      return lastPointOnEdge;
    }
  } else if (nextEdge.intersectionPoints.length > 2) {
    var lastPointOnEdge$1 = nextEdge.intersectionPoints[0];
    if (lastPointOnEdge$1 !== intersectionPoint) {
      var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);
      var nextIntersection$1 = nextEdge.intersectionPoints[currentIndex - 1];
      outPoly.push(nextIntersection$1.p);
      nextIntersection$1.incrementVisitCount();
      return nextIntersection$1;
    }
  }
  var condition = true;
  while (condition) {
    outPoly.push(nextEdge.p1.p);
    nextEdge = nextEdge.prevEdge;
    if (nextEdge.originalIndex === undefined) {
      return intersectionPoint;
    } else if (nextEdge.intersectionPoints.length > 0) {
      condition = false;
    }
  }
  if (nextEdge.originalIndex === undefined) {
    return intersectionPoint;
  }
  var lastIntersection = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];
  lastIntersection.incrementVisitCount();
  outPoly.push(lastIntersection.p);
  return lastIntersection;
};
var walkPolylineForwards = function(intersectionPoint, outPoly) {
  var nextEdge = intersectionPoint.polylineEdge;
  if (nextEdge.intersectionPoints.length > 1) {
    var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];
    if (lastPointOnEdge !== intersectionPoint) {
      var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);
      var nextIp = nextEdge.intersectionPoints[currentIndex + 1];
      outPoly.push(nextIp.p);
      nextIp.incrementVisitCount();
      return nextIp;
    }
  }
  var condition = true;
  while (condition) {
    outPoly.push(nextEdge.p2.p);
    nextEdge = nextEdge.nextEdge;
    if (nextEdge === null) {
      return intersectionPoint;
    } else if (nextEdge.intersectionPoints.length > 0) {
      condition = false;
    }
  }
  if (nextEdge === undefined) {
    return intersectionPoint;
  }
  var lastIntersection = nextEdge.intersectionPoints[0];
  lastIntersection.incrementVisitCount();
  outPoly.push(lastIntersection.p);
  return lastIntersection;
};
var Edge = function Edge2(p1, p2, edgeType, index2, contourId) {
  this.p1 = p1;
  this.p2 = p2;
  this.edgeType = edgeType;
  this.originalIndex = index2;
  this.polygonContourId = contourId;
  this.interiorRing = false;
  this.minX = Math.min(p1.p[0], p2.p[0]);
  this.minY = Math.min(p1.p[1], p2.p[1]);
  this.maxX = Math.max(p1.p[0], p2.p[0]);
  this.maxY = Math.max(p1.p[1], p2.p[1]);
  this.intersectionPoints = [];
  this.nextEdge = null;
};
var Point = function Point2(p2) {
  this.p = p2;
};
var Contour = function Contour2(contourId, coords) {
  this.id = contourId;
  this.rawCoords = coords;
};
var IntersectionPoint = function IntersectionPoint2(p2, edge1, edge2, isHeadingIn) {
  this.p = p2;
  this.polylineEdge = edge1;
  this.polygonEdge = edge2;
  this.isHeadingIn = isHeadingIn;
  this.distanceFromPolylineEdgeStart = distance(this.polylineEdge.p1.p, this.p);
  this.distanceFromPolygonEdgeStart = distance(this.polygonEdge.p1.p, this.p);
  this.polygonEdge.intersectionPoints.push(this);
  this.polylineEdge.intersectionPoints.push(this);
  this.visitCount = 0;
};
IntersectionPoint.prototype.incrementVisitCount = function incrementVisitCount() {
  this.visitCount = this.visitCount + 1;
};
var EPSILON = 0.000000001;

// node_modules/colord/plugins/names.mjsistener.
var import_poly_decomp = __toESM(require_src(), 1);

class SimuloPhysicsServerRapier {
  world = null;
  listeners = {};
  colliders = [];
  changedContents = {};
  removedContents = [];
  emit(event, data) {
    if (this.listeners[event]) {
      this.listeners[event].forEach((listener) => {
        listener(data);
      });
    }
  }
  on(event, listener) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(listener);
  }
  off(event, listener) {
    if (this.listeners[event]) {
      this.listeners[event] = this.listeners[event].filter((l2) => l2 != listener);
    }
  }
  currentIDs = {};
  getID(container, absolute = true) {
    if (!this.currentIDs[container]) {
      this.currentIDs[container] = 0;
    }
    let id = this.currentIDs[container];
    this.currentIDs[container]++;
    if (absolute) {
      return container + id;
    }
    return id.toString();
  }
  springs = {};
  addSpring(spring) {
    let id = this.getID("/");
    let springDesc = {
      applyBodyAImpulse: (impulse, worldPoint) => {
        if (spring.objectA) {
          if (spring.objectA.reference instanceof xI.RigidBody) {
            let body = spring.objectA.reference;
            body.applyImpulseAtPoint(impulse, worldPoint, true);
          }
        }
      },
      applyBodyBImpulse: (impulse, worldPoint) => {
        if (spring.objectB) {
          if (spring.objectB.reference instanceof xI.RigidBody) {
            let body = spring.objectB.reference;
            body.applyImpulseAtPoint(impulse, worldPoint, true);
          }
        }
      },
      getBodyAPosition: () => {
        if (spring.objectA) {
          if (spring.objectA.reference instanceof xI.RigidBody) {
            let body = spring.objectA.reference;
            return body.translation();
          }
        }
        return new xI.Vector2(0, 0);
      },
      getBodyBPosition: () => {
        if (spring.objectB) {
          if (spring.objectB.reference instanceof xI.RigidBody) {
            let body = spring.objectB.reference;
            return body.translation();
          }
        }
        return new xI.Vector2(0, 0);
      },
      getBodyARotation: () => {
        if (spring.objectA) {
          if (spring.objectA.reference instanceof xI.RigidBody) {
            let body = spring.objectA.reference;
            return body.rotation();
          }
        }
        return 0;
      },
      getBodyBRotation: () => {
        if (spring.objectB) {
          if (spring.objectB.reference instanceof xI.RigidBody) {
            let body = spring.objectB.reference;
            return body.rotation();
          }
        }
        return 0;
      },
      getBodyAVelocity: () => {
        if (spring.objectA) {
          if (spring.objectA.reference instanceof xI.RigidBody) {
            let body = spring.objectA.reference;
            return body.linvel();
          }
        }
        return new xI.Vector2(0, 0);
      },
      getBodyBVelocity: () => {
        if (spring.objectB) {
          if (spring.objectB.reference instanceof xI.RigidBody) {
            let body = spring.objectB.reference;
            return body.linvel();
          }
        }
        return new xI.Vector2(0, 0);
      },
      getBodyAAngularVelocity: () => {
        if (spring.objectA) {
          if (spring.objectA.reference instanceof xI.RigidBody) {
            let body = spring.objectA.reference;
            return body.angvel();
          }
        }
        return 0;
      },
      getBodyBAngularVelocity: () => {
        if (spring.objectB) {
          if (spring.objectB.reference instanceof xI.RigidBody) {
            let body = spring.objectB.reference;
            return body.angvel();
          }
        }
        return 0;
      },
      bodyA: spring.objectA ? spring.objectA.id : null,
      bodyB: spring.objectB ? spring.objectB.id : null,
      localAnchorA: new xI.Vector2(spring.localAnchorA.x, spring.localAnchorA.y),
      localAnchorB: new xI.Vector2(spring.localAnchorB.x, spring.localAnchorB.y),
      stiffness: spring.stiffness,
      damping: spring.damping,
      targetLength: spring.restLength
    };
    this.springs[id] = springDesc;
    return {
      destroy: () => {
        delete this.springs[id];
      },
      setLocalAnchorA: (localAnchorA) => {
        springDesc.localAnchorA = new xI.Vector2(localAnchorA.x, localAnchorA.y);
      },
      setLocalAnchorB: (localAnchorB) => {
        springDesc.localAnchorB = new xI.Vector2(localAnchorB.x, localAnchorB.y);
      },
      reference: id
    };
  }
  axles = {};
  addAxle(axle) {
    if (!this.world) {
      throw new Error("init world first");
    }
    let params = xI.JointData.revolute(axle.localAnchorA, axle.localAnchorB);
    let joint = this.world.createImpulseJoint(params, axle.bodyA.reference, axle.bodyB.reference, true);
    let colliderACount = axle.bodyA.reference.numColliders();
    let colliderBCount = axle.bodyB.reference.numColliders();
    for (let i2 = 0;i2 < colliderACount; i2++) {
      let collider = axle.bodyA.reference.collider(i2);
      collider.setActiveHooks(xI.ActiveHooks.FILTER_CONTACT_PAIRS);
    }
    for (let i2 = 0;i2 < colliderBCount; i2++) {
      let collider = axle.bodyB.reference.collider(i2);
      collider.setActiveHooks(xI.ActiveHooks.FILTER_CONTACT_PAIRS);
    }
    this.axles[axle.bodyA.reference.handle] = {
      body2Handle: axle.bodyB.reference.handle,
      joint
    };
  }
  getShapeContent(collider) {
    let shape = collider.shape;
    let parent = collider.parent();
    if (!parent)
      return null;
    let bodyData = parent.userData;
    let color = bodyData.color;
    let border = bodyData.border;
    let baseShape = {
      type: "cuboid",
      color,
      alpha: bodyData.alpha,
      border,
      id: bodyData.id,
      borderWidth: bodyData.borderWidth,
      name: bodyData.name ?? "Some kind of object",
      description: null,
      image: bodyData.image,
      imageTransformations: null,
      borderAlpha: 0.5,
      borderScaleWithZoom: bodyData.borderScaleWithZoom,
      text: null
    };
    switch (shape.type) {
      case xI.ShapeType.Cuboid:
        let cuboid = shape;
        let halfExtents = cuboid.halfExtents;
        let width = halfExtents.x * 2;
        let height = halfExtents.y * 2;
        let rect = {
          ...baseShape,
          type: "cuboid",
          width,
          height,
          depth: Math.min(Math.max(width, height), 5)
        };
        return rect;
      case xI.ShapeType.Ball:
        let ball = shape;
        let radius = ball.radius;
        return {
          ...baseShape,
          type: "ball",
          radius
        };
      case xI.ShapeType.ConvexPolygon:
        if (bodyData.polygonPoints) {
          return {
            ...baseShape,
            type: "polygon",
            points: bodyData.polygonPoints.map((point) => [point.x, point.y])
          };
        } else {
          let polygon = shape;
          let points = polygon.vertices;
          let pointsArray = [];
          for (let i2 = 0;i2 < points.length; i2 += 2) {
            pointsArray.push([points[i2], points[i2 + 1]]);
          }
          return {
            ...baseShape,
            type: "polygon",
            points: pointsArray
          };
        }
      default:
        console.log("Unknown shape type", shape.type);
        break;
    }
    return null;
  }
  getShapeTransforms() {
    let transforms = {};
    this.colliders.forEach((collider) => {
      let parent = collider.parent();
      if (!parent)
        return;
      let x2 = parent.translation().x;
      let y2 = parent.translation().y;
      let angle = parent.rotation();
      let data = parent.userData;
      transforms[data.id] = {
        x: x2,
        y: y2,
        z: 0,
        angle
      };
    });
    return transforms;
  }
  gravity = { x: 0, y: -9.81 };
  async init() {
    await xI.init();
    let gravity = new xI.Vector2(this.gravity.x, this.gravity.y);
    let world = new xI.World(gravity);
    this.world = world;
  }
  addPolygon(polygon) {
    if (!this.world) {
      throw new Error("init world first");
    }
    let pointsRaw = polygon.points.map((point) => [point.x, point.y]);
    import_poly_decomp.default.makeCCW(pointsRaw);
    import_poly_decomp.default.removeDuplicatePoints(pointsRaw, 0.05);
    import_poly_decomp.default.removeCollinearPoints(pointsRaw, 0.15);
    if (!import_poly_decomp.default.isSimple(pointsRaw)) {
      throw new Error("Polygon is not simple");
    }
    let polygons = import_poly_decomp.default.quickDecomp(pointsRaw);
    let colliders = [];
    console.log("count of polygons is", polygons.length);
    let id = polygon.id ?? this.getID("/");
    let bodyDesc = polygon.isStatic ? xI.RigidBodyDesc.fixed() : xI.RigidBodyDesc.dynamic();
    bodyDesc = bodyDesc.setTranslation(polygon.position.x, polygon.position.y);
    bodyDesc.setUserData({
      id,
      color: polygon.color,
      alpha: polygon.alpha,
      border: polygon.border,
      name: polygon.name,
      sound: polygon.sound,
      borderWidth: polygon.borderWidth,
      borderScaleWithZoom: polygon.borderScaleWithZoom,
      image: polygon.image,
      zDepth: polygon.zDepth,
      polygonPoints: polygon.points
    });
    let body = this.world.createRigidBody(bodyDesc);
    for (let points of polygons) {
      import_poly_decomp.default.removeDuplicatePoints(points, 0.01);
      import_poly_decomp.default.removeCollinearPoints(points, 0.1);
      points.push(points[0]);
      if (points.some((point) => {
        return point === undefined || point === null || !Array.isArray(point) || point.some((coord) => {
          return coord === undefined || coord === null || isNaN(coord);
        });
      })) {
        continue;
      }
      console.log("points is", points);
      let colliderDesc = xI.ColliderDesc.convexHull(new Float32Array(points.flat()));
      if (!colliderDesc) {
        throw new Error("Failed to create collider");
      }
      colliderDesc = colliderDesc.setRestitution(polygon.restitution).setFriction(polygon.friction).setDensity(polygon.density).setActiveEvents(xI.ActiveEvents.CONTACT_FORCE_EVENTS);
      let coll = this.world.createCollider(colliderDesc, body);
      this.colliders.push(coll);
      let content = this.getShapeContent(coll);
      if (content) {
        this.changedContents[id] = content;
      }
      colliders.push(coll);
    }
    return this.getSimuloObject(body);
  }
  addCuboid(rectangle) {
    if (!this.world) {
      throw new Error("init world first");
    }
    let id = rectangle.id ?? this.getID("/");
    let bodyDesc = rectangle.isStatic ? xI.RigidBodyDesc.fixed() : xI.RigidBodyDesc.dynamic();
    bodyDesc = bodyDesc.setTranslation(rectangle.position.x, rectangle.position.y);
    bodyDesc.setUserData({
      id,
      color: rectangle.color,
      alpha: rectangle.alpha,
      border: rectangle.border,
      name: rectangle.name,
      sound: rectangle.sound,
      borderWidth: rectangle.borderWidth,
      borderScaleWithZoom: rectangle.borderScaleWithZoom,
      image: rectangle.image,
      zDepth: rectangle.zDepth
    });
    let body = this.world.createRigidBody(bodyDesc);
    let colliderDesc = xI.ColliderDesc.cuboid(rectangle.width / 2, rectangle.height / 2).setRestitution(rectangle.restitution).setFriction(rectangle.friction).setDensity(rectangle.density).setActiveEvents(xI.ActiveEvents.CONTACT_FORCE_EVENTS);
    let coll = this.world.createCollider(colliderDesc, body);
    this.colliders.push(coll);
    let content = this.getShapeContent(coll);
    if (content) {
      this.changedContents[id] = content;
    }
    return this.getSimuloObject(body);
  }
  addBall(circle) {
    if (!this.world) {
      throw new Error("init world first");
    }
    let id = circle.id ?? this.getID("/");
    let bodyDesc = circle.isStatic ? xI.RigidBodyDesc.fixed() : xI.RigidBodyDesc.dynamic();
    bodyDesc = bodyDesc.setTranslation(circle.position.x, circle.position.y);
    bodyDesc.setUserData({
      id,
      color: circle.color,
      alpha: circle.alpha,
      border: circle.border,
      name: circle.name,
      sound: circle.sound,
      borderWidth: circle.borderWidth,
      borderScaleWithZoom: circle.borderScaleWithZoom,
      image: circle.image,
      zDepth: circle.zDepth,
      cakeSlice: circle.cakeSlice
    });
    let body = this.world.createRigidBody(bodyDesc);
    let colliderDesc = xI.ColliderDesc.ball(circle.radius).setRestitution(circle.restitution).setFriction(circle.friction).setDensity(circle.density).setActiveEvents(xI.ActiveEvents.CONTACT_FORCE_EVENTS);
    let coll = this.world.createCollider(colliderDesc, body);
    this.colliders.push(coll);
    let content = this.getShapeContent(coll);
    if (content) {
      this.changedContents[id] = content;
    }
    return this.getSimuloObject(body);
  }
  eventQueue = null;
  physicsHooks = null;
  step() {
    if (!this.world) {
      throw new Error("init world first");
    }
    let before = new Date().getTime();
    Object.values(this.springs).forEach((spring) => {
      this.applySpringForce(spring);
    });
    if (!this.eventQueue) {
      this.eventQueue = new xI.EventQueue(true);
    }
    if (!this.physicsHooks) {
      this.physicsHooks = {
        filterContactPair: (collider1, collider2, body1, body2) => {
          let axle = this.axles[body1];
          if (axle) {
            if (axle.body2Handle == body2) {
              return xI.SolverFlags.EMPTY;
            }
          }
          return xI.SolverFlags.COMPUTE_IMPULSE;
        },
        filterIntersectionPair(collider1, collider2, body1, body2) {
          return true;
        }
      };
    }
    this.world.step(this.eventQueue, this.physicsHooks);
    let sounds = [];
    this.eventQueue.drainContactForceEvents((e2) => {
      let colliderA = this.world?.getCollider(e2.collider1());
      let colliderB = this.world?.getCollider(e2.collider2());
      let bodyA = colliderA?.parent();
      let bodyB = colliderB?.parent();
      let userDataA = bodyA?.userData;
      let userDataB = bodyB?.userData;
      let magnitude = e2.totalForceMagnitude() / 1e5;
      if (userDataA.sound) {
        sounds.push({
          sound: userDataA.sound,
          volume: magnitude
        });
      }
      if (userDataB.sound) {
        sounds.push({
          sound: userDataB.sound,
          volume: magnitude
        });
      }
    });
    return this.getStepInfo(sounds, before);
  }
  getStepInfo(sounds, before) {
    let changed = this.changedContents;
    this.changedContents = {};
    let removed = this.removedContents;
    this.removedContents = [];
    return {
      delta: {
        shapeContent: changed,
        shapeTransforms: this.getShapeTransforms(),
        removedContents: removed
      },
      ms: new Date().getTime() - before,
      springs: Object.values(this.springs).map((spring) => {
        let pointA = this.getWorldPoint(spring.getBodyAPosition(), spring.getBodyARotation(), spring.localAnchorA);
        let pointB = this.getWorldPoint(spring.getBodyBPosition(), spring.getBodyBRotation(), spring.localAnchorB);
        return {
          pointA: { x: pointA.x, y: pointA.y },
          pointB: { x: pointB.x, y: pointB.y }
        };
      }),
      sounds
    };
  }
  getObjectAtPoint(point) {
    if (!this.world) {
      throw new Error("init world first");
    }
    let vec2 = new xI.Vector2(point.x, point.y);
    this.world.updateSceneQueries();
    let proj = this.world.projectPoint(vec2, true);
    if (proj != null && proj.isInside) {
      return this.getSimuloObject(proj.collider.parent());
    }
    return null;
  }
  getSimuloObject(reference) {
    let id = "unknown";
    try {
      let data = this.getShapeContent(reference.collider(0));
      id = data?.id ?? "unknown";
    } catch (e2) {
    }
    return {
      destroy: () => {
        if (!this.world) {
          throw new Error("init world first");
        }
        this.world.removeRigidBody(reference);
      },
      id,
      reference
    };
  }
  getObjectsInCuboid(startPoint, endPoint) {
    if (!this.world) {
      throw new Error("init world first");
    }
    let shape = new xI.Cuboid(Math.abs(startPoint.x - endPoint.x) / 2, Math.abs(startPoint.y - endPoint.y) / 2);
    let shapePos = { x: (startPoint.x + endPoint.x) / 2, y: (startPoint.y + endPoint.y) / 2 };
    this.world.updateSceneQueries();
    let intersecting = [];
    this.colliders.forEach((collider) => {
      if (collider.intersectsShape(shape, shapePos, 0)) {
        intersecting.push(collider);
      }
    });
    return intersecting.map((collider) => {
      return this.getSimuloObject(collider.parent());
    });
  }
  getObjectsAtPoint(point) {
    if (!this.world) {
      throw new Error("init world first");
    }
    let vec2 = new xI.Vector2(point.x, point.y);
    this.world.updateSceneQueries();
    let intersecting = [];
    this.colliders.forEach((collider) => {
      if (collider.containsPoint(vec2)) {
        intersecting.push(collider);
      }
    });
    return intersecting.map((collider) => {
      return this.getSimuloObject(collider.parent());
    });
  }
  destroyCollider(collider) {
    if (!this.world) {
      throw new Error("init world first");
    }
    this.colliders = this.colliders.filter((c2) => c2 != collider);
    let content = this.getShapeContent(collider);
    this.world.removeCollider(collider, true);
    if (content)
      this.removedContents.push(content.id);
  }
  destroyObject(simuloObject) {
    if (!this.world) {
      throw new Error("init world first");
    }
    let body = simuloObject.reference;
    if (!(body instanceof xI.RigidBody)) {
      throw new Error("Invalid object");
    }
    let colliderCount = body.numColliders();
    for (let i2 = 0;i2 < colliderCount; i2++) {
      let collider = body.collider(i2);
      this.destroyCollider(collider);
    }
    this.world.removeRigidBody(body);
  }
  getShapeContents() {
    let contents = {};
    this.colliders.forEach((collider) => {
      let content = this.getShapeContent(collider);
      if (content) {
        console.log('got of ID "' + content.id + '"');
        contents[content.id] = content;
      } else {
        console.log("no content for collider", collider);
      }
    });
    return contents;
  }
  normalize(v3) {
    let len = Math.sqrt(v3.x ** 2 + v3.y ** 2);
    if (len === 0)
      return new xI.Vector2(0, 0);
    return new xI.Vector2(v3.x / len, v3.y / len);
  }
  sub(a2, ...others) {
    let x2 = a2.x;
    let y2 = a2.y;
    others.forEach((other) => {
      x2 -= other.x;
      y2 -= other.y;
    });
    return new xI.Vector2(x2, y2);
  }
  magnitude(v3) {
    return Math.sqrt(v3.x ** 2 + v3.y ** 2);
  }
  distance(a2, b2) {
    return this.magnitude(this.sub(a2, b2));
  }
  multiply(v3, s2) {
    return new xI.Vector2(v3.x * s2, v3.y * s2);
  }
  vecToString(v3) {
    return `(${v3.x}, ${v3.y})`;
  }
  add(a2, ...others) {
    let x2 = a2.x;
    let y2 = a2.y;
    others.forEach((other) => {
      x2 += other.x;
      y2 += other.y;
    });
    return new xI.Vector2(x2, y2);
  }
  dot(a2, b2) {
    return a2.x * b2.x + a2.y * b2.y;
  }
  cross(a2, b2) {
    return new xI.Vector2(a2.x * b2.y, -a2.y * b2.x);
  }
  crossZV(z2, v3) {
    return new xI.Vector2(-z2 * v3.y, z2 * v3.x);
  }
  getLocalPoint(bodyPosition, bodyRotation, worldPoint) {
    const cos = Math.cos(bodyRotation);
    const sin = Math.sin(bodyRotation);
    const x2 = worldPoint.x - bodyPosition.x;
    const y2 = worldPoint.y - bodyPosition.y;
    const localX = x2 * cos + y2 * sin;
    const localY = -x2 * sin + y2 * cos;
    return new xI.Vector2(localX, localY);
  }
  getWorldPoint(bodyPosition, bodyRotation, localPoint) {
    const cos = Math.cos(bodyRotation);
    const sin = Math.sin(bodyRotation);
    const x2 = localPoint.x;
    const y2 = localPoint.y;
    const worldX = x2 * cos - y2 * sin + bodyPosition.x;
    const worldY = x2 * sin + y2 * cos + bodyPosition.y;
    return new xI.Vector2(worldX, worldY);
  }
  applySpringForce(spring) {
    const pointAWorld = this.getWorldPoint(spring.getBodyAPosition(), spring.getBodyARotation(), spring.localAnchorA);
    const pointBWorld = this.getWorldPoint(spring.getBodyBPosition(), spring.getBodyBRotation(), spring.localAnchorB);
    const velA = spring.getBodyAVelocity();
    const velB = spring.getBodyBVelocity();
    const springVector = this.sub(pointBWorld, pointAWorld);
    const distance2 = this.magnitude(springVector);
    if (distance2 == 0)
      return;
    const direction = this.normalize(springVector);
    const u5 = this.sub(velB, velA);
    const rj = this.crossZV(spring.getBodyBAngularVelocity(), spring.localAnchorB);
    const ri = this.crossZV(spring.getBodyAAngularVelocity(), spring.localAnchorA);
    const tmp = this.add(u5, rj, ri);
    const f2 = this.multiply(direction, -spring.stiffness * (distance2 - spring.targetLength) - spring.damping * this.dot(u5, direction));
    const forceA = this.multiply(f2, -1);
    const forceB = f2;
    spring.applyBodyAImpulse(forceA, pointAWorld);
    spring.applyBodyBImpulse(forceB, pointBWorld);
  }
  saveScene() {
    if (!this.world) {
      throw new Error("init world first");
    }
    let state = this.world.takeSnapshot();
    if (!state) {
      throw new Error("Failed to save scene");
    }
    let userDatas = Object.fromEntries(this.colliders.map((collider) => {
      let parent = collider.parent();
      if (!parent)
        return null;
      let userData = parent.userData;
      return [parent.handle, userData];
    }).filter((x2) => x2 != null));
    return {
      state: Array.from(state),
      userDatas,
      currentIDs: this.currentIDs,
      springs: Object.keys(this.springs).map((id) => {
        return {
          bodyA: this.springs[id].bodyA,
          bodyB: this.springs[id].bodyB,
          localAnchorA: this.springs[id].localAnchorA,
          localAnchorB: this.springs[id].localAnchorB,
          stiffness: this.springs[id].stiffness,
          damping: this.springs[id].damping,
          targetLength: this.springs[id].targetLength,
          id
        };
      })
    };
  }
  slicePolygon(collider, line) {
    let shape = collider.shape;
    let points = shape.vertices;
    let pointsArray = [];
    for (let i2 = 0;i2 < points.length; i2 += 2) {
      pointsArray.push([points[i2], points[i2 + 1]]);
    }
    let newPoints = index({
      type: "Polygon",
      coordinates: pointsArray
    }, {
      type: "LineString",
      coordinates: line
    });
    console.log("OMG POINTSER:", newPoints);
  }
  getObjectByID(id) {
    if (!this.world) {
      throw new Error("init world first");
    }
    let bodies = this.world.bodies.getAll();
    let body = bodies.find((body2) => {
      let userData = body2.userData;
      return userData.id === id;
    });
    if (body) {
      let simuloObject = {
        destroy: () => {
          this.world?.removeRigidBody(body);
        },
        id,
        reference: body
      };
    }
    return null;
  }
  async initFromSaved(scene) {
    await xI.init();
    let state = scene.state;
    this.world = xI.World.restoreSnapshot(Uint8Array.from(state));
    this.colliders = this.world.colliders.getAll();
    this.colliders.forEach((collider) => {
      let parent = collider.parent();
      if (!parent)
        return;
      let userData = scene.userDatas[parent.handle];
      if (!userData)
        return;
      parent.userData = userData;
    });
    this.changedContents = this.getShapeContents();
    this.currentIDs = scene.currentIDs;
    scene.springs.forEach((spring) => {
      let bodyA = null;
      let bodyB = null;
      if (spring.bodyA) {
        bodyA = this.getObjectByID(spring.bodyA)?.reference;
      }
      if (spring.bodyB) {
        bodyB = this.getObjectByID(spring.bodyB)?.reference;
      }
      this.springs[spring.id] = {
        bodyA: spring.bodyA,
        bodyB: spring.bodyB,
        stiffness: spring.stiffness,
        damping: spring.damping,
        targetLength: spring.targetLength,
        localAnchorA: spring.localAnchorA,
        localAnchorB: spring.localAnchorB,
        getBodyAPosition: () => {
          if (bodyA == null)
            return { x: 0, y: 0 };
          return bodyA.translation();
        },
        getBodyBPosition: () => {
          if (bodyB == null)
            return { x: 0, y: 0 };
          return bodyB.translation();
        },
        getBodyARotation: () => {
          if (bodyA == null)
            return 0;
          return bodyA.rotation();
        },
        getBodyBRotation: () => {
          if (bodyB == null)
            return 0;
          return bodyB.rotation();
        },
        getBodyAVelocity: () => {
          if (bodyA == null)
            return { x: 0, y: 0 };
          return bodyA.linvel();
        },
        getBodyBVelocity: () => {
          if (bodyB == null)
            return { x: 0, y: 0 };
          return bodyB.linvel();
        },
        getBodyAAngularVelocity: () => {
          if (bodyA == null)
            return 0;
          return bodyA.angvel();
        },
        getBodyBAngularVelocity: () => {
          if (bodyB == null)
            return 0;
          return bodyB.angvel();
        },
        applyBodyAImpulse: (impulse, worldPoint) => {
          if (bodyA == null)
            return;
          bodyA.applyImpulseAtPoint(impulse, worldPoint, true);
        },
        applyBodyBImpulse: (impulse, worldPoint) => {
          if (bodyB == null)
            return;
          bodyB.applyImpulseAtPoint(impulse, worldPoint, true);
        }
      };
    });
  }
  getObjectData(object) {
    if (!this.world) {
      throw new Error("init world first");
    }
    let body = object.reference;
    if (!(body instanceof xI.RigidBody)) {
      throw new Error("Invalid object");
    }
    return body.userData;
  }
  removeSpring(spring) {
    delete this.springs[spring.reference];
  }
  destroy() {
    if (this.world) {
      this.world.free();
    }
    this.world = null;
  }
  getLocalObjectPoint(object, worldPoint) {
    if (!this.world) {
      throw new Error("init world first");
    }
    let body = object.reference;
    if (!(body instanceof xI.RigidBody)) {
      throw new Error("Invalid object");
    }
    let localPoint = this.getLocalPoint(body.translation(), body.rotation(), new xI.Vector2(worldPoint.x, worldPoint.y));
    return { x: localPoint.x, y: localPoint.y, z: 0 };
  }
  getWorldObjectPoint(object, localPoint) {
    if (!this.world) {
      throw new Error("init world first");
    }
    let body = object.reference;
    if (!(body instanceof xI.RigidBody)) {
      throw new Error("Invalid object");
    }
    let worldPoint = this.getWorldPoint(body.translation(), body.rotation(), new xI.Vector2(localPoint.x, localPoint.y));
    return { x: worldPoint.x, y: worldPoint.y, z: 0 };
  }
}
var SimuloPhysicsServerRapier_default = SimuloPhysicsServerRapier;

// node_modules/colord/plugins/name
var crossLength = function(a2, b2) {
  return a2[0] * b2[1] - a2[1] * b2[0];
};
var crossVZ = function(out, vec2, zcomp) {
  rotate(out, vec2, -Math.PI / 2);
  scale2(out, out, zcomp);
  return out;
};
var crossZV = function(out, zcomp, vec2) {
  rotate(out, vec2, Math.PI / 2);
  scale2(out, out, zcomp);
  return out;
};
var rotate = function(out, a2, angle) {
  if (angle !== 0) {
    const c2 = Math.cos(angle), s2 = Math.sin(angle), x2 = a2[0], y2 = a2[1];
    out[0] = c2 * x2 - s2 * y2;
    out[1] = s2 * x2 + c2 * y2;
  } else {
    out[0] = a2[0];
    out[1] = a2[1];
  }
  return out;
};
var rotate90cw = function(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = y2;
  out[1] = -x2;
  return out;
};
var toLocalFrame = function(out, worldPoint, framePosition, frameAngle) {
  const c2 = Math.cos(-frameAngle), s2 = Math.sin(-frameAngle), x2 = worldPoint[0] - framePosition[0], y2 = worldPoint[1] - framePosition[1];
  out[0] = c2 * x2 - s2 * y2;
  out[1] = s2 * x2 + c2 * y2;
  return out;
};
var toGlobalFrame = function(out, localPoint, framePosition, frameAngle) {
  const c2 = Math.cos(frameAngle), s2 = Math.sin(frameAngle), x2 = localPoint[0], y2 = localPoint[1], addX = framePosition[0], addY = framePosition[1];
  out[0] = c2 * x2 - s2 * y2 + addX;
  out[1] = s2 * x2 + c2 * y2 + addY;
};
var vectorToLocalFrame = function(out, worldVector, frameAngle) {
  const c2 = Math.cos(-frameAngle), s2 = Math.sin(-frameAngle), x2 = worldVector[0], y2 = worldVector[1];
  out[0] = c2 * x2 - s2 * y2;
  out[1] = s2 * x2 + c2 * y2;
  return out;
};
var centroid = function(out, a2, b2, c2) {
  add(out, a2, b2);
  add(out, out, c2);
  scale2(out, out, 1 / 3);
  return out;
};
var create = function() {
  const out = new ARRAY_TYPE(2);
  out[0] = 0;
  out[1] = 0;
  return out;
};
var clone3 = function(a2) {
  const out = new ARRAY_TYPE(2);
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
};
var fromValues = function(x2, y2) {
  const out = new ARRAY_TYPE(2);
  out[0] = x2;
  out[1] = y2;
  return out;
};
var copy = function(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
};
var set = function(out, x2, y2) {
  out[0] = x2;
  out[1] = y2;
  return out;
};
var add = function(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  return out;
};
var subtract = function(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  return out;
};
var multiply = function(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  return out;
};
var divide = function(out, a2, b2) {
  out[0] = a2[0] / b2[0];
  out[1] = a2[1] / b2[1];
  return out;
};
var scale2 = function(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  return out;
};
var distance2 = function(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  return Math.sqrt(x2 * x2 + y2 * y2);
};
var squaredDistance = function(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  return x2 * x2 + y2 * y2;
};
var length = function(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  return Math.sqrt(x2 * x2 + y2 * y2);
};
var squaredLength = function(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  return x2 * x2 + y2 * y2;
};
var negate2 = function(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  return out;
};
var normalize = function(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  let len = x2 * x2 + y2 * y2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = a2[0] * len;
    out[1] = a2[1] * len;
  }
  return out;
};
var dot = function(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1];
};
var str = function(a2) {
  return "vec2(" + a2[0] + ", " + a2[1] + ")";
};
var lerp = function(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  out[0] = ax + t2 * (b2[0] - ax);
  out[1] = ay + t2 * (b2[1] - ay);
  return out;
};
var reflect = function(out, vector, normal) {
  const dot2 = vector[0] * normal[0] + vector[1] * normal[1];
  out[0] = vector[0] - 2 * normal[0] * dot2;
  out[1] = vector[1] - 2 * normal[1] * dot2;
  return out;
};
var getLineSegmentsIntersection = function(out, p0, p1, p2, p3) {
  const t2 = getLineSegmentsIntersectionFraction(p0, p1, p2, p3);
  if (t2 < 0) {
    return false;
  } else {
    out[0] = p0[0] + t2 * (p1[0] - p0[0]);
    out[1] = p0[1] + t2 * (p1[1] - p0[1]);
    return true;
  }
};
var getLineSegmentsIntersectionFraction = function(p0, p1, p2, p3) {
  const s1_x = p1[0] - p0[0];
  const s1_y = p1[1] - p0[1];
  const s2_x = p3[0] - p2[0];
  const s2_y = p3[1] - p2[1];
  const s2 = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);
  const t2 = (s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);
  if (s2 >= 0 && s2 <= 1 && t2 >= 0 && t2 <= 1) {
    return t2;
  }
  return -1;
};
var lineInt = function(l1, l2, precision) {
  if (precision === undefined) {
    precision = 0;
  }
  precision = precision || 0;
  const i2 = [0, 0];
  const a1 = l1[1][1] - l1[0][1];
  const b1 = l1[0][0] - l1[1][0];
  const c1 = a1 * l1[0][0] + b1 * l1[0][1];
  const a2 = l2[1][1] - l2[0][1];
  const b2 = l2[0][0] - l2[1][0];
  const c2 = a2 * l2[0][0] + b2 * l2[0][1];
  const det = a1 * b2 - a2 * b1;
  if (!scalarsEqual(det, 0, precision)) {
    i2[0] = (b2 * c1 - b1 * c2) / det;
    i2[1] = (a1 * c2 - a2 * c1) / det;
  }
  return i2;
};
var lineSegmentsIntersect = function(p1, p2, q1, q2) {
  const dx = p2[0] - p1[0];
  const dy = p2[1] - p1[1];
  const da2 = q2[0] - q1[0];
  const db = q2[1] - q1[1];
  if (da2 * dy - db * dx === 0) {
    return false;
  }
  const s2 = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da2 * dy - db * dx);
  const t2 = (da2 * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da2 * dy);
  return s2 >= 0 && s2 <= 1 && t2 >= 0 && t2 <= 1;
};
var triangleArea = function(a2, b2, c2) {
  return (b2[0] - a2[0]) * (c2[1] - a2[1]) - (c2[0] - a2[0]) * (b2[1] - a2[1]);
};
var isLeft = function(a2, b2, c2) {
  return triangleArea(a2, b2, c2) > 0;
};
var isLeftOn = function(a2, b2, c2) {
  return triangleArea(a2, b2, c2) >= 0;
};
var isRight = function(a2, b2, c2) {
  return triangleArea(a2, b2, c2) < 0;
};
var isRightOn = function(a2, b2, c2) {
  return triangleArea(a2, b2, c2) <= 0;
};
var collinear = function(a2, b2, c2, thresholdAngle) {
  if (thresholdAngle === undefined) {
    thresholdAngle = 0;
  }
  if (!thresholdAngle) {
    return triangleArea(a2, b2, c2) === 0;
  } else {
    const ab4 = tmpPoint1;
    const bc4 = tmpPoint2;
    ab4[0] = b2[0] - a2[0];
    ab4[1] = b2[1] - a2[1];
    bc4[0] = c2[0] - b2[0];
    bc4[1] = c2[1] - b2[1];
    const dot2 = ab4[0] * bc4[0] + ab4[1] * bc4[1];
    const magA = Math.sqrt(ab4[0] * ab4[0] + ab4[1] * ab4[1]);
    const magB = Math.sqrt(bc4[0] * bc4[0] + bc4[1] * bc4[1]);
    const angle = Math.acos(dot2 / (magA * magB));
    return angle < thresholdAngle;
  }
};
var sqdist = function(a2, b2) {
  const dx = b2[0] - a2[0];
  const dy = b2[1] - a2[1];
  return dx * dx + dy * dy;
};
var polygonAt = function(polygon, i2) {
  const s2 = polygon.length;
  return polygon[i2 < 0 ? i2 % s2 + s2 : i2 % s2];
};
var polygonClear = function(polygon) {
  polygon.length = 0;
};
var polygonAppend = function(polygon, poly, from, to) {
  for (let i2 = from;i2 < to; i2++) {
    polygon.push(poly[i2]);
  }
};
var makeCCW = function(polygon) {
  let br = 0;
  const v3 = polygon;
  for (let i2 = 1;i2 < polygon.length; ++i2) {
    if (v3[i2][1] < v3[br][1] || v3[i2][1] === v3[br][1] && v3[i2][0] > v3[br][0]) {
      br = i2;
    }
  }
  if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
    polygonReverse(polygon);
    return true;
  } else {
    return false;
  }
};
var polygonReverse = function(polygon) {
  const tmp = [];
  const N2 = polygon.length;
  for (let i2 = 0;i2 !== N2; i2++) {
    tmp.push(polygon.pop());
  }
  for (let i2 = 0;i2 !== N2; i2++) {
    polygon[i2] = tmp[i2];
  }
};
var polygonIsReflex = function(polygon, i2) {
  return isRight(polygonAt(polygon, i2 - 1), polygonAt(polygon, i2), polygonAt(polygon, i2 + 1));
};
var polygonCanSee = function(polygon, a2, b2) {
  const l1 = tmpLine1;
  const l2 = tmpLine2;
  if (isLeftOn(polygonAt(polygon, a2 + 1), polygonAt(polygon, a2), polygonAt(polygon, b2)) && isRightOn(polygonAt(polygon, a2 - 1), polygonAt(polygon, a2), polygonAt(polygon, b2))) {
    return false;
  }
  const dist = sqdist(polygonAt(polygon, a2), polygonAt(polygon, b2));
  for (let i2 = 0;i2 !== polygon.length; ++i2) {
    if ((i2 + 1) % polygon.length === a2 || i2 === a2) {
      continue;
    }
    if (isLeftOn(polygonAt(polygon, a2), polygonAt(polygon, b2), polygonAt(polygon, i2 + 1)) && isRightOn(polygonAt(polygon, a2), polygonAt(polygon, b2), polygonAt(polygon, i2))) {
      l1[0] = polygonAt(polygon, a2);
      l1[1] = polygonAt(polygon, b2);
      l2[0] = polygonAt(polygon, i2);
      l2[1] = polygonAt(polygon, i2 + 1);
      const p2 = lineInt(l1, l2);
      if (sqdist(polygonAt(polygon, a2), p2) < dist) {
        return false;
      }
    }
  }
  return true;
};
var polygonCanSee2 = function(polygon, a2, b2) {
  for (let i2 = 0;i2 !== polygon.length; ++i2) {
    if (i2 === a2 || i2 === b2 || (i2 + 1) % polygon.length === a2 || (i2 + 1) % polygon.length === b2) {
      continue;
    }
    if (lineSegmentsIntersect(polygonAt(polygon, a2), polygonAt(polygon, b2), polygonAt(polygon, i2), polygonAt(polygon, i2 + 1))) {
      return false;
    }
  }
  return true;
};
var polygonCopy = function(polygon, i2, j2, targetPoly) {
  if (targetPoly === undefined) {
    targetPoly = [];
  }
  polygonClear(targetPoly);
  if (i2 < j2) {
    for (let k2 = i2;k2 <= j2; k2++) {
      targetPoly.push(polygon[k2]);
    }
  } else {
    for (let k2 = 0;k2 <= j2; k2++) {
      targetPoly.push(polygon[k2]);
    }
    for (let k2 = i2;k2 < polygon.length; k2++) {
      targetPoly.push(polygon[k2]);
    }
  }
  return targetPoly;
};
var getCutEdges = function(polygon) {
  let min = [];
  let tmp1;
  let tmp2;
  const tmpPoly = [];
  let nDiags = Number.MAX_VALUE;
  for (let i2 = 0;i2 < polygon.length; ++i2) {
    if (polygonIsReflex(polygon, i2)) {
      for (let j2 = 0;j2 < polygon.length; ++j2) {
        if (polygonCanSee(polygon, i2, j2)) {
          tmp1 = getCutEdges(polygonCopy(polygon, i2, j2, tmpPoly));
          tmp2 = getCutEdges(polygonCopy(polygon, j2, i2, tmpPoly));
          for (let k2 = 0;k2 < tmp2.length; k2++) {
            tmp1.push(tmp2[k2]);
          }
          if (tmp1.length < nDiags) {
            min = tmp1;
            nDiags = tmp1.length;
            min.push([polygonAt(polygon, i2), polygonAt(polygon, j2)]);
          }
        }
      }
    }
  }
  return min;
};
var decomp = function(polygon) {
  const edges = getCutEdges(polygon);
  if (edges.length > 0) {
    return slicePolygon(polygon, edges);
  } else {
    return [polygon];
  }
};
var slicePolygon = function(polygon, cutEdges) {
  if (cutEdges.length === 0) {
    return [polygon];
  }
  if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {
    const polys = [polygon];
    for (let i2 = 0;i2 < cutEdges.length; i2++) {
      const cutEdge = cutEdges[i2];
      for (let j2 = 0;j2 < polys.length; j2++) {
        const poly = polys[j2];
        const result = slicePolygon(poly, cutEdge);
        if (result) {
          polys.splice(j2, 1);
          polys.push(result[0], result[1]);
          break;
        }
      }
    }
    return polys;
  } else {
    const cutEdge = cutEdges;
    const i2 = polygon.indexOf(cutEdge[0]);
    const j2 = polygon.indexOf(cutEdge[1]);
    if (i2 !== -1 && j2 !== -1) {
      return [polygonCopy(polygon, i2, j2), polygonCopy(polygon, j2, i2)];
    } else {
      return false;
    }
  }
};
var isSimple = function(polygon) {
  const path = polygon;
  let i2;
  for (i2 = 0;i2 < path.length - 1; i2++) {
    for (let j2 = 0;j2 < i2 - 1; j2++) {
      if (lineSegmentsIntersect(path[i2], path[i2 + 1], path[j2], path[j2 + 1])) {
        return false;
      }
    }
  }
  for (i2 = 1;i2 < path.length - 2; i2++) {
    if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i2], path[i2 + 1])) {
      return false;
    }
  }
  return true;
};
var getIntersectionPoint = function(p1, p2, q1, q2, delta) {
  if (delta === undefined) {
    delta = 0;
  }
  const a1 = p2[1] - p1[1];
  const b1 = p1[0] - p2[0];
  const c1 = a1 * p1[0] + b1 * p1[1];
  const a2 = q2[1] - q1[1];
  const b2 = q1[0] - q2[0];
  const c2 = a2 * q1[0] + b2 * q1[1];
  const det = a1 * b2 - a2 * b1;
  if (!scalarsEqual(det, 0, delta)) {
    return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];
  } else {
    return [0, 0];
  }
};
var quickDecomp = function(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
  if (result === undefined) {
    result = [];
  }
  if (reflexVertices === undefined) {
    reflexVertices = [];
  }
  if (steinerPoints === undefined) {
    steinerPoints = [];
  }
  if (delta === undefined) {
    delta = 25;
  }
  if (maxlevel === undefined) {
    maxlevel = 100;
  }
  if (level === undefined) {
    level = 0;
  }
  let upperInt = [0, 0];
  let lowerInt = [0, 0];
  let p2 = [0, 0];
  let upperDist = 0;
  let lowerDist = 0;
  let d2 = 0;
  let closestDist = 0;
  let upperIndex = 0;
  let lowerIndex = 0;
  let closestIndex = 0;
  const lowerPoly = [];
  const upperPoly = [];
  const poly = polygon;
  const v3 = polygon;
  if (v3.length < 3) {
    return result;
  }
  level++;
  if (level > maxlevel) {
    console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
    return result;
  }
  for (let i2 = 0;i2 < polygon.length; ++i2) {
    if (polygonIsReflex(poly, i2)) {
      reflexVertices.push(poly[i2]);
      upperDist = lowerDist = Number.MAX_VALUE;
      for (let j2 = 0;j2 < polygon.length; ++j2) {
        if (isLeft(polygonAt(poly, i2 - 1), polygonAt(poly, i2), polygonAt(poly, j2)) && isRightOn(polygonAt(poly, i2 - 1), polygonAt(poly, i2), polygonAt(poly, j2 - 1))) {
          p2 = getIntersectionPoint(polygonAt(poly, i2 - 1), polygonAt(poly, i2), polygonAt(poly, j2), polygonAt(poly, j2 - 1));
          if (isRight(polygonAt(poly, i2 + 1), polygonAt(poly, i2), p2)) {
            d2 = sqdist(poly[i2], p2);
            if (d2 < lowerDist) {
              lowerDist = d2;
              lowerInt = p2;
              lowerIndex = j2;
            }
          }
        }
        if (isLeft(polygonAt(poly, i2 + 1), polygonAt(poly, i2), polygonAt(poly, j2 + 1)) && isRightOn(polygonAt(poly, i2 + 1), polygonAt(poly, i2), polygonAt(poly, j2))) {
          p2 = getIntersectionPoint(polygonAt(poly, i2 + 1), polygonAt(poly, i2), polygonAt(poly, j2), polygonAt(poly, j2 + 1));
          if (isLeft(polygonAt(poly, i2 - 1), polygonAt(poly, i2), p2)) {
            d2 = sqdist(poly[i2], p2);
            if (d2 < upperDist) {
              upperDist = d2;
              upperInt = p2;
              upperIndex = j2;
            }
          }
        }
      }
      if (lowerIndex === (upperIndex + 1) % polygon.length) {
        p2[0] = (lowerInt[0] + upperInt[0]) / 2;
        p2[1] = (lowerInt[1] + upperInt[1]) / 2;
        steinerPoints.push(p2);
        if (i2 < upperIndex) {
          polygonAppend(lowerPoly, poly, i2, upperIndex + 1);
          lowerPoly.push(p2);
          upperPoly.push(p2);
          if (lowerIndex !== 0) {
            polygonAppend(upperPoly, poly, lowerIndex, poly.length);
          }
          polygonAppend(upperPoly, poly, 0, i2 + 1);
        } else {
          if (i2 !== 0) {
            polygonAppend(lowerPoly, poly, i2, poly.length);
          }
          polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
          lowerPoly.push(p2);
          upperPoly.push(p2);
          polygonAppend(upperPoly, poly, lowerIndex, i2 + 1);
        }
      } else {
        if (lowerIndex > upperIndex) {
          upperIndex += polygon.length;
        }
        closestDist = Number.MAX_VALUE;
        if (upperIndex < lowerIndex) {
          return result;
        }
        for (let j2 = lowerIndex;j2 <= upperIndex; ++j2) {
          if (isLeftOn(polygonAt(poly, i2 - 1), polygonAt(poly, i2), polygonAt(poly, j2)) && isRightOn(polygonAt(poly, i2 + 1), polygonAt(poly, i2), polygonAt(poly, j2))) {
            d2 = sqdist(polygonAt(poly, i2), polygonAt(poly, j2));
            if (d2 < closestDist && polygonCanSee2(poly, i2, j2)) {
              closestDist = d2;
              closestIndex = j2 % polygon.length;
            }
          }
        }
        if (i2 < closestIndex) {
          polygonAppend(lowerPoly, poly, i2, closestIndex + 1);
          if (closestIndex !== 0) {
            polygonAppend(upperPoly, poly, closestIndex, v3.length);
          }
          polygonAppend(upperPoly, poly, 0, i2 + 1);
        } else {
          if (i2 !== 0) {
            polygonAppend(lowerPoly, poly, i2, v3.length);
          }
          polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
          polygonAppend(upperPoly, poly, closestIndex, i2 + 1);
        }
      }
      if (lowerPoly.length < upperPoly.length) {
        quickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
        quickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
      } else {
        quickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
        quickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
      }
      return result;
    }
  }
  result.push(polygon);
  return result;
};
var removeCollinearPoints = function(polygon, thresholdAngle) {
  if (thresholdAngle === undefined) {
    thresholdAngle = 0;
  }
  let num = 0;
  for (let i2 = polygon.length - 1;polygon.length > 3 && i2 >= 0; --i2) {
    if (collinear(polygonAt(polygon, i2 - 1), polygonAt(polygon, i2), polygonAt(polygon, i2 + 1), thresholdAngle)) {
      polygon.splice(i2 % polygon.length, 1);
      num++;
    }
  }
  return num;
};
var scalarsEqual = function(a2, b2, precision) {
  if (precision === undefined) {
    precision = 0;
  }
  precision = precision || 0;
  return Math.abs(a2 - b2) <= precision;
};
var distanceFromIntersectionSquared = function(from, direction, position) {
  subtract(v0, position, from);
  const dot$1 = dot(v0, direction);
  scale2(intersect, direction, dot$1);
  add(intersect, intersect, from);
  return squaredDistance(position, intersect);
};
var triangulate = function(p2) {
  const n2 = p2.length >> 1;
  if (n2 < 3)
    return [];
  const tgs = [];
  const avl = [];
  for (let i3 = 0;i3 < n2; i3++)
    avl.push(i3);
  let i2 = 0;
  let al = n2;
  while (al > 3) {
    const i0 = avl[(i2 + 0) % al];
    const i1 = avl[(i2 + 1) % al];
    const i22 = avl[(i2 + 2) % al];
    const ax = p2[2 * i0], ay = p2[2 * i0 + 1];
    const bx = p2[2 * i1], by = p2[2 * i1 + 1];
    const cx = p2[2 * i22], cy = p2[2 * i22 + 1];
    let earFound = false;
    if (convex(ax, ay, bx, by, cx, cy)) {
      earFound = true;
      for (let j2 = 0;j2 < al; j2++) {
        const vi = avl[j2];
        if (vi == i0 || vi == i1 || vi == i22)
          continue;
        if (pointInTriangle(p2[2 * vi], p2[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
          earFound = false;
          break;
        }
      }
    }
    if (earFound) {
      tgs.push(i0, i1, i22);
      avl.splice((i2 + 1) % al, 1);
      al--;
      i2 = 0;
    } else if (i2++ > 3 * al)
      break;
  }
  tgs.push(avl[0], avl[1], avl[2]);
  return tgs;
};
var pointInTriangle = function(px, py, ax, ay, bx, by, cx, cy) {
  const v0x = cx - ax;
  const v0y = cy - ay;
  const v1x = bx - ax;
  const v1y = by - ay;
  const v2x = px - ax;
  const v2y = py - ay;
  const dot00 = v0x * v0x + v0y * v0y;
  const dot01 = v0x * v1x + v0y * v1y;
  const dot02 = v0x * v2x + v0y * v2y;
  const dot11 = v1x * v1x + v1y * v1y;
  const dot12 = v1x * v2x + v1y * v2y;
  const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
  const u5 = (dot11 * dot02 - dot01 * dot12) * invDenom;
  const v3 = (dot00 * dot12 - dot01 * dot02) * invDenom;
  return u5 >= 0 && v3 >= 0 && u5 + v3 < 1;
};
var convex = function(ax, ay, bx, by, cx, cy) {
  return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;
};
var addToVLambda = function(vlambda, Gx, Gy, invMass, deltalambda, massMultiplier) {
  vlambda[0] += Gx * invMass * deltalambda * massMultiplier[0];
  vlambda[1] += Gy * invMass * deltalambda * massMultiplier[1];
};
var addSubSub = function(out, a2, b2, c2, d2) {
  out[0] = a2[0] + b2[0] - c2[0] - d2[0];
  out[1] = a2[1] + b2[1] - c2[1] - d2[1];
};
var setConvexToCapsuleShapeMiddle = function(convexShape, capsuleShape) {
  const capsuleRadius = capsuleShape.radius;
  const halfCapsuleLength = capsuleShape.length * 0.5;
  const verts = convexShape.vertices;
  set(verts[0], -halfCapsuleLength, -capsuleRadius);
  set(verts[1], halfCapsuleLength, -capsuleRadius);
  set(verts[2], halfCapsuleLength, capsuleRadius);
  set(verts[3], -halfCapsuleLength, capsuleRadius);
};
var pointInConvex = function(worldPoint, convexShape, convexOffset, convexAngle) {
  const localPoint = pointInConvex_localPoint;
  const r0 = pointInConvex_r0;
  const r1 = pointInConvex_r1;
  const verts = convexShape.vertices;
  let lastCross = null;
  toLocalFrame(localPoint, worldPoint, convexOffset, convexAngle);
  for (let i2 = 0, numVerts = verts.length;i2 !== numVerts + 1; i2++) {
    const v0 = verts[i2 % numVerts], v1 = verts[(i2 + 1) % numVerts];
    subtract(r0, v0, localPoint);
    subtract(r1, v1, localPoint);
    const cross = crossLength(r0, r1);
    if (lastCross === null) {
      lastCross = cross;
    }
    if (cross * lastCross < 0) {
      return false;
    }
    lastCross = cross;
  }
  return true;
};
var addsubtract = function(out, a2, b2, c2) {
  out[0] = a2[0] + b2[0] - c2[0];
  out[1] = a2[1] + b2[1] - c2[1];
};
var pointInConvexLocal = function(localPoint, convexShape) {
  const r0 = pointInConvex_r0;
  const r1 = pointInConvex_r1;
  const verts = convexShape.vertices;
  const numVerts = verts.length;
  let lastCross = null;
  for (let i2 = 0;i2 < numVerts + 1; i2++) {
    const v0 = verts[i2 % numVerts], v1 = verts[(i2 + 1) % numVerts];
    subtract(r0, v0, localPoint);
    subtract(r1, v1, localPoint);
    const cross = crossLength(r0, r1);
    if (lastCross === null) {
      lastCross = cross;
    }
    if (cross * lastCross < 0) {
      return false;
    }
    lastCross = cross;
  }
  return true;
};
var findMaxSeparation = function(maxSeparationOut, poly1, position1, angle1, poly2, position2, angle2) {
  const count1 = poly1.vertices.length;
  const count2 = poly2.vertices.length;
  const n1s = poly1.normals;
  const v1s = poly1.vertices;
  const v2s = poly2.vertices;
  const n2 = findMaxSeparation_n;
  const v1 = findMaxSeparation_v1;
  const tmp = findMaxSeparation_tmp;
  const tmp2 = findMaxSeparation_tmp2;
  const angle = angle1 - angle2;
  let bestIndex = 0;
  let maxSeparation = -Number.MAX_VALUE;
  for (let i2 = 0;i2 < count1; ++i2) {
    rotate(n2, n1s[i2], angle);
    toGlobalFrame(tmp2, v1s[i2], position1, angle1);
    toLocalFrame(v1, tmp2, position2, angle2);
    let si = Number.MAX_VALUE;
    for (let j2 = 0;j2 < count2; ++j2) {
      subtract(tmp, v2s[j2], v1);
      const sij = dot(n2, tmp);
      if (sij < si) {
        si = sij;
      }
    }
    if (si > maxSeparation) {
      maxSeparation = si;
      bestIndex = i2;
    }
  }
  maxSeparationOut[0] = maxSeparation;
  return bestIndex;
};
var findIncidentEdge = function(clipVerticesOut, poly1, position1, angle1, edge1, poly2, position2, angle2) {
  const normals1 = poly1.normals;
  const count2 = poly2.vertices.length;
  const vertices2 = poly2.vertices;
  const normals2 = poly2.normals;
  const normal1 = findIncidentEdge_normal1;
  rotate(normal1, normals1[edge1], angle1 - angle2);
  let index2 = 0;
  let minDot = Number.MAX_VALUE;
  for (let i3 = 0;i3 < count2; ++i3) {
    const dot$1 = dot(normal1, normals2[i3]);
    if (dot$1 < minDot) {
      minDot = dot$1;
      index2 = i3;
    }
  }
  const i1 = index2;
  const i2 = i1 + 1 < count2 ? i1 + 1 : 0;
  toGlobalFrame(clipVerticesOut[0], vertices2[i1], position2, angle2);
  toGlobalFrame(clipVerticesOut[1], vertices2[i2], position2, angle2);
};
var clipSegmentToLine = function(vOut, vIn, normal, offset) {
  let numOut = 0;
  const distance0 = dot(normal, vIn[0]) - offset;
  const distance1 = dot(normal, vIn[1]) - offset;
  if (distance0 <= 0) {
    copy(vOut[numOut++], vIn[0]);
  }
  if (distance1 <= 0) {
    copy(vOut[numOut++], vIn[1]);
  }
  if (distance0 * distance1 < 0) {
    const interp = distance0 / (distance0 - distance1);
    const v3 = vOut[numOut];
    subtract(v3, vIn[1], vIn[0]);
    scale2(v3, v3, interp);
    add(v3, v3, vIn[0]);
    ++numOut;
  }
  return numOut;
};
var sortAxisList = function(a2, axisIndex) {
  axisIndex = axisIndex | 0;
  for (let i2 = 1, l2 = a2.length;i2 < l2; i2++) {
    const v3 = a2[i2];
    let j2;
    for (j2 = i2 - 1;j2 >= 0; j2--) {
      if (a2[j2].aabb.lowerBound[axisIndex] <= v3.aabb.lowerBound[axisIndex]) {
        break;
      }
      a2[j2 + 1] = a2[j2];
    }
    a2[j2 + 1] = v3;
  }
  return a2;
};
var updateMultipliers = function(equations, invDt) {
  let l2 = equations.length;
  while (l2--) {
    const eq = equations[l2];
    eq.multiplier = eq.lambda * invDt;
  }
};
var iterateEquation = function(eq) {
  const { B: B3, epsilon: eps, invC, lambda: lambdaj } = eq, GWlambda = eq.computeGWlambda(), maxForce_dt = eq.maxForceDt, minForce_dt = eq.minForceDt;
  let deltalambda = invC * (B3 - GWlambda - eps * lambdaj);
  const lambdaj_plus_deltalambda = lambdaj + deltalambda;
  if (lambdaj_plus_deltalambda < minForce_dt) {
    deltalambda = minForce_dt - lambdaj;
  } else if (lambdaj_plus_deltalambda > maxForce_dt) {
    deltalambda = maxForce_dt - lambdaj;
  }
  eq.lambda += deltalambda;
  eq.addToWlambda(deltalambda);
  return deltalambda;
};
var sortBodiesByIsland = function(a2, b2) {
  return a2.islandId - b2.islandId;
};
var sortEquationsByIsland = function(equationA, equationB) {
  const islandA = equationA.bodyA.islandId > 0 ? equationA.bodyA.islandId : equationA.bodyB.islandId;
  const islandB = equationB.bodyA.islandId > 0 ? equationB.bodyA.islandId : equationB.bodyB.islandId;
  if (islandA !== islandB) {
    return islandA - islandB;
  } else {
    return equationA.index - equationB.index;
  }
};
var runNarrowphase = function(world, np, bi, si, xi, ai, bj, sj, xj, aj, cm, glen) {
  if (!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)) {
    return;
  }
  toGlobalFrame(xiw, xi, bi.position, bi.angle);
  toGlobalFrame(xjw, xj, bj.position, bj.angle);
  if (distance2(xiw, xjw) > si.boundingRadius + sj.boundingRadius) {
    return;
  }
  const aiw = ai + bi.angle;
  const ajw = aj + bj.angle;
  np.enableFriction = cm.friction > 0;
  let reducedMass;
  if (bi.type === Body.STATIC || bi.type === Body.KINEMATIC) {
    reducedMass = bj.mass;
  } else if (bj.type === Body.STATIC || bj.type === Body.KINEMATIC) {
    reducedMass = bi.mass;
  } else {
    reducedMass = bi.mass * bj.mass / (bi.mass + bj.mass);
  }
  np.slipForce = cm.friction * glen * reducedMass;
  np.currentContactMaterial = cm;
  np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
  const resolver = np.narrowphases[si.type | sj.type];
  let numContacts = 0;
  if (resolver) {
    const sensor = si.sensor || sj.sensor;
    const numFrictionBefore = np.frictionEquations.length;
    if (si.type < sj.type) {
      numContacts = resolver.call(np, bi, si, xiw, aiw, bj, sj, xjw, ajw, sensor);
    } else {
      numContacts = resolver.call(np, bj, sj, xjw, ajw, bi, si, xiw, aiw, sensor);
    }
    const numFrictionEquations = np.frictionEquations.length - numFrictionBefore;
    if (numContacts) {
      if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
        const speedSquaredB = squaredLength(bj.velocity) + Math.pow(bj.angularVelocity, 2);
        const speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);
        if (speedSquaredB >= speedLimitSquaredB * 2) {
          bi._wakeUpAfterNarrowphase = true;
        }
      }
      if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
        const speedSquaredA = squaredLength(bi.velocity) + Math.pow(bi.angularVelocity, 2);
        const speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);
        if (speedSquaredA >= speedLimitSquaredA * 2) {
          bj._wakeUpAfterNarrowphase = true;
        }
      }
      world.overlapKeeper.setOverlapping(bi, si, bj, sj);
      if (world.has("beginContact") && world.overlapKeeper.isNewOverlap(si, sj)) {
        const equations = [];
        if (!sensor) {
          for (let i2 = np.contactEquations.length - numContacts;i2 < np.contactEquations.length; i2++) {
            equations.push(np.contactEquations[i2]);
          }
        }
        world.emit({
          type: "beginContact",
          shapeA: si,
          shapeB: sj,
          bodyA: bi,
          bodyB: bj,
          contactEquations: equations
        });
      }
      if (!sensor && numFrictionEquations > 1) {
        for (let i2 = np.frictionEquations.length - numFrictionEquations;i2 < np.frictionEquations.length; i2++) {
          const f2 = np.frictionEquations[i2];
          f2.setSlipForce(f2.getSlipForce() / numFrictionEquations);
        }
      }
    }
  }
};
var ARRAY_TYPE = (() => {
  if (typeof P2_ARRAY_TYPE !== "undefined") {
    return P2_ARRAY_TYPE;
  } else if (typeof Float32Array !== "undefined") {
    return Float32Array;
  } else {
    return Array;
  }
})();
var appendArray = (a2, b2) => {
  for (let i2 = 0, len = b2.length;i2 !== len; ++i2) {
    a2.push(b2[i2]);
  }
};
var splice = function(array, index2, howmany) {
  if (howmany === undefined) {
    howmany = 1;
  }
  const len = array.length - howmany;
  for (let i2 = index2;i2 < len; i2++) {
    array[i2] = array[i2 + howmany];
  }
  array.length = len;
};
var arrayRemove = (array, element) => {
  const l2 = array.length;
  for (let i2 = 0;i2 < l2; i2++) {
    if (array[i2] === element) {
      splice(array, i2, 1);
      break;
    }
  }
};
var vectorToGlobalFrame = rotate;
var vec2 = Object.freeze({
  __proto__: null,
  add,
  centroid,
  clone: clone3,
  copy,
  create,
  crossLength,
  crossVZ,
  crossZV,
  distance: distance2,
  divide,
  dot,
  fromValues,
  getLineSegmentsIntersection,
  getLineSegmentsIntersectionFraction,
  length,
  lerp,
  multiply,
  negate: negate2,
  normalize,
  reflect,
  rotate,
  rotate90cw,
  scale: scale2,
  set,
  squaredDistance,
  squaredLength,
  str,
  subtract,
  toGlobalFrame,
  toLocalFrame,
  vectorToGlobalFrame,
  vectorToLocalFrame
});

class AABB {
  constructor(options) {
    if (options === undefined) {
      options = {};
    }
    this.lowerBound = options.lowerBound ? clone3(options.lowerBound) : create();
    this.upperBound = options.upperBound ? clone3(options.upperBound) : create();
  }
  setFromPoints(points, position, angle, skinSize) {
    if (angle === undefined) {
      angle = 0;
    }
    if (skinSize === undefined) {
      skinSize = 0;
    }
    const l2 = this.lowerBound;
    const u5 = this.upperBound;
    if (angle !== 0) {
      rotate(l2, points[0], angle);
    } else {
      copy(l2, points[0]);
    }
    copy(u5, l2);
    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);
    const len = points.length;
    for (let i2 = 1;i2 < len; i2++) {
      let p2 = points[i2];
      if (angle !== 0) {
        const x2 = p2[0], y2 = p2[1];
        tmp$1[0] = cosAngle * x2 - sinAngle * y2;
        tmp$1[1] = sinAngle * x2 + cosAngle * y2;
        p2 = tmp$1;
      }
      for (let j2 = 0;j2 < 2; j2++) {
        if (p2[j2] > u5[j2]) {
          u5[j2] = p2[j2];
        }
        if (p2[j2] < l2[j2]) {
          l2[j2] = p2[j2];
        }
      }
    }
    if (position) {
      add(l2, l2, position);
      add(u5, u5, position);
    }
    if (skinSize) {
      l2[0] -= skinSize;
      l2[1] -= skinSize;
      u5[0] += skinSize;
      u5[1] += skinSize;
    }
  }
  copy(aabb) {
    copy(this.lowerBound, aabb.lowerBound);
    copy(this.upperBound, aabb.upperBound);
  }
  extend(aabb) {
    const lower = this.lowerBound, upper = this.upperBound;
    let i2 = 2;
    while (i2--) {
      const l2 = aabb.lowerBound[i2];
      if (lower[i2] > l2) {
        lower[i2] = l2;
      }
      const u5 = aabb.upperBound[i2];
      if (upper[i2] < u5) {
        upper[i2] = u5;
      }
    }
  }
  overlaps(aabb) {
    const l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u22 = aabb.upperBound;
    return (l2[0] <= u1[0] && u1[0] <= u22[0] || l1[0] <= u22[0] && u22[0] <= u1[0]) && (l2[1] <= u1[1] && u1[1] <= u22[1] || l1[1] <= u22[1] && u22[1] <= u1[1]);
  }
  containsPoint(point) {
    const l2 = this.lowerBound, u5 = this.upperBound;
    return l2[0] <= point[0] && point[0] <= u5[0] && l2[1] <= point[1] && point[1] <= u5[1];
  }
  overlapsRay(ray) {
    const dirFracX = 1 / ray.direction[0];
    const dirFracY = 1 / ray.direction[1];
    const from = ray.from;
    const lowerBound = this.lowerBound;
    const upperBound = this.upperBound;
    const t1 = (lowerBound[0] - from[0]) * dirFracX;
    const t2 = (upperBound[0] - from[0]) * dirFracX;
    const t3 = (lowerBound[1] - from[1]) * dirFracY;
    const t4 = (upperBound[1] - from[1]) * dirFracY;
    const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
    const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));
    if (tmax < 0) {
      return -1;
    }
    if (tmin > tmax) {
      return -1;
    }
    return tmin / ray.length;
  }
}
var tmp$1 = create();
var tmpPoint1 = [0, 0];
var tmpPoint2 = [0, 0];
var tmpLine1 = [[0, 0], [0, 0]];
var tmpLine2 = [[0, 0], [0, 0]];

class Ray {
  static CLOSEST = 1;
  static ANY = 2;
  static ALL = 4;
  direction = create();
  length = 1;
  _currentBody = null;
  _currentShape = null;
  constructor(options) {
    if (options === undefined) {
      options = {};
    }
    this.from = options.from ? clone3(options.from) : create();
    this.to = options.to ? clone3(options.to) : create();
    this.checkCollisionResponse = options.checkCollisionResponse ?? true;
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionMask = options.collisionMask ?? -1;
    this.collisionGroup = options.collisionGroup ?? -1;
    this.mode = options.mode ?? Ray.ANY;
    this.callback = options?.callback || function() {
    };
    this.update();
  }
  update() {
    const d2 = this.direction;
    subtract(d2, this.to, this.from);
    this.length = length(d2);
    normalize(d2, d2);
  }
  intersectBodies(result, bodies) {
    for (let i2 = 0, l2 = bodies.length;!result.shouldStop(this) && i2 < l2; i2++) {
      const body = bodies[i2];
      const aabb = body.getAABB();
      if (aabb.overlapsRay(this) >= 0 || aabb.containsPoint(this.from)) {
        this.intersectBody(result, body);
      }
    }
  }
  intersectBody(result, body) {
    const checkCollisionResponse = this.checkCollisionResponse;
    if (checkCollisionResponse && !body.collisionResponse) {
      return;
    }
    const worldPosition = intersectBody_worldPosition;
    for (let i2 = 0, N2 = body.shapes.length;i2 < N2; i2++) {
      const shape = body.shapes[i2];
      if (checkCollisionResponse && !shape.collisionResponse) {
        continue;
      }
      if ((this.collisionGroup & shape.collisionMask) === 0 || (shape.collisionGroup & this.collisionMask) === 0) {
        continue;
      }
      rotate(worldPosition, shape.position, body.angle);
      add(worldPosition, worldPosition, body.position);
      const worldAngle = shape.angle + body.angle;
      this.intersectShape(result, shape, worldAngle, worldPosition, body);
      if (result.shouldStop(this)) {
        break;
      }
    }
  }
  intersectShape(result, shape, angle, position, body) {
    const from = this.from;
    const distance3 = distanceFromIntersectionSquared(from, this.direction, position);
    if (distance3 > shape.boundingRadius * shape.boundingRadius) {
      return;
    }
    this._currentBody = body;
    this._currentShape = shape;
    shape.raycast(result, this, position, angle);
    this._currentBody = this._currentShape = null;
  }
  getAABB(result) {
    const to = this.to;
    const from = this.from;
    set(result.lowerBound, Math.min(to[0], from[0]), Math.min(to[1], from[1]));
    set(result.upperBound, Math.max(to[0], from[0]), Math.max(to[1], from[1]));
  }
  reportIntersection(result, fraction, normal, faceIndex) {
    if (faceIndex === undefined) {
      faceIndex = -1;
    }
    const shape = this._currentShape;
    const body = this._currentBody;
    if (this.skipBackfaces && dot(normal, this.direction) > 0) {
      return;
    }
    switch (this.mode) {
      case Ray.ALL:
        result.set(normal, shape, body, fraction, faceIndex);
        this.callback(result);
        break;
      case Ray.CLOSEST:
        if (fraction < result.fraction || !result.hasHit()) {
          result.set(normal, shape, body, fraction, faceIndex);
        }
        break;
      case Ray.ANY:
        result.set(normal, shape, body, fraction, faceIndex);
        break;
    }
  }
}
var v0 = create();
var intersect = create();
var intersectBody_worldPosition = create();

class RaycastResult {
  constructor() {
    this.normal = create();
    this.shape = null;
    this.body = null;
    this.faceIndex = -1;
    this.fraction = -1;
    this.isStopped = false;
  }
  reset() {
    set(this.normal, 0, 0);
    this.shape = null;
    this.body = null;
    this.faceIndex = -1;
    this.fraction = -1;
    this.isStopped = false;
  }
  getHitDistance(ray) {
    return distance2(ray.from, ray.to) * this.fraction;
  }
  hasHit() {
    return this.fraction !== -1;
  }
  getHitPoint(out, ray) {
    return lerp(out, ray.from, ray.to, this.fraction);
  }
  stop() {
    this.isStopped = true;
  }
  shouldStop(ray) {
    return this.isStopped || this.fraction !== -1 && ray.mode === Ray.ANY;
  }
  set(normal, shape, body, fraction, faceIndex) {
    copy(this.normal, normal);
    this.shape = shape;
    this.body = body;
    this.fraction = fraction;
    this.faceIndex = faceIndex;
  }
}

class EventEmitter {
  listeners = {};
  on(type, listener) {
    let listeners = this.listeners[type];
    if (listeners === undefined) {
      listeners = [];
      this.listeners[type] = listeners;
    }
    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
    return this;
  }
  off(type, listener) {
    const listeners = this.listeners[type];
    if (listeners) {
      const index2 = listeners.indexOf(listener);
      if (index2 !== -1) {
        listeners.splice(index2, 1);
      }
    }
    return this;
  }
  has(type, listener) {
    const listeners = this.listeners[type];
    if (!listener) {
      return listeners !== undefined;
    }
    return listeners !== undefined && listeners.indexOf(listener) !== -1;
  }
  emit(event) {
    if (this.listeners === undefined) {
      return this;
    }
    const eventListeners = this.listeners[event.type];
    if (eventListeners !== undefined) {
      for (const listener of [...eventListeners]) {
        listener(event);
      }
    }
    return this;
  }
}

class Shape {
  body = null;
  position = create();
  boundingRadius = 0;
  area = 0;
  static idCounter = 0;
  static CIRCLE = 1;
  static PARTICLE = 2;
  static PLANE = 4;
  static CONVEX = 8;
  static LINE = 16;
  static BOX = 32;
  static CAPSULE = 64;
  static HEIGHTFIELD = 128;
  constructor(options) {
    this.id = Shape.idCounter++;
    this.body = null;
    if (options.position) {
      copy(this.position, options.position);
    }
    this.type = options.type;
    this.angle = options.angle ?? 0;
    this.collisionGroup = options.collisionGroup ?? 1;
    this.collisionResponse = options.collisionResponse ?? true;
    this.collisionMask = options.collisionMask ?? 1;
    this.sensor = options.sensor ?? false;
    this.material = options.material ?? null;
  }
  updateBoundingRadius() {
  }
  updateArea() {
  }
  raycast(_result, _ray, _position, _angle) {
  }
  pointTest(_localPoint) {
    return false;
  }
  worldPointToLocal(out, worldPoint) {
    const body = this.body;
    rotate(shapeWorldPosition, this.position, body.angle);
    add(shapeWorldPosition, shapeWorldPosition, body.position);
    toLocalFrame(out, worldPoint, shapeWorldPosition, this.body.angle + this.angle);
    return out;
  }
}
var shapeWorldPosition = create();

class Convex extends Shape {
  constructor(options) {
    if (options === undefined) {
      options = {};
    }
    const params = {
      ...options,
      type: options.type ?? Shape.CONVEX,
      vertices: options.vertices ?? [],
      axes: options.axes ?? []
    };
    super(params);
    this.axes = params.axes;
    this.vertices = [];
    for (let i2 = 0;i2 < params.vertices.length; i2++) {
      this.vertices.push(clone3(params.vertices[i2]));
    }
    this.normals = [];
    for (let i2 = 0;i2 < params.vertices.length; i2++) {
      this.normals.push(create());
    }
    this.updateNormals();
    this.centerOfMass = create();
    this.triangles = [];
    if (this.vertices.length) {
      this.updateTriangles();
      this.updateCenterOfMass();
    }
    this.boundingRadius = 0;
    this.updateBoundingRadius();
    this.updateArea();
    if (this.area < 0) {
      throw new Error("Convex vertices must be given in counter-clockwise winding.");
    }
  }
  updateNormals() {
    for (let i2 = 0;i2 < this.vertices.length; i2++) {
      const worldPoint0 = this.vertices[i2];
      const worldPoint1 = this.vertices[(i2 + 1) % this.vertices.length];
      const normal = this.normals[i2];
      subtract(normal, worldPoint1, worldPoint0);
      rotate90cw(normal, normal);
      normalize(normal, normal);
    }
  }
  projectOntoLocalAxis(localAxis, result) {
    let max = 0;
    let min = 0;
    localAxis = tmpVec1;
    for (let i2 = 0;i2 < this.vertices.length; i2++) {
      const v3 = this.vertices[i2];
      const value = dot(v3, localAxis);
      if (max === null || value > max) {
        max = value;
      }
      if (min === null || value < min) {
        min = value;
      }
    }
    if (min > max) {
      const t2 = min;
      min = max;
      max = t2;
    }
    set(result, min, max);
  }
  projectOntoWorldAxis(localAxis, shapeOffset, shapeAngle, result) {
    let worldAxis = tmpVec2;
    this.projectOntoLocalAxis(localAxis, result);
    if (shapeAngle !== 0) {
      rotate(worldAxis, localAxis, shapeAngle);
    } else {
      worldAxis = localAxis;
    }
    const offset = dot(shapeOffset, worldAxis);
    set(result, result[0] + offset, result[1] + offset);
  }
  updateTriangles() {
    this.triangles.length = 0;
    const polykVerts = [];
    for (let i2 = 0;i2 < this.vertices.length; i2++) {
      const v3 = this.vertices[i2];
      polykVerts.push(v3[0], v3[1]);
    }
    const triangles = triangulate(polykVerts);
    const l2 = triangles.length;
    for (let i2 = 0;i2 < l2; i2 += 3) {
      const id1 = triangles[i2], id2 = triangles[i2 + 1], id3 = triangles[i2 + 2];
      this.triangles.push([id1, id2, id3]);
    }
  }
  updateCenterOfMass() {
    const triangles = this.triangles, verts = this.vertices, cm = this.centerOfMass, centroid$1 = updateCenterOfMass_centroid;
    let a2 = updateCenterOfMass_a, b2 = updateCenterOfMass_b, c2 = updateCenterOfMass_c;
    const centroid_times_mass = updateCenterOfMass_centroid_times_mass;
    set(cm, 0, 0);
    let totalArea = 0;
    const l2 = triangles.length;
    for (let i2 = 0;i2 !== l2; i2++) {
      const t2 = triangles[i2];
      a2 = verts[t2[0]], b2 = verts[t2[1]], c2 = verts[t2[2]];
      centroid(centroid$1, a2, b2, c2);
      const m2 = Convex.triangleArea(a2, b2, c2);
      totalArea += m2;
      scale2(centroid_times_mass, centroid$1, m2);
      add(cm, cm, centroid_times_mass);
    }
    scale2(cm, cm, 1 / totalArea);
  }
  computeMomentOfInertia() {
    let denom = 0, numer = 0;
    const N2 = this.vertices.length;
    for (let j2 = N2 - 1, i2 = 0;i2 < N2; j2 = i2, i2++) {
      const p0 = this.vertices[j2];
      const p1 = this.vertices[i2];
      const a2 = Math.abs(crossLength(p0, p1));
      const b2 = dot(p1, p1) + dot(p1, p0) + dot(p0, p0);
      denom += a2 * b2;
      numer += a2;
    }
    return 1 / 6 * (denom / numer);
  }
  updateBoundingRadius() {
    const verts = this.vertices;
    let r2 = 0;
    const l2 = verts.length;
    for (let i2 = 0;i2 !== l2; i2++) {
      const l22 = squaredLength(verts[i2]);
      if (l22 > r2) {
        r2 = l22;
      }
    }
    this.boundingRadius = Math.sqrt(r2);
  }
  updateArea() {
    this.updateTriangles();
    this.area = 0;
    const triangles = this.triangles, verts = this.vertices;
    const l2 = triangles.length;
    for (let i2 = 0;i2 !== l2; i2++) {
      const t2 = triangles[i2], a2 = verts[t2[0]], b2 = verts[t2[1]], c2 = verts[t2[2]];
      const m2 = Convex.triangleArea(a2, b2, c2);
      this.area += m2;
    }
  }
  computeAABB(out, position, angle) {
    out.setFromPoints(this.vertices, position, angle, 0);
  }
  raycast(result, ray, position, angle) {
    const rayStart = intersectConvex_rayStart;
    const rayEnd = intersectConvex_rayEnd;
    const normal = intersectConvex_normal;
    const vertices = this.vertices;
    toLocalFrame(rayStart, ray.from, position, angle);
    toLocalFrame(rayEnd, ray.to, position, angle);
    const n2 = vertices.length;
    for (let i2 = 0;i2 < n2 && !result.shouldStop(ray); i2++) {
      const q1 = vertices[i2];
      const q2 = vertices[(i2 + 1) % n2];
      const delta = getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);
      if (delta >= 0) {
        subtract(normal, q2, q1);
        rotate(normal, normal, -Math.PI / 2 + angle);
        normalize(normal, normal);
        ray.reportIntersection(result, delta, normal, i2);
      }
    }
  }
  pointTest(localPoint) {
    const r0 = pic_r0, r1 = pic_r1, verts = this.vertices, numVerts = verts.length;
    let lastCross = null;
    for (let i2 = 0;i2 < numVerts + 1; i2++) {
      const v02 = verts[i2 % numVerts], v1 = verts[(i2 + 1) % numVerts];
      subtract(r0, v02, localPoint);
      subtract(r1, v1, localPoint);
      const cross = crossLength(r0, r1);
      if (lastCross === null) {
        lastCross = cross;
      }
      if (cross * lastCross < 0) {
        return false;
      }
      lastCross = cross;
    }
    return true;
  }
  static triangleArea(a2, b2, c2) {
    return ((b2[0] - a2[0]) * (c2[1] - a2[1]) - (c2[0] - a2[0]) * (b2[1] - a2[1])) * 0.5;
  }
}
var tmpVec1 = create();
var tmpVec2 = create();
var updateCenterOfMass_centroid = create();
var updateCenterOfMass_centroid_times_mass = create();
var updateCenterOfMass_a = create();
var updateCenterOfMass_b = create();
var updateCenterOfMass_c = create();
var intersectConvex_rayStart = create();
var intersectConvex_rayEnd = create();
var intersectConvex_normal = create();
var pic_r0 = create();
var pic_r1 = create();

class Body extends EventEmitter {
  static DYNAMIC = 1;
  static STATIC = 2;
  static KINEMATIC = 4;
  static AWAKE = 0;
  static SLEEPY = 1;
  static SLEEPING = 2;
  static _idCounter = 0;
  world = null;
  constructor(options) {
    if (options === undefined) {
      options = {};
    }
    super();
    this.id = options.id || ++Body._idCounter;
    this.index = -1;
    this.shapes = [];
    this.mass = options.mass || 0;
    this.invMass = 0;
    this.inertia = 0;
    this.invInertia = 0;
    this.invMassSolve = 0;
    this.invInertiaSolve = 0;
    this.fixedRotation = !!options.fixedRotation;
    this.fixedX = !!options.fixedX;
    this.fixedY = !!options.fixedY;
    this.massMultiplier = create();
    this.position = options.position ? clone3(options.position) : create();
    this.interpolatedPosition = clone3(this.position);
    this.previousPosition = clone3(this.position);
    this.velocity = options.velocity ? clone3(options.velocity) : create();
    this.vlambda = create();
    this.wlambda = 0;
    this.angle = options.angle || 0;
    this.previousAngle = this.angle;
    this.interpolatedAngle = this.angle;
    this.angularVelocity = options.angularVelocity || 0;
    this.force = options.force ? clone3(options.force) : create();
    this.angularForce = options.angularForce || 0;
    this.damping = options.damping ?? 0.1;
    this.angularDamping = options.angularDamping ?? 0.1;
    this.type = Body.STATIC;
    if (options.type !== undefined) {
      this.type = options.type;
    } else if (!options.mass) {
      this.type = Body.STATIC;
    } else {
      this.type = Body.DYNAMIC;
    }
    this.boundingRadius = 0;
    this.aabb = new AABB;
    this.aabbNeedsUpdate = true;
    this.allowSleep = options.allowSleep ?? true;
    this.wantsToSleep = false;
    this.sleepState = Body.AWAKE;
    this.sleepSpeedLimit = options.sleepSpeedLimit ?? 0.2;
    this.sleepTimeLimit = options.sleepTimeLimit ?? 1;
    this.idleTime = 0;
    this.timeLastSleepy = 0;
    this.collisionResponse = options.collisionResponse ?? true;
    this.ccdSpeedThreshold = options.ccdSpeedThreshold ?? -1;
    this.ccdIterations = options.ccdIterations ?? 10;
    this.gravityScale = options.gravityScale ?? 1;
    this.islandId = -1;
    this.concavePath = null;
    this._wakeUpAfterNarrowphase = false;
    this.updateMassProperties();
  }
  updateSolveMassProperties() {
    if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
      this.invMassSolve = 0;
      this.invInertiaSolve = 0;
    } else {
      this.invMassSolve = this.invMass;
      this.invInertiaSolve = this.invInertia;
    }
  }
  setDensity(density) {
    const totalArea = this.getArea();
    this.mass = totalArea * density;
    this.updateMassProperties();
  }
  getArea() {
    let totalArea = 0;
    for (let i2 = 0;i2 < this.shapes.length; i2++) {
      totalArea += this.shapes[i2].area;
    }
    return totalArea;
  }
  getAABB() {
    if (this.aabbNeedsUpdate) {
      this.updateAABB();
    }
    return this.aabb;
  }
  updateAABB() {
    const shapes = this.shapes, N2 = shapes.length, offset = updateAABB_tmp, bodyAngle = this.angle;
    for (let i2 = 0;i2 !== N2; i2++) {
      const shape = shapes[i2], angle = shape.angle + bodyAngle;
      toGlobalFrame(offset, shape.position, this.position, bodyAngle);
      shape.computeAABB(updateAABB_shapeAABB, offset, angle);
      if (i2 === 0) {
        this.aabb.copy(updateAABB_shapeAABB);
      } else {
        this.aabb.extend(updateAABB_shapeAABB);
      }
    }
    this.aabbNeedsUpdate = false;
  }
  updateBoundingRadius() {
    const shapes = this.shapes;
    const N2 = shapes.length;
    let radius = 0;
    for (let i2 = 0;i2 !== N2; i2++) {
      const shape = shapes[i2], offset = length(shape.position), r2 = shape.boundingRadius;
      if (offset + r2 > radius) {
        radius = offset + r2;
      }
    }
    this.boundingRadius = radius;
  }
  addShape(shape, offset, angle) {
    if (shape.body) {
      throw new Error("A shape can only be added to one body.");
    }
    const world = this.world;
    if (world && world.stepping) {
      throw new Error("A shape cannot be added during step.");
    }
    shape.body = this;
    if (offset) {
      copy(shape.position, offset);
    } else {
      set(shape.position, 0, 0);
    }
    shape.angle = angle || 0;
    this.shapes.push(shape);
    this.updateMassProperties();
    this.updateBoundingRadius();
    this.aabbNeedsUpdate = true;
  }
  removeShape(shape) {
    const world = this.world;
    if (world && world.stepping) {
      throw new Error("A shape cannot be removed during step.");
    }
    const l2 = this.shapes.length;
    const shapes = this.shapes;
    for (let i2 = 0;i2 < l2; i2++) {
      if (shapes[i2] === shape) {
        shapes.splice(i2, 1);
        this.aabbNeedsUpdate = true;
        shape.body = null;
        return true;
      }
    }
    return false;
  }
  updateMassProperties() {
    if (this.type === Body.STATIC || this.type === Body.KINEMATIC) {
      this.mass = Number.MAX_VALUE;
      this.invMass = 0;
      this.inertia = Number.MAX_VALUE;
      this.invInertia = 0;
    } else {
      const shapes = this.shapes;
      const N2 = shapes.length;
      let I2 = 0;
      if (!this.fixedRotation) {
        for (let i2 = 0;i2 < N2; i2++) {
          const shape = shapes[i2], r2 = squaredLength(shape.position), Icm = shape.computeMomentOfInertia();
          I2 += Icm + r2;
        }
        this.inertia = this.mass * I2;
        this.invInertia = I2 > 0 ? 1 / I2 : 0;
      } else {
        this.inertia = Number.MAX_VALUE;
        this.invInertia = 0;
      }
      this.invMass = 1 / this.mass;
      set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1);
    }
  }
  applyForce(force, relativePoint) {
    add(this.force, this.force, force);
    if (relativePoint) {
      const rotForce = crossLength(relativePoint, force);
      this.angularForce += rotForce;
    }
  }
  applyForceLocal(localForce, localPoint) {
    localPoint = localPoint || applyForce_pointLocal;
    const worldForce = applyForce_forceWorld;
    const worldPoint = applyForce_pointWorld;
    this.vectorToWorldFrame(worldForce, localForce);
    this.vectorToWorldFrame(worldPoint, localPoint);
    this.applyForce(worldForce, worldPoint);
  }
  applyImpulse(impulseVector, relativePoint) {
    if (this.type !== Body.DYNAMIC) {
      return;
    }
    const velo = applyImpulse_velo;
    scale2(velo, impulseVector, this.invMass);
    multiply(velo, this.massMultiplier, velo);
    add(this.velocity, velo, this.velocity);
    if (relativePoint) {
      let rotVelo = crossLength(relativePoint, impulseVector);
      rotVelo *= this.invInertia;
      this.angularVelocity += rotVelo;
    }
  }
  applyImpulseLocal(localImpulse, localPoint) {
    localPoint = localPoint || applyImpulse_pointLocal;
    const worldImpulse = applyImpulse_impulseWorld;
    const worldPoint = applyImpulse_pointWorld;
    this.vectorToWorldFrame(worldImpulse, localImpulse);
    this.vectorToWorldFrame(worldPoint, localPoint);
    this.applyImpulse(worldImpulse, worldPoint);
  }
  toLocalFrame(out, worldPoint) {
    toLocalFrame(out, worldPoint, this.position, this.angle);
  }
  toWorldFrame(out, localPoint) {
    toGlobalFrame(out, localPoint, this.position, this.angle);
  }
  vectorToLocalFrame(out, worldVector) {
    vectorToLocalFrame(out, worldVector, this.angle);
  }
  vectorToWorldFrame(out, localVector) {
    vectorToGlobalFrame(out, localVector, this.angle);
  }
  fromPolygon(path, options) {
    if (options === undefined) {
      options = {};
    }
    for (let i2 = this.shapes.length;i2 >= 0; --i2) {
      this.removeShape(this.shapes[i2]);
    }
    const p2 = [];
    const l2 = path.length;
    for (let i2 = 0;i2 < l2; i2++) {
      p2[i2] = clone3(path[i2]);
    }
    makeCCW(p2);
    if (options.removeCollinearPoints !== undefined) {
      if (typeof options.removeCollinearPoints === "boolean") {
        if (options.removeCollinearPoints === true) {
          removeCollinearPoints(p2);
        }
      } else {
        removeCollinearPoints(p2, options.removeCollinearPoints);
      }
    }
    if (!options.skipSimpleCheck) {
      if (!isSimple(p2)) {
        return false;
      }
    }
    const concavePath = this.concavePath = [];
    const pl = p2.length;
    for (let i2 = 0;i2 < pl; i2++) {
      concavePath[i2] = clone3(p2[i2]);
    }
    let convexes;
    if (options.optimalDecomp) {
      convexes = decomp(p2);
      if (convexes === false) {
        throw new Error("Convex decomposition failed!");
      }
    } else {
      convexes = quickDecomp(p2);
    }
    const cm = create();
    const convexL = convexes.length;
    for (let i2 = 0;i2 !== convexL; i2++) {
      let c2 = new Convex({
        vertices: convexes[i2]
      });
      const vertsL = c2.vertices.length;
      for (let j2 = 0;j2 !== vertsL; j2++) {
        const v3 = c2.vertices[j2];
        subtract(v3, v3, c2.centerOfMass);
      }
      copy(cm, c2.centerOfMass);
      c2 = new Convex({
        vertices: c2.vertices
      });
      this.addShape(c2, cm);
    }
    this.adjustCenterOfMass();
    this.aabbNeedsUpdate = true;
    return true;
  }
  adjustCenterOfMass() {
    const offset_times_area = adjustCenterOfMass_tmp2;
    const sum2 = adjustCenterOfMass_tmp3;
    const cm = adjustCenterOfMass_tmp4;
    let totalArea = 0;
    set(sum2, 0, 0);
    for (let i2 = 0;i2 !== this.shapes.length; i2++) {
      const s2 = this.shapes[i2];
      scale2(offset_times_area, s2.position, s2.area);
      add(sum2, sum2, offset_times_area);
      totalArea += s2.area;
    }
    scale2(cm, sum2, 1 / totalArea);
    for (let i2 = 0;i2 !== this.shapes.length; i2++) {
      const s2 = this.shapes[i2];
      subtract(s2.position, s2.position, cm);
    }
    add(this.position, this.position, cm);
    for (let i2 = 0;this.concavePath && i2 < this.concavePath.length; i2++) {
      subtract(this.concavePath[i2], this.concavePath[i2], cm);
    }
    this.updateMassProperties();
    this.updateBoundingRadius();
  }
  setZeroForce() {
    const f2 = this.force;
    f2[0] = f2[1] = this.angularForce = 0;
  }
  applyDamping(dt) {
    if (this.type === Body.DYNAMIC) {
      const v3 = this.velocity;
      scale2(v3, v3, Math.pow(1 - this.damping, dt));
      this.angularVelocity *= Math.pow(1 - this.angularDamping, dt);
    }
  }
  wakeUp() {
    const s2 = this.sleepState;
    this.sleepState = Body.AWAKE;
    this.idleTime = 0;
    if (s2 !== Body.AWAKE) {
      this.emit({
        type: "wakeup"
      });
    }
  }
  sleep() {
    this.sleepState = Body.SLEEPING;
    this.angularVelocity = this.angularForce = 0;
    set(this.velocity, 0, 0);
    set(this.force, 0, 0);
    this.emit({
      type: "sleep"
    });
  }
  sleepTick(time, dontSleep, dt) {
    if (!this.allowSleep || this.type === Body.SLEEPING) {
      return;
    }
    this.wantsToSleep = false;
    const speedSquared = squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2), speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);
    if (speedSquared >= speedLimitSquared) {
      this.idleTime = 0;
      this.sleepState = Body.AWAKE;
    } else {
      this.idleTime += dt;
      if (this.sleepState !== Body.SLEEPY) {
        this.sleepState = Body.SLEEPY;
        this.emit({
          type: "sleepy"
        });
      }
    }
    if (this.idleTime > this.sleepTimeLimit) {
      if (!dontSleep) {
        this.sleep();
      } else {
        this.wantsToSleep = true;
      }
    }
  }
  overlaps(body) {
    if (this.world === null) {
      return false;
    }
    return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
  }
  integrate(dt) {
    const minv = this.invMass, f2 = this.force, pos = this.position, velo = this.velocity;
    copy(this.previousPosition, this.position);
    this.previousAngle = this.angle;
    if (!this.fixedRotation) {
      this.angularVelocity += this.angularForce * this.invInertia * dt;
    }
    scale2(integrate_fhMinv, f2, dt * minv);
    multiply(integrate_fhMinv, this.massMultiplier, integrate_fhMinv);
    add(velo, integrate_fhMinv, velo);
    if (!this.integrateToTimeOfImpact(dt)) {
      scale2(integrate_velodt, velo, dt);
      add(pos, pos, integrate_velodt);
      if (!this.fixedRotation) {
        this.angle += this.angularVelocity * dt;
      }
    }
    this.aabbNeedsUpdate = true;
  }
  getVelocityAtPoint(result, relativePoint) {
    crossVZ(result, relativePoint, this.angularVelocity);
    subtract(result, this.velocity, result);
    return result;
  }
  integrateToTimeOfImpact(dt) {
    if (this.world === null) {
      throw new Error("world is not set for body");
    }
    if (this.ccdSpeedThreshold < 0 || squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) {
      return false;
    }
    const ignoreBodies = [];
    const disabledPairs = this.world.disabledBodyCollisionPairs;
    const l2 = disabledPairs.length;
    for (let i2 = 0;i2 < l2; i2 += 2) {
      const bodyA = disabledPairs[i2];
      const bodyB = disabledPairs[i2 + 1];
      if (bodyA === this) {
        ignoreBodies.push(bodyB);
      } else if (bodyB === this) {
        ignoreBodies.push(bodyA);
      }
    }
    normalize(integrateToTimeOfImpact_direction, this.velocity);
    scale2(integrateToTimeOfImpact_end, this.velocity, dt);
    add(integrateToTimeOfImpact_end, integrateToTimeOfImpact_end, this.position);
    subtract(integrateToTimeOfImpact_startToEnd, integrateToTimeOfImpact_end, this.position);
    const startToEndAngle = this.angularVelocity * dt;
    const len = length(integrateToTimeOfImpact_startToEnd);
    let timeOfImpact = 1;
    let hitBody = null;
    copy(integrateToTimeOfImpact_ray.from, this.position);
    copy(integrateToTimeOfImpact_ray.to, integrateToTimeOfImpact_end);
    integrateToTimeOfImpact_ray.update();
    for (let i2 = 0;i2 < this.shapes.length; i2++) {
      const shape = this.shapes[i2];
      integrateToTimeOfImpact_result.reset();
      integrateToTimeOfImpact_ray.collisionGroup = shape.collisionGroup;
      integrateToTimeOfImpact_ray.collisionMask = shape.collisionMask;
      this.world.raycast(integrateToTimeOfImpact_result, integrateToTimeOfImpact_ray);
      hitBody = integrateToTimeOfImpact_result.body;
      if (hitBody !== null && (hitBody === this || ignoreBodies.indexOf(hitBody) !== -1)) {
        hitBody = null;
      }
      if (hitBody) {
        break;
      }
    }
    if (!hitBody || !timeOfImpact) {
      return false;
    }
    integrateToTimeOfImpact_result.getHitPoint(integrateToTimeOfImpact_end, integrateToTimeOfImpact_ray);
    subtract(integrateToTimeOfImpact_startToEnd, integrateToTimeOfImpact_end, this.position);
    timeOfImpact = distance2(integrateToTimeOfImpact_end, this.position) / len;
    const rememberAngle = this.angle;
    copy(integrateToTimeOfImpact_rememberPosition, this.position);
    let iter = 0;
    let tmin = 0;
    let tmid = timeOfImpact;
    let tmax = 1;
    while (tmax >= tmin && iter < this.ccdIterations) {
      iter++;
      tmid = (tmax + tmin) / 2;
      scale2(integrate_velodt, integrateToTimeOfImpact_startToEnd, tmid);
      add(this.position, integrateToTimeOfImpact_rememberPosition, integrate_velodt);
      this.angle = rememberAngle + startToEndAngle * tmid;
      this.updateAABB();
      const overlaps = this.aabb.overlaps(hitBody.aabb) && this.world.narrowphase.bodiesOverlap(this, hitBody, true);
      if (overlaps) {
        tmax = tmid;
      } else {
        tmin = tmid;
      }
    }
    timeOfImpact = tmax;
    copy(this.position, integrateToTimeOfImpact_rememberPosition);
    this.angle = rememberAngle;
    scale2(integrate_velodt, integrateToTimeOfImpact_startToEnd, timeOfImpact);
    add(this.position, this.position, integrate_velodt);
    if (!this.fixedRotation) {
      this.angle += startToEndAngle * timeOfImpact;
    }
    return true;
  }
  resetConstraintVelocity() {
    const vlambda = this.vlambda;
    set(vlambda, 0, 0);
    this.wlambda = 0;
  }
  addConstraintVelocity() {
    const v3 = this.velocity;
    add(v3, v3, this.vlambda);
    this.angularVelocity += this.wlambda;
  }
}
var updateAABB_shapeAABB = new AABB;
var updateAABB_tmp = create();
var applyForce_forceWorld = create();
var applyForce_pointWorld = create();
var applyForce_pointLocal = create();
var applyImpulse_velo = create();
var applyImpulse_impulseWorld = create();
var applyImpulse_pointWorld = create();
var applyImpulse_pointLocal = create();
var adjustCenterOfMass_tmp2 = create();
var adjustCenterOfMass_tmp3 = create();
var adjustCenterOfMass_tmp4 = create();
var integrate_fhMinv = create();
var integrate_velodt = create();
var integrateToTimeOfImpact_result = new RaycastResult;
var integrateToTimeOfImpact_ray = new Ray({
  mode: Ray.CLOSEST,
  skipBackfaces: true
});
var integrateToTimeOfImpact_direction = create();
var integrateToTimeOfImpact_end = create();
var integrateToTimeOfImpact_startToEnd = create();
var integrateToTimeOfImpact_rememberPosition = create();

class Broadphase {
  static AABB = 1;
  static BOUNDING_CIRCLE = 2;
  static NAIVE = 1;
  static SAP = 2;
  static boundingRadiusCheck(bodyA, bodyB) {
    const d2 = squaredDistance(bodyA.position, bodyB.position), r2 = bodyA.boundingRadius + bodyB.boundingRadius;
    return d2 <= r2 * r2;
  }
  static aabbCheck(bodyA, bodyB) {
    return bodyA.getAABB().overlaps(bodyB.getAABB());
  }
  static canCollide(bodyA, bodyB) {
    const KINEMATIC = Body.KINEMATIC;
    const STATIC = Body.STATIC;
    const typeA = bodyA.type;
    const typeB = bodyB.type;
    if (typeA === STATIC && typeB === STATIC) {
      return false;
    }
    if (typeA === KINEMATIC && typeB === STATIC || typeA === STATIC && typeB === KINEMATIC) {
      return false;
    }
    if (typeA === KINEMATIC && typeB === KINEMATIC) {
      return false;
    }
    if (bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING) {
      return false;
    }
    if (bodyA.sleepState === Body.SLEEPING && typeB === STATIC || bodyB.sleepState === Body.SLEEPING && typeA === STATIC) {
      return false;
    }
    return true;
  }
  constructor(type) {
    this.type = type;
    this.result = [];
    this.world = undefined;
    this.boundingVolumeType = Broadphase.AABB;
  }
  setWorld(world) {
    this.world = world;
  }
  boundingVolumeCheck(bodyA, bodyB) {
    switch (this.boundingVolumeType) {
      case Broadphase.BOUNDING_CIRCLE:
        return Broadphase.boundingRadiusCheck(bodyA, bodyB);
      case Broadphase.AABB:
        return Broadphase.aabbCheck(bodyA, bodyB);
      default:
        throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType);
    }
  }
}
class Box extends Convex {
  constructor(options) {
    if (options === undefined) {
      options = {};
    }
    const params = {
      ...options,
      type: Shape.BOX,
      width: options.width ?? 1,
      height: options.height ?? 1
    };
    const verts = [fromValues(-params.width / 2, -params.height / 2), fromValues(params.width / 2, -params.height / 2), fromValues(params.width / 2, params.height / 2), fromValues(-params.width / 2, params.height / 2)];
    const convexOptions = {
      ...options,
      vertices: verts
    };
    super(convexOptions);
    this.width = params.width;
    this.height = params.height;
    this.updateBoundingRadius();
    this.updateArea();
  }
  computeMomentOfInertia() {
    const w2 = this.width;
    const h2 = this.height;
    return (h2 * h2 + w2 * w2) / 12;
  }
  updateBoundingRadius() {
    const w2 = this.width, h2 = this.height;
    this.boundingRadius = Math.sqrt(w2 * w2 + h2 * h2) / 2;
  }
  computeAABB(out, position, angle) {
    const c2 = Math.abs(Math.cos(angle));
    const s2 = Math.abs(Math.sin(angle));
    const w2 = this.width;
    const h2 = this.height;
    const height = (w2 * s2 + h2 * c2) * 0.5;
    const width = (h2 * s2 + w2 * c2) * 0.5;
    const l2 = out.lowerBound;
    const u5 = out.upperBound;
    const px = position[0];
    const py = position[1];
    l2[0] = px - width;
    l2[1] = py - height;
    u5[0] = px + width;
    u5[1] = py + height;
  }
  updateArea() {
    this.area = this.width * this.height;
  }
  pointTest(localPoint) {
    return Math.abs(localPoint[0]) <= this.width * 0.5 && Math.abs(localPoint[1]) <= this.height * 0.5;
  }
}

class Circle extends Shape {
  constructor(options) {
    if (options === undefined) {
      options = {};
    }
    const params = {
      ...options,
      type: Shape.CIRCLE,
      radius: options.radius ?? 1
    };
    super(params);
    this.radius = params.radius;
    this.updateBoundingRadius();
    this.updateArea();
  }
  updateBoundingRadius() {
    this.boundingRadius = this.radius;
  }
  computeMomentOfInertia() {
    const r2 = this.radius;
    return r2 * r2 / 2;
  }
  updateArea() {
    this.area = Math.PI * this.radius * this.radius;
  }
  computeAABB(out, position) {
    const r2 = this.radius;
    set(out.upperBound, r2, r2);
    set(out.lowerBound, -r2, -r2);
    if (position) {
      add(out.lowerBound, out.lowerBound, position);
      add(out.upperBound, out.upperBound, position);
    }
  }
  raycast(result, ray, position) {
    const from = ray.from;
    const to = ray.to;
    const r2 = this.radius;
    const a2 = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
    const b2 = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
    const c2 = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r2, 2);
    const delta = Math.pow(b2, 2) - 4 * a2 * c2;
    const intersectionPoint = Ray_intersectSphere_intersectionPoint;
    const normal = Ray_intersectSphere_normal;
    if (delta < 0) {
      return;
    } else if (delta === 0) {
      lerp(intersectionPoint, from, to, delta);
      subtract(normal, intersectionPoint, position);
      normalize(normal, normal);
      ray.reportIntersection(result, delta, normal, -1);
    } else {
      const sqrtDelta = Math.sqrt(delta);
      const inv2a = 1 / (2 * a2);
      const d1 = (-b2 - sqrtDelta) * inv2a;
      const d2 = (-b2 + sqrtDelta) * inv2a;
      if (d1 >= 0 && d1 <= 1) {
        lerp(intersectionPoint, from, to, d1);
        subtract(normal, intersectionPoint, position);
        normalize(normal, normal);
        ray.reportIntersection(result, d1, normal, -1);
        if (result.shouldStop(ray)) {
          return;
        }
      }
      if (d2 >= 0 && d2 <= 1) {
        lerp(intersectionPoint, from, to, d2);
        subtract(normal, intersectionPoint, position);
        normalize(normal, normal);
        ray.reportIntersection(result, d2, normal, -1);
      }
    }
  }
  pointTest(localPoint) {
    const radius = this.radius;
    return squaredLength(localPoint) <= radius * radius;
  }
}
var Ray_intersectSphere_intersectionPoint = create();
var Ray_intersectSphere_normal = create();

class Equation {
  static DEFAULT_STIFFNESS = 1e6;
  static DEFAULT_RELAXATION = 4;
  constructor(bodyA, bodyB, minForce, maxForce) {
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.minForce = minForce ?? -Number.MAX_VALUE;
    this.maxForce = maxForce ?? Number.MAX_VALUE;
    this.maxBias = Number.MAX_VALUE;
    this.stiffness = Equation.DEFAULT_STIFFNESS;
    this.relaxation = Equation.DEFAULT_RELAXATION;
    this.G = new ARRAY_TYPE(6);
    for (let i2 = 0;i2 < 6; i2++) {
      this.G[i2] = 0;
    }
    this.offset = 0;
    this.a = 0;
    this.b = 0;
    this.epsilon = 0;
    this.timeStep = 1 / 60;
    this.needsUpdate = true;
    this.multiplier = 0;
    this.relativeVelocity = 0;
    this.enabled = true;
    this.lambda = this.B = this.invC = this.minForceDt = this.maxForceDt = 0;
    this.index = -1;
  }
  update() {
    const k2 = this.stiffness, d2 = this.relaxation, h2 = this.timeStep;
    this.a = 4 / (h2 * (1 + 4 * d2));
    this.b = 4 * d2 / (1 + 4 * d2);
    this.epsilon = 4 / (h2 * h2 * k2 * (1 + 4 * d2));
    this.needsUpdate = false;
  }
  gmult(G2, vi, wi, vj, wj) {
    return G2[0] * vi[0] + G2[1] * vi[1] + G2[2] * wi + G2[3] * vj[0] + G2[4] * vj[1] + G2[5] * wj;
  }
  computeB(a2, b2, h2) {
    const GW = this.computeGW();
    let Gq = this.computeGq();
    const maxBias = this.maxBias;
    if (Math.abs(Gq) > maxBias) {
      Gq = Gq > 0 ? maxBias : -maxBias;
    }
    const GiMf = this.computeGiMf();
    const B3 = -Gq * a2 - GW * b2 - GiMf * h2;
    return B3;
  }
  computeGq() {
    const G2 = this.G, bi = this.bodyA, bj = this.bodyB, ai = bi.angle, aj = bj.angle;
    return this.gmult(G2, qi, ai, qj, aj) + this.offset;
  }
  computeGW() {
    const G2 = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
    return this.gmult(G2, vi, wi, vj, wj) + this.relativeVelocity;
  }
  computeGWlambda() {
    const G2 = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.vlambda, vj = bj.vlambda, wi = bi.wlambda, wj = bj.wlambda;
    return this.gmult(G2, vi, wi, vj, wj);
  }
  computeGiMf() {
    const bi = this.bodyA, bj = this.bodyB, fi = bi.force, ti = bi.angularForce, fj = bj.force, tj = bj.angularForce, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G2 = this.G;
    scale2(iMfi, fi, invMassi);
    multiply(iMfi, bi.massMultiplier, iMfi);
    scale2(iMfj, fj, invMassj);
    multiply(iMfj, bj.massMultiplier, iMfj);
    return this.gmult(G2, iMfi, ti * invIi, iMfj, tj * invIj);
  }
  computeGiMGt() {
    const bi = this.bodyA, bj = this.bodyB, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G2 = this.G;
    return G2[0] * G2[0] * invMassi * bi.massMultiplier[0] + G2[1] * G2[1] * invMassi * bi.massMultiplier[1] + G2[2] * G2[2] * invIi + G2[3] * G2[3] * invMassj * bj.massMultiplier[0] + G2[4] * G2[4] * invMassj * bj.massMultiplier[1] + G2[5] * G2[5] * invIj;
  }
  addToWlambda(deltalambda) {
    const bi = this.bodyA, bj = this.bodyB, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G2 = this.G;
    addToVLambda(bi.vlambda, G2[0], G2[1], invMassi, deltalambda, bi.massMultiplier);
    bi.wlambda += invIi * G2[2] * deltalambda;
    addToVLambda(bj.vlambda, G2[3], G2[4], invMassj, deltalambda, bj.massMultiplier);
    bj.wlambda += invIj * G2[5] * deltalambda;
  }
  computeInvC(eps) {
    const invC = 1 / (this.computeGiMGt() + eps);
    return invC;
  }
}
var qi = create();
var qj = create();
var iMfi = create();
var iMfj = create();
var vi = create();
var vj = create();
var relVel = create();
var tmpShape$1 = new Circle({
  radius: 1
});

class ContactEquation extends Equation {
  constructor(bodyA, bodyB) {
    super(bodyA, bodyB, 0, Number.MAX_VALUE);
    this.contactPointA = create();
    this.penetrationVec = create();
    this.contactPointB = create();
    this.normalA = create();
    this.restitution = 0;
    this.firstImpact = false;
    this.shapeA = tmpShape$1;
    this.shapeB = tmpShape$1;
  }
  computeB(a2, b2, h2) {
    const bi = this.bodyA, bj = this.bodyB, ri = this.contactPointA, rj = this.contactPointB, xi = bi.position, xj = bj.position;
    const n2 = this.normalA;
    const G2 = this.G;
    const rixn = crossLength(ri, n2);
    const rjxn = crossLength(rj, n2);
    G2[0] = -n2[0];
    G2[1] = -n2[1];
    G2[2] = -rixn;
    G2[3] = n2[0];
    G2[4] = n2[1];
    G2[5] = rjxn;
    let GW, Gq;
    if (this.firstImpact && this.restitution !== 0) {
      Gq = 0;
      GW = 1 / b2 * (1 + this.restitution) * this.computeGW();
    } else {
      const penetrationVec = this.penetrationVec;
      addSubSub(penetrationVec, xj, rj, xi, ri);
      Gq = dot(n2, penetrationVec) + this.offset;
      GW = this.computeGW();
    }
    const GiMf = this.computeGiMf();
    const B3 = -Gq * a2 - GW * b2 - h2 * GiMf;
    return B3;
  }
  getVelocityAlongNormal() {
    this.bodyA.getVelocityAtPoint(vi, this.contactPointA);
    this.bodyB.getVelocityAtPoint(vj, this.contactPointB);
    subtract(relVel, vi, vj);
    return dot(this.normalA, relVel);
  }
}

class Pool {
  objects = [];
  constructor(options) {
    if (options?.size !== undefined) {
      this.resize(options.size);
    }
  }
  resize(size) {
    const objects = this.objects;
    while (objects.length > size) {
      objects.pop();
    }
    while (objects.length < size) {
      objects.push(this.create());
    }
    return this;
  }
  get() {
    const objects = this.objects;
    return objects.length ? objects.pop() : this.create();
  }
  release(object) {
    this.destroy(object);
    this.objects.push(object);
    return this;
  }
}

class ContactEquationPool extends Pool {
  create() {
    return new ContactEquation(tmpBody$2, tmpBody$2);
  }
  destroy(equation) {
    equation.bodyA = equation.bodyB = tmpBody$2;
    return this;
  }
}
var tmpBody$2 = new Body;

class FrictionEquation extends Equation {
  constructor(bodyA, bodyB, slipForce) {
    if (slipForce === undefined) {
      slipForce = Number.MAX_VALUE;
    }
    super(bodyA, bodyB, -slipForce, slipForce);
    this.contactPointA = create();
    this.contactPointB = create();
    this.t = create();
    this.contactEquations = [];
    this.shapeA = null;
    this.shapeB = null;
    this.frictionCoefficient = 0.3;
  }
  setSlipForce(slipForce) {
    this.maxForce = slipForce;
    this.minForce = -slipForce;
  }
  getSlipForce() {
    return this.maxForce;
  }
  computeB(a2, b2, h2) {
    const ri = this.contactPointA, rj = this.contactPointB, t2 = this.t, G2 = this.G;
    G2[0] = -t2[0];
    G2[1] = -t2[1];
    G2[2] = -crossLength(ri, t2);
    G2[3] = t2[0];
    G2[4] = t2[1];
    G2[5] = crossLength(rj, t2);
    const GW = this.computeGW();
    const GiMf = this.computeGiMf();
    const B3 = -GW * b2 - h2 * GiMf;
    return B3;
  }
}

class FrictionEquationPool extends Pool {
  create() {
    return new FrictionEquation(tmpBody$1, tmpBody$1);
  }
  destroy(equation) {
    equation.bodyA = equation.bodyB = tmpBody$1;
    return this;
  }
}
var tmpBody$1 = new Body;

class TupleDictionary {
  data = {};
  keys = [];
  getKey(id1, id2) {
    id1 = id1 | 0;
    id2 = id2 | 0;
    if ((id1 | 0) === (id2 | 0)) {
      return -1;
    }
    return ((id1 | 0) > (id2 | 0) ? id1 << 16 | id2 & 65535 : id2 << 16 | id1 & 65535) | 0;
  }
  getByKey(key) {
    key = key | 0;
    return this.data[key];
  }
  get(i2, j2) {
    return this.data[this.getKey(i2, j2)];
  }
  set(i2, j2, value) {
    if (!value) {
      throw new Error("No data!");
    }
    const key = this.getKey(i2, j2);
    if (!this.data[key]) {
      this.keys.push(key);
    }
    this.data[key] = value;
    return key;
  }
  reset() {
    this.keys = [];
    this.data = {};
  }
  copy(dict) {
    this.keys = dict.keys;
    this.data = dict.data;
  }
}

class Narrowphase {
  constructor() {
    this.contactEquations = [];
    this.frictionEquations = [];
    this.enableFriction = true;
    this.enabledEquations = true;
    this.slipForce = 10;
    this.contactEquationPool = new ContactEquationPool({
      size: 32
    });
    this.frictionEquationPool = new FrictionEquationPool({
      size: 64
    });
    this.enableFrictionReduction = true;
    this.collidingBodiesLastStep = new TupleDictionary;
    this.currentContactMaterial = null;
  }
  bodiesOverlap(bodyA, bodyB, checkCollisionMasks) {
    const shapePositionA = bodiesOverlap_shapePositionA;
    const shapePositionB = bodiesOverlap_shapePositionB;
    for (let k2 = 0, Nshapesi = bodyA.shapes.length;k2 !== Nshapesi; k2++) {
      const shapeA = bodyA.shapes[k2];
      for (let l2 = 0, Nshapesj = bodyB.shapes.length;l2 !== Nshapesj; l2++) {
        const shapeB = bodyB.shapes[l2];
        if (checkCollisionMasks && !((shapeA.collisionGroup & shapeB.collisionMask) !== 0 && (shapeB.collisionGroup & shapeA.collisionMask) !== 0)) {
          return false;
        }
        bodyA.toWorldFrame(shapePositionA, shapeA.position);
        bodyB.toWorldFrame(shapePositionB, shapeB.position);
        if (shapeA.type <= shapeB.type) {
          if (this.narrowphases[shapeA.type | shapeB.type](bodyA, shapeA, shapePositionA, shapeA.angle + bodyA.angle, bodyB, shapeB, shapePositionB, shapeB.angle + bodyB.angle, true)) {
            return true;
          }
        } else {
          if (this.narrowphases[shapeA.type | shapeB.type](bodyB, shapeB, shapePositionB, shapeB.angle + bodyB.angle, bodyA, shapeA, shapePositionA, shapeA.angle + bodyA.angle, true)) {
            return true;
          }
        }
      }
    }
    return false;
  }
  collidedLastStep(bodyA, bodyB) {
    const id1 = bodyA.id | 0;
    const id2 = bodyB.id | 0;
    return !!this.collidingBodiesLastStep.get(id1, id2);
  }
  reset() {
    this.collidingBodiesLastStep.reset();
    const eqs = this.contactEquations;
    let l2 = eqs.length;
    while (l2--) {
      const eq = eqs[l2], id1 = eq.bodyA.id, id2 = eq.bodyB.id;
      this.collidingBodiesLastStep.set(id1, id2, true);
    }
    const ce2 = this.contactEquations;
    const fe = this.frictionEquations;
    const cel = ce2.length;
    const fel = fe.length;
    for (let i2 = 0;i2 < cel; i2++) {
      this.contactEquationPool.release(ce2[i2]);
    }
    for (let i2 = 0;i2 < fel; i2++) {
      this.frictionEquationPool.release(fe[i2]);
    }
    this.contactEquations.length = this.frictionEquations.length = 0;
  }
  createContactEquation(bodyA, bodyB, shapeA, shapeB) {
    const c2 = this.contactEquationPool.get();
    const currentContactMaterial = this.currentContactMaterial;
    c2.bodyA = bodyA;
    c2.bodyB = bodyB;
    c2.shapeA = shapeA;
    c2.shapeB = shapeB;
    c2.enabled = this.enabledEquations;
    c2.firstImpact = !this.collidedLastStep(bodyA, bodyB);
    c2.restitution = currentContactMaterial.restitution;
    c2.stiffness = currentContactMaterial.stiffness;
    c2.relaxation = currentContactMaterial.relaxation;
    c2.offset = currentContactMaterial.contactSkinSize;
    c2.needsUpdate = true;
    return c2;
  }
  createFrictionEquation(bodyA, bodyB, shapeA, shapeB) {
    const c2 = this.frictionEquationPool.get();
    const currentContactMaterial = this.currentContactMaterial;
    c2.bodyA = bodyA;
    c2.bodyB = bodyB;
    c2.shapeA = shapeA;
    c2.shapeB = shapeB;
    c2.setSlipForce(this.slipForce);
    c2.enabled = this.enabledEquations;
    c2.frictionCoefficient = currentContactMaterial.friction;
    c2.relativeVelocity = currentContactMaterial.surfaceVelocity;
    c2.stiffness = currentContactMaterial.frictionStiffness;
    c2.relaxation = currentContactMaterial.frictionRelaxation;
    c2.needsUpdate = true;
    c2.contactEquations.length = 0;
    return c2;
  }
  createFrictionFromContact(c2) {
    const eq = this.createFrictionEquation(c2.bodyA, c2.bodyB, c2.shapeA, c2.shapeB);
    copy(eq.contactPointA, c2.contactPointA);
    copy(eq.contactPointB, c2.contactPointB);
    rotate90cw(eq.t, c2.normalA);
    eq.contactEquations.push(c2);
    return eq;
  }
  createFrictionFromAverage(numContacts) {
    let c2 = this.contactEquations[this.contactEquations.length - 1];
    const eq = this.createFrictionEquation(c2.bodyA, c2.bodyB, c2.shapeA, c2.shapeB);
    const bodyA = c2.bodyA;
    set(eq.contactPointA, 0, 0);
    set(eq.contactPointB, 0, 0);
    set(eq.t, 0, 0);
    for (let i2 = 0;i2 !== numContacts; i2++) {
      c2 = this.contactEquations[this.contactEquations.length - 1 - i2];
      if (c2.bodyA === bodyA) {
        add(eq.t, eq.t, c2.normalA);
        add(eq.contactPointA, eq.contactPointA, c2.contactPointA);
        add(eq.contactPointB, eq.contactPointB, c2.contactPointB);
      } else {
        subtract(eq.t, eq.t, c2.normalA);
        add(eq.contactPointA, eq.contactPointA, c2.contactPointB);
        add(eq.contactPointB, eq.contactPointB, c2.contactPointA);
      }
      eq.contactEquations.push(c2);
    }
    const invNumContacts = 1 / numContacts;
    scale2(eq.contactPointA, eq.contactPointA, invNumContacts);
    scale2(eq.contactPointB, eq.contactPointB, invNumContacts);
    normalize(eq.t, eq.t);
    rotate90cw(eq.t, eq.t);
    return eq;
  }
  convexLine = (() => function(_convexBody, _convexShape, _convexOffset, _convexAngle, _lineBody, _lineShape, _lineOffset, _lineAngle, _justTest) {
    return 0;
  })();
  lineBox = (() => function(_lineBody, _lineShape, _lineOffset, _lineAngle, _boxBody, _boxShape, _boxOffset, _boxAngle, _justTest) {
    return 0;
  })();
  convexCapsule = (() => {
    var _this = this;
    return function(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      const circlePos = convexCapsule_tempVec;
      const halfLength = capsuleShape.length / 2;
      set(circlePos, halfLength, 0);
      toGlobalFrame(circlePos, circlePos, capsulePosition, capsuleAngle);
      const result1 = _this.circleConvex(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
      set(circlePos, -halfLength, 0);
      toGlobalFrame(circlePos, circlePos, capsulePosition, capsuleAngle);
      const result2 = _this.circleConvex(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
      if (justTest && result1 + result2 !== 0) {
        return 1;
      }
      const r2 = convexCapsule_tempRect;
      setConvexToCapsuleShapeMiddle(r2, capsuleShape);
      const result = _this.convexConvex(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, r2, capsulePosition, capsuleAngle, justTest);
      return result + result1 + result2;
    };
  })();
  lineCapsule = (() => function(_lineBody, _lineShape, _linePosition, _lineAngle, _capsuleBody, _capsuleShape, _capsulePosition, _capsuleAngle, _justTest) {
    return 0;
  })();
  capsuleCapsule = (() => {
    var _this2 = this;
    return function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      let enableFrictionBefore = true;
      const circlePosi = capsuleCapsule_tempVec1;
      const circlePosj = capsuleCapsule_tempVec2;
      let numContacts = 0;
      for (let i2 = 0;i2 < 2; i2++) {
        set(circlePosi, (i2 === 0 ? -1 : 1) * si.length / 2, 0);
        toGlobalFrame(circlePosi, circlePosi, xi, ai);
        for (let j2 = 0;j2 < 2; j2++) {
          set(circlePosj, (j2 === 0 ? -1 : 1) * sj.length / 2, 0);
          toGlobalFrame(circlePosj, circlePosj, xj, aj);
          if (_this2.enableFrictionReduction) {
            enableFrictionBefore = _this2.enableFriction;
            _this2.enableFriction = false;
          }
          const result = _this2.circleCircle(bi, si, circlePosi, ai, bj, sj, circlePosj, aj, justTest, si.radius, sj.radius);
          if (_this2.enableFrictionReduction) {
            _this2.enableFriction = enableFrictionBefore;
          }
          if (justTest && result !== 0) {
            return 1;
          }
          numContacts += result;
        }
      }
      if (_this2.enableFrictionReduction) {
        enableFrictionBefore = _this2.enableFriction;
        _this2.enableFriction = false;
      }
      const rect = capsuleCapsule_tempRect1;
      setConvexToCapsuleShapeMiddle(rect, si);
      const result1 = _this2.convexCapsule(bi, rect, xi, ai, bj, sj, xj, aj, justTest);
      if (_this2.enableFrictionReduction) {
        _this2.enableFriction = enableFrictionBefore;
      }
      if (justTest && result1 !== 0) {
        return 1;
      }
      numContacts += result1;
      if (_this2.enableFrictionReduction) {
        enableFrictionBefore = _this2.enableFriction;
        _this2.enableFriction = false;
      }
      setConvexToCapsuleShapeMiddle(rect, sj);
      const result2 = _this2.convexCapsule(bj, rect, xj, aj, bi, si, xi, ai, justTest);
      if (_this2.enableFrictionReduction) {
        _this2.enableFriction = enableFrictionBefore;
      }
      if (justTest && result2 !== 0) {
        return 1;
      }
      numContacts += result2;
      if (_this2.enableFrictionReduction) {
        if (numContacts && _this2.enableFriction) {
          _this2.frictionEquations.push(_this2.createFrictionFromAverage(numContacts));
        }
      }
      return numContacts;
    };
  })();
  lineLine = (() => function(_bodyA, _shapeA, _positionA, _angleA, _bodyB, _shapeB, _positionB, _angleB, _justTest) {
    return 0;
  })();
  planeLine = (() => {
    var _this3 = this;
    return function(planeBody, planeShape, planeOffset, planeAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      const worldVertex0 = tmp1;
      const worldVertex1 = tmp2;
      const worldVertex01 = tmp3;
      const worldVertex11 = tmp4;
      const worldEdge = tmp5;
      const worldEdgeUnit = tmp6;
      const dist = tmp7;
      const worldNormal = tmp8;
      const worldTangent = tmp9;
      const verts = tmpArray;
      let numContacts = 0;
      set(worldVertex0, -lineShape.length / 2, 0);
      set(worldVertex1, lineShape.length / 2, 0);
      toGlobalFrame(worldVertex01, worldVertex0, lineOffset, lineAngle);
      toGlobalFrame(worldVertex11, worldVertex1, lineOffset, lineAngle);
      copy(worldVertex0, worldVertex01);
      copy(worldVertex1, worldVertex11);
      subtract(worldEdge, worldVertex1, worldVertex0);
      normalize(worldEdgeUnit, worldEdge);
      rotate90cw(worldTangent, worldEdgeUnit);
      rotate(worldNormal, yAxis$3, planeAngle);
      verts[0] = worldVertex0;
      verts[1] = worldVertex1;
      const l2 = verts.length;
      for (let i2 = 0;i2 < l2; i2++) {
        const v3 = verts[i2];
        subtract(dist, v3, planeOffset);
        const d2 = dot(dist, worldNormal);
        if (d2 < 0) {
          if (justTest) {
            return 1;
          }
          const c2 = _this3.createContactEquation(planeBody, lineBody, planeShape, lineShape);
          numContacts++;
          copy(c2.normalA, worldNormal);
          normalize(c2.normalA, c2.normalA);
          scale2(dist, worldNormal, d2);
          subtract(c2.contactPointA, v3, dist);
          subtract(c2.contactPointA, c2.contactPointA, planeBody.position);
          subtract(c2.contactPointB, v3, lineOffset);
          add(c2.contactPointB, c2.contactPointB, lineOffset);
          subtract(c2.contactPointB, c2.contactPointB, lineBody.position);
          _this3.contactEquations.push(c2);
          if (!_this3.enableFrictionReduction) {
            if (_this3.enableFriction) {
              _this3.frictionEquations.push(_this3.createFrictionFromContact(c2));
            }
          }
        }
      }
      if (justTest) {
        return 0;
      }
      if (!_this3.enableFrictionReduction) {
        if (numContacts && _this3.enableFriction) {
          _this3.frictionEquations.push(_this3.createFrictionFromAverage(numContacts));
        }
      }
      return numContacts;
    };
  })();
  particleCapsule = (() => {
    var _this4 = this;
    return function(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      return _this4.circleLine(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest, capsuleShape.radius, 0);
    };
  })();
  circleLine = (() => {
    var _this5 = this;
    return function(circleBody, circleShape, circleOffset, _circleAngle, lineBody, lineShape, lineOffset, lineAngle, justTest, lineRadius, circleRadius) {
      if (justTest === undefined) {
        justTest = false;
      }
      if (lineRadius === undefined) {
        lineRadius = 0;
      }
      if (circleRadius === undefined) {
        circleRadius = circleShape.radius;
      }
      const orthoDist = tmp1;
      const lineToCircleOrthoUnit = tmp2;
      const projectedPoint = tmp3;
      const centerDist = tmp4;
      const worldTangent = tmp5;
      const worldEdge = tmp6;
      const worldEdgeUnit = tmp7;
      const worldVertex0 = tmp8;
      const worldVertex1 = tmp9;
      const worldVertex01 = tmp10;
      const worldVertex11 = tmp11;
      const dist = tmp12;
      const lineToCircle = tmp13;
      const lineEndToLineRadius = tmp14;
      const verts = tmpArray;
      const halfLineLength = lineShape.length / 2;
      set(worldVertex0, -halfLineLength, 0);
      set(worldVertex1, halfLineLength, 0);
      toGlobalFrame(worldVertex01, worldVertex0, lineOffset, lineAngle);
      toGlobalFrame(worldVertex11, worldVertex1, lineOffset, lineAngle);
      copy(worldVertex0, worldVertex01);
      copy(worldVertex1, worldVertex11);
      subtract(worldEdge, worldVertex1, worldVertex0);
      normalize(worldEdgeUnit, worldEdge);
      rotate90cw(worldTangent, worldEdgeUnit);
      subtract(dist, circleOffset, worldVertex0);
      const d2 = dot(dist, worldTangent);
      subtract(centerDist, worldVertex0, lineOffset);
      subtract(lineToCircle, circleOffset, lineOffset);
      const radiusSum = circleRadius + lineRadius;
      if (Math.abs(d2) < radiusSum) {
        scale2(orthoDist, worldTangent, d2);
        subtract(projectedPoint, circleOffset, orthoDist);
        scale2(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
        normalize(lineToCircleOrthoUnit, lineToCircleOrthoUnit);
        scale2(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
        add(projectedPoint, projectedPoint, lineToCircleOrthoUnit);
        const pos = dot(worldEdgeUnit, projectedPoint);
        const pos0 = dot(worldEdgeUnit, worldVertex0);
        const pos1 = dot(worldEdgeUnit, worldVertex1);
        if (pos > pos0 && pos < pos1) {
          if (justTest) {
            return 1;
          }
          const c2 = _this5.createContactEquation(circleBody, lineBody, circleShape, lineShape);
          scale2(c2.normalA, orthoDist, -1);
          normalize(c2.normalA, c2.normalA);
          scale2(c2.contactPointA, c2.normalA, circleRadius);
          add(c2.contactPointA, c2.contactPointA, circleOffset);
          subtract(c2.contactPointA, c2.contactPointA, circleBody.position);
          subtract(c2.contactPointB, projectedPoint, lineOffset);
          add(c2.contactPointB, c2.contactPointB, lineOffset);
          subtract(c2.contactPointB, c2.contactPointB, lineBody.position);
          _this5.contactEquations.push(c2);
          if (_this5.enableFriction) {
            _this5.frictionEquations.push(_this5.createFrictionFromContact(c2));
          }
          return 1;
        }
      }
      verts[0] = worldVertex0;
      verts[1] = worldVertex1;
      const l2 = verts.length;
      for (let i2 = 0;i2 < l2; i2++) {
        const v3 = verts[i2];
        subtract(dist, v3, circleOffset);
        if (squaredLength(dist) < Math.pow(radiusSum, 2)) {
          if (justTest) {
            return 1;
          }
          const c2 = _this5.createContactEquation(circleBody, lineBody, circleShape, lineShape);
          copy(c2.normalA, dist);
          normalize(c2.normalA, c2.normalA);
          scale2(c2.contactPointA, c2.normalA, circleRadius);
          add(c2.contactPointA, c2.contactPointA, circleOffset);
          subtract(c2.contactPointA, c2.contactPointA, circleBody.position);
          subtract(c2.contactPointB, v3, lineOffset);
          scale2(lineEndToLineRadius, c2.normalA, -lineRadius);
          add(c2.contactPointB, c2.contactPointB, lineEndToLineRadius);
          add(c2.contactPointB, c2.contactPointB, lineOffset);
          subtract(c2.contactPointB, c2.contactPointB, lineBody.position);
          _this5.contactEquations.push(c2);
          if (_this5.enableFriction) {
            _this5.frictionEquations.push(_this5.createFrictionFromContact(c2));
          }
          return 1;
        }
      }
      return 0;
    };
  })();
  circleCapsule = (() => {
    var _this6 = this;
    return function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      return _this6.circleLine(bi, si, xi, ai, bj, sj, xj, aj, justTest, sj.radius);
    };
  })();
  circleConvex = (() => {
    var _this7 = this;
    return function(circleBody, circleShape, circleOffset, _circleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest, circleRadius) {
      if (justTest === undefined) {
        justTest = false;
      }
      if (circleRadius === undefined) {
        circleRadius = circleShape.radius;
      }
      const worldVertex0 = tmp1;
      const worldVertex1 = tmp2;
      const edge = tmp3;
      const edgeUnit = tmp4;
      const normal = tmp5;
      const zero = tmp6;
      const localCirclePosition = tmp7;
      const r2 = tmp8;
      const dist = tmp10;
      const worldVertex = tmp11;
      const closestEdgeProjectedPoint = tmp13;
      const candidate = tmp14;
      const candidateDist = tmp15;
      let found = -1;
      let minCandidateDistance = Number.MAX_VALUE;
      set(zero, 0, 0);
      toLocalFrame(localCirclePosition, circleOffset, convexOffset, convexAngle);
      const vertices = convexShape.vertices;
      const normals = convexShape.normals;
      const numVertices = vertices.length;
      let normalIndex = -1;
      let separation = -Number.MAX_VALUE;
      const radius = convexShape.boundingRadius + circleRadius;
      for (let i2 = 0;i2 < numVertices; i2++) {
        subtract(r2, localCirclePosition, vertices[i2]);
        const s2 = dot(normals[i2], r2);
        if (s2 > radius) {
          return 0;
        }
        if (s2 > separation) {
          separation = s2;
          normalIndex = i2;
        }
      }
      for (let i2 = normalIndex + numVertices - 1;i2 < normalIndex + numVertices + 2; i2++) {
        const v02 = vertices[i2 % numVertices];
        const n2 = normals[i2 % numVertices];
        scale2(candidate, n2, -circleRadius);
        add(candidate, candidate, localCirclePosition);
        if (pointInConvexLocal(candidate, convexShape)) {
          subtract(candidateDist, v02, candidate);
          const candidateDistance = Math.abs(dot(candidateDist, n2));
          if (candidateDistance < minCandidateDistance) {
            minCandidateDistance = candidateDistance;
            found = i2;
          }
        }
      }
      if (found !== -1) {
        if (justTest) {
          return 1;
        }
        const v02 = vertices[found % numVertices];
        const v1 = vertices[(found + 1) % numVertices];
        toGlobalFrame(worldVertex0, v02, convexOffset, convexAngle);
        toGlobalFrame(worldVertex1, v1, convexOffset, convexAngle);
        subtract(edge, worldVertex1, worldVertex0);
        normalize(edgeUnit, edge);
        rotate90cw(normal, edgeUnit);
        scale2(candidate, normal, -circleRadius);
        add(candidate, candidate, circleOffset);
        scale2(closestEdgeProjectedPoint, normal, minCandidateDistance);
        add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, candidate);
        const c2 = _this7.createContactEquation(circleBody, convexBody, circleShape, convexShape);
        subtract(c2.normalA, candidate, circleOffset);
        normalize(c2.normalA, c2.normalA);
        scale2(c2.contactPointA, c2.normalA, circleRadius);
        add(c2.contactPointA, c2.contactPointA, circleOffset);
        subtract(c2.contactPointA, c2.contactPointA, circleBody.position);
        subtract(c2.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c2.contactPointB, c2.contactPointB, convexOffset);
        subtract(c2.contactPointB, c2.contactPointB, convexBody.position);
        _this7.contactEquations.push(c2);
        if (_this7.enableFriction) {
          _this7.frictionEquations.push(_this7.createFrictionFromContact(c2));
        }
        return 1;
      }
      if (circleRadius > 0 && normalIndex !== -1) {
        for (let i2 = normalIndex + numVertices;i2 < normalIndex + numVertices + 2; i2++) {
          const localVertex = vertices[i2 % numVertices];
          subtract(dist, localVertex, localCirclePosition);
          if (squaredLength(dist) < circleRadius * circleRadius) {
            if (justTest) {
              return 1;
            }
            toGlobalFrame(worldVertex, localVertex, convexOffset, convexAngle);
            subtract(dist, worldVertex, circleOffset);
            const c2 = _this7.createContactEquation(circleBody, convexBody, circleShape, convexShape);
            copy(c2.normalA, dist);
            normalize(c2.normalA, c2.normalA);
            scale2(c2.contactPointA, c2.normalA, circleRadius);
            add(c2.contactPointA, c2.contactPointA, circleOffset);
            subtract(c2.contactPointA, c2.contactPointA, circleBody.position);
            subtract(c2.contactPointB, worldVertex, convexOffset);
            add(c2.contactPointB, c2.contactPointB, convexOffset);
            subtract(c2.contactPointB, c2.contactPointB, convexBody.position);
            _this7.contactEquations.push(c2);
            if (_this7.enableFriction) {
              _this7.frictionEquations.push(_this7.createFrictionFromContact(c2));
            }
            return 1;
          }
        }
      }
      return 0;
    };
  })();
  particleConvex = (() => {
    var _this8 = this;
    return function(particleBody, particleShape, particleOffset, _particleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      const worldVertex0 = tmp1;
      const worldVertex1 = tmp2;
      const worldEdge = tmp3;
      const worldEdgeUnit = tmp4;
      const worldTangent = tmp5;
      const centerDist = tmp6;
      const convexToparticle = tmp7;
      const closestEdgeProjectedPoint = tmp13;
      const candidateDist = tmp14;
      const minEdgeNormal = tmp15;
      const verts = convexShape.vertices;
      let minCandidateDistance = Number.MAX_VALUE;
      let found = false;
      if (!pointInConvex(particleOffset, convexShape, convexOffset, convexAngle)) {
        return 0;
      }
      if (justTest) {
        return 1;
      }
      for (let i2 = 0, numVerts = verts.length;i2 !== numVerts + 1; i2++) {
        const v02 = verts[i2 % numVerts], v1 = verts[(i2 + 1) % numVerts];
        rotate(worldVertex0, v02, convexAngle);
        rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);
        subtract(worldEdge, worldVertex1, worldVertex0);
        normalize(worldEdgeUnit, worldEdge);
        rotate90cw(worldTangent, worldEdgeUnit);
        subtract(centerDist, worldVertex0, convexOffset);
        subtract(convexToparticle, particleOffset, convexOffset);
        subtract(candidateDist, worldVertex0, particleOffset);
        const candidateDistance = Math.abs(dot(candidateDist, worldTangent));
        if (candidateDistance < minCandidateDistance) {
          minCandidateDistance = candidateDistance;
          scale2(closestEdgeProjectedPoint, worldTangent, candidateDistance);
          add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, particleOffset);
          copy(minEdgeNormal, worldTangent);
          found = true;
        }
      }
      if (found) {
        const c2 = _this8.createContactEquation(particleBody, convexBody, particleShape, convexShape);
        scale2(c2.normalA, minEdgeNormal, -1);
        normalize(c2.normalA, c2.normalA);
        set(c2.contactPointA, 0, 0);
        add(c2.contactPointA, c2.contactPointA, particleOffset);
        subtract(c2.contactPointA, c2.contactPointA, particleBody.position);
        subtract(c2.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c2.contactPointB, c2.contactPointB, convexOffset);
        subtract(c2.contactPointB, c2.contactPointB, convexBody.position);
        _this8.contactEquations.push(c2);
        if (_this8.enableFriction) {
          _this8.frictionEquations.push(_this8.createFrictionFromContact(c2));
        }
        return 1;
      }
      return 0;
    };
  })();
  circleCircle = (() => {
    var _this9 = this;
    return function(bodyA, shapeA, offsetA, _angleA, bodyB, shapeB, offsetB, _angleB, justTest, radiusA, radiusB) {
      if (justTest === undefined) {
        justTest = false;
      }
      if (radiusA === undefined) {
        radiusA = shapeA.radius;
      }
      if (radiusB === undefined) {
        radiusB = shapeB.radius;
      }
      const dist = tmp1;
      subtract(dist, offsetA, offsetB);
      const r2 = radiusA + radiusB;
      if (squaredLength(dist) > r2 * r2) {
        return 0;
      }
      if (justTest) {
        return 1;
      }
      const c2 = _this9.createContactEquation(bodyA, bodyB, shapeA, shapeB);
      const cpA = c2.contactPointA;
      const cpB = c2.contactPointB;
      const normalA = c2.normalA;
      subtract(normalA, offsetB, offsetA);
      normalize(normalA, normalA);
      scale2(cpA, normalA, radiusA);
      scale2(cpB, normalA, -radiusB);
      addsubtract(cpA, cpA, offsetA, bodyA.position);
      addsubtract(cpB, cpB, offsetB, bodyB.position);
      _this9.contactEquations.push(c2);
      if (_this9.enableFriction) {
        _this9.frictionEquations.push(_this9.createFrictionFromContact(c2));
      }
      return 1;
    };
  })();
  planeConvex = (() => {
    var _this10 = this;
    return function(planeBody, planeShape, planeOffset, planeAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      const worldVertex = tmp1;
      const worldNormal = tmp2;
      const dist = tmp3;
      const localPlaneOffset = tmp4;
      const localPlaneNormal = tmp5;
      const localDist = tmp6;
      let numReported = 0;
      rotate(worldNormal, yAxis$3, planeAngle);
      vectorToLocalFrame(localPlaneNormal, worldNormal, convexAngle);
      toLocalFrame(localPlaneOffset, planeOffset, convexOffset, convexAngle);
      const vertices = convexShape.vertices;
      for (let i2 = 0, numVerts = vertices.length;i2 !== numVerts; i2++) {
        const v3 = vertices[i2];
        subtract(localDist, v3, localPlaneOffset);
        if (dot(localDist, localPlaneNormal) <= 0) {
          if (justTest) {
            return 1;
          }
          toGlobalFrame(worldVertex, v3, convexOffset, convexAngle);
          subtract(dist, worldVertex, planeOffset);
          numReported++;
          const c2 = _this10.createContactEquation(planeBody, convexBody, planeShape, convexShape);
          subtract(dist, worldVertex, planeOffset);
          copy(c2.normalA, worldNormal);
          const d2 = dot(dist, c2.normalA);
          scale2(dist, c2.normalA, d2);
          subtract(c2.contactPointB, worldVertex, convexBody.position);
          subtract(c2.contactPointA, worldVertex, dist);
          subtract(c2.contactPointA, c2.contactPointA, planeBody.position);
          _this10.contactEquations.push(c2);
          if (!_this10.enableFrictionReduction) {
            if (_this10.enableFriction) {
              _this10.frictionEquations.push(_this10.createFrictionFromContact(c2));
            }
          }
        }
      }
      if (_this10.enableFrictionReduction) {
        if (_this10.enableFriction && numReported) {
          _this10.frictionEquations.push(_this10.createFrictionFromAverage(numReported));
        }
      }
      return numReported;
    };
  })();
  particlePlane = (() => {
    var _this11 = this;
    return function(particleBody, particleShape, particleOffset, _particleAngle, planeBody, planeShape, planeOffset, planeAngle, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      const dist = tmp1;
      const worldNormal = tmp2;
      planeAngle = planeAngle || 0;
      subtract(dist, particleOffset, planeOffset);
      rotate(worldNormal, yAxis$3, planeAngle);
      const d2 = dot(dist, worldNormal);
      if (d2 > 0) {
        return 0;
      }
      if (justTest) {
        return 1;
      }
      const c2 = _this11.createContactEquation(planeBody, particleBody, planeShape, particleShape);
      copy(c2.normalA, worldNormal);
      scale2(dist, c2.normalA, d2);
      subtract(c2.contactPointA, particleOffset, dist);
      subtract(c2.contactPointA, c2.contactPointA, planeBody.position);
      subtract(c2.contactPointB, particleOffset, particleBody.position);
      _this11.contactEquations.push(c2);
      if (_this11.enableFriction) {
        _this11.frictionEquations.push(_this11.createFrictionFromContact(c2));
      }
      return 1;
    };
  })();
  circleParticle = (() => {
    var _this12 = this;
    return function(circleBody, circleShape, circleOffset, _circleAngle, particleBody, particleShape, particleOffset, _particleAngle, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      const dist = tmp1;
      const circleRadius = circleShape.radius;
      subtract(dist, particleOffset, circleOffset);
      if (squaredLength(dist) > circleRadius * circleRadius) {
        return 0;
      }
      if (justTest) {
        return 1;
      }
      const c2 = _this12.createContactEquation(circleBody, particleBody, circleShape, particleShape);
      const normalA = c2.normalA;
      const contactPointA = c2.contactPointA;
      const contactPointB = c2.contactPointB;
      copy(normalA, dist);
      normalize(normalA, normalA);
      scale2(contactPointA, normalA, circleRadius);
      add(contactPointA, contactPointA, circleOffset);
      subtract(contactPointA, contactPointA, circleBody.position);
      subtract(contactPointB, particleOffset, particleBody.position);
      _this12.contactEquations.push(c2);
      if (_this12.enableFriction) {
        _this12.frictionEquations.push(_this12.createFrictionFromContact(c2));
      }
      return 1;
    };
  })();
  planeCapsule = (() => {
    var _this13 = this;
    return function(planeBody, planeShape, planeOffset, planeAngle, capsuleBody, capsuleShape, capsuleOffset, capsuleAngle, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      const end1 = planeCapsule_tmp1;
      const end2 = planeCapsule_tmp2;
      const circle = planeCapsule_tmpCircle;
      const halfLength = capsuleShape.length / 2;
      set(end1, -halfLength, 0);
      set(end2, halfLength, 0);
      toGlobalFrame(end1, end1, capsuleOffset, capsuleAngle);
      toGlobalFrame(end2, end2, capsuleOffset, capsuleAngle);
      circle.radius = capsuleShape.radius;
      let enableFrictionBefore = true;
      if (_this13.enableFrictionReduction) {
        enableFrictionBefore = _this13.enableFriction;
        _this13.enableFriction = false;
      }
      const numContacts1 = _this13.circlePlane(capsuleBody, circle, end1, 0, planeBody, planeShape, planeOffset, planeAngle, justTest), numContacts2 = _this13.circlePlane(capsuleBody, circle, end2, 0, planeBody, planeShape, planeOffset, planeAngle, justTest);
      if (_this13.enableFrictionReduction) {
        _this13.enableFriction = enableFrictionBefore;
      }
      if (justTest) {
        return numContacts1 + numContacts2;
      } else {
        const numTotal = numContacts1 + numContacts2;
        if (_this13.enableFrictionReduction) {
          if (numTotal) {
            _this13.frictionEquations.push(_this13.createFrictionFromAverage(numTotal));
          }
        }
        return numTotal;
      }
    };
  })();
  circlePlane = (() => {
    var _this14 = this;
    return function(circleBody, circleShape, circleOffset, _circleAngle, planeBody, planeShape, planeOffset, planeAngle, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      const circleRadius = circleShape.radius;
      const planeToCircle = tmp1, worldNormal = tmp2, temp = tmp3;
      subtract(planeToCircle, circleOffset, planeOffset);
      rotate(worldNormal, yAxis$3, planeAngle);
      const d2 = dot(worldNormal, planeToCircle);
      if (d2 > circleRadius) {
        return 0;
      }
      if (justTest) {
        return 1;
      }
      const contact = _this14.createContactEquation(planeBody, circleBody, planeShape, circleShape);
      copy(contact.normalA, worldNormal);
      const cpB = contact.contactPointB;
      scale2(cpB, contact.normalA, -circleRadius);
      add(cpB, cpB, circleOffset);
      subtract(cpB, cpB, circleBody.position);
      const cpA = contact.contactPointA;
      scale2(temp, contact.normalA, d2);
      subtract(cpA, planeToCircle, temp);
      add(cpA, cpA, planeOffset);
      subtract(cpA, cpA, planeBody.position);
      _this14.contactEquations.push(contact);
      if (_this14.enableFriction) {
        _this14.frictionEquations.push(_this14.createFrictionFromContact(contact));
      }
      return 1;
    };
  })();
  convexConvex = (() => {
    var _this15 = this;
    return function(bodyA, polyA, positionA, angleA, bodyB, polyB, positionB, angleB, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      const totalRadius = 0;
      const dist = convexConvex_dist;
      const tempVec = convexConvex_tempVec;
      const tmpVec = convexConvex_tmpVec;
      const edgeA = findMaxSeparation(tempVec, polyA, positionA, angleA, polyB, positionB, angleB);
      const separationA = tempVec[0];
      if (separationA > totalRadius) {
        return 0;
      }
      const edgeB = findMaxSeparation(tmpVec, polyB, positionB, angleB, polyA, positionA, angleA);
      const separationB = tmpVec[0];
      if (separationB > totalRadius) {
        return 0;
      }
      let poly1;
      let poly2;
      let position1;
      let position2;
      let angle1;
      let angle2;
      let body1;
      let body2;
      let edge1;
      if (separationB > separationA) {
        poly1 = polyB;
        poly2 = polyA;
        body1 = bodyB;
        body2 = bodyA;
        position1 = positionB;
        angle1 = angleB;
        position2 = positionA;
        angle2 = angleA;
        edge1 = edgeB;
      } else {
        poly1 = polyA;
        poly2 = polyB;
        body1 = bodyA;
        body2 = bodyB;
        position1 = positionA;
        angle1 = angleA;
        position2 = positionB;
        angle2 = angleB;
        edge1 = edgeA;
      }
      const incidentEdge = convexConvex_incidentEdge;
      findIncidentEdge(incidentEdge, poly1, position1, angle1, edge1, poly2, position2, angle2);
      const count1 = poly1.vertices.length;
      const vertices1 = poly1.vertices;
      const iv1 = edge1;
      const iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;
      const v11 = convexConvex_v11;
      const v12 = convexConvex_v12;
      copy(v11, vertices1[iv1]);
      copy(v12, vertices1[iv2]);
      const localTangent = convexConvex_localTangent;
      subtract(localTangent, v12, v11);
      normalize(localTangent, localTangent);
      const localNormal = convexConvex_localNormal;
      crossVZ(localNormal, localTangent, 1);
      const planePoint = convexConvex_planePoint;
      add(planePoint, v11, v12);
      scale2(planePoint, planePoint, 0.5);
      const tangent = convexConvex_tangent;
      rotate(tangent, localTangent, angle1);
      const normal = convexConvex_normal;
      crossVZ(normal, tangent, 1);
      toGlobalFrame(v11, v11, position1, angle1);
      toGlobalFrame(v12, v12, position1, angle1);
      const frontOffset = dot(normal, v11);
      const sideOffset1 = -dot(tangent, v11) + totalRadius;
      const sideOffset2 = dot(tangent, v12) + totalRadius;
      const clipPoints1 = convexConvex_clipPoints1;
      const clipPoints2 = convexConvex_clipPoints2;
      let np = 0;
      const negativeTangent = convexConvex_negativeTangent;
      scale2(negativeTangent, tangent, -1);
      np = clipSegmentToLine(clipPoints1, incidentEdge, negativeTangent, sideOffset1);
      if (np < 2) {
        return 0;
      }
      np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
      if (np < 2) {
        return 0;
      }
      let pointCount = 0;
      for (let i2 = 0;i2 < maxManifoldPoints; ++i2) {
        const separation = dot(normal, clipPoints2[i2]) - frontOffset;
        if (separation <= totalRadius) {
          if (justTest) {
            return 1;
          }
          ++pointCount;
          const c2 = _this15.createContactEquation(body1, body2, poly1, poly2);
          copy(c2.normalA, normal);
          copy(c2.contactPointB, clipPoints2[i2]);
          subtract(c2.contactPointB, c2.contactPointB, body2.position);
          scale2(dist, normal, -separation);
          add(c2.contactPointA, clipPoints2[i2], dist);
          subtract(c2.contactPointA, c2.contactPointA, body1.position);
          _this15.contactEquations.push(c2);
          if (_this15.enableFriction && !_this15.enableFrictionReduction) {
            _this15.frictionEquations.push(_this15.createFrictionFromContact(c2));
          }
        }
      }
      if (pointCount && _this15.enableFrictionReduction && _this15.enableFriction) {
        _this15.frictionEquations.push(_this15.createFrictionFromAverage(pointCount));
      }
      return pointCount;
    };
  })();
  circleHeightfield = (() => {
    var _this16 = this;
    return function(circleBody, circleShape, circlePos, _circleAngle, hfBody, hfShape, hfPos, _fAngle, justTest, radius) {
      if (justTest === undefined) {
        justTest = false;
      }
      if (radius === undefined) {
        radius = circleShape.radius;
      }
      const data = hfShape.heights;
      const w2 = hfShape.elementWidth;
      const dist = circleHeightfield_dist;
      const candidate = circleHeightfield_candidate;
      const minCandidate = circleHeightfield_minCandidate;
      const minCandidateNormal = circleHeightfield_minCandidateNormal;
      const worldNormal = circleHeightfield_worldNormal;
      const v02 = circleHeightfield_v0;
      const v1 = circleHeightfield_v1;
      let idxA = Math.floor((circlePos[0] - radius - hfPos[0]) / w2), idxB = Math.ceil((circlePos[0] + radius - hfPos[0]) / w2);
      if (idxA < 0) {
        idxA = 0;
      }
      if (idxB >= data.length) {
        idxB = data.length - 1;
      }
      let max = data[idxA], min = data[idxB];
      for (let i2 = idxA;i2 < idxB; i2++) {
        if (data[i2] < min) {
          min = data[i2];
        }
        if (data[i2] > max) {
          max = data[i2];
        }
      }
      if (circlePos[1] - radius > max) {
        return 0;
      }
      let found = false;
      for (let i2 = idxA;i2 < idxB; i2++) {
        set(v02, i2 * w2, data[i2]);
        set(v1, (i2 + 1) * w2, data[i2 + 1]);
        add(v02, v02, hfPos);
        add(v1, v1, hfPos);
        subtract(worldNormal, v1, v02);
        rotate(worldNormal, worldNormal, Math.PI / 2);
        normalize(worldNormal, worldNormal);
        scale2(candidate, worldNormal, -radius);
        add(candidate, candidate, circlePos);
        subtract(dist, candidate, v02);
        const d2 = dot(dist, worldNormal);
        if (candidate[0] >= v02[0] && candidate[0] < v1[0] && d2 <= 0) {
          if (justTest) {
            return 1;
          }
          found = true;
          scale2(dist, worldNormal, -d2);
          add(minCandidate, candidate, dist);
          copy(minCandidateNormal, worldNormal);
          const c2 = _this16.createContactEquation(hfBody, circleBody, hfShape, circleShape);
          copy(c2.normalA, minCandidateNormal);
          scale2(c2.contactPointB, c2.normalA, -radius);
          add(c2.contactPointB, c2.contactPointB, circlePos);
          subtract(c2.contactPointB, c2.contactPointB, circleBody.position);
          copy(c2.contactPointA, minCandidate);
          subtract(c2.contactPointA, c2.contactPointA, hfBody.position);
          _this16.contactEquations.push(c2);
          if (_this16.enableFriction) {
            _this16.frictionEquations.push(_this16.createFrictionFromContact(c2));
          }
        }
      }
      found = false;
      if (radius > 0) {
        for (let i2 = idxA;i2 <= idxB; i2++) {
          set(v02, i2 * w2, data[i2]);
          add(v02, v02, hfPos);
          subtract(dist, circlePos, v02);
          if (squaredLength(dist) < Math.pow(radius, 2)) {
            if (justTest) {
              return 1;
            }
            found = true;
            const c2 = _this16.createContactEquation(hfBody, circleBody, hfShape, circleShape);
            copy(c2.normalA, dist);
            normalize(c2.normalA, c2.normalA);
            scale2(c2.contactPointB, c2.normalA, -radius);
            add(c2.contactPointB, c2.contactPointB, circlePos);
            subtract(c2.contactPointB, c2.contactPointB, circleBody.position);
            subtract(c2.contactPointA, v02, hfPos);
            add(c2.contactPointA, c2.contactPointA, hfPos);
            subtract(c2.contactPointA, c2.contactPointA, hfBody.position);
            _this16.contactEquations.push(c2);
            if (_this16.enableFriction) {
              _this16.frictionEquations.push(_this16.createFrictionFromContact(c2));
            }
          }
        }
      }
      if (found) {
        return 1;
      }
      return 0;
    };
  })();
  convexHeightfield = (() => {
    var _this17 = this;
    return function(convexBody, convexShape, convexPos, convexAngle, hfBody, hfShape, hfPos, _hfAngle, justTest) {
      if (justTest === undefined) {
        justTest = false;
      }
      const { heights: data, elementWidth: w2 } = hfShape, v02 = convexHeightfield_v0, v1 = convexHeightfield_v1, tilePos = convexHeightfield_tilePos, tileConvex = convexHeightfield_tempConvexShape;
      let idxA = Math.floor((convexBody.aabb.lowerBound[0] - hfPos[0]) / w2), idxB = Math.ceil((convexBody.aabb.upperBound[0] - hfPos[0]) / w2);
      if (idxA < 0) {
        idxA = 0;
      }
      if (idxB >= data.length) {
        idxB = data.length - 1;
      }
      let max = data[idxA], min = data[idxB];
      for (let i2 = idxA;i2 < idxB; i2++) {
        if (data[i2] < min) {
          min = data[i2];
        }
        if (data[i2] > max) {
          max = data[i2];
        }
      }
      if (convexBody.aabb.lowerBound[1] > max) {
        return 0;
      }
      let numContacts = 0;
      for (let i2 = idxA;i2 < idxB; i2++) {
        set(v02, i2 * w2, data[i2]);
        set(v1, (i2 + 1) * w2, data[i2 + 1]);
        add(v02, v02, hfPos);
        add(v1, v1, hfPos);
        const tileHeight = 100;
        set(tilePos, (v1[0] + v02[0]) * 0.5, (v1[1] + v02[1] - tileHeight) * 0.5);
        subtract(tileConvex.vertices[0], v1, tilePos);
        subtract(tileConvex.vertices[1], v02, tilePos);
        copy(tileConvex.vertices[2], tileConvex.vertices[1]);
        copy(tileConvex.vertices[3], tileConvex.vertices[0]);
        tileConvex.vertices[2][1] -= tileHeight;
        tileConvex.vertices[3][1] -= tileHeight;
        tileConvex.updateNormals();
        numContacts += _this17.convexConvex(convexBody, convexShape, convexPos, convexAngle, hfBody, tileConvex, tilePos, 0, justTest);
      }
      return numContacts;
    };
  })();
  narrowphases = {
    [Shape.CONVEX | Shape.LINE]: this.convexLine,
    [Shape.LINE | Shape.BOX]: this.lineBox,
    [Shape.CONVEX | Shape.CAPSULE]: this.convexCapsule,
    [Shape.BOX | Shape.CAPSULE]: this.convexCapsule,
    [Shape.LINE | Shape.CAPSULE]: this.lineCapsule,
    [Shape.CAPSULE]: this.capsuleCapsule,
    [Shape.LINE]: this.lineLine,
    [Shape.PLANE | Shape.LINE]: this.planeLine,
    [Shape.PARTICLE | Shape.CAPSULE]: this.particleCapsule,
    [Shape.CIRCLE | Shape.LINE]: this.circleLine,
    [Shape.CIRCLE | Shape.CAPSULE]: this.circleCapsule,
    [Shape.CIRCLE | Shape.CONVEX]: this.circleConvex,
    [Shape.CIRCLE | Shape.BOX]: this.circleConvex,
    [Shape.PARTICLE | Shape.CONVEX]: this.particleConvex,
    [Shape.PARTICLE | Shape.BOX]: this.particleConvex,
    [Shape.CIRCLE]: this.circleCircle,
    [Shape.PLANE | Shape.CONVEX]: this.planeConvex,
    [Shape.PLANE | Shape.BOX]: this.planeConvex,
    [Shape.PARTICLE | Shape.PLANE]: this.particlePlane,
    [Shape.CIRCLE | Shape.PARTICLE]: this.circleParticle,
    [Shape.PLANE | Shape.CAPSULE]: this.planeCapsule,
    [Shape.CIRCLE | Shape.PLANE]: this.circlePlane,
    [Shape.CONVEX]: this.convexConvex,
    [Shape.CONVEX | Shape.BOX]: this.convexConvex,
    [Shape.BOX]: this.convexConvex,
    [Shape.CIRCLE | Shape.HEIGHTFIELD]: this.circleHeightfield,
    [Shape.BOX | Shape.HEIGHTFIELD]: this.convexHeightfield,
    [Shape.CONVEX | Shape.HEIGHTFIELD]: this.convexHeightfield
  };
}
var yAxis$3 = fromValues(0, 1);
var tmp1 = create();
var tmp2 = create();
var tmp3 = create();
var tmp4 = create();
var tmp5 = create();
var tmp6 = create();
var tmp7 = create();
var tmp8 = create();
var tmp9 = create();
var tmp10 = create();
var tmp11 = create();
var tmp12 = create();
var tmp13 = create();
var tmp14 = create();
var tmp15 = create();
var tmpArray = [];
var bodiesOverlap_shapePositionA = create();
var bodiesOverlap_shapePositionB = create();
var convexConvex_tempVec = create();
var convexConvex_tmpVec = create();
var convexConvex_localTangent = create();
var convexConvex_localNormal = create();
var convexConvex_planePoint = create();
var convexConvex_tangent = create();
var convexConvex_normal = create();
var convexConvex_negativeTangent = create();
var convexConvex_v11 = create();
var convexConvex_v12 = create();
var convexConvex_dist = create();
var convexConvex_clipPoints1 = [create(), create()];
var convexConvex_clipPoints2 = [create(), create()];
var convexConvex_incidentEdge = [create(), create()];
var maxManifoldPoints = 2;
var circleHeightfield_candidate = create();
var circleHeightfield_dist = create();
var circleHeightfield_v0 = create();
var circleHeightfield_v1 = create();
var circleHeightfield_minCandidate = create();
var circleHeightfield_worldNormal = create();
var circleHeightfield_minCandidateNormal = create();
var convexCapsule_tempRect = new Box({
  width: 1,
  height: 1
});
var convexCapsule_tempVec = create();
var capsuleCapsule_tempVec1 = create();
var capsuleCapsule_tempVec2 = create();
var capsuleCapsule_tempRect1 = new Box({
  width: 1,
  height: 1
});
var pointInConvex_localPoint = create();
var pointInConvex_r0 = create();
var pointInConvex_r1 = create();
var planeCapsule_tmpCircle = new Circle({
  radius: 1
});
var planeCapsule_tmp1 = create();
var planeCapsule_tmp2 = create();
var findMaxSeparation_n = create();
var findMaxSeparation_v1 = create();
var findMaxSeparation_tmp = create();
var findMaxSeparation_tmp2 = create();
var findIncidentEdge_normal1 = create();
var convexHeightfield_v0 = create();
var convexHeightfield_v1 = create();
var convexHeightfield_tilePos = create();
var convexHeightfield_tempConvexShape = new Convex({
  vertices: [create(), create(), create(), create()]
});

class SAPBroadphase extends Broadphase {
  axisList = [];
  axisIndex = 0;
  constructor() {
    super(Broadphase.SAP);
    this.addBodyHandler = (e2) => {
      this.axisList.push(e2.body);
    };
    this.removeBodyHandler = (e2) => {
      const l2 = this.axisList.length;
      const list = this.axisList;
      for (let i2 = 0;i2 < l2; i2++) {
        if (list[i2] === e2.body) {
          list.splice(i2, 1);
          break;
        }
      }
    };
  }
  setWorld(world) {
    this.axisList.length = 0;
    appendArray(this.axisList, world.bodies);
    world.off("addBody", this.addBodyHandler).off("removeBody", this.removeBodyHandler);
    world.on("addBody", this.addBodyHandler).on("removeBody", this.removeBodyHandler);
    this.world = world;
  }
  sortList() {
    const bodies = this.axisList;
    const axisIndex = this.axisIndex;
    sortAxisList(bodies, axisIndex);
  }
  getCollisionPairs(_world) {
    const bodies = this.axisList;
    const result = this.result;
    const axisIndex = this.axisIndex;
    result.length = 0;
    let l2 = bodies.length;
    while (l2--) {
      const b2 = bodies[l2];
      if (b2.aabbNeedsUpdate) {
        b2.updateAABB();
      }
    }
    this.sortList();
    for (let i2 = 0, N2 = bodies.length | 0;i2 !== N2; i2++) {
      const bi = bodies[i2];
      for (let j2 = i2 + 1;j2 < N2; j2++) {
        const bj = bodies[j2];
        const overlaps = bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex];
        if (!overlaps) {
          break;
        }
        if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
          result.push(bi, bj);
        }
      }
    }
    return result;
  }
  aabbQuery(world, aabb, result) {
    if (result === undefined) {
      result = [];
    }
    this.sortList();
    const axisList = this.axisList;
    const l2 = axisList.length;
    for (let i2 = 0;i2 < l2; i2++) {
      const b2 = axisList[i2];
      if (b2.aabbNeedsUpdate) {
        b2.updateAABB();
      }
      if (b2.aabb.overlaps(aabb)) {
        result.push(b2);
      }
    }
    return result;
  }
}
var n2 = create();
var ri = create();
var rj = create();
var l2 = create();
var r$1 = create();
var t2 = create();
var xAxis$2 = fromValues(1, 0);
var yAxis$2 = fromValues(0, 1);
var worldVectorA = create();
var worldVectorB = create();
var xAxis$1 = fromValues(1, 0);
var yAxis$1 = fromValues(0, 1);
var worldAxisA = create();
var worldAnchorA = create();
var worldAnchorB = create();
var orientedAnchorA = create();
var orientedAnchorB = create();
var tmp = create();
var worldPivotA = create();
var worldPivotB = create();
var xAxis = fromValues(1, 0);
var yAxis = fromValues(0, 1);
var g2 = create();

class Material {
  static idCounter = 0;
  constructor() {
    this.id = Material.idCounter++;
  }
}

class ContactMaterial {
  static idCounter = 0;
  constructor(materialA, materialB, options) {
    if (options === undefined) {
      options = {};
    }
    if (!(materialA instanceof Material) || !(materialB instanceof Material)) {
      throw new Error("First two arguments must be Material instances.");
    }
    this.id = ContactMaterial.idCounter++;
    this.materialA = materialA;
    this.materialB = materialB;
    this.friction = options.friction ?? 0.3;
    this.restitution = options.restitution ?? 0;
    this.stiffness = options.stiffness ?? Equation.DEFAULT_STIFFNESS;
    this.relaxation = options.relaxation ?? Equation.DEFAULT_RELAXATION;
    this.frictionStiffness = options.frictionStiffness ?? Equation.DEFAULT_STIFFNESS;
    this.frictionRelaxation = options.frictionRelaxation ?? Equation.DEFAULT_RELAXATION;
    this.surfaceVelocity = options.surfaceVelocity ?? 0;
    this.contactSkinSize = 0.005;
  }
}

class Spring {
  constructor(bodyA, bodyB, options) {
    if (options === undefined) {
      options = {};
    }
    this.stiffness = options.stiffness ?? 100;
    this.damping = options.damping ?? 1;
    this.bodyA = bodyA;
    this.bodyB = bodyB;
  }
}

class LinearSpring extends Spring {
  constructor(bodyA, bodyB, options) {
    if (options === undefined) {
      options = {};
    }
    super(bodyA, bodyB, options);
    this.localAnchorA = create();
    this.localAnchorB = create();
    if (options.localAnchorA) {
      copy(this.localAnchorA, options.localAnchorA);
    }
    if (options.localAnchorB) {
      copy(this.localAnchorB, options.localAnchorB);
    }
    if (options.worldAnchorA) {
      this.setWorldAnchorA(options.worldAnchorA);
    }
    if (options.worldAnchorB) {
      this.setWorldAnchorB(options.worldAnchorB);
    }
    const worldAnchorA2 = create();
    const worldAnchorB2 = create();
    this.getWorldAnchorA(worldAnchorA2);
    this.getWorldAnchorB(worldAnchorB2);
    const worldDistance = distance2(worldAnchorA2, worldAnchorB2);
    this.restLength = options.restLength ?? worldDistance;
  }
  setWorldAnchorA(worldAnchorA2) {
    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA2);
  }
  setWorldAnchorB(worldAnchorB2) {
    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB2);
  }
  getWorldAnchorA(result) {
    this.bodyA.toWorldFrame(result, this.localAnchorA);
  }
  getWorldAnchorB(result) {
    this.bodyB.toWorldFrame(result, this.localAnchorB);
  }
  applyForce() {
    const k2 = this.stiffness, d2 = this.damping, l3 = this.restLength, bodyA = this.bodyA, bodyB = this.bodyB, r2 = applyForce_r, r_unit = applyForce_r_unit, u5 = applyForce_u, f2 = applyForce_f, tmp16 = applyForce_tmp;
    const worldAnchorA2 = applyForce_worldAnchorA, worldAnchorB2 = applyForce_worldAnchorB, ri2 = applyForce_ri, rj2 = applyForce_rj;
    this.getWorldAnchorA(worldAnchorA2);
    this.getWorldAnchorB(worldAnchorB2);
    subtract(ri2, worldAnchorA2, bodyA.position);
    subtract(rj2, worldAnchorB2, bodyB.position);
    subtract(r2, worldAnchorB2, worldAnchorA2);
    const rlen = length(r2);
    normalize(r_unit, r2);
    subtract(u5, bodyB.velocity, bodyA.velocity);
    crossZV(tmp16, bodyB.angularVelocity, rj2);
    add(u5, u5, tmp16);
    crossZV(tmp16, bodyA.angularVelocity, ri2);
    subtract(u5, u5, tmp16);
    scale2(f2, r_unit, -k2 * (rlen - l3) - d2 * dot(u5, r_unit));
    subtract(bodyA.force, bodyA.force, f2);
    add(bodyB.force, bodyB.force, f2);
    const ri_x_f = crossLength(ri2, f2);
    const rj_x_f = crossLength(rj2, f2);
    bodyA.angularForce -= ri_x_f;
    bodyB.angularForce += rj_x_f;
  }
}
var applyForce_r = create();
var applyForce_r_unit = create();
var applyForce_u = create();
var applyForce_f = create();
var applyForce_worldAnchorA = create();
var applyForce_worldAnchorB = create();
var applyForce_ri = create();
var applyForce_rj = create();
var applyForce_tmp = create();
var worldVelocity = create();
var relativePoint = create();
var tmpVec = create();
var r2 = create();
var intersectCapsule_hitPointWorld = create();
var intersectCapsule_normal = create();
var intersectCapsule_l0 = create();
var intersectCapsule_l1 = create();
var intersectCapsule_unit_y = fromValues(0, 1);
var points$1 = [create(), create(), create(), create()];
var intersectHeightfield_worldNormal = create();
var intersectHeightfield_l0 = create();
var intersectHeightfield_l1 = create();
var intersectHeightfield_localFrom = create();
var intersectHeightfield_localTo = create();

class Line extends Shape {
  constructor(options) {
    if (options === undefined) {
      options = {};
    }
    const params = {
      ...options,
      type: Shape.LINE,
      length: options.length ?? 1
    };
    super(params);
    this.length = params.length;
    this.updateBoundingRadius();
    this.updateArea();
  }
  computeMomentOfInertia() {
    return Math.pow(this.length, 2) / 12;
  }
  updateBoundingRadius() {
    this.boundingRadius = this.length / 2;
  }
  computeAABB(out, position, angle) {
    const l22 = this.length / 2;
    set(points[0], -l22, 0);
    set(points[1], l22, 0);
    out.setFromPoints(points, position, angle, 0);
  }
  raycast(result, ray, position, angle) {
    const from = ray.from;
    const to = ray.to;
    const l0 = raycast_l0;
    const l1 = raycast_l1;
    const halfLen = this.length / 2;
    set(l0, -halfLen, 0);
    set(l1, halfLen, 0);
    toGlobalFrame(l0, l0, position, angle);
    toGlobalFrame(l1, l1, position, angle);
    const fraction = getLineSegmentsIntersectionFraction(from, to, l0, l1);
    if (fraction >= 0) {
      const normal = raycast_normal;
      rotate(normal, raycast_unit_y, angle);
      ray.reportIntersection(result, fraction, normal, -1);
    }
  }
}
var points = [create(), create()];
var raycast_normal = create();
var raycast_l0 = create();
var raycast_l1 = create();
var raycast_unit_y = fromValues(0, 1);
class Plane extends Shape {
  constructor(options) {
    if (options === undefined) {
      options = {};
    }
    super({
      ...options,
      type: Shape.PLANE
    });
    this.updateBoundingRadius();
    this.updateArea();
  }
  computeMomentOfInertia() {
    return 0;
  }
  updateBoundingRadius() {
    this.boundingRadius = Number.MAX_VALUE;
  }
  updateArea() {
    this.area = Number.MAX_VALUE;
  }
  computeAABB(out, position, angle) {
    const a2 = angle % (2 * Math.PI);
    const set$1 = set;
    const max = 1e7;
    const lowerBound = out.lowerBound;
    const upperBound = out.upperBound;
    set$1(lowerBound, -max, -max);
    set$1(upperBound, max, max);
    if (a2 === 0) {
      upperBound[1] = position[1];
    } else if (a2 === Math.PI / 2) {
      lowerBound[0] = position[0];
    } else if (a2 === Math.PI) {
      lowerBound[1] = position[1];
    } else if (a2 === 3 * Math.PI / 2) {
      upperBound[0] = position[0];
    }
  }
  raycast(result, ray, position, angle) {
    const from = ray.from;
    const to = ray.to;
    const direction = ray.direction;
    const planePointToFrom = intersectPlane_planePointToFrom;
    const normal = intersectPlane_normal;
    const len = intersectPlane_len;
    set(normal, 0, 1);
    rotate(normal, normal, angle);
    subtract(len, from, position);
    const planeToFrom = dot(len, normal);
    subtract(len, to, position);
    const planeToTo = dot(len, normal);
    if (planeToFrom * planeToTo > 0) {
      return;
    }
    if (squaredDistance(from, to) < planeToFrom * planeToFrom) {
      return;
    }
    const n_dot_dir = dot(normal, direction);
    subtract(planePointToFrom, from, position);
    const t3 = -dot(normal, planePointToFrom) / n_dot_dir / ray.length;
    ray.reportIntersection(result, t3, normal, -1);
  }
  pointTest(localPoint) {
    return localPoint[1] <= 0;
  }
}
var intersectPlane_planePointToFrom = create();
var intersectPlane_normal = create();
var intersectPlane_len = create();

class Solver {
  constructor(options, type) {
    if (options === undefined) {
      options = {};
    }
    this.type = type;
    this.equations = [];
    this.equationSortFunction = options.equationSortFunction;
  }
  sortEquations() {
    if (this.equationSortFunction) {
      this.equations.sort(this.equationSortFunction);
    }
  }
  addEquation(eq) {
    if (eq.enabled) {
      this.equations.push(eq);
    }
  }
  addEquations(eqs) {
    for (let i2 = 0, N2 = eqs.length;i2 !== N2; i2++) {
      const eq = eqs[i2];
      if (eq.enabled) {
        this.equations.push(eq);
      }
    }
  }
  removeEquation(eq) {
    const l3 = this.equations.length;
    for (let i2 = 0;i2 < l3; i2++) {
      if (this.equations[i2] === eq) {
        this.equations.splice(i2, 1);
        break;
      }
    }
  }
  removeAllEquations() {
    this.equations.length = 0;
  }
}

class GSSolver extends Solver {
  type = Solver.GS;
  constructor(options) {
    if (options === undefined) {
      options = {};
    }
    super(options, Solver.GS);
    this.iterations = options.iterations ?? 10;
    this.tolerance = options.tolerance ?? 0.0000001;
    this.frictionIterations = options.frictionIterations ?? 0;
    this.usedIterations = 0;
  }
  solve(h2, world) {
    this.sortEquations();
    let iter = 0;
    const maxIter = this.iterations;
    const maxFrictionIter = this.frictionIterations;
    const equations = this.equations;
    const Neq = equations.length;
    const tolSquared = Math.pow(this.tolerance * Neq, 2);
    const bodies = world.bodies;
    const Nbodies = bodies.length;
    this.usedIterations = 0;
    if (Neq) {
      for (let i3 = 0;i3 !== Nbodies; i3++) {
        const b2 = bodies[i3];
        b2.updateSolveMassProperties();
      }
    }
    for (let i3 = 0;i3 !== Neq; i3++) {
      const c3 = equations[i3];
      c3.lambda = 0;
      if (c3.timeStep !== h2 || c3.needsUpdate) {
        c3.timeStep = h2;
        c3.update();
      }
      c3.B = c3.computeB(c3.a, c3.b, h2);
      c3.invC = c3.computeInvC(c3.epsilon);
      c3.maxForceDt = c3.maxForce * h2;
      c3.minForceDt = c3.minForce * h2;
    }
    let c2, deltalambdaTot, i2, j2;
    if (Neq !== 0) {
      for (i2 = 0;i2 !== Nbodies; i2++) {
        const b2 = bodies[i2];
        b2.resetConstraintVelocity();
      }
      if (maxFrictionIter) {
        for (iter = 0;iter !== maxFrictionIter; iter++) {
          deltalambdaTot = 0;
          for (j2 = 0;j2 !== Neq; j2++) {
            c2 = equations[j2];
            const deltalambda = iterateEquation(c2);
            deltalambdaTot += Math.abs(deltalambda);
          }
          this.usedIterations++;
          if (deltalambdaTot * deltalambdaTot <= tolSquared) {
            break;
          }
        }
        updateMultipliers(equations, 1 / h2);
        for (j2 = 0;j2 !== Neq; j2++) {
          const eq = equations[j2];
          if (eq instanceof FrictionEquation) {
            let f2 = 0;
            const equationsLength = eq.contactEquations.length;
            for (let k2 = 0;k2 !== equationsLength; k2++) {
              f2 += eq.contactEquations[k2].multiplier;
            }
            f2 *= eq.frictionCoefficient / equationsLength;
            eq.maxForce = f2;
            eq.minForce = -f2;
            eq.maxForceDt = f2 * h2;
            eq.minForceDt = -f2 * h2;
          }
        }
      }
      for (iter = 0;iter !== maxIter; iter++) {
        deltalambdaTot = 0;
        for (j2 = 0;j2 !== Neq; j2++) {
          c2 = equations[j2];
          const deltalambda = iterateEquation(c2);
          deltalambdaTot += Math.abs(deltalambda);
        }
        this.usedIterations++;
        if (deltalambdaTot * deltalambdaTot < tolSquared) {
          break;
        }
      }
      for (i2 = 0;i2 !== Nbodies; i2++) {
        bodies[i2].addConstraintVelocity();
      }
      updateMultipliers(equations, 1 / h2);
    }
  }
}

class OverlapKeeperRecord {
  constructor(bodyA, shapeA, bodyB, shapeB) {
    this.bodyA = bodyA;
    this.shapeA = shapeA;
    this.bodyB = bodyB;
    this.shapeB = shapeB;
  }
  set(bodyA, shapeA, bodyB, shapeB) {
    this.bodyA = bodyA;
    this.shapeA = shapeA;
    this.bodyB = bodyB;
    this.shapeB = shapeB;
  }
}

class OverlapKeeperRecordPool extends Pool {
  create() {
    return new OverlapKeeperRecord(tmpBody, tmpShape, tmpBody, tmpShape);
  }
  destroy(record) {
    record.bodyA = record.bodyB = tmpBody;
    record.shapeA = record.shapeB = tmpShape;
    return this;
  }
}
var tmpShape = new Circle({
  radius: 1
});
var tmpBody = new Body;

class OverlapKeeper {
  constructor() {
    this.overlappingShapesLastState = new TupleDictionary;
    this.overlappingShapesCurrentState = new TupleDictionary;
    this.recordPool = new OverlapKeeperRecordPool({
      size: 16
    });
    this.tmpDict = new TupleDictionary;
    this.tmpArray1 = [];
  }
  tick() {
    const last = this.overlappingShapesLastState;
    const current = this.overlappingShapesCurrentState;
    let l3 = last.keys.length;
    while (l3--) {
      const key = last.keys[l3];
      const lastObject = last.getByKey(key);
      if (lastObject) {
        this.recordPool.release(lastObject);
      }
    }
    last.copy(current);
    current.reset();
  }
  bodiesAreOverlapping(bodyA, bodyB) {
    const current = this.overlappingShapesCurrentState;
    let l3 = current.keys.length;
    while (l3--) {
      const key = current.keys[l3];
      const data = current.data[key];
      if (data.bodyA === bodyA && data.bodyB === bodyB || data.bodyA === bodyB && data.bodyB === bodyA) {
        return true;
      }
    }
    return false;
  }
  setOverlapping(bodyA, shapeA, bodyB, shapeB) {
    const current = this.overlappingShapesCurrentState;
    if (!current.get(shapeA.id, shapeB.id)) {
      const data = this.recordPool.get();
      data.set(bodyA, shapeA, bodyB, shapeB);
      current.set(shapeA.id, shapeB.id, data);
    }
  }
  getNewOverlaps(result) {
    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
  }
  getEndOverlaps(result) {
    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
  }
  getDiff(dictA, dictB, result) {
    if (result === undefined) {
      result = [];
    }
    const last = dictA;
    const current = dictB;
    result.length = 0;
    let l3 = current.keys.length;
    while (l3--) {
      const key = current.keys[l3];
      const data = current.data[key];
      if (!data) {
        throw new Error("Key " + key + " had no data!");
      }
      const lastData = last.data[key];
      if (!lastData) {
        result.push(data);
      }
    }
    return result;
  }
  isNewOverlap(shapeA, shapeB) {
    const idA = shapeA.id | 0, idB = shapeB.id | 0;
    const last = this.overlappingShapesLastState;
    const current = this.overlappingShapesCurrentState;
    return !last.get(idA, idB) && !!current.get(idA, idB);
  }
  getNewBodyOverlaps(result) {
    this.tmpArray1.length = 0;
    const overlaps = this.getNewOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
  }
  getEndBodyOverlaps(result) {
    this.tmpArray1.length = 0;
    const overlaps = this.getEndOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
  }
  getBodyDiff(overlaps, result) {
    if (result === undefined) {
      result = [];
    }
    const accumulator = this.tmpDict;
    let l3 = overlaps.length;
    while (l3--) {
      const data = overlaps[l3];
      accumulator.set(data.bodyA.id | 0, data.bodyB.id | 0, data);
    }
    l3 = accumulator.keys.length;
    while (l3--) {
      const data = accumulator.getByKey(accumulator.keys[l3]);
      if (data) {
        result.push(data.bodyA, data.bodyB);
      }
    }
    accumulator.reset();
    return result;
  }
}

class UnionFind {
  id = [];
  sz = [];
  constructor(size) {
    this.size = size;
    this.count = size;
    this.resize(size);
  }
  resize(size) {
    this.count = this.size = size;
    const sz = this.sz;
    const id = this.id;
    for (let i2 = 0;i2 < size; i2++) {
      id[i2] = i2;
      sz[i2] = 1;
    }
  }
  find(p2) {
    const id = this.id;
    while (p2 !== id[p2]) {
      id[p2] = id[id[p2]];
      p2 = id[p2];
    }
    return p2;
  }
  union(p2, q2) {
    const i2 = this.find(p2), j2 = this.find(q2);
    if (i2 === j2) {
      return;
    }
    const sz = this.sz;
    const id = this.id;
    if (sz[i2] < sz[j2]) {
      id[i2] = j2;
      sz[j2] += sz[i2];
    } else {
      id[j2] = i2;
      sz[i2] += sz[j2];
    }
    this.count--;
    return;
  }
}

class World extends EventEmitter {
  static NO_SLEEPING = 1;
  static BODY_SLEEPING = 2;
  static ISLAND_SLEEPING = 4;
  springs = [];
  bodies = [];
  hasActiveBodies = false;
  narrowphase = new Narrowphase;
  useWorldGravityAsFrictionGravity = true;
  useFrictionGravityOnZeroGravity = true;
  constraints = [];
  lastTimeStep = 1 / 60;
  applySpringForces = true;
  applyDamping = true;
  applyGravity = true;
  solveConstraints = true;
  contactMaterials = [];
  time = 0;
  accumulator = 0;
  stepping = false;
  emitImpactEvent = true;
  sleepMode = World.NO_SLEEPING;
  overlapKeeper = new OverlapKeeper;
  disabledBodyCollisionPairs = [];
  unionFind = new UnionFind(1);
  bodiesToAdd = [];
  bodiesToRemove = [];
  constraintsToAdd = [];
  constraintsToRemove = [];
  springsToAdd = [];
  springsToRemove = [];
  constructor(options) {
    if (options === undefined) {
      options = {};
    }
    super();
    this.solver = options.solver || new GSSolver;
    this.gravity = fromValues(0, -9.78);
    if (options.gravity) {
      copy(this.gravity, options.gravity);
    }
    this.frictionGravity = length(this.gravity) || 10;
    this.broadphase = options.broadphase || new SAPBroadphase;
    this.broadphase.setWorld(this);
    this.defaultMaterial = new Material;
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial);
    this.islandSplit = options.islandSplit ?? true;
  }
  addConstraint(constraint) {
    if (this.stepping) {
      this.constraintsToAdd.push(constraint);
      return;
    }
    const bodies = this.bodies;
    if (bodies.indexOf(constraint.bodyA) === -1) {
      throw new Error("Cannot add Constraint: bodyA is not added to the World.");
    }
    if (bodies.indexOf(constraint.bodyB) === -1) {
      throw new Error("Cannot add Constraint: bodyB is not added to the World.");
    }
    this.constraints.push(constraint);
  }
  addContactMaterial(contactMaterial) {
    this.contactMaterials.push(contactMaterial);
  }
  removeContactMaterial(cm) {
    arrayRemove(this.contactMaterials, cm);
  }
  getContactMaterial(materialA, materialB) {
    const cmats = this.contactMaterials;
    for (let i2 = 0, N2 = cmats.length;i2 !== N2; i2++) {
      const cm = cmats[i2];
      if (cm.materialA === materialA && cm.materialB === materialB || cm.materialA === materialB && cm.materialB === materialA) {
        return cm;
      }
    }
    return false;
  }
  removeConstraint(constraint) {
    if (this.stepping) {
      this.constraintsToRemove.push(constraint);
      return;
    }
    arrayRemove(this.constraints, constraint);
  }
  step(dt, timeSinceLastCalled, maxSubSteps) {
    if (maxSubSteps === undefined) {
      maxSubSteps = 10;
    }
    this.digestChanges();
    if (timeSinceLastCalled === undefined) {
      this.internalStep(dt);
      this.time += dt;
    } else {
      this.accumulator += timeSinceLastCalled;
      let substeps = 0;
      while (this.accumulator >= dt && substeps < maxSubSteps) {
        this.internalStep(dt);
        this.time += dt;
        this.accumulator -= dt;
        substeps++;
      }
      const t3 = this.accumulator % dt / dt;
      const l3 = this.bodies.length;
      for (let j2 = 0;j2 !== l3; j2++) {
        const b2 = this.bodies[j2];
        lerp(b2.interpolatedPosition, b2.previousPosition, b2.position, t3);
        b2.interpolatedAngle = b2.previousAngle + t3 * (b2.angle - b2.previousAngle);
      }
    }
  }
  digestChanges() {
    const bodiesToAdd = this.bodiesToAdd;
    const nBodiesToAdd = bodiesToAdd.length;
    for (let i2 = 0;i2 !== nBodiesToAdd; i2++) {
      this.addBody(bodiesToAdd[i2]);
    }
    bodiesToAdd.length = 0;
    const constraintsToAdd = this.constraintsToAdd;
    const nConstraintsToAdd = constraintsToAdd.length;
    for (let i2 = 0;i2 !== nConstraintsToAdd; i2++) {
      this.addConstraint(constraintsToAdd[i2]);
    }
    constraintsToAdd.length = 0;
    const springsToAdd = this.springsToAdd;
    const nSpringsToAdd = springsToAdd.length;
    for (let i2 = 0;i2 !== nSpringsToAdd; i2++) {
      this.addSpring(springsToAdd[i2]);
    }
    springsToAdd.length = 0;
    const bodiesToRemove = this.bodiesToRemove;
    const nBodiesToRemove = bodiesToRemove.length;
    for (let i2 = 0;i2 !== nBodiesToRemove; i2++) {
      this.removeBody(bodiesToRemove[i2]);
    }
    bodiesToRemove.length = 0;
    const constraintsToRemove = this.constraintsToRemove;
    const nConstraintsToRemove = constraintsToRemove.length;
    for (let i2 = 0;i2 !== nConstraintsToRemove; i2++) {
      this.removeConstraint(constraintsToRemove[i2]);
    }
    constraintsToRemove.length = 0;
    const springsToRemove = this.springsToRemove;
    const nSpringsToRemove = springsToRemove.length;
    for (let i2 = 0;i2 !== nSpringsToRemove; i2++) {
      this.removeSpring(springsToRemove[i2]);
    }
    springsToRemove.length = 0;
  }
  internalStep(dt) {
    this.stepping = true;
    const Nsprings = this.springs.length, springs = this.springs, bodies = this.bodies, g3 = this.gravity, solver = this.solver, Nbodies = this.bodies.length, broadphase = this.broadphase, np = this.narrowphase, constraints = this.constraints, mg = step_mg, add$1 = add;
    this.overlapKeeper.tick();
    this.lastTimeStep = dt;
    if (this.useWorldGravityAsFrictionGravity) {
      const gravityLen = length(this.gravity);
      if (!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)) {
        this.frictionGravity = gravityLen;
      }
    }
    if (this.applyGravity) {
      for (let i2 = 0;i2 !== Nbodies; i2++) {
        const b2 = bodies[i2], fi = b2.force;
        if (b2.type !== Body.DYNAMIC || b2.sleepState === Body.SLEEPING) {
          continue;
        }
        scale2(mg, g3, b2.mass * b2.gravityScale);
        add$1(fi, fi, mg);
      }
    }
    if (this.applySpringForces) {
      for (let i2 = 0;i2 !== Nsprings; i2++) {
        const s2 = springs[i2];
        s2.applyForce();
      }
    }
    if (this.applyDamping) {
      for (let i2 = 0;i2 !== Nbodies; i2++) {
        const b2 = bodies[i2];
        if (b2.type === Body.DYNAMIC) {
          b2.applyDamping(dt);
        }
      }
    }
    const result = broadphase.getCollisionPairs(this);
    const ignoredPairs = this.disabledBodyCollisionPairs;
    for (let i2 = ignoredPairs.length - 2;i2 >= 0; i2 -= 2) {
      for (let j2 = result.length - 2;j2 >= 0; j2 -= 2) {
        if (ignoredPairs[i2] === result[j2] && ignoredPairs[i2 + 1] === result[j2 + 1] || ignoredPairs[i2 + 1] === result[j2] && ignoredPairs[i2] === result[j2 + 1]) {
          result.splice(j2, 2);
        }
      }
    }
    let Nconstraints = constraints.length;
    for (let i2 = 0;i2 !== Nconstraints; i2++) {
      const c2 = constraints[i2];
      if (!c2.collideConnected) {
        for (let j2 = result.length - 2;j2 >= 0; j2 -= 2) {
          if (c2.bodyA === result[j2] && c2.bodyB === result[j2 + 1] || c2.bodyB === result[j2] && c2.bodyA === result[j2 + 1]) {
            result.splice(j2, 2);
          }
        }
      }
    }
    this.emit({
      type: "postBroadphase",
      pairs: result
    });
    np.reset();
    const defaultContactMaterial = this.defaultContactMaterial;
    const frictionGravity = this.frictionGravity;
    for (let i2 = 0, Nresults = result.length;i2 !== Nresults; i2 += 2) {
      const bi = result[i2];
      const bj = result[i2 + 1];
      for (let k2 = 0, Nshapesi = bi.shapes.length;k2 !== Nshapesi; k2++) {
        const si = bi.shapes[k2];
        const xi = si.position;
        const ai = si.angle;
        for (let l3 = 0, Nshapesj = bj.shapes.length;l3 !== Nshapesj; l3++) {
          const sj = bj.shapes[l3];
          const xj = sj.position;
          const aj = sj.angle;
          let contactMaterial = false;
          if (si.material && sj.material) {
            contactMaterial = this.getContactMaterial(si.material, sj.material);
          }
          runNarrowphase(this, np, bi, si, xi, ai, bj, sj, xj, aj, contactMaterial || defaultContactMaterial, frictionGravity);
        }
      }
    }
    for (let i2 = 0;i2 !== Nbodies; i2++) {
      const body = bodies[i2];
      if (body._wakeUpAfterNarrowphase) {
        body.wakeUp();
        body._wakeUpAfterNarrowphase = false;
      }
    }
    if (this.has("endContact")) {
      this.overlapKeeper.getEndOverlaps(endOverlaps);
      let l3 = endOverlaps.length;
      while (l3--) {
        const data = endOverlaps[l3];
        const e2 = {
          type: "endContact",
          shapeA: data.shapeA,
          shapeB: data.shapeB,
          bodyA: data.bodyA,
          bodyB: data.bodyB
        };
        this.emit(e2);
      }
      endOverlaps.length = 0;
    }
    this.emit({
      type: "preSolve",
      contactEquations: np.contactEquations,
      frictionEquations: np.frictionEquations
    });
    Nconstraints = constraints.length;
    for (let i2 = 0;i2 !== Nconstraints; i2++) {
      constraints[i2].update();
    }
    if (np.contactEquations.length || np.frictionEquations.length || Nconstraints) {
      let equations = [];
      appendArray(equations, np.contactEquations);
      appendArray(equations, np.frictionEquations);
      for (let i2 = 0;i2 !== Nconstraints; i2++) {
        appendArray(equations, constraints[i2].equations);
      }
      if (this.islandSplit) {
        const unionFind = this.unionFind;
        unionFind.resize(Nbodies + 1);
        const Nequations = equations.length;
        for (let i2 = 0;i2 < Nequations; i2++) {
          equations[i2].index = i2;
        }
        for (let i2 = 0;i2 < Nequations; i2++) {
          const bodyA = equations[i2].bodyA;
          const bodyB = equations[i2].bodyB;
          if (bodyA.type === Body.DYNAMIC && bodyB.type === Body.DYNAMIC) {
            unionFind.union(bodyA.index, bodyB.index);
          }
        }
        for (let i2 = 0;i2 < Nbodies; i2++) {
          const body = bodies[i2];
          body.islandId = body.type === Body.DYNAMIC ? unionFind.find(body.index) : -1;
        }
        equations = equations.sort(sortEquationsByIsland);
        let equationIndex = 0;
        while (equationIndex < Nequations) {
          const equation = equations[equationIndex++];
          solver.addEquation(equation);
          const currentIslandId = equation.bodyA.islandId > 0 ? equation.bodyA.islandId : equation.bodyB.islandId;
          let nextIslandId = -1;
          if (equations[equationIndex]) {
            nextIslandId = equations[equationIndex].bodyA.islandId > 0 ? equations[equationIndex].bodyA.islandId : equations[equationIndex].bodyB.islandId;
          }
          if (nextIslandId !== currentIslandId || equationIndex === equations.length) {
            if (this.solveConstraints) {
              solver.solve(dt, this);
            }
            solver.removeAllEquations();
          }
        }
      } else {
        solver.addEquations(equations);
        if (this.solveConstraints) {
          solver.solve(dt, this);
        }
        solver.removeAllEquations();
      }
    }
    for (let i2 = 0;i2 !== Nbodies; i2++) {
      const body = bodies[i2];
      if (body.type === Body.DYNAMIC || body.type === Body.KINEMATIC) {
        body.integrate(dt);
      }
    }
    for (let i2 = 0;i2 !== Nbodies; i2++) {
      bodies[i2].setZeroForce();
    }
    if (this.emitImpactEvent && this.has("impact")) {
      for (let i2 = 0;i2 !== np.contactEquations.length; i2++) {
        const eq = np.contactEquations[i2];
        if (eq.firstImpact) {
          this.emit({
            type: "impact",
            bodyA: eq.bodyA,
            bodyB: eq.bodyB,
            shapeA: eq.shapeA,
            shapeB: eq.shapeB,
            contactEquation: eq
          });
        }
      }
    }
    let hasActiveBodies = true;
    if (this.sleepMode === World.BODY_SLEEPING) {
      hasActiveBodies = false;
      for (let i2 = 0;i2 !== Nbodies; i2++) {
        const body = bodies[i2];
        body.sleepTick(this.time, false, dt);
        if (body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC) {
          hasActiveBodies = true;
        }
      }
    } else if (this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit) {
      for (let i2 = 0;i2 !== Nbodies; i2++) {
        bodies[i2].sleepTick(this.time, true, dt);
      }
      const bodiesSortedByIsland = bodies.sort(sortBodiesByIsland);
      let islandEnd = 1;
      for (let islandStart = 0;islandStart < bodiesSortedByIsland.length; islandStart = islandEnd) {
        const islandId = bodiesSortedByIsland[islandStart].islandId;
        for (islandEnd = islandStart + 1;islandEnd < bodiesSortedByIsland.length && bodiesSortedByIsland[islandEnd].islandId === islandId; islandEnd++) {
        }
        if (islandId === -1) {
          continue;
        }
        let islandShouldSleep = true;
        for (let i2 = islandStart;i2 < islandEnd; i2++) {
          if (!bodiesSortedByIsland[i2].wantsToSleep) {
            islandShouldSleep = false;
            break;
          }
        }
        if (islandShouldSleep) {
          for (let i2 = islandStart;i2 < islandEnd; i2++) {
            bodiesSortedByIsland[i2].sleep();
          }
        }
      }
      hasActiveBodies = false;
      for (let i2 = 0;i2 !== Nbodies; i2++) {
        const body = bodies[i2];
        if (body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC) {
          hasActiveBodies = true;
          break;
        }
      }
    }
    this.hasActiveBodies = hasActiveBodies;
    this.stepping = false;
    this.emit({
      type: "postStep"
    });
  }
  addSpring(spring) {
    if (this.stepping) {
      this.springsToAdd.push(spring);
      return;
    }
    this.springs.push(spring);
    this.emit({
      type: "addSpring",
      spring
    });
  }
  removeSpring(spring) {
    if (this.stepping) {
      this.springsToRemove.push(spring);
      return;
    }
    arrayRemove(this.springs, spring);
    this.emit({
      type: "removeSpring",
      spring
    });
  }
  addBody(body) {
    if (this.stepping) {
      this.bodiesToAdd.push(body);
      return;
    }
    if (body.world) {
      throw new Error("Body is already added to a World.");
    }
    body.index = this.bodies.length;
    this.bodies.push(body);
    body.world = this;
    this.emit({
      type: "addBody",
      body
    });
  }
  removeBody(body) {
    if (this.stepping) {
      this.bodiesToRemove.push(body);
      return;
    }
    const constraints = this.constraints;
    let l3 = constraints.length;
    while (l3--) {
      if (constraints[l3].bodyA === body || constraints[l3].bodyB === body) {
        throw new Error("Cannot remove Body from World: it still has constraints connected to it.");
      }
    }
    body.world = null;
    const bodies = this.bodies;
    arrayRemove(bodies, body);
    body.index = -1;
    l3 = bodies.length;
    while (l3--) {
      bodies[l3].index = l3;
    }
    body.resetConstraintVelocity();
    this.emit({
      type: "removeBody",
      body
    });
    const pairs = this.disabledBodyCollisionPairs;
    let i2 = 0;
    const pl = pairs.length;
    while (i2 < pl) {
      if (pairs[i2] === body || pairs[i2 + 1] === body) {
        pairs.splice(i2, 2);
      } else {
        i2 += 2;
      }
    }
  }
  getBodyByID(id) {
    const bodies = this.bodies;
    const l3 = bodies.length;
    for (let i2 = 0;i2 < l3; i2++) {
      const b2 = bodies[i2];
      if (b2.id === id) {
        return b2;
      }
    }
    return false;
  }
  disableBodyCollision(bodyA, bodyB) {
    this.disabledBodyCollisionPairs.push(bodyA, bodyB);
  }
  enableBodyCollision(bodyA, bodyB) {
    const pairs = this.disabledBodyCollisionPairs;
    const l3 = pairs.length;
    for (let i2 = 0;i2 < l3; i2 += 2) {
      if (pairs[i2] === bodyA && pairs[i2 + 1] === bodyB || pairs[i2 + 1] === bodyA && pairs[i2] === bodyB) {
        pairs.splice(i2, 2);
        return;
      }
    }
  }
  clear() {
    this.solver.removeAllEquations();
    const cs = this.constraints;
    let i2 = cs.length;
    while (i2--) {
      this.removeConstraint(cs[i2]);
    }
    const bodies = this.bodies;
    i2 = bodies.length;
    while (i2--) {
      this.removeBody(bodies[i2]);
    }
    const springs = this.springs;
    i2 = springs.length;
    while (i2--) {
      this.removeSpring(springs[i2]);
    }
    const cms = this.contactMaterials;
    i2 = cms.length;
    while (i2--) {
      this.removeContactMaterial(cms[i2]);
    }
  }
  hitTest(worldPoint, bodies, precision) {
    if (precision === undefined) {
      precision = 0;
    }
    const shapeWorldPosition2 = hitTest_tmp1, shapeLocalPoint = hitTest_tmp2;
    const result = [];
    for (let i2 = 0, N2 = bodies.length;i2 !== N2; i2++) {
      const body = bodies[i2];
      for (let j2 = 0, NS = body.shapes.length;j2 !== NS; j2++) {
        const shape = body.shapes[j2];
        shape.worldPointToLocal(shapeLocalPoint, worldPoint);
        if (shape.pointTest(shapeLocalPoint)) {
          result.push(body);
        } else {
          rotate(shapeWorldPosition2, shape.position, body.angle);
          add(shapeWorldPosition2, shapeWorldPosition2, body.position);
          if (shape.type === Shape.PARTICLE && squaredDistance(shapeWorldPosition2, worldPoint) < precision * precision) {
            result.push(body);
          }
        }
      }
    }
    return result;
  }
  setGlobalStiffness(stiffness) {
    this.setGlobalEquationParameters({
      stiffness
    });
    const contactMaterials = this.contactMaterials;
    const l3 = contactMaterials.length;
    for (let i2 = 0;i2 !== l3; i2++) {
      const c3 = contactMaterials[i2];
      c3.stiffness = c3.frictionStiffness = stiffness;
    }
    const c2 = this.defaultContactMaterial;
    c2.stiffness = c2.frictionStiffness = stiffness;
  }
  setGlobalRelaxation(relaxation) {
    this.setGlobalEquationParameters({
      relaxation
    });
    const l3 = this.contactMaterials.length;
    for (let i2 = 0;i2 !== l3; i2++) {
      const c3 = this.contactMaterials[i2];
      c3.relaxation = c3.frictionRelaxation = relaxation;
    }
    const c2 = this.defaultContactMaterial;
    c2.relaxation = c2.frictionRelaxation = relaxation;
  }
  raycast(result, ray) {
    ray.getAABB(tmpRaycastAABB);
    this.broadphase.aabbQuery(this, tmpRaycastAABB, tmpRaycastArray);
    ray.intersectBodies(result, tmpRaycastArray);
    tmpRaycastArray.length = 0;
    return result.hasHit();
  }
  setGlobalEquationParameters(parameters) {
    const constraints = this.constraints;
    const l3 = constraints.length;
    for (let i2 = 0;i2 !== l3; i2++) {
      const c2 = constraints[i2];
      const eqs = c2.equations;
      const Nequations = eqs.length;
      for (let j2 = 0;j2 !== Nequations; j2++) {
        const eq = eqs[j2];
        eq.relaxation = parameters.relaxation ?? eq.relaxation;
        eq.stiffness = parameters.stiffness ?? eq.stiffness;
        eq.needsUpdate = true;
      }
    }
  }
}
var tmpRaycastAABB = new AABB;
var tmpRaycastArray = [];
var step_mg = create();
var xiw = create();
var xjw = create();
var endOverlaps = [];
var hitTest_tmp1 = create();
var hitTest_tmp2 = create();

// node_modules/colord/plugins/names.mjsiste
class SimuloPhysicsServerP2 {
  world;
  changedContents = {};
  removedContents = [];
  objectDatas = {};
  constructor() {
    this.world = new World({
      gravity: [0, -9.81]
    });
  }
  step() {
    let before = performance.now();
    this.world.step(0.016666666666666666);
    return this.getStepInfo([], before);
  }
  getStepInfo(sounds, before) {
    let changed = this.changedContents;
    let removed = this.removedContents;
    this.changedContents = {};
    this.removedContents = [];
    return {
      delta: {
        shapeContent: changed,
        shapeTransforms: this.getShapeTransforms(),
        removedContents: removed
      },
      ms: performance.now() - before,
      sounds: [],
      springs: this.world.springs.map((spring) => {
        if (spring instanceof LinearSpring) {
          let outA = vec2.create();
          let outB = vec2.create();
          spring.getWorldAnchorA(outA);
          spring.getWorldAnchorB(outB);
          return {
            pointA: {
              x: outA[0],
              y: outA[1]
            },
            pointB: {
              x: outB[0],
              y: outB[1]
            }
          };
        }
        return null;
      }).filter((spring) => {
        return spring !== null;
      })
    };
  }
  getShapeTransforms() {
    let transforms = {};
    this.world.bodies.forEach((body) => {
      body.shapes.forEach((shape) => {
        let id = shape.id;
        let transform = {
          x: body.position[0],
          y: body.position[1],
          z: 0,
          angle: body.angle
        };
        transforms[id] = transform;
      });
    });
    return transforms;
  }
  destroyBody(body) {
    this.world.removeBody(body);
    this.removedContents.push(body.shapes[0].id.toString());
  }
  destroyObject(object) {
    if (object.reference instanceof Body) {
      this.destroyBody(object.reference);
    }
  }
  addPolygon(polygon) {
    let body = new Body({
      mass: 1
    });
    if (body.fromPolygon(polygon.points.map((point) => {
      return [point.x, point.y];
    }), {
      removeCollinearPoints: 0.1
    })) {
      body.position = [polygon.position.x, polygon.position.y];
      body.angle = 0;
      this.world.addBody(body);
      this.objectDatas[body.id] = {
        id: body.id.toString(),
        name: polygon.name,
        sound: null,
        color: polygon.color,
        alpha: polygon.alpha,
        border: polygon.border,
        borderWidth: polygon.borderWidth,
        image: null,
        zDepth: 1,
        borderScaleWithZoom: false
      };
      this.changedContents[body.shapes[0].id.toString()] = this.getShapeContent(body);
      return this.getSimuloObject(body);
    }
    throw new Error("Failed to create polygon");
  }
  getSimuloObject(reference) {
    if (reference instanceof Body) {
      return {
        destroy: () => {
          this.destroyBody(reference);
        },
        id: reference.id.toString(),
        reference
      };
    }
    return null;
  }
  getShapeContent(body) {
    let shape = body.shapes[0];
    shape.type;
    if (!shape)
      return null;
    let id = shape.id;
    let objectData = this.objectDatas[body.id];
    let baseShape = {
      id: id.toString(),
      type: "cuboid",
      color: objectData ? objectData.color : 16777215,
      alpha: 1,
      border: null,
      borderWidth: null,
      name: objectData ? objectData.name ?? "Some kind of object" : "Some kind of object",
      description: null
    };
    if (shape instanceof Box) {
      let rect = {
        ...baseShape,
        type: "cuboid",
        width: shape.width,
        height: shape.height,
        depth: 1
      };
      return rect;
    } else if (shape instanceof Circle) {
      let circle = {
        ...baseShape,
        type: "ball",
        radius: shape.radius,
        cakeSlice: true
      };
      return circle;
    } else if (shape instanceof Convex) {
      let polygon = {
        ...baseShape,
        type: "polygon",
        points: shape.vertices.map((vertex) => {
          return [vertex[0], vertex[1]];
        })
      };
      return polygon;
    } else if (shape instanceof Line) {
      return null;
    } else if (shape instanceof Plane) {
      let plane = {
        ...baseShape,
        type: "plane"
      };
      return plane;
    } else {
      return null;
    }
  }
  getObjectAtPoint(point) {
    let bodies = this.world.hitTest([point.x, point.y], this.world.bodies, 5);
    let b2 = undefined;
    while (bodies.length > 0) {
      b2 = bodies.shift();
      if (!b2 || b2.type === Body.STATIC) {
        b2 = undefined;
      } else {
        break;
      }
    }
    return this.getSimuloObject(b2) || null;
  }
  getObjectsAtPoint(point) {
    let bodies = this.world.hitTest([point.x, point.y], this.world.bodies, 5);
    return bodies.map((body) => {
      return this.getSimuloObject(body);
    });
  }
  getObjectsInCuboid(startPoint, endPoint) {
    let intersection = this.world.broadphase.aabbQuery(this.world, new AABB({
      lowerBound: [Math.min(startPoint.x, endPoint.x), Math.min(startPoint.y, endPoint.y)],
      upperBound: [Math.max(startPoint.x, endPoint.x), Math.max(startPoint.y, endPoint.y)]
    }));
    let bodies = intersection.filter((body) => {
      return !(body.shapes[0] instanceof Plane);
    });
    return bodies.map((body) => {
      return this.getSimuloObject(body);
    });
  }
  addBall(circle) {
    let body = new Body({
      mass: 1
    });
    let shape = new Circle({
      radius: circle.radius
    });
    body.addShape(shape);
    body.position = [circle.position.x, circle.position.y];
    body.angle = 0;
    this.world.addBody(body);
    this.objectDatas[body.id] = {
      id: body.id.toString(),
      name: circle.name,
      sound: null,
      color: circle.color,
      alpha: circle.alpha,
      border: circle.border,
      borderWidth: circle.borderWidth,
      image: null,
      zDepth: 1,
      borderScaleWithZoom: false,
      circleCake: circle.cakeSlice
    };
    this.changedContents[body.shapes[0].id.toString()] = this.getShapeContent(body);
    return this.getSimuloObject(body);
  }
  addCuboid(rectangle) {
    let body = new Body({
      mass: rectangle.isStatic ? 0 : rectangle.density / 10 * rectangle.width * rectangle.height
    });
    let shape = new Box({
      width: rectangle.width,
      height: rectangle.height
    });
    body.updateSolveMassProperties();
    let inertia = body.mass * (rectangle.width * rectangle.width + rectangle.height * rectangle.height) * 50000;
    body.inertia = inertia;
    body.invInertia = 1 / inertia;
    body.addShape(shape);
    body.position = [rectangle.position.x, rectangle.position.y];
    body.angle = 0;
    this.world.addBody(body);
    this.objectDatas[body.id] = {
      id: body.id.toString(),
      name: rectangle.name,
      sound: null,
      color: rectangle.color,
      alpha: rectangle.alpha,
      border: rectangle.border,
      borderWidth: rectangle.borderWidth,
      image: null,
      zDepth: 1,
      borderScaleWithZoom: false
    };
    this.changedContents[body.shapes[0].id.toString()] = this.getShapeContent(body);
    return this.getSimuloObject(body);
  }
  addSpring(spring) {
    let constraint = new LinearSpring(spring.objectA?.reference, spring.objectB?.reference, {
      stiffness: spring.stiffness,
      damping: spring.damping,
      restLength: spring.restLength,
      localAnchorA: [spring.localAnchorA.x, spring.localAnchorA.y],
      localAnchorB: [spring.localAnchorB.x, spring.localAnchorB.y]
    });
    this.world.addSpring(constraint);
    return {
      destroy: () => {
        this.world.removeSpring(constraint);
      },
      reference: constraint,
      setLocalAnchorA: (anchor) => {
        constraint.localAnchorA = [anchor.x, anchor.y];
      },
      setLocalAnchorB: (anchor) => {
        constraint.localAnchorB = [anchor.x, anchor.y];
      }
    };
  }
  removeSpring(spring) {
    this.world.removeSpring(spring.reference);
  }
  getLocalPoint(body, worldPoint) {
    let vec3 = vec2.create();
    body.toLocalFrame(vec3, worldPoint);
    return [vec3[0], vec3[1]];
  }
  getObjectData(body) {
    if (!(body instanceof Body)) {
      body = body.reference;
    }
    return this.objectDatas[body.id] || null;
  }
  getObjectByID(id) {
    let body = this.world.getBodyByID(parseInt(id));
    if (!body)
      return null;
    return this.getSimuloObject(body);
  }
  saveScene() {
    return {};
  }
  destroy() {
    this.world.clear();
    this.world = null;
  }
  getLocalObjectPoint(object, worldPoint) {
    let out = vec2.create();
    object.reference.toLocalFrame(out, [worldPoint.x, worldPoint.y]);
    return {
      x: out[0],
      y: out[1],
      z: 0
    };
  }
  getWorldObjectPoint(object, localPoint) {
    let out = vec2.create();
    object.reference.toWorldFrame(out, [localPoint.x, localPoint.y]);
    return {
      x: out[0],
      y: out[1],
      z: 0
    };
  }
}
var SimuloPhysicsServerP2_default = SimuloPhysicsServerP2;

// node_modules/colord/plugins/names.mjsiste
class SimuloPhysicsPlugin {
  name = "Simulo Physics Plugin";
  description = "Rapier physics for Simulo. This can change physics backends.";
  version = "0.1.0";
  author = "Carroted";
  namespace = "carroted";
  id = "simulo-physics-plugin";
  dependencies = [];
  controller;
  physicsServer;
  previousStepInfo = null;
  paused = false;
  constructor(controller, backend) {
    this.controller = controller;
    if (backend === "rapier") {
      this.physicsServer = new SimuloPhysicsServerRapier_default;
    } else if (backend === "p2") {
      this.physicsServer = new SimuloPhysicsServerP2_default;
    } else {
      console.log("No physics backend specified, defaulting to rapier");
      this.physicsServer = new SimuloPhysicsServerRapier_default;
    }
  }
  async switchBackends(backend) {
    this.physicsServer.destroy();
    if (backend === "rapier") {
      this.physicsServer = new SimuloPhysicsServerRapier_default;
    } else if (backend === "p2") {
      this.physicsServer = new SimuloPhysicsServerP2_default;
    }
    await this.init();
  }
  async init() {
    if (this.physicsServer instanceof SimuloPhysicsServerRapier_default) {
      await this.physicsServer.init();
    }
    let groundPlane = this.physicsServer.addCuboid({
      width: 2000,
      height: 1000,
      depth: 1,
      color: 10595578,
      alpha: 1,
      border: null,
      name: "joe",
      sound: "/assets/sounds/impact.wav",
      borderWidth: 1,
      borderScaleWithZoom: true,
      image: null,
      zDepth: 0,
      position: { x: 0, y: -510 },
      isStatic: true,
      friction: 0.5,
      restitution: 0.3,
      density: 1
    });
    let addBox = (x2, y2) => {
      this.physicsServer.addCuboid({
        width: 1,
        height: 1,
        depth: 1,
        color: 16732240,
        alpha: 1,
        border: 16711680,
        name: "joe",
        sound: "/assets/sounds/impact.wav",
        borderWidth: 1,
        borderScaleWithZoom: true,
        image: null,
        zDepth: 0,
        position: { x: x2, y: y2 },
        isStatic: false,
        friction: 0,
        restitution: 1,
        density: 10
      });
    };
    let doIt = (x2, color) => {
      this.addPerson([x2, 10], color);
      addBox(x2 + 0.1, 2);
      this.physicsServer.addCuboid({
        width: 2,
        height: 8,
        depth: 1,
        color: 16752800,
        alpha: 1,
        border: null,
        name: "joe",
        sound: "/assets/sounds/impact.wav",
        borderWidth: 1,
        borderScaleWithZoom: true,
        image: null,
        zDepth: 0,
        position: { x: x2 + 2, y: -6 },
        isStatic: true,
        friction: 0.5,
        restitution: 0,
        density: 1
      });
      this.physicsServer.addCuboid({
        width: 2,
        height: 8,
        depth: 1,
        color: 16752800,
        alpha: 1,
        border: null,
        name: "joe",
        sound: "/assets/sounds/impact.wav",
        borderWidth: 1,
        borderScaleWithZoom: true,
        image: null,
        zDepth: 0,
        position: { x: x2 - 10, y: -6 },
        isStatic: true,
        friction: 0.5,
        restitution: 0,
        density: 1
      });
    };
    doIt(-40, 10084471);
    doIt(40, 16744517);
    doIt(0, 6521087);
    let createTestbed = (offsetX, offsetY, size, cubeFriction = 0.5, density = 1) => {
      {
        let groundSize = 40;
        let grounds = [
          { x: 0, y: 0, hx: groundSize, hy: 0.1 },
          { x: -groundSize, y: groundSize, hx: 0.1, hy: groundSize },
          { x: groundSize, y: groundSize, hx: 0.1, hy: groundSize }
        ];
        grounds.forEach((ground) => {
          this.physicsServer.addCuboid({
            width: ground.hx * 2 * size,
            height: ground.hy * 2 * size,
            depth: 1,
            color: 15980977,
            alpha: 1,
            border: null,
            name: "joe",
            sound: "/assets/sounds/impact.wav",
            borderWidth: 1,
            borderScaleWithZoom: true,
            image: null,
            zDepth: 0,
            position: { x: ground.x * size + offsetX, y: ground.y * size + offsetY },
            isStatic: true,
            friction: 0.5,
            restitution: 0,
            density: 1
          });
        });
        let num = 20;
        let numy = 50;
        let rad = 1;
        let shift = rad * 2 + rad;
        let centerx = shift * (num / 2);
        let centery = shift / 2;
        let i2, j2;
        let colors = [10011097, 343134, 2062988];
        let colorIndex = 0;
        for (j2 = 0;j2 < numy; ++j2) {
          for (i2 = 0;i2 < num; ++i2) {
            let x2 = i2 * shift - centerx;
            let y2 = j2 * shift + centery + 3;
            this.physicsServer.addCuboid({
              width: rad * 2 * size,
              height: rad * 2 * size,
              depth: 1,
              color: colors[colorIndex],
              alpha: 1,
              border: null,
              name: "joe",
              sound: "/assets/sounds/impact.wav",
              borderWidth: 1,
              borderScaleWithZoom: true,
              image: null,
              zDepth: 0,
              position: { x: x2 * size + offsetX, y: y2 * size + offsetY },
              isStatic: false,
              friction: cubeFriction,
              restitution: 0,
              density
            });
            colorIndex = (colorIndex + 1) % colors.length;
          }
        }
      }
    };
  }
  start() {
    console.log("start");
  }
  addPerson(offset, color, personScale = 0.4) {
    let personBodyPoints = [
      [0, 0.64],
      [0.712, 0.499],
      [1.19, 0.172],
      [1.504, -0.27],
      [1.67, -0.779],
      [1.678, -3.272],
      [1.643, -3.469],
      [1.451, -3.597],
      [-1.416, -3.589],
      [-1.582, -3.51],
      [-1.654, -3.35],
      [-1.67, -0.779],
      [-1.497, -0.305],
      [-1.231, 0.126],
      [-0.65, 0.517],
      [-0.328, 0.614]
    ];
    personBodyPoints = personBodyPoints.map(function(point) {
      return [point[0] * personScale, point[1] * personScale];
    });
    let body = this.physicsServer.addPolygon({
      points: personBodyPoints.map((point) => {
        return { x: point[0], y: point[1] };
      }),
      position: { x: offset[0], y: offset[1] },
      alpha: 1,
      name: "Polygon",
      border: null,
      borderScaleWithZoom: true,
      borderWidth: 0.1,
      image: null,
      sound: "/assets/sounds/impact.wav",
      zDepth: 0,
      isStatic: false,
      density: 1,
      friction: 0.5,
      restitution: 0,
      color
    });
    let head = this.physicsServer.addBall({
      radius: 1.71 * personScale,
      position: { x: offset[0], y: offset[1] + 1.88 * personScale },
      alpha: 1,
      name: "some kind of Object",
      border: null,
      borderScaleWithZoom: true,
      borderWidth: 0.1,
      image: null,
      sound: "/assets/sounds/impact.wav",
      zDepth: 0,
      isStatic: false,
      density: 1,
      friction: 0.5,
      restitution: 0,
      color,
      cakeSlice: true
    });
    let axle = this.physicsServer.addAxle({
      localAnchorA: { x: 0, y: 0.32 * personScale, z: 0 },
      localAnchorB: { x: 0, y: 1.5599999999999998 * -personScale, z: 0 },
      bodyA: body,
      bodyB: head
    });
    let spring = this.physicsServer.addSpring({
      localAnchorA: { x: 0, y: 3.26 * personScale, z: 0 },
      localAnchorB: { x: 0, y: -1.38 * -personScale, z: 0 },
      objectA: body,
      objectB: head,
      stiffness: 0.6 * personScale,
      restLength: 0.005 * personScale,
      damping: 0.01
    });
  }
  update() {
    if (this.paused) {
      let stepInfo2 = this.physicsServer.getStepInfo([], new Date().getTime());
      this.previousStepInfo = stepInfo2;
      return;
    }
    let stepInfo = this.physicsServer.step();
    this.previousStepInfo = stepInfo;
  }
  destroy() {
    console.log("destroy");
  }
  handleIncomingEvent(event, data, id) {
  }
  handleOutgoingEvent(event, data, id) {
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureE
class DragTool {
  name = "Drag";
  description = "Drag physics objects with a spring";
  icon = "icons/cursor-default.svg";
  physicsSandbox;
  springs = {};
  startPoints = {};
  constructor(physicsSandbox) {
    this.physicsSandbox = physicsSandbox;
  }
  playerDown(player) {
    this.startPoints[player.id] = { x: player.x, y: player.y };
    let target = this.physicsSandbox.physicsPlugin.physicsServer.getObjectAtPoint({ x: player.x, y: player.y, z: 0 });
    if (target) {
      let bodyA = target;
      if (this.springs[player.id]) {
        this.physicsSandbox.physicsPlugin.physicsServer.removeSpring(this.springs[player.id]);
        this.springs[player.id] = null;
      }
      this.springs[player.id] = this.physicsSandbox.physicsPlugin.physicsServer.addSpring({
        objectA: bodyA,
        objectB: null,
        stiffness: 0.5,
        localAnchorA: this.physicsSandbox.physicsPlugin.physicsServer.getLocalObjectPoint(bodyA, { x: player.x, y: player.y, z: 0 }),
        localAnchorB: { x: player.x, y: player.y, z: 0 },
        damping: 0.1,
        restLength: 0
      });
    }
  }
  playerMove(player) {
    if (!player.down)
      return;
    if (!this.springs[player.id])
      return;
    this.springs[player.id].setLocalAnchorB({
      x: player.x,
      y: player.y,
      z: 0
    });
  }
  playerUp(player) {
    let startPoint = this.startPoints[player.id];
    if (startPoint) {
      this.physicsSandbox.selectionUpdate(startPoint, player);
    }
    if (!this.springs[player.id])
      return;
    this.physicsSandbox.physicsPlugin.physicsServer.removeSpring(this.springs[player.id]);
    this.springs[player.id] = null;
  }
  update(player) {
  }
}

// node_modules/colord/pl
var hsvToHex = function(h2, s2, v3) {
  let r3, g3, b2;
  let i2 = Math.floor(h2 * 6);
  let f2 = h2 * 6 - i2;
  let p2 = v3 * (1 - s2);
  let q2 = v3 * (1 - f2 * s2);
  let t3 = v3 * (1 - (1 - f2) * s2);
  switch (i2 % 6) {
    case 0:
      r3 = v3, g3 = t3, b2 = p2;
      break;
    case 1:
      r3 = q2, g3 = v3, b2 = p2;
      break;
    case 2:
      r3 = p2, g3 = v3, b2 = t3;
      break;
    case 3:
      r3 = p2, g3 = q2, b2 = v3;
      break;
    case 4:
      r3 = t3, g3 = p2, b2 = v3;
      break;
    case 5:
      r3 = v3, g3 = p2, b2 = q2;
      break;
  }
  r3 = r3 ?? 0.5;
  g3 = g3 ?? 0.5;
  b2 = b2 ?? 0.5;
  return parseInt("0x" + Math.floor(r3 * 255).toString(16) + Math.floor(g3 * 255).toString(16) + Math.floor(b2 * 255).toString(16));
};
var hsvToHex_default = hsvToHex;

// node_modules/colord/plugi
var randomColor = function(hueMin = 0, hueMax = 1, saturationMin = 0.5, saturationMax = 0.8, valueMin = 0.8, valueMax = 1) {
  let hue = hueMin + Math.random() * (hueMax - hueMin);
  let saturation = saturationMin + Math.random() * (saturationMax - saturationMin);
  let value = valueMin + Math.random() * (valueMax - valueMin);
  return hsvToHex_default(hue, saturation, value);
};
var randomColor_default = randomColor;

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExtens
class RectangleTool {
  name = "Rectangle";
  description = "Draw rectangles";
  icon = "icons/square.svg";
  physicsSandbox;
  constructor(physicsSandbox) {
    this.physicsSandbox = physicsSandbox;
  }
  startPoints = {};
  color = null;
  playerDown(player) {
    this.startPoints[player.id] = { x: player.x, y: player.y };
    this.color = randomColor_default();
  }
  playerMove(player) {
  }
  playerUp(player) {
    let startPoint = this.startPoints[player.id];
    if (!startPoint)
      return;
    if (this.physicsSandbox.selectionUpdate(startPoint, player)) {
      this.startPoints[player.id] = null;
      return;
    }
    this.physicsSandbox.physicsPlugin.physicsServer.addCuboid({
      width: Math.abs(startPoint.x - player.x),
      height: Math.abs(startPoint.y - player.y),
      depth: 1,
      color: this.color ?? 16777215,
      alpha: 1,
      name: "Rectangle",
      border: null,
      borderScaleWithZoom: true,
      borderWidth: 0.1,
      image: null,
      sound: "/assets/sounds/impact.wav",
      zDepth: 0,
      isStatic: false,
      density: 1,
      friction: 0.5,
      restitution: 0.3,
      position: { x: (startPoint.x + player.x) / 2, y: (startPoint.y + player.y) / 2 }
    });
    this.startPoints[player.id] = null;
  }
  update(player) {
    let startPoint = this.startPoints[player.id];
    if (startPoint) {
      this.physicsSandbox.addOverlayShape({
        content: {
          width: Math.abs(startPoint.x - player.x),
          height: Math.abs(startPoint.y - player.y),
          depth: 1,
          color: this.color ?? 16777215,
          alpha: 0.5,
          zDepth: 0,
          type: "cuboid",
          border: 16777215,
          id: "rectangleToolOverlay",
          borderWidth: 0.1,
          name: "Rectangle",
          description: null,
          borderScaleWithZoom: true,
          borderAlpha: 1,
          image: null,
          imageTransformations: null,
          text: null
        },
        transform: {
          x: (startPoint.x + player.x) / 2,
          y: (startPoint.y + player.y) / 2,
          z: 0,
          angle: 0
        }
      });
    }
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExt
class CircleTool {
  name = "Circle";
  description = "Draw circles";
  icon = "icons/circle.svg";
  physicsSandbox;
  constructor(physicsSandbox) {
    this.physicsSandbox = physicsSandbox;
  }
  startPoints = {};
  color = null;
  playerDown(player) {
    this.startPoints[player.id] = { x: player.x, y: player.y };
    this.color = randomColor_default();
  }
  playerMove(player) {
  }
  playerUp(player) {
    let startPoint = this.startPoints[player.id];
    if (!startPoint)
      return;
    if (this.physicsSandbox.selectionUpdate(startPoint, player)) {
      this.startPoints[player.id] = null;
      return;
    }
    this.physicsSandbox.physicsPlugin.physicsServer.addBall({
      radius: Math.max(Math.abs(startPoint.x - player.x) / 2, Math.abs(startPoint.y - player.y) / 2),
      color: this.color ?? 16777215,
      alpha: 1,
      name: "Circle",
      border: null,
      borderScaleWithZoom: true,
      borderWidth: 0.1,
      image: null,
      sound: null,
      zDepth: 0,
      isStatic: false,
      density: 1,
      friction: 0.5,
      restitution: 0.3,
      position: { x: (startPoint.x + player.x) / 2, y: (startPoint.y + player.y) / 2 },
      cakeSlice: true
    });
    this.startPoints[player.id] = null;
  }
  update(player) {
    let startPoint = this.startPoints[player.id];
    if (startPoint) {
      this.physicsSandbox.addOverlayShape({
        content: {
          radius: Math.max(Math.abs(startPoint.x - player.x) / 2, Math.abs(startPoint.y - player.y) / 2),
          color: this.color ?? 16777215,
          alpha: 0.5,
          zDepth: 0,
          type: "ball",
          border: 16777215,
          id: "circleToolOverlay",
          borderWidth: 0.1,
          cakeSlice: true,
          name: "Circle",
          description: null,
          borderScaleWithZoom: true,
          borderAlpha: 1,
          image: null,
          imageTransformations: null,
          text: null
        },
        transform: {
          x: (startPoint.x + player.x) / 2,
          y: (startPoint.y + player.y) / 2,
          z: 0,
          angle: 0
        }
      });
    }
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExt
class SpringTool {
  name = "Spring";
  description = "Draw springs, real";
  icon = "icons/spring.svg";
  physicsSandbox;
  constructor(physicsSandbox) {
    this.physicsSandbox = physicsSandbox;
  }
  startPoints = {};
  playerDown(player) {
    this.startPoints[player.id] = { x: player.x, y: player.y };
  }
  playerUp(player) {
    let startPoint = this.startPoints[player.id];
    if (!startPoint)
      return;
    if (this.physicsSandbox.selectionUpdate(startPoint, player)) {
      this.startPoints[player.id] = null;
      return;
    }
    let targetA = this.physicsSandbox.physicsPlugin.physicsServer.getObjectAtPoint({ x: startPoint.x, y: startPoint.y, z: 0 });
    let targetB = this.physicsSandbox.physicsPlugin.physicsServer.getObjectAtPoint({ x: player.x, y: player.y, z: 0 });
    if (!targetA && !targetB)
      return;
    let bodyA = targetA;
    let bodyB = targetB;
    if (!bodyA && !bodyB)
      return;
    this.physicsSandbox.physicsPlugin.physicsServer.addSpring({
      objectA: bodyA,
      objectB: bodyB,
      stiffness: 0.2,
      damping: 0,
      restLength: Math.sqrt(Math.pow(player.x - startPoint.x, 2) + Math.pow(player.y - startPoint.y, 2)),
      localAnchorA: bodyA ? this.physicsSandbox.physicsPlugin.physicsServer.getLocalObjectPoint(bodyA, { x: startPoint.x, y: startPoint.y, z: 0 }) : { x: startPoint.x, y: startPoint.y, z: 0 },
      localAnchorB: bodyB ? this.physicsSandbox.physicsPlugin.physicsServer.getLocalObjectPoint(bodyB, { x: player.x, y: player.y, z: 0 }) : { x: player.x, y: player.y, z: 0 }
    });
    this.startPoints[player.id] = null;
  }
  playerMove(player) {
  }
  update(player) {
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExtensi
class SelectMoveTool {
  name = "Select and Move";
  description = "Box select and/or move";
  icon = "icons/cursor-move.svg";
  physicsSandbox;
  constructor(physicsSandbox) {
    this.physicsSandbox = physicsSandbox;
  }
  startPoints = {};
  shapes = {};
  previousPositions = {};
  shapeBodyTypes = {};
  playerDown(player) {
  }
  playerMove(player) {
  }
  playerUp(player) {
  }
  update(player) {
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExte
class PolygonTool {
  name = "Polygon";
  description = "Draw polygons";
  icon = "icons/polygon.svg";
  physicsSandbox;
  constructor(physicsSandbox) {
    this.physicsSandbox = physicsSandbox;
  }
  points = {};
  color = null;
  playerDown(player) {
    this.points[player.id] = [{ x: player.x, y: player.y }];
    this.color = randomColor_default();
  }
  playerMove(player) {
    if (!this.points[player.id] || this.points[player.id].length < 1)
      return;
    let lastPoint = this.points[player.id][this.points[player.id].length - 1];
    if (Math.abs(lastPoint.x - player.x) < 0.1 && Math.abs(lastPoint.y - player.y) < 0.1)
      return;
    this.points[player.id].push({ x: player.x, y: player.y });
  }
  playerUp(player) {
    let points2 = this.points[player.id];
    if (!points2 || points2.length < 3)
      return;
    this.physicsSandbox.physicsPlugin.physicsServer.addPolygon({
      points: points2,
      color: this.color ?? 16777215,
      alpha: 1,
      name: "Polygon",
      border: null,
      borderScaleWithZoom: true,
      borderWidth: 0.1,
      image: null,
      sound: "/assets/sounds/impact.wav",
      zDepth: 0,
      isStatic: false,
      density: 1,
      friction: 0.5,
      restitution: 0.3,
      position: { x: 0, y: 0 }
    });
    this.points[player.id] = [];
  }
  update(player) {
    let points2 = this.points[player.id];
    if (!points2 || points2.length < 3)
      return;
    this.physicsSandbox.addOverlayShape({
      content: {
        points: points2.map((point) => [point.x, point.y]),
        color: this.color ?? 16777215,
        alpha: 0.5,
        zDepth: 0,
        type: "polygon",
        border: 16777215,
        id: "polygonToolOverlay",
        borderWidth: 0.1,
        name: "Polygon",
        description: null,
        borderScaleWithZoom: true,
        borderAlpha: 1,
        image: null,
        imageTransformations: null,
        text: null
      },
      transform: {
        x: 0,
        y: 0,
        z: 0,
        angle: 0
      }
    });
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureE
class AxleTool {
  name = "Axle";
  description = "Draw axles, also known as hinges, swivels and pivots";
  icon = "icons/axle.svg";
  physicsSandbox;
  constructor(physicsSandbox) {
    this.physicsSandbox = physicsSandbox;
  }
  startPoints = {};
  playerDown(player) {
    this.startPoints[player.id] = { x: player.x, y: player.y };
  }
  playerUp(player) {
    let startPoint = this.startPoints[player.id];
    if (!startPoint)
      return;
    let targets = this.physicsSandbox.physicsPlugin.physicsServer.getObjectsAtPoint({
      x: startPoint.x,
      y: startPoint.y,
      z: 0
    });
    if (targets.length < 2)
      return;
    let targetA = targets[0];
    let targetB = targets[1];
    let bodyA = targetA;
    let bodyB = targetB;
    if (!bodyA || !bodyB)
      return;
    this.physicsSandbox.physicsPlugin.physicsServer.addAxle({
      bodyA,
      bodyB,
      localAnchorA: bodyA ? this.physicsSandbox.physicsPlugin.physicsServer.getLocalObjectPoint(bodyA, { x: startPoint.x, y: startPoint.y, z: 0 }) : { x: 0, y: 0, z: 0 },
      localAnchorB: bodyB ? this.physicsSandbox.physicsPlugin.physicsServer.getLocalObjectPoint(bodyB, { x: startPoint.x, y: startPoint.y, z: 0 }) : { x: 0, y: 0, z: 0 }
    });
    this.startPoints[player.id] = null;
  }
  playerMove(player) {
  }
  update(player) {
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mj
class SimuloPhysicsSandboxServerPlugin {
  name = "Simulo Physics Sandbox Server Plugin";
  description = "Simple physics sandbox for Simulo in multiplayer, with tools to create and interact with the world.";
  version = "0.1.0";
  author = "Carroted";
  namespace = "carroted";
  id = "simulo-physics-sandbox-server-plugin";
  dependencies = ["@carroted/simulo-physics-plugin"];
  controller;
  physicsPlugin;
  players = {};
  builtInTools = [{
    sketch: null,
    knife: null,
    select_move: new SelectMoveTool(this),
    drag: new DragTool(this),
    rotate: null,
    resize: {
      name: "Resize",
      icon: "icons/arrow-top-left-bottom-right-bold.svg",
      description: "Resize objects"
    }
  }, {
    brush: null,
    eraser: null,
    polygon: new PolygonTool(this),
    gear: null,
    rectangle: new RectangleTool(this),
    circle: new CircleTool(this),
    plane: null,
    chain: null
  }, {
    spring: new SpringTool(this),
    bolt: null,
    axle: new AxleTool(this),
    thruster: null,
    laser: null,
    tracer: null,
    uv: null
  }];
  getTools() {
    let tools = [];
    this.builtInTools.forEach((builtInTools) => {
      let toolsMapped = Object.keys(builtInTools).map((id) => {
        let tool = builtInTools[id];
        if (!tool)
          return null;
        return {
          name: tool.name,
          icon: tool.icon,
          description: tool.description,
          id
        };
      });
      tools.push(toolsMapped);
    });
    return tools;
  }
  selectionUpdate(startPoint, player) {
    let distance3 = Math.sqrt(Math.pow(startPoint.x - player.x, 2) + Math.pow(startPoint.y - player.y, 2));
    if (distance3 < 0.3) {
      let target = this.physicsPlugin.physicsServer.getObjectAtPoint({
        x: player.x,
        y: player.y,
        z: 0
      });
      this.players[player.id].selectedObjects = target ? [target] : [];
      return true;
    }
    return false;
  }
  overlayShapes = [];
  overlayTexts = [];
  addOverlayShape(shape) {
    let length2 = this.overlayShapes.push(shape);
    return length2 - 1;
  }
  addOverlayText(text) {
    let length2 = this.overlayTexts.push(text);
    return length2 - 1;
  }
  removeOverlayShape(index2) {
    this.overlayShapes.splice(index2, 1);
  }
  removeOverlayText(index2) {
    this.overlayTexts.splice(index2, 1);
  }
  constructor(controller, physicsPlugin) {
    this.controller = controller;
    this.physicsPlugin = physicsPlugin;
  }
  start() {
  }
  update() {
    if (this.physicsPlugin.previousStepInfo) {
      let selectedObjects = {};
      Object.keys(this.players).forEach((id) => {
        let player = this.players[id];
        selectedObjects[id] = player.selectedObjects.map((collider) => {
          return this.physicsPlugin.physicsServer.getShapeContent(collider);
        }).filter((element) => element !== null);
      });
      this.controller.emit("world_update", {
        ...this.physicsPlugin.previousStepInfo,
        overlays: {
          shapes: this.overlayShapes,
          texts: this.overlayTexts
        },
        selectedObjects
      }, null);
    }
    this.overlayShapes = [];
    this.overlayTexts = [];
    Object.keys(this.players).forEach((playerId) => {
      let tool = this.getTool(this.players[playerId].tool);
      if (tool) {
        tool.update(this.players[playerId]);
      }
    });
  }
  getTool(id) {
    let tool = null;
    this.builtInTools.forEach((builtInTools) => {
      if (builtInTools[id]) {
        tool = builtInTools[id];
      }
    });
    return tool;
  }
  destroy() {
  }
  async handleIncomingEvent(event, data, id) {
    if (!this.players[id]) {
      this.players[id] = {
        x: 0,
        y: 0,
        color: 16777215,
        id,
        down: false,
        tool: "drag",
        selectedObjects: []
      };
    }
    if (this.players[id]) {
      if (event === "player_move" || event === "player_down" || event === "player_up") {
        this.players[id].x = data.x ?? 0;
        this.players[id].y = data.y ?? 0;
      }
      if (event === "player_down") {
        this.players[id].down = true;
        let tool = this.getTool(this.players[id].tool);
        if (tool) {
          tool.playerDown(this.players[id]);
        }
      }
      if (event === "player_move") {
        let tool = this.getTool(this.players[id].tool);
        if (tool) {
          tool.playerMove(this.players[id]);
        }
      }
      if (event === "player_up") {
        this.players[id].down = false;
        let tool = this.getTool(this.players[id].tool);
        if (tool) {
          tool.playerUp(this.players[id]);
        }
      }
      if (event === "player_tool") {
        this.players[id].tool = data.toString();
        console.log("changed tool to", data);
        this.controller.emit("player_tool_success", data, id);
      }
      if (event === "player_delete_selection") {
        this.players[id].selectedObjects.forEach((obj) => {
          this.physicsPlugin.physicsServer.destroyObject(obj);
          console.log("obj gone");
        });
        console.log("removed selection");
        this.players[id].selectedObjects = [];
      }
    }
    if (event === "save") {
    }
    if (event === "load") {
    }
    if (event === "set_paused") {
      this.physicsPlugin.paused = data ? true : false;
      this.controller.emit("pause_changed", this.physicsPlugin.paused, null);
    }
  }
  handleOutgoingEvent(event, data, id) {
  }
}

// node_modules/colord/plugins/names.mjsisten
var ENV = ((ENV2) => {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
  return ENV2;
})(ENV || {});
var RENDERER_TYPE = ((RENDERER_TYPE2) => {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
  return RENDERER_TYPE2;
})(RENDERER_TYPE || {});
var BUFFER_BITS = ((BUFFER_BITS2) => {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
  return BUFFER_BITS2;
})(BUFFER_BITS || {});
var BLEND_MODES = ((BLEND_MODES2) => {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
  return BLEND_MODES2;
})(BLEND_MODES || {});
var DRAW_MODES = ((DRAW_MODES2) => {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  return DRAW_MODES2;
})(DRAW_MODES || {});
var FORMATS = ((FORMATS2) => {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  return FORMATS2;
})(FORMATS || {});
var TARGETS = ((TARGETS2) => {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  return TARGETS2;
})(TARGETS || {});
var TYPES = ((TYPES2) => {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  return TYPES2;
})(TYPES || {});
var SAMPLER_TYPES = ((SAMPLER_TYPES2) => {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
  return SAMPLER_TYPES2;
})(SAMPLER_TYPES || {});
var SCALE_MODES = ((SCALE_MODES2) => {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
  return SCALE_MODES2;
})(SCALE_MODES || {});
var WRAP_MODES = ((WRAP_MODES2) => {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  return WRAP_MODES2;
})(WRAP_MODES || {});
var MIPMAP_MODES = ((MIPMAP_MODES2) => {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
  return MIPMAP_MODES2;
})(MIPMAP_MODES || {});
var ALPHA_MODES = ((ALPHA_MODES2) => {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  return ALPHA_MODES2;
})(ALPHA_MODES || {});
var CLEAR_MODES = ((CLEAR_MODES2) => {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
  return CLEAR_MODES2;
})(CLEAR_MODES || {});
var GC_MODES = ((GC_MODES2) => {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
  return GC_MODES2;
})(GC_MODES || {});
var PRECISION = ((PRECISION2) => {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
  return PRECISION2;
})(PRECISION || {});
var MASK_TYPES = ((MASK_TYPES2) => {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
  MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";
  return MASK_TYPES2;
})(MASK_TYPES || {});
var MSAA_QUALITY = ((MSAA_QUALITY2) => {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
  return MSAA_QUALITY2;
})(MSAA_QUALITY || {});
var BUFFER_TYPE = ((BUFFER_TYPE2) => {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  return BUFFER_TYPE2;
})(BUFFER_TYPE || {});

// node_modules/colord/plugins/names.mjsistene
var BrowserAdapter = {
  createCanvas: (width, height) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url, options) => fetch(url, options),
  parseXML: (xml) => {
    const parser = new DOMParser;
    return parser.parseFromString(xml, "text/xml");
  }
};
// node_modules/colord/plugins/names.mjsistener
var settings = {
  ADAPTER: BrowserAdapter,
  RESOLUTION: 1,
  CREATE_IMAGE_BITMAP: false,
  ROUND_PIXELS: false
};
// node_modules/colord/plugins/names.mjsis
var createMatch = function(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
};
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
function isMobile(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp16 = userAgent.split("[FBAN");
  if (typeof tmp16[1] !== "undefined") {
    userAgent = tmp16[0];
  }
  tmp16 = userAgent.split("Twitter");
  if (typeof tmp16[1] !== "undefined") {
    userAgent = tmp16[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
// node_modules/colord/plugins/names.mjsistener.mjsgl
var isMobileCall = isMobile.default ?? isMobile;
var isMobile3 = isMobileCall(globalThis.navigator);
// node_modules/colord/plugins/names.mjsi
var exports_lib = {};
__export(exports_lib, {
  url: () => {
    {
      return url;
    }
  },
  uid: () => {
    {
      return uid;
    }
  },
  trimCanvas: () => {
    {
      return trimCanvas;
    }
  },
  string2hex: () => {
    {
      return string2hex;
    }
  },
  skipHello: () => {
    {
      return skipHello;
    }
  },
  sign: () => {
    {
      return sign;
    }
  },
  sayHello: () => {
    {
      return sayHello;
    }
  },
  rgb2hex: () => {
    {
      return rgb2hex;
    }
  },
  removeItems: () => {
    {
      return removeItems;
    }
  },
  premultiplyTintToRgba: () => {
    {
      return premultiplyTintToRgba;
    }
  },
  premultiplyTint: () => {
    {
      return premultiplyTint;
    }
  },
  premultiplyRgba: () => {
    {
      return premultiplyRgba;
    }
  },
  premultiplyBlendMode: () => {
    {
      return premultiplyBlendMode;
    }
  },
  path: () => {
    {
      return path;
    }
  },
  nextPow2: () => {
    {
      return nextPow2;
    }
  },
  log2: () => {
    {
      return log2;
    }
  },
  isWebGLSupported: () => {
    {
      return isWebGLSupported;
    }
  },
  isPow2: () => {
    {
      return isPow2;
    }
  },
  isMobile: () => {
    {
      return isMobile3;
    }
  },
  interleaveTypedArrays: () => {
    {
      return interleaveTypedArrays;
    }
  },
  hex2string: () => {
    {
      return hex2string;
    }
  },
  hex2rgb: () => {
    {
      return hex2rgb;
    }
  },
  getResolutionOfUrl: () => {
    {
      return getResolutionOfUrl;
    }
  },
  getCanvasBoundingBox: () => {
    {
      return getCanvasBoundingBox;
    }
  },
  getBufferType: () => {
    {
      return getBufferType;
    }
  },
  earcut: () => {
    {
      return import_earcut.default;
    }
  },
  determineCrossOrigin: () => {
    {
      return determineCrossOrigin;
    }
  },
  destroyTextureCache: () => {
    {
      return destroyTextureCache;
    }
  },
  deprecation: () => {
    {
      return deprecation;
    }
  },
  decomposeDataUri: () => {
    {
      return decomposeDataUri;
    }
  },
  createIndicesForQuads: () => {
    {
      return createIndicesForQuads;
    }
  },
  correctBlendMode: () => {
    {
      return correctBlendMode;
    }
  },
  clearTextureCache: () => {
    {
      return clearTextureCache;
    }
  },
  TextureCache: () => {
    {
      return TextureCache;
    }
  },
  ProgramCache: () => {
    {
      return ProgramCache;
    }
  },
  EventEmitter: () => {
    {
      return import_eventemitter3.default;
    }
  },
  DATA_URI: () => {
    {
      return DATA_URI;
    }
  },
  CanvasRenderTarget: () => {
    {
      return CanvasRenderTarget;
    }
  },
  BoundingBox: () => {
    {
      return BoundingBox;
    }
  },
  BaseTextureCache: () => {
    {
      return BaseTextureCache;
    }
  }
});

// node_modules/colord/plugins/names.mjsiste
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;

// node_modules/colord/plugins/names.mjsi
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);
var import_earcut = __toESM(require_earcut(), 1);

// node:url
var M2 = function(s2) {
  return typeof s2 == "string";
};
var S2 = function(s2) {
  return typeof s2 == "object" && s2 !== null;
};
var I2 = function(s2) {
  return s2 === null;
};
var H2 = function(s2) {
  return s2 == null;
};
var m2 = function() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
};
var L2 = function(s2, r3, t3) {
  if (s2 && S2(s2) && s2 instanceof m2)
    return s2;
  var o2 = new m2;
  return o2.parse(s2, r3, t3), o2;
};
var at = function(s2) {
  return M2(s2) && (s2 = L2(s2)), s2 instanceof m2 ? s2.format() : m2.prototype.format.call(s2);
};
var nt = function(s2, r3) {
  return L2(s2, false, true).resolve(r3);
};
var { URL: K2, URLSearchParams: k2, [Symbol.for("Bun.lazy")]: F2 } = globalThis;
var Q2 = /^([a-z0-9.+-]+:)/i;
var E2 = /:[0-9]*$/;
var tt = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var st = ["<", ">", '"', "`", " ", "\r", `
`, "	"];
var ht = ["{", "}", "|", "\\", "^", "`"].concat(st);
var B3 = ["'"].concat(ht);
var D3 = ["%", "/", "?", ";", "#"].concat(B3);
var G2 = ["/", "?", "#"];
var et = 255;
var J2 = /^[+a-z0-9A-Z_-]{0,63}$/;
var rt = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var ot = { javascript: true, "javascript:": true };
var N2 = { javascript: true, "javascript:": true };
var R2 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
var Z2 = { parse(s2) {
  var r3 = decodeURIComponent;
  return (s2 + "").replace(/\+/g, " ").split("&").filter(Boolean).reduce(function(t3, o2, a2) {
    var l3 = o2.split("="), f2 = r3(l3[0] || ""), h2 = r3(l3[1] || ""), y2 = t3[f2];
    return t3[f2] = y2 === undefined ? h2 : [].concat(y2, h2), t3;
  }, {});
}, stringify(s2) {
  var r3 = encodeURIComponent;
  return Object.keys(s2 || {}).reduce(function(t3, o2) {
    return [].concat(s2[o2]).forEach(function(a2) {
      t3.push(r3(o2) + "=" + r3(a2));
    }), t3;
  }, []).join("&").replace(/\s/g, "+");
} };
m2.prototype.parse = function(s2, r3, t3) {
  if (!M2(s2))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof s2);
  var o2 = s2.indexOf("?"), a2 = o2 !== -1 && o2 < s2.indexOf("#") ? "?" : "#", l3 = s2.split(a2), f2 = /\\/g;
  l3[0] = l3[0].replace(f2, "/"), s2 = l3.join(a2);
  var h2 = s2;
  if (h2 = h2.trim(), !t3 && s2.split("#").length === 1) {
    var y2 = tt.exec(h2);
    if (y2)
      return this.path = h2, this.href = h2, this.pathname = y2[1], y2[2] ? (this.search = y2[2], r3 ? this.query = Z2.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : r3 && (this.search = "", this.query = {}), this;
  }
  var c2 = Q2.exec(h2);
  if (c2) {
    c2 = c2[0];
    var v3 = c2.toLowerCase();
    this.protocol = v3, h2 = h2.substr(c2.length);
  }
  if (t3 || c2 || h2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var A2 = h2.substr(0, 2) === "//";
    A2 && !(c2 && N2[c2]) && (h2 = h2.substr(2), this.slashes = true);
  }
  if (!N2[c2] && (A2 || c2 && !R2[c2])) {
    for (var u5 = -1, n3 = 0;n3 < G2.length; n3++) {
      var b2 = h2.indexOf(G2[n3]);
      b2 !== -1 && (u5 === -1 || b2 < u5) && (u5 = b2);
    }
    var j2, p2;
    u5 === -1 ? p2 = h2.lastIndexOf("@") : p2 = h2.lastIndexOf("@", u5), p2 !== -1 && (j2 = h2.slice(0, p2), h2 = h2.slice(p2 + 1), this.auth = decodeURIComponent(j2)), u5 = -1;
    for (var n3 = 0;n3 < D3.length; n3++) {
      var b2 = h2.indexOf(D3[n3]);
      b2 !== -1 && (u5 === -1 || b2 < u5) && (u5 = b2);
    }
    u5 === -1 && (u5 = h2.length), this.host = h2.slice(0, u5), h2 = h2.slice(u5), this.parseHost(), this.hostname = this.hostname || "";
    var P2 = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!P2)
      for (var e2 = this.hostname.split(/\./), n3 = 0, i2 = e2.length;n3 < i2; n3++) {
        var d2 = e2[n3];
        if (!!d2 && !d2.match(J2)) {
          for (var g3 = "", x2 = 0, _2 = d2.length;x2 < _2; x2++)
            d2.charCodeAt(x2) > 127 ? g3 += "x" : g3 += d2[x2];
          if (!g3.match(J2)) {
            var q2 = e2.slice(0, n3), O2 = e2.slice(n3 + 1), U2 = d2.match(rt);
            U2 && (q2.push(U2[1]), O2.unshift(U2[2])), O2.length && (h2 = "/" + O2.join(".") + h2), this.hostname = q2.join(".");
            break;
          }
        }
      }
    this.hostname.length > et ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), P2 || (this.hostname = new K2(`https://${this.hostname}`).hostname);
    var w2 = this.port ? ":" + this.port : "", X2 = this.hostname || "";
    this.host = X2 + w2, this.href += this.host, P2 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), h2[0] !== "/" && (h2 = "/" + h2));
  }
  if (!ot[v3])
    for (var n3 = 0, i2 = B3.length;n3 < i2; n3++) {
      var C3 = B3[n3];
      if (h2.indexOf(C3) !== -1) {
        var z2 = encodeURIComponent(C3);
        z2 === C3 && (z2 = escape(C3)), h2 = h2.split(C3).join(z2);
      }
    }
  var $2 = h2.indexOf("#");
  $2 !== -1 && (this.hash = h2.substr($2), h2 = h2.slice(0, $2));
  var T2 = h2.indexOf("?");
  if (T2 !== -1 ? (this.search = h2.substr(T2), this.query = h2.substr(T2 + 1), r3 && (this.query = Z2.parse(this.query)), h2 = h2.slice(0, T2)) : r3 && (this.search = "", this.query = {}), h2 && (this.pathname = h2), R2[v3] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var w2 = this.pathname || "", Y2 = this.search || "";
    this.path = w2 + Y2;
  }
  return this.href = this.format(), this;
};
m2.prototype.format = function() {
  var s2 = this.auth || "";
  s2 && (s2 = encodeURIComponent(s2), s2 = s2.replace(/%3A/i, ":"), s2 += "@");
  var r3 = this.protocol || "", t3 = this.pathname || "", o2 = this.hash || "", a2 = false, l3 = "";
  this.host ? a2 = s2 + this.host : this.hostname && (a2 = s2 + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (a2 += ":" + this.port)), this.query && S2(this.query) && Object.keys(this.query).length && (l3 = Z2.stringify(this.query));
  var f2 = this.search || l3 && "?" + l3 || "";
  return r3 && r3.substr(-1) !== ":" && (r3 += ":"), this.slashes || (!r3 || R2[r3]) && a2 !== false ? (a2 = "//" + (a2 || ""), t3 && t3.charAt(0) !== "/" && (t3 = "/" + t3)) : a2 || (a2 = ""), o2 && o2.charAt(0) !== "#" && (o2 = "#" + o2), f2 && f2.charAt(0) !== "?" && (f2 = "?" + f2), t3 = t3.replace(/[?#]/g, function(h2) {
    return encodeURIComponent(h2);
  }), f2 = f2.replace("#", "%23"), r3 + a2 + t3 + f2 + o2;
};
m2.prototype.resolve = function(s2) {
  return this.resolveObject(L2(s2, false, true)).format();
};
m2.prototype.resolveObject = function(s2) {
  if (M2(s2)) {
    var r3 = new m2;
    r3.parse(s2, false, true), s2 = r3;
  }
  for (var t3 = new m2, o2 = Object.keys(this), a2 = 0;a2 < o2.length; a2++) {
    var l3 = o2[a2];
    t3[l3] = this[l3];
  }
  if (t3.hash = s2.hash, s2.href === "")
    return t3.href = t3.format(), t3;
  if (s2.slashes && !s2.protocol) {
    for (var f2 = Object.keys(s2), h2 = 0;h2 < f2.length; h2++) {
      var y2 = f2[h2];
      y2 !== "protocol" && (t3[y2] = s2[y2]);
    }
    return R2[t3.protocol] && t3.hostname && !t3.pathname && (t3.path = t3.pathname = "/"), t3.href = t3.format(), t3;
  }
  if (s2.protocol && s2.protocol !== t3.protocol) {
    if (!R2[s2.protocol]) {
      for (var c2 = Object.keys(s2), v3 = 0;v3 < c2.length; v3++) {
        var A2 = c2[v3];
        t3[A2] = s2[A2];
      }
      return t3.href = t3.format(), t3;
    }
    if (t3.protocol = s2.protocol, !s2.host && !N2[s2.protocol]) {
      for (var i2 = (s2.pathname || "").split("/");i2.length && !(s2.host = i2.shift()); )
        ;
      s2.host || (s2.host = ""), s2.hostname || (s2.hostname = ""), i2[0] !== "" && i2.unshift(""), i2.length < 2 && i2.unshift(""), t3.pathname = i2.join("/");
    } else
      t3.pathname = s2.pathname;
    if (t3.search = s2.search, t3.query = s2.query, t3.host = s2.host || "", t3.auth = s2.auth, t3.hostname = s2.hostname || s2.host, t3.port = s2.port, t3.pathname || t3.search) {
      var u5 = t3.pathname || "", n3 = t3.search || "";
      t3.path = u5 + n3;
    }
    return t3.slashes = t3.slashes || s2.slashes, t3.href = t3.format(), t3;
  }
  var b2 = t3.pathname && t3.pathname.charAt(0) === "/", j2 = s2.host || s2.pathname && s2.pathname.charAt(0) === "/", p2 = j2 || b2 || t3.host && s2.pathname, P2 = p2, e2 = t3.pathname && t3.pathname.split("/") || [], i2 = s2.pathname && s2.pathname.split("/") || [], d2 = t3.protocol && !R2[t3.protocol];
  if (d2 && (t3.hostname = "", t3.port = null, t3.host && (e2[0] === "" ? e2[0] = t3.host : e2.unshift(t3.host)), t3.host = "", s2.protocol && (s2.hostname = null, s2.port = null, s2.host && (i2[0] === "" ? i2[0] = s2.host : i2.unshift(s2.host)), s2.host = null), p2 = p2 && (i2[0] === "" || e2[0] === "")), j2)
    t3.host = s2.host || s2.host === "" ? s2.host : t3.host, t3.hostname = s2.hostname || s2.hostname === "" ? s2.hostname : t3.hostname, t3.search = s2.search, t3.query = s2.query, e2 = i2;
  else if (i2.length)
    e2 || (e2 = []), e2.pop(), e2 = e2.concat(i2), t3.search = s2.search, t3.query = s2.query;
  else if (!H2(s2.search)) {
    if (d2) {
      t3.hostname = t3.host = e2.shift();
      var g3 = t3.host && t3.host.indexOf("@") > 0 ? t3.host.split("@") : false;
      g3 && (t3.auth = g3.shift(), t3.host = t3.hostname = g3.shift());
    }
    return t3.search = s2.search, t3.query = s2.query, (!I2(t3.pathname) || !I2(t3.search)) && (t3.path = (t3.pathname ? t3.pathname : "") + (t3.search ? t3.search : "")), t3.href = t3.format(), t3;
  }
  if (!e2.length)
    return t3.pathname = null, t3.search ? t3.path = "/" + t3.search : t3.path = null, t3.href = t3.format(), t3;
  for (var x2 = e2.slice(-1)[0], _2 = (t3.host || s2.host || e2.length > 1) && (x2 === "." || x2 === "..") || x2 === "", q2 = 0, O2 = e2.length;O2 >= 0; O2--)
    x2 = e2[O2], x2 === "." ? e2.splice(O2, 1) : x2 === ".." ? (e2.splice(O2, 1), q2++) : q2 && (e2.splice(O2, 1), q2--);
  if (!p2 && !P2)
    for (;q2--; q2)
      e2.unshift("..");
  p2 && e2[0] !== "" && (!e2[0] || e2[0].charAt(0) !== "/") && e2.unshift(""), _2 && e2.join("/").substr(-1) !== "/" && e2.push("");
  var U2 = e2[0] === "" || e2[0] && e2[0].charAt(0) === "/";
  if (d2) {
    t3.hostname = t3.host = U2 ? "" : e2.length ? e2.shift() : "";
    var g3 = t3.host && t3.host.indexOf("@") > 0 ? t3.host.split("@") : false;
    g3 && (t3.auth = g3.shift(), t3.host = t3.hostname = g3.shift());
  }
  return p2 = p2 || t3.host && e2.length, p2 && !U2 && e2.unshift(""), e2.length ? t3.pathname = e2.join("/") : (t3.pathname = null, t3.path = null), (!I2(t3.pathname) || !I2(t3.search)) && (t3.path = (t3.pathname ? t3.pathname : "") + (t3.search ? t3.search : "")), t3.auth = s2.auth || t3.auth, t3.slashes = t3.slashes || s2.slashes, t3.href = t3.format(), t3;
};
m2.prototype.parseHost = function() {
  var s2 = this.host, r3 = E2.exec(s2);
  r3 && (r3 = r3[0], r3 !== ":" && (this.port = r3.substr(1)), s2 = s2.substr(0, s2.length - r3.length)), s2 && (this.hostname = s2);
};
var V2;
var W2;
F2 && (V2 = F2("pathToFileURL"), W2 = F2("fileURLToPath"));

// node_modules/colord/plugins/names.mj
var url = {
  parse: L2,
  format: at,
  resolve: nt
};
// node_modules/colord/plugins/names.mjs
var assertPath = function(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
};
var removeUrlParams = function(url2) {
  const re = url2.split("?")[0];
  return re.split("#")[0];
};
var escapeRegExp = function(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var replaceAll = function(str2, find, replace) {
  return str2.replace(new RegExp(escapeRegExp(find), "g"), replace);
};
var normalizeStringPosix = function(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i2 = 0;i2 <= path2.length; ++i2) {
    if (i2 < path2.length) {
      code = path2.charCodeAt(i2);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i2;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i2)}`;
        } else {
          res = path2.slice(lastSlash + 1, i2);
        }
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
};
var path = {
  toPosix(path2) {
    return replaceAll(path2, "\\", "/");
  },
  isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  },
  isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  },
  hasProtocol(path2) {
    return /^[^/:]+:\//.test(this.toPosix(path2));
  },
  getProtocol(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let protocol = "";
    const isFile = /^file:\/\/\//.exec(path2);
    const isHttp = /^[^/:]+:\/\//.exec(path2);
    const isWindows = /^[^/:]+:\//.exec(path2);
    if (isFile || isHttp || isWindows) {
      const arr = isFile?.[0] || isHttp?.[0] || isWindows?.[0];
      protocol = arr;
      path2 = path2.slice(arr.length);
    }
    return protocol;
  },
  toAbsolute(url2, customBaseUrl, customRootUrl) {
    if (this.isDataUrl(url2))
      return url2;
    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl()));
    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    assertPath(url2);
    url2 = this.toPosix(url2);
    if (url2.startsWith("/")) {
      return path.join(rootUrl, url2.slice(1));
    }
    const absolutePath = this.isAbsolute(url2) ? url2 : this.join(baseUrl, url2);
    return absolutePath;
  },
  normalize(path2) {
    path2 = this.toPosix(path2);
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    let protocol = "";
    const isAbsolute = path2.startsWith("/");
    if (this.hasProtocol(path2)) {
      protocol = this.rootname(path2);
      path2 = path2.slice(protocol.length);
    }
    const trailingSeparator = path2.endsWith("/");
    path2 = normalizeStringPosix(path2, false);
    if (path2.length > 0 && trailingSeparator)
      path2 += "/";
    if (isAbsolute)
      return `/${path2}`;
    return protocol + path2;
  },
  isAbsolute(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    if (this.hasProtocol(path2))
      return true;
    return path2.startsWith("/");
  },
  join(...segments) {
    if (segments.length === 0) {
      return ".";
    }
    let joined;
    for (let i2 = 0;i2 < segments.length; ++i2) {
      const arg = segments[i2];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else {
          const prevArg = segments[i2 - 1] ?? "";
          if (this.extname(prevArg)) {
            joined += `/../${arg}`;
          } else {
            joined += `/${arg}`;
          }
        }
      }
    }
    if (joined === undefined) {
      return ".";
    }
    return this.normalize(joined);
  },
  dirname(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1;
    let matchedSlash = true;
    const proto = this.getProtocol(path2);
    const origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i2 = path2.length - 1;i2 >= 1; --i2) {
      code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          end = i2;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1)
      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
    if (hasRoot && end === 1)
      return "//";
    return proto + path2.slice(0, end);
  },
  rootname(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let root = "";
    if (path2.startsWith("/"))
      root = "/";
    else {
      root = this.getProtocol(path2);
    }
    if (this.isUrl(path2)) {
      const index2 = path2.indexOf("/", root.length);
      if (index2 !== -1) {
        root = path2.slice(0, index2);
      } else
        root = path2;
      if (!root.endsWith("/"))
        root += "/";
    }
    return root;
  },
  basename(path2, ext) {
    assertPath(path2);
    if (ext)
      assertPath(ext);
    path2 = removeUrlParams(this.toPosix(path2));
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i2;
    if (ext !== undefined && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2)
        return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i2 = path2.length - 1;i2 >= 0; --i2) {
        const code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i2 + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i2;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path2.length;
      return path2.slice(start, end);
    }
    for (i2 = path2.length - 1;i2 >= 0; --i2) {
      if (path2.charCodeAt(i2) === 47) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
    }
    if (end === -1)
      return "";
    return path2.slice(start, end);
  },
  extname(path2) {
    assertPath(path2);
    path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i2 = path2.length - 1;i2 >= 0; --i2) {
      const code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  },
  parse(path2) {
    assertPath(path2);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0)
      return ret;
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path2);
    let start;
    const protocol = "";
    ret.root = this.rootname(path2);
    if (isAbsolute || this.hasProtocol(path2)) {
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i2 = path2.length - 1;
    let preDotState = 0;
    for (;i2 >= start; --i2) {
      code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute)
          ret.base = ret.name = path2.slice(1, end);
        else
          ret.base = ret.name = path2.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    ret.dir = this.dirname(path2);
    if (protocol)
      ret.dir = protocol + ret.dir;
    return ret;
  },
  sep: "/",
  delimiter: ":"
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.
var deprecation = function(version, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${message}
Deprecated since v${version}`);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
};
var warnings = {};

// node_modules/colord/plugins/names.mjsistener.m
var skipHello = function() {
  deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");
};
var sayHello = function() {
  deprecation("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`);
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
var isWebGLSupported = function() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!settings.ADAPTER.getWebGLRenderingContext()) {
          return false;
        }
        const canvas = settings.ADAPTER.createCanvas();
        let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e2) {
        return false;
      }
    }();
  }
  return supported;
};
var supported;
// node_modules/colord/plugins/n
var r3 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
var t3 = function(r4) {
  return typeof r4 == "string" ? r4.length > 0 : typeof r4 == "number";
};
var n3 = function(r4, t4, n4) {
  return t4 === undefined && (t4 = 0), n4 === undefined && (n4 = Math.pow(10, t4)), Math.round(n4 * r4) / n4 + 0;
};
var e2 = function(r4, t4, n4) {
  return t4 === undefined && (t4 = 0), n4 === undefined && (n4 = 1), r4 > n4 ? n4 : r4 > t4 ? r4 : t4;
};
var u5 = function(r4) {
  return (r4 = isFinite(r4) ? r4 % 360 : 0) > 0 ? r4 : r4 + 360;
};
var a2 = function(r4) {
  return { r: e2(r4.r, 0, 255), g: e2(r4.g, 0, 255), b: e2(r4.b, 0, 255), a: e2(r4.a) };
};
var o2 = function(r4) {
  return { r: n3(r4.r), g: n3(r4.g), b: n3(r4.b), a: n3(r4.a, 3) };
};
var i2 = /^#([0-9a-f]{3,8})$/i;
var s2 = function(r4) {
  var t4 = r4.toString(16);
  return t4.length < 2 ? "0" + t4 : t4;
};
var h2 = function(r4) {
  var { r: t4, g: n4, b: e3, a: u6 } = r4, a3 = Math.max(t4, n4, e3), o3 = a3 - Math.min(t4, n4, e3), i3 = o3 ? a3 === t4 ? (n4 - e3) / o3 : a3 === n4 ? 2 + (e3 - t4) / o3 : 4 + (t4 - n4) / o3 : 0;
  return { h: 60 * (i3 < 0 ? i3 + 6 : i3), s: a3 ? o3 / a3 * 100 : 0, v: a3 / 255 * 100, a: u6 };
};
var b2 = function(r4) {
  var { h: t4, s: n4, v: e3, a: u6 } = r4;
  t4 = t4 / 360 * 6, n4 /= 100, e3 /= 100;
  var a3 = Math.floor(t4), o3 = e3 * (1 - n4), i3 = e3 * (1 - (t4 - a3) * n4), s3 = e3 * (1 - (1 - t4 + a3) * n4), h3 = a3 % 6;
  return { r: 255 * [e3, i3, o3, o3, s3, e3][h3], g: 255 * [s3, e3, e3, i3, o3, o3][h3], b: 255 * [o3, o3, s3, e3, e3, i3][h3], a: u6 };
};
var g3 = function(r4) {
  return { h: u5(r4.h), s: e2(r4.s, 0, 100), l: e2(r4.l, 0, 100), a: e2(r4.a) };
};
var d2 = function(r4) {
  return { h: n3(r4.h), s: n3(r4.s), l: n3(r4.l), a: n3(r4.a, 3) };
};
var f2 = function(r4) {
  return b2((n4 = (t4 = r4).s, { h: t4.h, s: (n4 *= ((e3 = t4.l) < 50 ? e3 : 100 - e3) / 100) > 0 ? 2 * n4 / (e3 + n4) * 100 : 0, v: e3 + n4, a: t4.a }));
  var t4, n4, e3;
};
var c2 = function(r4) {
  return { h: (t4 = h2(r4)).h, s: (u6 = (200 - (n4 = t4.s)) * (e3 = t4.v) / 100) > 0 && u6 < 200 ? n4 * e3 / 100 / (u6 <= 100 ? u6 : 200 - u6) * 100 : 0, l: u6 / 2, a: t4.a };
  var t4, n4, e3, u6;
};
var l3 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var p2 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var v3 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var m3 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var y2 = { string: [[function(r4) {
  var t4 = i2.exec(r4);
  return t4 ? (r4 = t4[1]).length <= 4 ? { r: parseInt(r4[0] + r4[0], 16), g: parseInt(r4[1] + r4[1], 16), b: parseInt(r4[2] + r4[2], 16), a: r4.length === 4 ? n3(parseInt(r4[3] + r4[3], 16) / 255, 2) : 1 } : r4.length === 6 || r4.length === 8 ? { r: parseInt(r4.substr(0, 2), 16), g: parseInt(r4.substr(2, 2), 16), b: parseInt(r4.substr(4, 2), 16), a: r4.length === 8 ? n3(parseInt(r4.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r4) {
  var t4 = v3.exec(r4) || m3.exec(r4);
  return t4 ? t4[2] !== t4[4] || t4[4] !== t4[6] ? null : a2({ r: Number(t4[1]) / (t4[2] ? 100 / 255 : 1), g: Number(t4[3]) / (t4[4] ? 100 / 255 : 1), b: Number(t4[5]) / (t4[6] ? 100 / 255 : 1), a: t4[7] === undefined ? 1 : Number(t4[7]) / (t4[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t4) {
  var n4 = l3.exec(t4) || p2.exec(t4);
  if (!n4)
    return null;
  var e3, u6, a3 = g3({ h: (e3 = n4[1], u6 = n4[2], u6 === undefined && (u6 = "deg"), Number(e3) * (r3[u6] || 1)), s: Number(n4[3]), l: Number(n4[4]), a: n4[5] === undefined ? 1 : Number(n4[5]) / (n4[6] ? 100 : 1) });
  return f2(a3);
}, "hsl"]], object: [[function(r4) {
  var { r: n4, g: e3, b: u6, a: o3 } = r4, i3 = o3 === undefined ? 1 : o3;
  return t3(n4) && t3(e3) && t3(u6) ? a2({ r: Number(n4), g: Number(e3), b: Number(u6), a: Number(i3) }) : null;
}, "rgb"], [function(r4) {
  var { h: n4, s: e3, l: u6, a: a3 } = r4, o3 = a3 === undefined ? 1 : a3;
  if (!t3(n4) || !t3(e3) || !t3(u6))
    return null;
  var i3 = g3({ h: Number(n4), s: Number(e3), l: Number(u6), a: Number(o3) });
  return f2(i3);
}, "hsl"], [function(r4) {
  var { h: n4, s: a3, v: o3, a: i3 } = r4, s3 = i3 === undefined ? 1 : i3;
  if (!t3(n4) || !t3(a3) || !t3(o3))
    return null;
  var h3 = function(r5) {
    return { h: u5(r5.h), s: e2(r5.s, 0, 100), v: e2(r5.v, 0, 100), a: e2(r5.a) };
  }({ h: Number(n4), s: Number(a3), v: Number(o3), a: Number(s3) });
  return b2(h3);
}, "hsv"]] };
var N3 = function(r4, t4) {
  for (var n4 = 0;n4 < t4.length; n4++) {
    var e3 = t4[n4][0](r4);
    if (e3)
      return [e3, t4[n4][1]];
  }
  return [null, undefined];
};
var x2 = function(r4) {
  return typeof r4 == "string" ? N3(r4.trim(), y2.string) : typeof r4 == "object" && r4 !== null ? N3(r4, y2.object) : [null, undefined];
};
var M3 = function(r4, t4) {
  var n4 = c2(r4);
  return { h: n4.h, s: e2(n4.s + 100 * t4, 0, 100), l: n4.l, a: n4.a };
};
var H3 = function(r4) {
  return (299 * r4.r + 587 * r4.g + 114 * r4.b) / 1000 / 255;
};
var $2 = function(r4, t4) {
  var n4 = c2(r4);
  return { h: n4.h, s: n4.s, l: e2(n4.l + 100 * t4, 0, 100), a: n4.a };
};
var j2 = function() {
  function r4(r5) {
    this.parsed = x2(r5)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r4.prototype.isValid = function() {
    return this.parsed !== null;
  }, r4.prototype.brightness = function() {
    return n3(H3(this.rgba), 2);
  }, r4.prototype.isDark = function() {
    return H3(this.rgba) < 0.5;
  }, r4.prototype.isLight = function() {
    return H3(this.rgba) >= 0.5;
  }, r4.prototype.toHex = function() {
    return r5 = o2(this.rgba), t4 = r5.r, e3 = r5.g, u6 = r5.b, i3 = (a3 = r5.a) < 1 ? s2(n3(255 * a3)) : "", "#" + s2(t4) + s2(e3) + s2(u6) + i3;
    var r5, t4, e3, u6, a3, i3;
  }, r4.prototype.toRgb = function() {
    return o2(this.rgba);
  }, r4.prototype.toRgbString = function() {
    return r5 = o2(this.rgba), t4 = r5.r, n4 = r5.g, e3 = r5.b, (u6 = r5.a) < 1 ? "rgba(" + t4 + ", " + n4 + ", " + e3 + ", " + u6 + ")" : "rgb(" + t4 + ", " + n4 + ", " + e3 + ")";
    var r5, t4, n4, e3, u6;
  }, r4.prototype.toHsl = function() {
    return d2(c2(this.rgba));
  }, r4.prototype.toHslString = function() {
    return r5 = d2(c2(this.rgba)), t4 = r5.h, n4 = r5.s, e3 = r5.l, (u6 = r5.a) < 1 ? "hsla(" + t4 + ", " + n4 + "%, " + e3 + "%, " + u6 + ")" : "hsl(" + t4 + ", " + n4 + "%, " + e3 + "%)";
    var r5, t4, n4, e3, u6;
  }, r4.prototype.toHsv = function() {
    return r5 = h2(this.rgba), { h: n3(r5.h), s: n3(r5.s), v: n3(r5.v), a: n3(r5.a, 3) };
    var r5;
  }, r4.prototype.invert = function() {
    return w2({ r: 255 - (r5 = this.rgba).r, g: 255 - r5.g, b: 255 - r5.b, a: r5.a });
    var r5;
  }, r4.prototype.saturate = function(r5) {
    return r5 === undefined && (r5 = 0.1), w2(M3(this.rgba, r5));
  }, r4.prototype.desaturate = function(r5) {
    return r5 === undefined && (r5 = 0.1), w2(M3(this.rgba, -r5));
  }, r4.prototype.grayscale = function() {
    return w2(M3(this.rgba, -1));
  }, r4.prototype.lighten = function(r5) {
    return r5 === undefined && (r5 = 0.1), w2($2(this.rgba, r5));
  }, r4.prototype.darken = function(r5) {
    return r5 === undefined && (r5 = 0.1), w2($2(this.rgba, -r5));
  }, r4.prototype.rotate = function(r5) {
    return r5 === undefined && (r5 = 15), this.hue(this.hue() + r5);
  }, r4.prototype.alpha = function(r5) {
    return typeof r5 == "number" ? w2({ r: (t4 = this.rgba).r, g: t4.g, b: t4.b, a: r5 }) : n3(this.rgba.a, 3);
    var t4;
  }, r4.prototype.hue = function(r5) {
    var t4 = c2(this.rgba);
    return typeof r5 == "number" ? w2({ h: r5, s: t4.s, l: t4.l, a: t4.a }) : n3(t4.h);
  }, r4.prototype.isEqual = function(r5) {
    return this.toHex() === w2(r5).toHex();
  }, r4;
}();
var w2 = function(r4) {
  return r4 instanceof j2 ? r4 : new j2(r4);
};
var S3 = [];
var k3 = function(r4) {
  r4.forEach(function(r5) {
    S3.indexOf(r5) < 0 && (r5(j2, y2), S3.push(r5));
  });
};

// node_modules/colord/plugins/names.mjs
function names_default(e3, f3) {
  var a3 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r4 = {};
  for (var d3 in a3)
    r4[a3[d3]] = d3;
  var l4 = {};
  e3.prototype.toName = function(f4) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
      return "transparent";
    var d4, i3, n4 = r4[this.toHex()];
    if (n4)
      return n4;
    if (f4 == null ? undefined : f4.closest) {
      var o3 = this.toRgb(), t4 = 1 / 0, b3 = "black";
      if (!l4.length)
        for (var c3 in a3)
          l4[c3] = new e3(a3[c3]).toRgb();
      for (var g4 in a3) {
        var u6 = (d4 = o3, i3 = l4[g4], Math.pow(d4.r - i3.r, 2) + Math.pow(d4.g - i3.g, 2) + Math.pow(d4.b - i3.b, 2));
        u6 < t4 && (t4 = u6, b3 = g4);
      }
      return b3;
    }
  };
  f3.string.push([function(f4) {
    var r5 = f4.toLowerCase(), d4 = r5 === "transparent" ? "#0000" : a3[r5];
    return d4 ? new e3(d4).toRgb() : null;
  }, "name"]);
}

// node_modules/colord/plugins/names.mjsi
k3([names_default]);
var _Color = class {
  constructor(value = 16777215) {
    this._value = null;
    this._components = new Float32Array(4);
    this._components.fill(1);
    this._int = 16777215;
    this.value = value;
  }
  get red() {
    return this._components[0];
  }
  get green() {
    return this._components[1];
  }
  get blue() {
    return this._components[2];
  }
  get alpha() {
    return this._components[3];
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  set value(value) {
    if (value instanceof _Color) {
      this._value = this.cloneSource(value._value);
      this._int = value._int;
      this._components.set(value._components);
    } else if (value === null) {
      throw new Error("Cannot set PIXI.Color#value to null");
    } else if (this._value === null || !this.isSourceEqual(this._value, value)) {
      this.normalize(value);
      this._value = this.cloneSource(value);
    }
  }
  get value() {
    return this._value;
  }
  cloneSource(value) {
    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
      return value;
    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return value.slice(0);
    } else if (typeof value === "object" && value !== null) {
      return { ...value };
    }
    return value;
  }
  isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    const type2 = typeof value2;
    if (type1 !== type2) {
      return false;
    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
      return value1 === value2;
    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
      if (value1.length !== value2.length) {
        return false;
      }
      return value1.every((v4, i3) => v4 === value2[i3]);
    } else if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1);
      const keys2 = Object.keys(value2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keys1.every((key) => value1[key] === value2[key]);
    }
    return value1 === value2;
  }
  toRgba() {
    const [r4, g4, b3, a3] = this._components;
    return { r: r4, g: g4, b: b3, a: a3 };
  }
  toRgb() {
    const [r4, g4, b3] = this._components;
    return { r: r4, g: g4, b: b3 };
  }
  toRgbaString() {
    const [r4, g4, b3] = this.toUint8RgbArray();
    return `rgba(${r4},${g4},${b3},${this.alpha})`;
  }
  toUint8RgbArray(out) {
    const [r4, g4, b3] = this._components;
    out = out ?? [];
    out[0] = Math.round(r4 * 255);
    out[1] = Math.round(g4 * 255);
    out[2] = Math.round(b3 * 255);
    return out;
  }
  toRgbArray(out) {
    out = out ?? [];
    const [r4, g4, b3] = this._components;
    out[0] = r4;
    out[1] = g4;
    out[2] = b3;
    return out;
  }
  toNumber() {
    return this._int;
  }
  toLittleEndianNumber() {
    const value = this._int;
    return (value >> 16) + (value & 65280) + ((value & 255) << 16);
  }
  multiply(value) {
    const [r4, g4, b3, a3] = _Color.temp.setValue(value)._components;
    this._components[0] *= r4;
    this._components[1] *= g4;
    this._components[2] *= b3;
    this._components[3] *= a3;
    this.refreshInt();
    this._value = null;
    return this;
  }
  premultiply(alpha, applyToRGB = true) {
    if (applyToRGB) {
      this._components[0] *= alpha;
      this._components[1] *= alpha;
      this._components[2] *= alpha;
    }
    this._components[3] = alpha;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1) {
      return (255 << 24) + this._int;
    }
    if (alpha === 0) {
      return applyToRGB ? 0 : this._int;
    }
    let r4 = this._int >> 16 & 255;
    let g4 = this._int >> 8 & 255;
    let b3 = this._int & 255;
    if (applyToRGB) {
      r4 = r4 * alpha + 0.5 | 0;
      g4 = g4 * alpha + 0.5 | 0;
      b3 = b3 * alpha + 0.5 | 0;
    }
    return (alpha * 255 << 24) + (r4 << 16) + (g4 << 8) + b3;
  }
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  toHexa() {
    const alphaValue = Math.round(this._components[3] * 255);
    const alphaString = alphaValue.toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  setAlpha(alpha) {
    this._components[3] = this._clamp(alpha);
    return this;
  }
  round(steps) {
    const [r4, g4, b3] = this._components;
    this._components[0] = Math.round(r4 * steps) / steps;
    this._components[1] = Math.round(g4 * steps) / steps;
    this._components[2] = Math.round(b3 * steps) / steps;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toArray(out) {
    out = out ?? [];
    const [r4, g4, b3, a3] = this._components;
    out[0] = r4;
    out[1] = g4;
    out[2] = b3;
    out[3] = a3;
    return out;
  }
  normalize(value) {
    let r4;
    let g4;
    let b3;
    let a3;
    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
      const int = value;
      r4 = (int >> 16 & 255) / 255;
      g4 = (int >> 8 & 255) / 255;
      b3 = (int & 255) / 255;
      a3 = 1;
    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value);
      [r4, g4, b3, a3 = 1] = value;
    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value, 0, 255);
      [r4, g4, b3, a3 = 255] = value;
      r4 /= 255;
      g4 /= 255;
      b3 /= 255;
      a3 /= 255;
    } else if (typeof value === "string" || typeof value === "object") {
      if (typeof value === "string") {
        const match = _Color.HEX_PATTERN.exec(value);
        if (match) {
          value = `#${match[2]}`;
        }
      }
      const color = w2(value);
      if (color.isValid()) {
        ({ r: r4, g: g4, b: b3, a: a3 } = color.rgba);
        r4 /= 255;
        g4 /= 255;
        b3 /= 255;
      }
    }
    if (r4 !== undefined) {
      this._components[0] = r4;
      this._components[1] = g4;
      this._components[2] = b3;
      this._components[3] = a3;
      this.refreshInt();
    } else {
      throw new Error(`Unable to convert color ${value}`);
    }
  }
  refreshInt() {
    this._clamp(this._components);
    const [r4, g4, b3] = this._components;
    this._int = (r4 * 255 << 16) + (g4 * 255 << 8) + (b3 * 255 | 0);
  }
  _clamp(value, min = 0, max = 1) {
    if (typeof value === "number") {
      return Math.min(Math.max(value, min), max);
    }
    value.forEach((v4, i3) => {
      value[i3] = Math.min(Math.max(v4, min), max);
    });
    return value;
  }
};
var Color = _Color;
Color.shared = new _Color;
Color.temp = new _Color;
Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
// node_modules/colord/plugins/names.mjsisten
var hex2rgb = function(hex, out = []) {
  deprecation("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead");
  return Color.shared.setValue(hex).toRgbArray(out);
};
var hex2string = function(hex) {
  deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead");
  return Color.shared.setValue(hex).toHex();
};
var string2hex = function(string) {
  deprecation("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead");
  return Color.shared.setValue(string).toNumber();
};
var rgb2hex = function(rgb) {
  deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead");
  return Color.shared.setValue(rgb).toNumber();
};
// node_modules/colord/plugins/names.mjsistener.mjsgl
var mapPremultipliedBlendModes = function() {
  const pm = [];
  const npm = [];
  for (let i3 = 0;i3 < 32; i3++) {
    pm[i3] = i3;
    npm[i3] = i3;
  }
  pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;
  pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;
  pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;
  npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;
  npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;
  npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  const array = [];
  array.push(npm);
  array.push(pm);
  return array;
};
var correctBlendMode = function(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
};
var premultiplyRgba = function(rgb, alpha, out, premultiply = true) {
  deprecation("7.2.0", `utils.premultiplyRgba has moved to Color.premultiply`);
  return Color.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
};
var premultiplyTint = function(tint, alpha) {
  deprecation("7.2.0", `utils.premultiplyTint has moved to Color.toPremultiplied`);
  return Color.shared.setValue(tint).toPremultiplied(alpha);
};
var premultiplyTintToRgba = function(tint, alpha, out, premultiply = true) {
  deprecation("7.2.0", `utils.premultiplyTintToRgba has moved to Color.premultiply`);
  return Color.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
};
var premultiplyBlendMode = mapPremultipliedBlendModes();
// node_modules/colord/plugins/names.mjsi
var DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
var createIndicesForQuads = function(size, outBuffer = null) {
  const totalIndices = size * 6;
  outBuffer = outBuffer || new Uint16Array(totalIndices);
  if (outBuffer.length !== totalIndices) {
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  }
  for (let i3 = 0, j3 = 0;i3 < totalIndices; i3 += 6, j3 += 4) {
    outBuffer[i3 + 0] = j3 + 0;
    outBuffer[i3 + 1] = j3 + 1;
    outBuffer[i3 + 2] = j3 + 2;
    outBuffer[i3 + 3] = j3 + 0;
    outBuffer[i3 + 4] = j3 + 2;
    outBuffer[i3 + 5] = j3 + 3;
  }
  return outBuffer;
};
// node_modules/colord/plugins/names.mjsistener.mjsgle
var getBufferType = function(array) {
  if (array.BYTES_PER_ELEMENT === 4) {
    if (array instanceof Float32Array) {
      return "Float32Array";
    } else if (array instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array.BYTES_PER_ELEMENT === 1) {
    if (array instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
var interleaveTypedArrays = function(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i3 = 0;i3 < arrays.length; i3++) {
    stride += sizes[i3];
    outSize += arrays[i3].length;
  }
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i3 = 0;i3 < arrays.length; i3++) {
    const size = sizes[i3];
    const array = arrays[i3];
    const type = getBufferType(array);
    if (!views[type]) {
      views[type] = new map[type](buffer);
    }
    out = views[type];
    for (let j3 = 0;j3 < array.length; j3++) {
      const indexStart = (j3 / size | 0) * stride + littleOffset;
      const index2 = j3 % size;
      out[indexStart + index2] = array[j3];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
};
var map = { Float32Array, Uint32Array, Int32Array, Uint8Array };
// node_modules/colord/plugins/names.mjsisten
var nextPow2 = function(v4) {
  v4 += v4 === 0 ? 1 : 0;
  --v4;
  v4 |= v4 >>> 1;
  v4 |= v4 >>> 2;
  v4 |= v4 >>> 4;
  v4 |= v4 >>> 8;
  v4 |= v4 >>> 16;
  return v4 + 1;
};
var isPow2 = function(v4) {
  return !(v4 & v4 - 1) && !!v4;
};
var log2 = function(v4) {
  let r4 = (v4 > 65535 ? 1 : 0) << 4;
  v4 >>>= r4;
  let shift = (v4 > 255 ? 1 : 0) << 3;
  v4 >>>= shift;
  r4 |= shift;
  shift = (v4 > 15 ? 1 : 0) << 2;
  v4 >>>= shift;
  r4 |= shift;
  shift = (v4 > 3 ? 1 : 0) << 1;
  v4 >>>= shift;
  r4 |= shift;
  return r4 | v4 >> 1;
};
// node_modules/colord/plugins/names.mjsistener.mjsg
var removeItems = function(arr, startIdx, removeCount) {
  const length2 = arr.length;
  let i3;
  if (startIdx >= length2 || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length2 ? length2 - startIdx : removeCount;
  const len = length2 - removeCount;
  for (i3 = startIdx;i3 < len; ++i3) {
    arr[i3] = arr[i3 + removeCount];
  }
  arr.length = len;
};
// node_modules/colord/plugins/names.mjsisten
var sign = function(n4) {
  if (n4 === 0)
    return 0;
  return n4 < 0 ? -1 : 1;
};
// node_modules/colord/plugins/names.mjsiste
var uid = function() {
  return ++nextUid;
};
var nextUid = 0;
// node_modules/colord/plugins/names.mjsistener.mjsgl
var _BoundingBox = class {
  constructor(left, top, right, bottom) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }
  get width() {
    return this.right - this.left;
  }
  get height() {
    return this.bottom - this.top;
  }
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
};
var BoundingBox = _BoundingBox;
BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);
// node_modules/colord/plugins/names.mjsistener.
var destroyTextureCache = function() {
  let key;
  for (key in TextureCache) {
    TextureCache[key].destroy();
  }
  for (key in BaseTextureCache) {
    BaseTextureCache[key].destroy();
  }
};
var clearTextureCache = function() {
  let key;
  for (key in TextureCache) {
    delete TextureCache[key];
  }
  for (key in BaseTextureCache) {
    delete BaseTextureCache[key];
  }
};
var ProgramCache = {};
var TextureCache = Object.create(null);
var BaseTextureCache = Object.create(null);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
class CanvasRenderTarget {
  constructor(width, height, resolution) {
    this._canvas = settings.ADAPTER.createCanvas();
    this._context = this._canvas.getContext("2d");
    this.resolution = resolution || settings.RESOLUTION;
    this.resize(width, height);
  }
  clear() {
    this._checkDestroyed();
    this._context.setTransform(1, 0, 0, 1, 0, 0);
    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
  }
  resize(desiredWidth, desiredHeight) {
    this._checkDestroyed();
    this._canvas.width = Math.round(desiredWidth * this.resolution);
    this._canvas.height = Math.round(desiredHeight * this.resolution);
  }
  destroy() {
    this._context = null;
    this._canvas = null;
  }
  get width() {
    this._checkDestroyed();
    return this._canvas.width;
  }
  set width(val) {
    this._checkDestroyed();
    this._canvas.width = Math.round(val);
  }
  get height() {
    this._checkDestroyed();
    return this._canvas.height;
  }
  set height(val) {
    this._checkDestroyed();
    this._canvas.height = Math.round(val);
  }
  get canvas() {
    this._checkDestroyed();
    return this._canvas;
  }
  get context() {
    this._checkDestroyed();
    return this._context;
  }
  _checkDestroyed() {
    if (this._canvas === null) {
      throw new TypeError("The CanvasRenderTarget has already been destroyed");
    }
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
var checkRow = function(data, width, y3) {
  for (let x3 = 0, index2 = 4 * y3 * width;x3 < width; ++x3, index2 += 4) {
    if (data[index2 + 3] !== 0)
      return false;
  }
  return true;
};
var checkColumn = function(data, width, x3, top, bottom) {
  const stride = 4 * width;
  for (let y3 = top, index2 = top * stride + 4 * x3;y3 <= bottom; ++y3, index2 += stride) {
    if (data[index2 + 3] !== 0)
      return false;
  }
  return true;
};
var getCanvasBoundingBox = function(canvas) {
  const { width, height } = canvas;
  const context = canvas.getContext("2d", {
    willReadFrequently: true
  });
  if (context === null) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  const imageData = context.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return BoundingBox.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  return new BoundingBox(left, top, right, bottom);
};
// node_modules/colord/plugins/names.mjsistener.mjsg
var trimCanvas = function(canvas) {
  const boundingBox = getCanvasBoundingBox(canvas);
  const { width, height } = boundingBox;
  let data = null;
  if (!boundingBox.isEmpty()) {
    const context = canvas.getContext("2d");
    if (context === null) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    data = context.getImageData(boundingBox.left, boundingBox.top, width, height);
  }
  return { width, height, data };
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
var decomposeDataUri = function(dataUri) {
  const dataUriMatch = DATA_URI.exec(dataUri);
  if (dataUriMatch) {
    return {
      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : undefined,
      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : undefined,
      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : undefined,
      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : undefined,
      data: dataUriMatch[5]
    };
  }
  return;
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
var determineCrossOrigin = function(url$1, loc = globalThis.location) {
  if (url$1.startsWith("data:")) {
    return "";
  }
  loc = loc || globalThis.location;
  if (!tempAnchor) {
    tempAnchor = document.createElement("a");
  }
  tempAnchor.href = url$1;
  const parsedUrl = url.parse(tempAnchor.href);
  const samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
};
var tempAnchor;
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
var getResolutionOfUrl = function(url3, defaultValue = 1) {
  const resolution = settings.RETINA_PREFIX?.exec(url3);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue;
};
// node_modules/colord/plugins/names.mjsistene
var ExtensionType = ((ExtensionType2) => {
  ExtensionType2["Renderer"] = "renderer";
  ExtensionType2["Application"] = "application";
  ExtensionType2["RendererSystem"] = "renderer-webgl-system";
  ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";
  ExtensionType2["CanvasRendererSystem"] = "renderer-canvas-system";
  ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";
  ExtensionType2["Asset"] = "asset";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
  return ExtensionType2;
})(ExtensionType || {});
var normalizeExtension = (ext) => {
  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
    if (!ext.extension) {
      throw new Error("Extension class must have an extension object");
    }
    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
    ext = { ...metadata, ref: ext };
  }
  if (typeof ext === "object") {
    ext = { ...ext };
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext.type === "string") {
    ext.type = [ext.type];
  }
  return ext;
};
var normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
var extensions = {
  _addHandlers: {},
  _removeHandlers: {},
  _queue: {},
  remove(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
    });
    return this;
  },
  add(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => {
        const handlers = this._addHandlers;
        const queue = this._queue;
        if (!handlers[type]) {
          queue[type] = queue[type] || [];
          queue[type].push(ext);
        } else {
          handlers[type](ext);
        }
      });
    });
    return this;
  },
  handle(type, onAdd, onRemove) {
    const addHandlers = this._addHandlers;
    const removeHandlers = this._removeHandlers;
    if (addHandlers[type] || removeHandlers[type]) {
      throw new Error(`Extension type ${type} already has a handler`);
    }
    addHandlers[type] = onAdd;
    removeHandlers[type] = onRemove;
    const queue = this._queue;
    if (queue[type]) {
      queue[type].forEach((ext) => onAdd(ext));
      delete queue[type];
    }
    return this;
  },
  handleByMap(type, map2) {
    return this.handle(type, (extension) => {
      map2[extension.name] = extension.ref;
    }, (extension) => {
      delete map2[extension.name];
    });
  },
  handleByList(type, list, defaultPriority = -1) {
    return this.handle(type, (extension) => {
      if (list.includes(extension.ref)) {
        return;
      }
      list.push(extension.ref);
      list.sort((a3, b3) => normalizePriority(b3, defaultPriority) - normalizePriority(a3, defaultPriority));
    }, (extension) => {
      const index2 = list.indexOf(extension.ref);
      if (index2 !== -1) {
        list.splice(index2, 1);
      }
    });
  }
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
class ViewableBuffer {
  constructor(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
  }
  get int8View() {
    if (!this._int8View) {
      this._int8View = new Int8Array(this.rawBinaryData);
    }
    return this._int8View;
  }
  get uint8View() {
    if (!this._uint8View) {
      this._uint8View = new Uint8Array(this.rawBinaryData);
    }
    return this._uint8View;
  }
  get int16View() {
    if (!this._int16View) {
      this._int16View = new Int16Array(this.rawBinaryData);
    }
    return this._int16View;
  }
  get uint16View() {
    if (!this._uint16View) {
      this._uint16View = new Uint16Array(this.rawBinaryData);
    }
    return this._uint16View;
  }
  get int32View() {
    if (!this._int32View) {
      this._int32View = new Int32Array(this.rawBinaryData);
    }
    return this._int32View;
  }
  view(type) {
    return this[`${type}View`];
  }
  destroy() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  }
  static sizeOf(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type} isn't a valid view type`);
    }
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExten
var generateIfTestSrc = function(maxIfs) {
  let src = "";
  for (let i3 = 0;i3 < maxIfs; ++i3) {
    if (i3 > 0) {
      src += "\nelse ";
    }
    if (i3 < maxIfs - 1) {
      src += `if(test == ${i3}.0){}`;
    }
  }
  return src;
};
var checkMaxIfStatementsInShader = function(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
};
var fragTemplate = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");

// node_modules/colord/plugins/names.mjsistene
var BLEND = 0;
var OFFSET = 1;
var CULLING = 2;
var DEPTH_TEST = 3;
var WINDING = 4;
var DEPTH_MASK = 5;

class State {
  constructor() {
    this.data = 0;
    this.blendMode = BLEND_MODES.NORMAL;
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  get blend() {
    return !!(this.data & 1 << BLEND);
  }
  set blend(value) {
    if (!!(this.data & 1 << BLEND) !== value) {
      this.data ^= 1 << BLEND;
    }
  }
  get offsets() {
    return !!(this.data & 1 << OFFSET);
  }
  set offsets(value) {
    if (!!(this.data & 1 << OFFSET) !== value) {
      this.data ^= 1 << OFFSET;
    }
  }
  get culling() {
    return !!(this.data & 1 << CULLING);
  }
  set culling(value) {
    if (!!(this.data & 1 << CULLING) !== value) {
      this.data ^= 1 << CULLING;
    }
  }
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST);
  }
  set depthTest(value) {
    if (!!(this.data & 1 << DEPTH_TEST) !== value) {
      this.data ^= 1 << DEPTH_TEST;
    }
  }
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK);
  }
  set depthMask(value) {
    if (!!(this.data & 1 << DEPTH_MASK) !== value) {
      this.data ^= 1 << DEPTH_MASK;
    }
  }
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING);
  }
  set clockwiseFrontFace(value) {
    if (!!(this.data & 1 << WINDING) !== value) {
      this.data ^= 1 << WINDING;
    }
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value) {
    this.blend = value !== BLEND_MODES.NONE;
    this._blendMode = value;
  }
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value) {
    this.offsets = !!value;
    this._polygonOffset = value;
  }
  toString() {
    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  static for2d() {
    const state = new State;
    state.depthTest = false;
    state.blend = true;
    return state;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureE
var autoDetectResource = function(source, options) {
  if (!source) {
    return null;
  }
  let extension = "";
  if (typeof source === "string") {
    const result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (let i3 = INSTALLED.length - 1;i3 >= 0; --i3) {
    const ResourcePlugin = INSTALLED[i3];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
};
var INSTALLED = [];

// node_modules/colord/plugins/names.mjsist
class Runner {
  constructor(name) {
    this.items = [];
    this._name = name;
    this._aliasCount = 0;
  }
  emit(a0, a1, a22, a3, a4, a5, a6, a7) {
    if (arguments.length > 8) {
      throw new Error("max arguments reached");
    }
    const { name, items } = this;
    this._aliasCount++;
    for (let i3 = 0, len = items.length;i3 < len; i3++) {
      items[i3][name](a0, a1, a22, a3, a4, a5, a6, a7);
    }
    if (items === this.items) {
      this._aliasCount--;
    }
    return this;
  }
  ensureNonAliasedItems() {
    if (this._aliasCount > 0 && this.items.length > 1) {
      this._aliasCount = 0;
      this.items = this.items.slice(0);
    }
  }
  add(item) {
    if (item[this._name]) {
      this.ensureNonAliasedItems();
      this.remove(item);
      this.items.push(item);
    }
    return this;
  }
  remove(item) {
    const index2 = this.items.indexOf(item);
    if (index2 !== -1) {
      this.ensureNonAliasedItems();
      this.items.splice(index2, 1);
    }
    return this;
  }
  contains(item) {
    return this.items.includes(item);
  }
  removeAll() {
    this.ensureNonAliasedItems();
    this.items.length = 0;
    return this;
  }
  destroy() {
    this.removeAll();
    this.items = null;
    this._name = null;
  }
  get empty() {
    return this.items.length === 0;
  }
  get name() {
    return this._name;
  }
}
Object.defineProperties(Runner.prototype, {
  dispatch: { value: Runner.prototype.emit },
  run: { value: Runner.prototype.emit }
});
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
class Resource {
  constructor(width = 0, height = 0) {
    this._width = width;
    this._height = height;
    this.destroyed = false;
    this.internal = false;
    this.onResize = new Runner("setRealSize");
    this.onUpdate = new Runner("update");
    this.onError = new Runner("onError");
  }
  bind(baseTexture) {
    this.onResize.add(baseTexture);
    this.onUpdate.add(baseTexture);
    this.onError.add(baseTexture);
    if (this._width || this._height) {
      this.onResize.emit(this._width, this._height);
    }
  }
  unbind(baseTexture) {
    this.onResize.remove(baseTexture);
    this.onUpdate.remove(baseTexture);
    this.onError.remove(baseTexture);
  }
  resize(width, height) {
    if (width !== this._width || height !== this._height) {
      this._width = width;
      this._height = height;
      this.onResize.emit(width, height);
    }
  }
  get valid() {
    return !!this._width && !!this._height;
  }
  update() {
    if (!this.destroyed) {
      this.onUpdate.emit();
    }
  }
  load() {
    return Promise.resolve(this);
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  style(_renderer, _baseTexture, _glTexture) {
    return false;
  }
  dispose() {
  }
  destroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.dispose();
      this.onError.removeAll();
      this.onError = null;
      this.onResize.removeAll();
      this.onResize = null;
      this.onUpdate.removeAll();
      this.onUpdate = null;
    }
  }
  static test(_source, _extension) {
    return false;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsText
class BufferResource extends Resource {
  constructor(source, options) {
    const { width, height } = options || {};
    if (!width || !height) {
      throw new Error("BufferResource width or height invalid");
    }
    super(width, height);
    this.data = source;
  }
  upload(renderer, baseTexture, glTexture) {
    const gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
  dispose() {
    this.data = null;
  }
  static test(source) {
    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.
var defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  format: FORMATS.RGBA,
  alphaMode: ALPHA_MODES.NPM
};
var _BaseTexture = class extends import_eventemitter3.default {
  constructor(resource = null, options = null) {
    super();
    options = Object.assign({}, _BaseTexture.defaultOptions, options);
    const {
      alphaMode,
      mipmap,
      anisotropicLevel,
      scaleMode,
      width,
      height,
      wrapMode,
      format,
      type,
      target,
      resolution,
      resourceOptions
    } = options;
    if (resource && !(resource instanceof Resource)) {
      resource = autoDetectResource(resource, resourceOptions);
      resource.internal = true;
    }
    this.resolution = resolution || settings.RESOLUTION;
    this.width = Math.round((width || 0) * this.resolution) / this.resolution;
    this.height = Math.round((height || 0) * this.resolution) / this.resolution;
    this._mipmap = mipmap;
    this.anisotropicLevel = anisotropicLevel;
    this._wrapMode = wrapMode;
    this._scaleMode = scaleMode;
    this.format = format;
    this.type = type;
    this.target = target;
    this.alphaMode = alphaMode;
    this.uid = uid();
    this.touched = 0;
    this.isPowerOfTwo = false;
    this._refreshPOT();
    this._glTextures = {};
    this.dirtyId = 0;
    this.dirtyStyleId = 0;
    this.cacheId = null;
    this.valid = width > 0 && height > 0;
    this.textureCacheIds = [];
    this.destroyed = false;
    this.resource = null;
    this._batchEnabled = 0;
    this._batchLocation = 0;
    this.parentTextureArray = null;
    this.setResource(resource);
  }
  get realWidth() {
    return Math.round(this.width * this.resolution);
  }
  get realHeight() {
    return Math.round(this.height * this.resolution);
  }
  get mipmap() {
    return this._mipmap;
  }
  set mipmap(value) {
    if (this._mipmap !== value) {
      this._mipmap = value;
      this.dirtyStyleId++;
    }
  }
  get scaleMode() {
    return this._scaleMode;
  }
  set scaleMode(value) {
    if (this._scaleMode !== value) {
      this._scaleMode = value;
      this.dirtyStyleId++;
    }
  }
  get wrapMode() {
    return this._wrapMode;
  }
  set wrapMode(value) {
    if (this._wrapMode !== value) {
      this._wrapMode = value;
      this.dirtyStyleId++;
    }
  }
  setStyle(scaleMode, mipmap) {
    let dirty;
    if (scaleMode !== undefined && scaleMode !== this.scaleMode) {
      this.scaleMode = scaleMode;
      dirty = true;
    }
    if (mipmap !== undefined && mipmap !== this.mipmap) {
      this.mipmap = mipmap;
      dirty = true;
    }
    if (dirty) {
      this.dirtyStyleId++;
    }
    return this;
  }
  setSize(desiredWidth, desiredHeight, resolution) {
    resolution = resolution || this.resolution;
    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  }
  setRealSize(realWidth, realHeight, resolution) {
    this.resolution = resolution || this.resolution;
    this.width = Math.round(realWidth) / this.resolution;
    this.height = Math.round(realHeight) / this.resolution;
    this._refreshPOT();
    this.update();
    return this;
  }
  _refreshPOT() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  }
  setResolution(resolution) {
    const oldResolution = this.resolution;
    if (oldResolution === resolution) {
      return this;
    }
    this.resolution = resolution;
    if (this.valid) {
      this.width = Math.round(this.width * oldResolution) / resolution;
      this.height = Math.round(this.height * oldResolution) / resolution;
      this.emit("update", this);
    }
    this._refreshPOT();
    return this;
  }
  setResource(resource) {
    if (this.resource === resource) {
      return this;
    }
    if (this.resource) {
      throw new Error("Resource can be set only once");
    }
    resource.bind(this);
    this.resource = resource;
    return this;
  }
  update() {
    if (!this.valid) {
      if (this.width > 0 && this.height > 0) {
        this.valid = true;
        this.emit("loaded", this);
        this.emit("update", this);
      }
    } else {
      this.dirtyId++;
      this.dirtyStyleId++;
      this.emit("update", this);
    }
  }
  onError(event) {
    this.emit("error", this, event);
  }
  destroy() {
    if (this.resource) {
      this.resource.unbind(this);
      if (this.resource.internal) {
        this.resource.destroy();
      }
      this.resource = null;
    }
    if (this.cacheId) {
      delete BaseTextureCache[this.cacheId];
      delete TextureCache[this.cacheId];
      this.cacheId = null;
    }
    this.dispose();
    _BaseTexture.removeFromCache(this);
    this.textureCacheIds = null;
    this.destroyed = true;
  }
  dispose() {
    this.emit("dispose", this);
  }
  castToBaseTexture() {
    return this;
  }
  static from(source, options, strict = settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else {
      if (!source._pixiId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix}_${uid()}`;
      }
      cacheId = source._pixiId;
    }
    let baseTexture = BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
    }
    if (!baseTexture) {
      baseTexture = new _BaseTexture(source, options);
      baseTexture.cacheId = cacheId;
      _BaseTexture.addToCache(baseTexture, cacheId);
    }
    return baseTexture;
  }
  static fromBuffer(buffer, width, height, options) {
    buffer = buffer || new Float32Array(width * height * 4);
    const resource = new BufferResource(buffer, { width, height });
    const type = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
    return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, { type }, options));
  }
  static addToCache(baseTexture, id) {
    if (id) {
      if (!baseTexture.textureCacheIds.includes(id)) {
        baseTexture.textureCacheIds.push(id);
      }
      if (BaseTextureCache[id] && BaseTextureCache[id] !== baseTexture) {
        console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);
      }
      BaseTextureCache[id] = baseTexture;
    }
  }
  static removeFromCache(baseTexture) {
    if (typeof baseTexture === "string") {
      const baseTextureFromCache = BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        const index2 = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        if (index2 > -1) {
          baseTextureFromCache.textureCacheIds.splice(index2, 1);
        }
        delete BaseTextureCache[baseTexture];
        return baseTextureFromCache;
      }
    } else if (baseTexture?.textureCacheIds) {
      for (let i3 = 0;i3 < baseTexture.textureCacheIds.length; ++i3) {
        delete BaseTextureCache[baseTexture.textureCacheIds[i3]];
      }
      baseTexture.textureCacheIds.length = 0;
      return baseTexture;
    }
    return null;
  }
};
var BaseTexture = _BaseTexture;
BaseTexture.defaultOptions = {
  mipmap: MIPMAP_MODES.POW2,
  anisotropicLevel: 0,
  scaleMode: SCALE_MODES.LINEAR,
  wrapMode: WRAP_MODES.CLAMP,
  alphaMode: ALPHA_MODES.UNPACK,
  target: TARGETS.TEXTURE_2D,
  format: FORMATS.RGBA,
  type: TYPES.UNSIGNED_BYTE
};
BaseTexture._globalBatch = 0;

// node_modules/colord/plugins/names.mjsistener.mjsgle
class BatchDrawCall {
  constructor() {
    this.texArray = null;
    this.blend = 0;
    this.type = DRAW_MODES.TRIANGLES;
    this.start = 0;
    this.size = 0;
    this.data = null;
  }
}

// node_modules/colord/plugins/names.mjsistener.mj
var UID = 0;

class Buffer {
  constructor(data, _static = true, index2 = false) {
    this.data = data || new Float32Array(1);
    this._glBuffers = {};
    this._updateID = 0;
    this.index = index2;
    this.static = _static;
    this.id = UID++;
    this.disposeRunner = new Runner("disposeBuffer");
  }
  update(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this.data = data || this.data;
    this._updateID++;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.data = null;
  }
  set index(value) {
    this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
  }
  get index() {
    return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
  }
  static from(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    return new Buffer(data);
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgl
class Attribute {
  constructor(buffer, size = 0, normalized = false, type = TYPES.FLOAT, stride, start, instance, divisor = 1) {
    this.buffer = buffer;
    this.size = size;
    this.normalized = normalized;
    this.type = type;
    this.stride = stride;
    this.start = start;
    this.instance = instance;
    this.divisor = divisor;
  }
  destroy() {
    this.buffer = null;
  }
  static from(buffer, size, normalized, type, stride) {
    return new Attribute(buffer, size, normalized, type, stride);
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTexture
var interleaveTypedArrays2 = function(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i3 = 0;i3 < arrays.length; i3++) {
    stride += sizes[i3];
    outSize += arrays[i3].length;
  }
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i3 = 0;i3 < arrays.length; i3++) {
    const size = sizes[i3];
    const array = arrays[i3];
    const type = getBufferType(array);
    if (!views[type]) {
      views[type] = new map2[type](buffer);
    }
    out = views[type];
    for (let j3 = 0;j3 < array.length; j3++) {
      const indexStart = (j3 / size | 0) * stride + littleOffset;
      const index2 = j3 % size;
      out[indexStart + index2] = array[j3];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
};
var map2 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};

// node_modules/colord/plugins/names.mjsistener.mjsg
var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
var UID2 = 0;
var map3 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};

class Geometry {
  constructor(buffers = [], attributes = {}) {
    this.buffers = buffers;
    this.indexBuffer = null;
    this.attributes = attributes;
    this.glVertexArrayObjects = {};
    this.id = UID2++;
    this.instanced = false;
    this.instanceCount = 1;
    this.disposeRunner = new Runner("disposeGeometry");
    this.refCount = 0;
  }
  addAttribute(id, buffer, size = 0, normalized = false, type, stride, start, instance = false) {
    if (!buffer) {
      throw new Error("You must pass a buffer when creating an attribute");
    }
    if (!(buffer instanceof Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Float32Array(buffer);
      }
      buffer = new Buffer(buffer);
    }
    const ids = id.split("|");
    if (ids.length > 1) {
      for (let i3 = 0;i3 < ids.length; i3++) {
        this.addAttribute(ids[i3], buffer, size, normalized, type);
      }
      return this;
    }
    let bufferIndex = this.buffers.indexOf(buffer);
    if (bufferIndex === -1) {
      this.buffers.push(buffer);
      bufferIndex = this.buffers.length - 1;
    }
    this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance);
    this.instanced = this.instanced || instance;
    return this;
  }
  getAttribute(id) {
    return this.attributes[id];
  }
  getBuffer(id) {
    return this.buffers[this.getAttribute(id).buffer];
  }
  addIndex(buffer) {
    if (!(buffer instanceof Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Uint16Array(buffer);
      }
      buffer = new Buffer(buffer);
    }
    buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    this.indexBuffer = buffer;
    if (!this.buffers.includes(buffer)) {
      this.buffers.push(buffer);
    }
    return this;
  }
  getIndex() {
    return this.indexBuffer;
  }
  interleave() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    const arrays = [];
    const sizes = [];
    const interleavedBuffer = new Buffer;
    let i3;
    for (i3 in this.attributes) {
      const attribute = this.attributes[i3];
      const buffer = this.buffers[attribute.buffer];
      arrays.push(buffer.data);
      sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
      attribute.buffer = 0;
    }
    interleavedBuffer.data = interleaveTypedArrays2(arrays, sizes);
    for (i3 = 0;i3 < this.buffers.length; i3++) {
      if (this.buffers[i3] !== this.indexBuffer) {
        this.buffers[i3].destroy();
      }
    }
    this.buffers = [interleavedBuffer];
    if (this.indexBuffer) {
      this.buffers.push(this.indexBuffer);
    }
    return this;
  }
  getSize() {
    for (const i3 in this.attributes) {
      const attribute = this.attributes[i3];
      const buffer = this.buffers[attribute.buffer];
      return buffer.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.buffers = null;
    this.indexBuffer = null;
    this.attributes = null;
  }
  clone() {
    const geometry = new Geometry;
    for (let i3 = 0;i3 < this.buffers.length; i3++) {
      geometry.buffers[i3] = new Buffer(this.buffers[i3].data.slice(0));
    }
    for (const i3 in this.attributes) {
      const attrib = this.attributes[i3];
      geometry.attributes[i3] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
    }
    if (this.indexBuffer) {
      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
      geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    }
    return geometry;
  }
  static merge(geometries) {
    const geometryOut = new Geometry;
    const arrays = [];
    const sizes = [];
    const offsets = [];
    let geometry;
    for (let i3 = 0;i3 < geometries.length; i3++) {
      geometry = geometries[i3];
      for (let j3 = 0;j3 < geometry.buffers.length; j3++) {
        sizes[j3] = sizes[j3] || 0;
        sizes[j3] += geometry.buffers[j3].data.length;
        offsets[j3] = 0;
      }
    }
    for (let i3 = 0;i3 < geometry.buffers.length; i3++) {
      arrays[i3] = new map3[getBufferType(geometry.buffers[i3].data)](sizes[i3]);
      geometryOut.buffers[i3] = new Buffer(arrays[i3]);
    }
    for (let i3 = 0;i3 < geometries.length; i3++) {
      geometry = geometries[i3];
      for (let j3 = 0;j3 < geometry.buffers.length; j3++) {
        arrays[j3].set(geometry.buffers[j3].data, offsets[j3]);
        offsets[j3] += geometry.buffers[j3].data.length;
      }
    }
    geometryOut.attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
      geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      let offset = 0;
      let stride = 0;
      let offset2 = 0;
      let bufferIndexToCount = 0;
      for (let i3 = 0;i3 < geometry.buffers.length; i3++) {
        if (geometry.buffers[i3] !== geometry.indexBuffer) {
          bufferIndexToCount = i3;
          break;
        }
      }
      for (const i3 in geometry.attributes) {
        const attribute = geometry.attributes[i3];
        if ((attribute.buffer | 0) === bufferIndexToCount) {
          stride += attribute.size * byteSizeMap[attribute.type] / 4;
        }
      }
      for (let i3 = 0;i3 < geometries.length; i3++) {
        const indexBufferData = geometries[i3].indexBuffer.data;
        for (let j3 = 0;j3 < indexBufferData.length; j3++) {
          geometryOut.indexBuffer.data[j3 + offset2] += offset;
        }
        offset += geometries[i3].buffers[bufferIndexToCount].data.length / stride;
        offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle
class BatchGeometry extends Geometry {
  constructor(_static = false) {
    super();
    this._buffer = new Buffer(null, _static, false);
    this._indexBuffer = new Buffer(null, _static, true);
    this.addAttribute("aVertexPosition", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, TYPES.FLOAT).addIndex(this._indexBuffer);
  }
}

// node_modules/colord/plugins/names.mjs
var PI_2 = Math.PI * 2;
var RAD_TO_DEG = 180 / Math.PI;
var DEG_TO_RAD = Math.PI / 180;
var SHAPES = ((SHAPES2) => {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
  return SHAPES2;
})(SHAPES || {});

// node_modules/colord/plugins/names.mjs
class Point3 {
  constructor(x3 = 0, y3 = 0) {
    this.x = 0;
    this.y = 0;
    this.x = x3;
    this.y = y3;
  }
  clone() {
    return new Point3(this.x, this.y);
  }
  copyFrom(p3) {
    this.set(p3.x, p3.y);
    return this;
  }
  copyTo(p3) {
    p3.set(this.x, this.y);
    return p3;
  }
  equals(p3) {
    return p3.x === this.x && p3.y === this.y;
  }
  set(x3 = 0, y3 = x3) {
    this.x = x3;
    this.y = y3;
    return this;
  }
  toString() {
    return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjs
var tempPoints = [new Point3, new Point3, new Point3, new Point3];

class Rectangle {
  constructor(x3 = 0, y3 = 0, width = 0, height = 0) {
    this.x = Number(x3);
    this.y = Number(y3);
    this.width = Number(width);
    this.height = Number(height);
    this.type = SHAPES.RECT;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  copyTo(rectangle) {
    rectangle.x = this.x;
    rectangle.y = this.y;
    rectangle.width = this.width;
    rectangle.height = this.height;
    return rectangle;
  }
  contains(x3, y3) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x3 >= this.x && x3 < this.x + this.width) {
      if (y3 >= this.y && y3 < this.y + this.height) {
        return true;
      }
    }
    return false;
  }
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      const x12 = this.right > other.right ? other.right : this.right;
      if (x12 <= x02) {
        return false;
      }
      const y02 = this.y < other.y ? other.y : this.y;
      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y12 > y02;
    }
    const x0 = this.left;
    const x1 = this.right;
    const y0 = this.top;
    const y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    const lt = tempPoints[0].set(other.left, other.top);
    const lb = tempPoints[1].set(other.left, other.bottom);
    const rt2 = tempPoints[2].set(other.right, other.top);
    const rb = tempPoints[3].set(other.right, other.bottom);
    if (rt2.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    const s3 = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s3 === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt2, rt2);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt2.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt2.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt2.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt2.y, rb.y) >= y1) {
      return false;
    }
    const nx = s3 * (lb.y - lt.y);
    const ny = s3 * (lt.x - lb.x);
    const n00 = nx * x0 + ny * y0;
    const n10 = nx * x1 + ny * y0;
    const n01 = nx * x0 + ny * y1;
    const n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    const mx = s3 * (lt.y - rt2.y);
    const my = s3 * (rt2.x - lt.x);
    const m00 = mx * x0 + my * y0;
    const m10 = mx * x1 + my * y0;
    const m01 = mx * x0 + my * y1;
    const m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  }
  pad(paddingX = 0, paddingY = paddingX) {
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  }
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x);
    const x22 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.max(this.y, rectangle.y);
    const y22 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x22 - x1, 0);
    this.y = y1;
    this.height = Math.max(y22 - y1, 0);
    return this;
  }
  ceil(resolution = 1, eps = 0.001) {
    const x22 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    const y22 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x22 - this.x;
    this.height = y22 - this.y;
    return this;
  }
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x);
    const x22 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.min(this.y, rectangle.y);
    const y22 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x22 - x1;
    this.y = y1;
    this.height = y22 - y1;
    return this;
  }
  toString() {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}

// node_modules/colord/plugins/names.mjsistener.
class Circle2 {
  constructor(x3 = 0, y3 = 0, radius = 0) {
    this.x = x3;
    this.y = y3;
    this.radius = radius;
    this.type = SHAPES.CIRC;
  }
  clone() {
    return new Circle2(this.x, this.y, this.radius);
  }
  contains(x3, y3) {
    if (this.radius <= 0) {
      return false;
    }
    const r22 = this.radius * this.radius;
    let dx = this.x - x3;
    let dy = this.y - y3;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r22;
  }
  getBounds() {
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
  toString() {
    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}
// node_modules/colord/plugins/names.mjsistener.m
class Ellipse {
  constructor(x3 = 0, y3 = 0, halfWidth = 0, halfHeight = 0) {
    this.x = x3;
    this.y = y3;
    this.width = halfWidth;
    this.height = halfHeight;
    this.type = SHAPES.ELIP;
  }
  clone() {
    return new Ellipse(this.x, this.y, this.width, this.height);
  }
  contains(x3, y3) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    let normx = (x3 - this.x) / this.width;
    let normy = (y3 - this.y) / this.height;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  }
  getBounds() {
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  }
  toString() {
    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}
// node_modules/colord/plugins/names.mjsistener.m
class Polygon {
  constructor(...points2) {
    let flat = Array.isArray(points2[0]) ? points2[0] : points2;
    if (typeof flat[0] !== "number") {
      const p3 = [];
      for (let i3 = 0, il = flat.length;i3 < il; i3++) {
        p3.push(flat[i3].x, flat[i3].y);
      }
      flat = p3;
    }
    this.points = flat;
    this.type = SHAPES.POLY;
    this.closeStroke = true;
  }
  clone() {
    const points2 = this.points.slice();
    const polygon = new Polygon(points2);
    polygon.closeStroke = this.closeStroke;
    return polygon;
  }
  contains(x3, y3) {
    let inside = false;
    const length2 = this.points.length / 2;
    for (let i3 = 0, j3 = length2 - 1;i3 < length2; j3 = i3++) {
      const xi = this.points[i3 * 2];
      const yi = this.points[i3 * 2 + 1];
      const xj = this.points[j3 * 2];
      const yj = this.points[j3 * 2 + 1];
      const intersect2 = yi > y3 !== yj > y3 && x3 < (xj - xi) * ((y3 - yi) / (yj - yi)) + xi;
      if (intersect2) {
        inside = !inside;
      }
    }
    return inside;
  }
  toString() {
    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
class RoundedRectangle {
  constructor(x3 = 0, y3 = 0, width = 0, height = 0, radius = 20) {
    this.x = x3;
    this.y = y3;
    this.width = width;
    this.height = height;
    this.radius = radius;
    this.type = SHAPES.RREC;
  }
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  contains(x3, y3) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x3 >= this.x && x3 <= this.x + this.width) {
      if (y3 >= this.y && y3 <= this.y + this.height) {
        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y3 >= this.y + radius && y3 <= this.y + this.height - radius || x3 >= this.x + radius && x3 <= this.x + this.width - radius) {
          return true;
        }
        let dx = x3 - (this.x + radius);
        let dy = y3 - (this.y + radius);
        const radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x3 - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y3 - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x3 - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  }
  toString() {
    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}
// node_modules/colord/plugins/names.mjsi
class Matrix {
  constructor(a3 = 1, b3 = 0, c3 = 0, d3 = 1, tx = 0, ty = 0) {
    this.array = null;
    this.a = a3;
    this.b = b3;
    this.c = c3;
    this.d = d3;
    this.tx = tx;
    this.ty = ty;
  }
  fromArray(array) {
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
  }
  set(a3, b3, c3, d3, tx, ty) {
    this.a = a3;
    this.b = b3;
    this.c = c3;
    this.d = d3;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  toArray(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    const array = out || this.array;
    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  }
  apply(pos, newPos) {
    newPos = newPos || new Point3;
    const x3 = pos.x;
    const y3 = pos.y;
    newPos.x = this.a * x3 + this.c * y3 + this.tx;
    newPos.y = this.b * x3 + this.d * y3 + this.ty;
    return newPos;
  }
  applyInverse(pos, newPos) {
    newPos = newPos || new Point3;
    const id = 1 / (this.a * this.d + this.c * -this.b);
    const x3 = pos.x;
    const y3 = pos.y;
    newPos.x = this.d * id * x3 + -this.c * id * y3 + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y3 + -this.b * id * x3 + (-this.ty * this.a + this.tx * this.b) * id;
    return newPos;
  }
  translate(x3, y3) {
    this.tx += x3;
    this.ty += y3;
    return this;
  }
  scale(x3, y3) {
    this.a *= x3;
    this.d *= y3;
    this.c *= x3;
    this.b *= y3;
    this.tx *= x3;
    this.ty *= y3;
    return this;
  }
  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const a1 = this.a;
    const c1 = this.c;
    const tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  }
  append(matrix) {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  }
  setTransform(x3, y3, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x3 - (pivotX * this.a + pivotY * this.c);
    this.ty = y3 - (pivotX * this.b + pivotY * this.d);
    return this;
  }
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a;
      const c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  }
  decompose(transform) {
    const a3 = this.a;
    const b3 = this.b;
    const c3 = this.c;
    const d3 = this.d;
    const pivot = transform.pivot;
    const skewX = -Math.atan2(-c3, d3);
    const skewY = Math.atan2(b3, a3);
    const delta = Math.abs(skewX + skewY);
    if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a3 * a3 + b3 * b3);
    transform.scale.y = Math.sqrt(c3 * c3 + d3 * d3);
    transform.position.x = this.tx + (pivot.x * a3 + pivot.y * c3);
    transform.position.y = this.ty + (pivot.x * b3 + pivot.y * d3);
    return transform;
  }
  invert() {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    const tx1 = this.tx;
    const n4 = a1 * d1 - b1 * c1;
    this.a = d1 / n4;
    this.b = -b1 / n4;
    this.c = -c1 / n4;
    this.d = a1 / n4;
    this.tx = (c1 * this.ty - d1 * tx1) / n4;
    this.ty = -(a1 * this.ty - b1 * tx1) / n4;
    return this;
  }
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  }
  clone() {
    const matrix = new Matrix;
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyTo(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyFrom(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  }
  toString() {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  static get IDENTITY() {
    return new Matrix;
  }
  static get TEMP_MATRIX() {
    return new Matrix;
  }
}

// node_modules/colord/plugins/names.mjsis
var init = function() {
  for (let i3 = 0;i3 < 16; i3++) {
    const row = [];
    rotationCayley.push(row);
    for (let j3 = 0;j3 < 16; j3++) {
      const _ux = signum(ux[i3] * ux[j3] + vx[i3] * uy[j3]);
      const _uy = signum(uy[i3] * ux[j3] + vy[i3] * uy[j3]);
      const _vx = signum(ux[i3] * vx[j3] + vx[i3] * vy[j3]);
      const _vy = signum(uy[i3] * vx[j3] + vy[i3] * vy[j3]);
      for (let k4 = 0;k4 < 16; k4++) {
        if (ux[k4] === _ux && uy[k4] === _uy && vx[k4] === _vx && vy[k4] === _vy) {
          row.push(k4);
          break;
        }
      }
    }
  }
  for (let i3 = 0;i3 < 16; i3++) {
    const mat = new Matrix;
    mat.set(ux[i3], uy[i3], vx[i3], vy[i3], 0, 0);
    rotationMatrices.push(mat);
  }
};
var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
var rotationCayley = [];
var rotationMatrices = [];
var signum = Math.sign;
init();
var groupD8 = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: (ind) => ux[ind],
  uY: (ind) => uy[ind],
  vX: (ind) => vx[ind],
  vY: (ind) => vy[ind],
  inv: (rotation) => {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
  rotate180: (rotation) => rotation ^ 4,
  isVertical: (rotation) => (rotation & 3) === 2,
  byDirection: (dx, dy) => {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
    const mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};
// node_modules/colord/plugins/names.mjsistener.mj
class ObservablePoint {
  constructor(cb, scope, x3 = 0, y3 = 0) {
    this._x = x3;
    this._y = y3;
    this.cb = cb;
    this.scope = scope;
  }
  clone(cb = this.cb, scope = this.scope) {
    return new ObservablePoint(cb, scope, this._x, this._y);
  }
  set(x3 = 0, y3 = x3) {
    if (this._x !== x3 || this._y !== y3) {
      this._x = x3;
      this._y = y3;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyFrom(p3) {
    if (this._x !== p3.x || this._y !== p3.y) {
      this._x = p3.x;
      this._y = p3.y;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyTo(p3) {
    p3.set(this._x, this._y);
    return p3;
  }
  equals(p3) {
    return p3.x === this._x && p3.y === this._y;
  }
  toString() {
    return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    if (this._x !== value) {
      this._x = value;
      this.cb.call(this.scope);
    }
  }
  get y() {
    return this._y;
  }
  set y(value) {
    if (this._y !== value) {
      this._y = value;
      this.cb.call(this.scope);
    }
  }
}
// node_modules/colord/plugins/names.mjsiste
var _Transform = class {
  constructor() {
    this.worldTransform = new Matrix;
    this.localTransform = new Matrix;
    this.position = new ObservablePoint(this.onChange, this, 0, 0);
    this.scale = new ObservablePoint(this.onChange, this, 1, 1);
    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
    this._localID = 0;
    this._currentLocalID = 0;
    this._worldID = 0;
    this._parentID = 0;
  }
  onChange() {
    this._localID++;
  }
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this._localID++;
  }
  toString() {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  updateLocalTransform() {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
  }
  updateTransform(parentTransform) {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
    if (this._parentID !== parentTransform._worldID) {
      const pt = parentTransform.worldTransform;
      const wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c;
      wt.b = lt.a * pt.b + lt.b * pt.d;
      wt.c = lt.c * pt.a + lt.d * pt.c;
      wt.d = lt.c * pt.b + lt.d * pt.d;
      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
      this._parentID = parentTransform._worldID;
      this._worldID++;
    }
  }
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this._localID++;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this.updateSkew();
    }
  }
};
var Transform = _Transform;
Transform.IDENTITY = new _Transform;
// node_modules/colord/plugins/names.mjsistener.mjsgle.m
var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mj
var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.
var compileShader = function(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
var booleanArray = function(size) {
  const array = new Array(size);
  for (let i3 = 0;i3 < array.length; i3++) {
    array[i3] = false;
  }
  return array;
};
var defaultValue = function(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
var uniformParsers = [
  {
    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
    code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
  },
  {
    test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== undefined),
    code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
  },
  {
    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== undefined,
    code: (name) => `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `,
    codeUbo: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];
        
                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];
        
                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
  },
  {
    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== undefined,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`,
    codeUbo: (name) => `
                v = uv.${name};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
  },
  {
    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== undefined,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== undefined,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
  },
  {
    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== undefined,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
  },
  {
    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
  }
];

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsText
var generateUniformsSync = function(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i3 in group.uniforms) {
    const data = uniformData[i3];
    if (!data) {
      if (group.uniforms[i3]?.group) {
        if (group.uniforms[i3].ubo) {
          funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i3}, '${i3}');
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i3}, syncData);
                    `);
        }
      }
      continue;
    }
    const uniform = group.uniforms[i3];
    let parsed = false;
    for (let j3 = 0;j3 < uniformParsers.length; j3++) {
      if (uniformParsers[j3].test(data, uniform)) {
        funcFragments.push(uniformParsers[j3].code(i3, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      const template = templateType[data.type].replace("location", `ud["${i3}"].location`);
      funcFragments.push(`
            cu = ud["${i3}"];
            cv = cu.value;
            v = uv["${i3}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
};
var GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
};
var GLSL_TO_ARRAY_SETTERS = {
  float: `gl.uniform1fv(location, v)`,
  vec2: `gl.uniform2fv(location, v)`,
  vec3: `gl.uniform3fv(location, v)`,
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
var getTestContext = function() {
  if (context === unknownContext || context?.isContextLost()) {
    const canvas = settings.ADAPTER.createCanvas();
    let gl;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
};
var unknownContext = {};
var context = unknownContext;

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTexture
var getMaxFragmentPrecision = function() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION.MEDIUM;
    const gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
};
var maxFragmentPrecision;
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mj
var logPrettyShaderError = function(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index2) => `${index2}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n4) => {
    if (n4 && !dedupe[n4]) {
      dedupe[n4] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
};
var logProgramError = function(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.
var mapSize = function(type) {
  return GLSL_TO_SIZE[type];
};
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.
var mapType = function(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i3 = 0;i3 < typeNames.length; ++i3) {
      const tn = typeNames[i3];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
};
var GL_TABLE = null;
var GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
var setPrecision = function(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    let precision = requestedPrecision;
    if (requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH) {
      precision = PRECISION.MEDIUM;
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTex
var unsafeEvalSupported = function() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e3) {
    unsafeEval = false;
  }
  return unsafeEval;
};
var unsafeEval;
// node_modules/colord/plugins/names.mjsistener.m
var UID3 = 0;
var nameCache = {};
var _Program = class {
  constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {
    this.extra = {};
    this.id = UID3++;
    this.vertexSrc = vertexSrc || _Program.defaultVertexSrc;
    this.fragmentSrc = fragmentSrc || _Program.defaultFragmentSrc;
    this.vertexSrc = this.vertexSrc.trim();
    this.fragmentSrc = this.fragmentSrc.trim();
    this.extra = extra;
    if (this.vertexSrc.substring(0, 8) !== "#version") {
      name = name.replace(/\s+/g, "-");
      if (nameCache[name]) {
        nameCache[name]++;
        name += `-${nameCache[name]}`;
      } else {
        nameCache[name] = 1;
      }
      this.vertexSrc = `#define SHADER_NAME ${name}
${this.vertexSrc}`;
      this.fragmentSrc = `#define SHADER_NAME ${name}
${this.fragmentSrc}`;
      this.vertexSrc = setPrecision(this.vertexSrc, _Program.defaultVertexPrecision, PRECISION.HIGH);
      this.fragmentSrc = setPrecision(this.fragmentSrc, _Program.defaultFragmentPrecision, getMaxFragmentPrecision());
    }
    this.glPrograms = {};
    this.syncUniforms = null;
  }
  static get defaultVertexSrc() {
    return defaultVertex;
  }
  static get defaultFragmentSrc() {
    return defaultFragment;
  }
  static from(vertexSrc, fragmentSrc, name) {
    const key = vertexSrc + fragmentSrc;
    let program = ProgramCache[key];
    if (!program) {
      ProgramCache[key] = program = new _Program(vertexSrc, fragmentSrc, name);
    }
    return program;
  }
};
var Program = _Program;
Program.defaultVertexPrecision = PRECISION.HIGH;
Program.defaultFragmentPrecision = isMobile3.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM;

// node_modules/colord/plugins/names.mjsistener.mjsgle
var UID4 = 0;

class UniformGroup {
  constructor(uniforms, isStatic, isUbo) {
    this.group = true;
    this.syncUniforms = {};
    this.dirtyId = 0;
    this.id = UID4++;
    this.static = !!isStatic;
    this.ubo = !!isUbo;
    if (uniforms instanceof Buffer) {
      this.buffer = uniforms;
      this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
      this.autoManage = false;
      this.ubo = true;
    } else {
      this.uniforms = uniforms;
      if (this.ubo) {
        this.buffer = new Buffer(new Float32Array(1));
        this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
        this.autoManage = true;
      }
    }
  }
  update() {
    this.dirtyId++;
    if (!this.autoManage && this.buffer) {
      this.buffer.update();
    }
  }
  add(name, uniforms, _static) {
    if (!this.ubo) {
      this.uniforms[name] = new UniformGroup(uniforms, _static);
    } else {
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }
  }
  static from(uniforms, _static, _ubo) {
    return new UniformGroup(uniforms, _static, _ubo);
  }
  static uboFrom(uniforms, _static) {
    return new UniformGroup(uniforms, _static ?? true, true);
  }
}

// node_modules/colord/plugins/names.mjsistener.
class Shader {
  constructor(program, uniforms) {
    this.uniformBindCount = 0;
    this.program = program;
    if (uniforms) {
      if (uniforms instanceof UniformGroup) {
        this.uniformGroup = uniforms;
      } else {
        this.uniformGroup = new UniformGroup(uniforms);
      }
    } else {
      this.uniformGroup = new UniformGroup({});
    }
    this.disposeRunner = new Runner("disposeShader");
  }
  checkUniformExists(name, group) {
    if (group.uniforms[name]) {
      return true;
    }
    for (const i3 in group.uniforms) {
      const uniform = group.uniforms[i3];
      if (uniform.group) {
        if (this.checkUniformExists(name, uniform)) {
          return true;
        }
      }
    }
    return false;
  }
  destroy() {
    this.uniformGroup = null;
    this.disposeRunner.emit(this);
    this.disposeRunner.destroy();
  }
  get uniforms() {
    return this.uniformGroup.uniforms;
  }
  static from(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.from(vertexSrc, fragmentSrc);
    return new Shader(program, uniforms);
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.
class BatchShaderGenerator {
  constructor(vertexSrc, fragTemplate2) {
    this.vertexSrc = vertexSrc;
    this.fragTemplate = fragTemplate2;
    this.programCache = {};
    this.defaultGroupCache = {};
    if (!fragTemplate2.includes("%count%")) {
      throw new Error('Fragment template must contain "%count%".');
    }
    if (!fragTemplate2.includes("%forloop%")) {
      throw new Error('Fragment template must contain "%forloop%".');
    }
  }
  generateShader(maxTextures) {
    if (!this.programCache[maxTextures]) {
      const sampleValues = new Int32Array(maxTextures);
      for (let i3 = 0;i3 < maxTextures; i3++) {
        sampleValues[i3] = i3;
      }
      this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
      let fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);
      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
    }
    const uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix,
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader(this.programCache[maxTextures], uniforms);
  }
  generateSampleSrc(maxTextures) {
    let src = "";
    src += "\n";
    src += "\n";
    for (let i3 = 0;i3 < maxTextures; i3++) {
      if (i3 > 0) {
        src += "\nelse ";
      }
      if (i3 < maxTextures - 1) {
        src += `if(vTextureId < ${i3}.5)`;
      }
      src += "\n{";
      src += `
	color = texture2D(uSamplers[${i3}], vTextureCoord);`;
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
class BatchTextureArray {
  constructor() {
    this.elements = [];
    this.ids = [];
    this.count = 0;
  }
  clear() {
    for (let i3 = 0;i3 < this.count; i3++) {
      this.elements[i3] = null;
    }
    this.count = 0;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
var canUploadSameBuffer = function() {
  return !isMobile3.apple.device;
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mj
var maxRecommendedTextures = function(max) {
  let allowMax = true;
  const navigator2 = settings.ADAPTER.getNavigator();
  if (isMobile3.tablet || isMobile3.phone) {
    if (isMobile3.apple.device) {
      const match = navigator2.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile3.android.device) {
      const match = navigator2.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max : 4;
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.
class ObjectRenderer {
  constructor(renderer) {
    this.renderer = renderer;
  }
  flush() {
  }
  destroy() {
    this.renderer = null;
  }
  start() {
  }
  stop() {
    this.flush();
  }
  render(_object) {
  }
}

// node_modules/colord/plugins/names.mjsistener.
var defaultFragment2 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";

// node_modules/colord/plugins/names.mjsistener.m
var defaultVertex2 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle
var _BatchRenderer = class extends ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    this.setShaderGenerator();
    this.geometryClass = BatchGeometry;
    this.vertexSize = 6;
    this.state = State.for2d();
    this.size = _BatchRenderer.defaultBatchSize * 4;
    this._vertexCount = 0;
    this._indexCount = 0;
    this._bufferedElements = [];
    this._bufferedTextures = [];
    this._bufferSize = 0;
    this._shader = null;
    this._packedGeometries = [];
    this._packedGeometryPoolSize = 2;
    this._flushId = 0;
    this._aBuffers = {};
    this._iBuffers = {};
    this.maxTextures = 1;
    this.renderer.on("prerender", this.onPrerender, this);
    renderer.runners.contextChange.add(this);
    this._dcIndex = 0;
    this._aIndex = 0;
    this._iIndex = 0;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    this._tempBoundTextures = [];
  }
  static get defaultMaxTextures() {
    this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32);
    return this._defaultMaxTextures;
  }
  static set defaultMaxTextures(value) {
    this._defaultMaxTextures = value;
  }
  static get canUploadSameBuffer() {
    this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer();
    return this._canUploadSameBuffer;
  }
  static set canUploadSameBuffer(value) {
    this._canUploadSameBuffer = value;
  }
  get MAX_TEXTURES() {
    deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures");
    return this.maxTextures;
  }
  static get defaultVertexSrc() {
    return defaultVertex2;
  }
  static get defaultFragmentTemplate() {
    return defaultFragment2;
  }
  setShaderGenerator({
    vertex = _BatchRenderer.defaultVertexSrc,
    fragment = _BatchRenderer.defaultFragmentTemplate
  } = {}) {
    this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);
  }
  contextChange() {
    const gl = this.renderer.gl;
    if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
      this.maxTextures = 1;
    } else {
      this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _BatchRenderer.defaultMaxTextures);
      this.maxTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);
    }
    this._shader = this.shaderGenerator.generateShader(this.maxTextures);
    for (let i3 = 0;i3 < this._packedGeometryPoolSize; i3++) {
      this._packedGeometries[i3] = new this.geometryClass;
    }
    this.initFlushBuffers();
  }
  initFlushBuffers() {
    const {
      _drawCallPool,
      _textureArrayPool
    } = _BatchRenderer;
    const MAX_SPRITES = this.size / 4;
    const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
    while (_drawCallPool.length < MAX_SPRITES) {
      _drawCallPool.push(new BatchDrawCall);
    }
    while (_textureArrayPool.length < MAX_TA) {
      _textureArrayPool.push(new BatchTextureArray);
    }
    for (let i3 = 0;i3 < this.maxTextures; i3++) {
      this._tempBoundTextures[i3] = null;
    }
  }
  onPrerender() {
    this._flushId = 0;
  }
  render(element) {
    if (!element._texture.valid) {
      return;
    }
    if (this._vertexCount + element.vertexData.length / 2 > this.size) {
      this.flush();
    }
    this._vertexCount += element.vertexData.length / 2;
    this._indexCount += element.indices.length;
    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
    this._bufferedElements[this._bufferSize++] = element;
  }
  buildTexturesAndDrawCalls() {
    const {
      _bufferedTextures: textures,
      maxTextures
    } = this;
    const textureArrays = _BatchRenderer._textureArrayPool;
    const batch = this.renderer.batch;
    const boundTextures = this._tempBoundTextures;
    const touch = this.renderer.textureGC.count;
    let TICK = ++BaseTexture._globalBatch;
    let countTexArrays = 0;
    let texArray = textureArrays[0];
    let start = 0;
    batch.copyBoundTextures(boundTextures, maxTextures);
    for (let i3 = 0;i3 < this._bufferSize; ++i3) {
      const tex = textures[i3];
      textures[i3] = null;
      if (tex._batchEnabled === TICK) {
        continue;
      }
      if (texArray.count >= maxTextures) {
        batch.boundArray(texArray, boundTextures, TICK, maxTextures);
        this.buildDrawCalls(texArray, start, i3);
        start = i3;
        texArray = textureArrays[++countTexArrays];
        ++TICK;
      }
      tex._batchEnabled = TICK;
      tex.touched = touch;
      texArray.elements[texArray.count++] = tex;
    }
    if (texArray.count > 0) {
      batch.boundArray(texArray, boundTextures, TICK, maxTextures);
      this.buildDrawCalls(texArray, start, this._bufferSize);
      ++countTexArrays;
      ++TICK;
    }
    for (let i3 = 0;i3 < boundTextures.length; i3++) {
      boundTextures[i3] = null;
    }
    BaseTexture._globalBatch = TICK;
  }
  buildDrawCalls(texArray, start, finish) {
    const {
      _bufferedElements: elements,
      _attributeBuffer,
      _indexBuffer,
      vertexSize
    } = this;
    const drawCalls = _BatchRenderer._drawCallPool;
    let dcIndex = this._dcIndex;
    let aIndex = this._aIndex;
    let iIndex = this._iIndex;
    let drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex;
    drawCall.texArray = texArray;
    for (let i3 = start;i3 < finish; ++i3) {
      const sprite = elements[i3];
      const tex = sprite._texture.baseTexture;
      const spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i3] = null;
      if (start < i3 && drawCall.blend !== spriteBlendMode) {
        drawCall.size = iIndex - drawCall.start;
        start = i3;
        drawCall = drawCalls[++dcIndex];
        drawCall.texArray = texArray;
        drawCall.start = iIndex;
      }
      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
      aIndex += sprite.vertexData.length / 2 * vertexSize;
      iIndex += sprite.indices.length;
      drawCall.blend = spriteBlendMode;
    }
    if (start < finish) {
      drawCall.size = iIndex - drawCall.start;
      ++dcIndex;
    }
    this._dcIndex = dcIndex;
    this._aIndex = aIndex;
    this._iIndex = iIndex;
  }
  bindAndClearTexArray(texArray) {
    const textureSystem = this.renderer.texture;
    for (let j3 = 0;j3 < texArray.count; j3++) {
      textureSystem.bind(texArray.elements[j3], texArray.ids[j3]);
      texArray.elements[j3] = null;
    }
    texArray.count = 0;
  }
  updateGeometry() {
    const {
      _packedGeometries: packedGeometries,
      _attributeBuffer: attributeBuffer,
      _indexBuffer: indexBuffer
    } = this;
    if (!_BatchRenderer.canUploadSameBuffer) {
      if (this._packedGeometryPoolSize <= this._flushId) {
        this._packedGeometryPoolSize++;
        packedGeometries[this._flushId] = new this.geometryClass;
      }
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.bind(packedGeometries[this._flushId]);
      this.renderer.geometry.updateBuffers();
      this._flushId++;
    } else {
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.updateBuffers();
    }
  }
  drawBatches() {
    const dcCount = this._dcIndex;
    const { gl, state: stateSystem } = this.renderer;
    const drawCalls = _BatchRenderer._drawCallPool;
    let curTexArray = null;
    for (let i3 = 0;i3 < dcCount; i3++) {
      const { texArray, type, size, start, blend } = drawCalls[i3];
      if (curTexArray !== texArray) {
        curTexArray = texArray;
        this.bindAndClearTexArray(texArray);
      }
      this.state.blendMode = blend;
      stateSystem.set(this.state);
      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
    }
  }
  flush() {
    if (this._vertexCount === 0) {
      return;
    }
    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
    this._indexBuffer = this.getIndexBuffer(this._indexCount);
    this._aIndex = 0;
    this._iIndex = 0;
    this._dcIndex = 0;
    this.buildTexturesAndDrawCalls();
    this.updateGeometry();
    this.drawBatches();
    this._bufferSize = 0;
    this._vertexCount = 0;
    this._indexCount = 0;
  }
  start() {
    this.renderer.state.set(this.state);
    this.renderer.texture.ensureSamplerType(this.maxTextures);
    this.renderer.shader.bind(this._shader);
    if (_BatchRenderer.canUploadSameBuffer) {
      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
  }
  stop() {
    this.flush();
  }
  destroy() {
    for (let i3 = 0;i3 < this._packedGeometryPoolSize; i3++) {
      if (this._packedGeometries[i3]) {
        this._packedGeometries[i3].destroy();
      }
    }
    this.renderer.off("prerender", this.onPrerender, this);
    this._aBuffers = null;
    this._iBuffers = null;
    this._packedGeometries = null;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    if (this._shader) {
      this._shader.destroy();
      this._shader = null;
    }
    super.destroy();
  }
  getAttributeBuffer(size) {
    const roundedP2 = nextPow2(Math.ceil(size / 8));
    const roundedSizeIndex = log2(roundedP2);
    const roundedSize = roundedP2 * 8;
    if (this._aBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer = this._aBuffers[roundedSize];
    if (!buffer) {
      this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
    }
    return buffer;
  }
  getIndexBuffer(size) {
    const roundedP2 = nextPow2(Math.ceil(size / 12));
    const roundedSizeIndex = log2(roundedP2);
    const roundedSize = roundedP2 * 12;
    if (this._iBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer = this._iBuffers[roundedSizeIndex];
    if (!buffer) {
      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
    }
    return buffer;
  }
  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    const {
      uint32View,
      float32View
    } = attributeBuffer;
    const packedVertices = aIndex / this.vertexSize;
    const uvs = element.uvs;
    const indicies = element.indices;
    const vertexData = element.vertexData;
    const textureId = element._texture.baseTexture._batchLocation;
    const alpha = Math.min(element.worldAlpha, 1);
    const argb = Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);
    for (let i3 = 0;i3 < vertexData.length; i3 += 2) {
      float32View[aIndex++] = vertexData[i3];
      float32View[aIndex++] = vertexData[i3 + 1];
      float32View[aIndex++] = uvs[i3];
      float32View[aIndex++] = uvs[i3 + 1];
      uint32View[aIndex++] = argb;
      float32View[aIndex++] = textureId;
    }
    for (let i3 = 0;i3 < indicies.length; i3++) {
      indexBuffer[iIndex++] = packedVertices + indicies[i3];
    }
  }
};
var BatchRenderer = _BatchRenderer;
BatchRenderer.defaultBatchSize = 4096;
BatchRenderer.extension = {
  name: "batch",
  type: ExtensionType.RendererPlugin
};
BatchRenderer._drawCallPool = [];
BatchRenderer._textureArrayPool = [];
extensions.add(BatchRenderer);

// node_modules/colord/plugins/names.mjsistener.mjsgle.m
var defaultFragment3 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mj
var defaultVertex3 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

// node_modules/colord/plugins/names.mjsistener.m
var _Filter = class extends Shader {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.from(vertexSrc || _Filter.defaultVertexSrc, fragmentSrc || _Filter.defaultFragmentSrc);
    super(program, uniforms);
    this.padding = 0;
    this.resolution = _Filter.defaultResolution;
    this.multisample = _Filter.defaultMultisample;
    this.enabled = true;
    this.autoFit = true;
    this.state = new State;
  }
  apply(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._resolution = value;
  }
  static get defaultVertexSrc() {
    return defaultVertex3;
  }
  static get defaultFragmentSrc() {
    return defaultFragment3;
  }
};
var Filter = _Filter;
Filter.defaultResolution = 1;
Filter.defaultMultisample = MSAA_QUALITY.NONE;

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
class BackgroundSystem {
  constructor() {
    this.clearBeforeRender = true;
    this._backgroundColor = new Color(0);
    this.alpha = 1;
  }
  init(options) {
    this.clearBeforeRender = options.clearBeforeRender;
    const { backgroundColor, background, backgroundAlpha } = options;
    const color5 = background ?? backgroundColor;
    if (color5 !== undefined) {
      this.color = color5;
    }
    this.alpha = backgroundAlpha;
  }
  get color() {
    return this._backgroundColor.value;
  }
  set color(value) {
    this._backgroundColor.setValue(value);
  }
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value) {
    this._backgroundColor.setAlpha(value);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  destroy() {
  }
}
BackgroundSystem.defaultOptions = {
  backgroundAlpha: 1,
  backgroundColor: 0,
  clearBeforeRender: true
};
BackgroundSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "background"
};
extensions.add(BackgroundSystem);
// node_modules/colord/plugins/names.mjsistener.mjsg
class BatchSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.emptyRenderer = new ObjectRenderer(renderer);
    this.currentRenderer = this.emptyRenderer;
  }
  setObjectRenderer(objectRenderer) {
    if (this.currentRenderer === objectRenderer) {
      return;
    }
    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
  }
  flush() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  reset() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  copyBoundTextures(arr, maxTextures) {
    const { boundTextures } = this.renderer.texture;
    for (let i3 = maxTextures - 1;i3 >= 0; --i3) {
      arr[i3] = boundTextures[i3] || null;
      if (arr[i3]) {
        arr[i3]._batchLocation = i3;
      }
    }
  }
  boundArray(texArray, boundTextures, batchId, maxTextures) {
    const { elements, ids, count } = texArray;
    let j3 = 0;
    for (let i3 = 0;i3 < count; i3++) {
      const tex = elements[i3];
      const loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i3] = loc;
        continue;
      }
      while (j3 < maxTextures) {
        const bound = boundTextures[j3];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j3) {
          j3++;
          continue;
        }
        ids[i3] = j3;
        tex._batchLocation = j3;
        boundTextures[j3] = tex;
        break;
      }
    }
  }
  destroy() {
    this.renderer = null;
  }
}
BatchSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "batch"
};
extensions.add(BatchSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.m
var CONTEXT_UID_COUNTER = 0;

class ContextSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.webGLVersion = 1;
    this.extensions = {};
    this.supports = {
      uint32Indices: false
    };
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  contextChange(gl) {
    this.gl = gl;
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
  }
  init(options) {
    if (options.context) {
      this.initFromContext(options.context);
    } else {
      const alpha = this.renderer.background.alpha < 1;
      const premultipliedAlpha = options.premultipliedAlpha;
      this.preserveDrawingBuffer = options.preserveDrawingBuffer;
      this.useContextAlpha = options.useContextAlpha;
      this.powerPreference = options.powerPreference;
      this.initFromOptions({
        alpha,
        premultipliedAlpha,
        antialias: options.antialias,
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: options.powerPreference
      });
    }
  }
  initFromContext(gl) {
    this.gl = gl;
    this.validateContext(gl);
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    this.renderer.runners.contextChange.emit(gl);
    const view = this.renderer.view;
    if (view.addEventListener !== undefined) {
      view.addEventListener("webglcontextlost", this.handleContextLost, false);
      view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
  }
  initFromOptions(options) {
    const gl = this.createContext(this.renderer.view, options);
    this.initFromContext(gl);
  }
  createContext(canvas, options) {
    let gl;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", options);
    }
    if (gl) {
      this.webGLVersion = 2;
    } else {
      this.webGLVersion = 1;
      gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.getExtensions();
    return this.gl;
  }
  getExtensions() {
    const { gl } = this;
    const common = {
      loseContext: gl.getExtension("WEBGL_lose_context"),
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    if (this.webGLVersion === 1) {
      Object.assign(this.extensions, common, {
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
      });
    } else if (this.webGLVersion === 2) {
      Object.assign(this.extensions, common, {
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      });
    }
  }
  handleContextLost(event) {
    event.preventDefault();
    setTimeout(() => {
      if (this.gl.isContextLost() && this.extensions.loseContext) {
        this.extensions.loseContext.restoreContext();
      }
    }, 0);
  }
  handleContextRestored() {
    this.renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const view = this.renderer.view;
    this.renderer = null;
    if (view.removeEventListener !== undefined) {
      view.removeEventListener("webglcontextlost", this.handleContextLost);
      view.removeEventListener("webglcontextrestored", this.handleContextRestored);
    }
    this.gl.useProgram(null);
    if (this.extensions.loseContext) {
      this.extensions.loseContext.loseContext();
    }
  }
  postrender() {
    if (this.renderer.objectRenderer.renderingToScreen) {
      this.gl.flush();
    }
  }
  validateContext(gl) {
    const attributes = gl.getContextAttributes();
    const isWebGl2 = ("WebGL2RenderingContext" in globalThis) && gl instanceof globalThis.WebGL2RenderingContext;
    if (isWebGl2) {
      this.webGLVersion = 2;
    }
    if (attributes && !attributes.stencil) {
      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32;
    if (!hasuint32) {
      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }
  }
}
ContextSystem.defaultOptions = {
  context: null,
  antialias: false,
  premultipliedAlpha: true,
  preserveDrawingBuffer: false,
  powerPreference: "default"
};
ContextSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "context"
};
extensions.add(ContextSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTex
class DepthResource extends BufferResource {
  upload(renderer, baseTexture, glTexture) {
    const gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
class Framebuffer {
  constructor(width, height) {
    this.width = Math.round(width || 100);
    this.height = Math.round(height || 100);
    this.stencil = false;
    this.depth = false;
    this.dirtyId = 0;
    this.dirtyFormat = 0;
    this.dirtySize = 0;
    this.depthTexture = null;
    this.colorTextures = [];
    this.glFramebuffers = {};
    this.disposeRunner = new Runner("disposeFramebuffer");
    this.multisample = MSAA_QUALITY.NONE;
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  addColorTexture(index2 = 0, texture3) {
    this.colorTextures[index2] = texture3 || new BaseTexture(null, {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  addDepthTexture(texture3) {
    this.depthTexture = texture3 || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES.OFF,
      format: FORMATS.DEPTH_COMPONENT,
      type: TYPES.UNSIGNED_SHORT
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableDepth() {
    this.depth = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableStencil() {
    this.stencil = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  resize(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    if (width === this.width && height === this.height)
      return;
    this.width = width;
    this.height = height;
    this.dirtyId++;
    this.dirtySize++;
    for (let i3 = 0;i3 < this.colorTextures.length; i3++) {
      const texture3 = this.colorTextures[i3];
      const resolution = texture3.resolution;
      texture3.setSize(width / resolution, height / resolution);
    }
    if (this.depthTexture) {
      const resolution = this.depthTexture.resolution;
      this.depthTexture.setSize(width / resolution, height / resolution);
    }
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroyDepthTexture() {
    if (this.depthTexture) {
      this.depthTexture.destroy();
      this.depthTexture = null;
      ++this.dirtyId;
      ++this.dirtyFormat;
    }
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTe
class BaseRenderTexture extends BaseTexture {
  constructor(options = {}) {
    if (typeof options === "number") {
      const width = arguments[0];
      const height = arguments[1];
      const scaleMode = arguments[2];
      const resolution = arguments[3];
      options = { width, height, scaleMode, resolution };
    }
    options.width = options.width || 100;
    options.height = options.height || 100;
    options.multisample ?? (options.multisample = MSAA_QUALITY.NONE);
    super(null, options);
    this.mipmap = MIPMAP_MODES.OFF;
    this.valid = true;
    this._clear = new Color([0, 0, 0, 0]);
    this.framebuffer = new Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this);
    this.framebuffer.multisample = options.multisample;
    this.maskStack = [];
    this.filterStack = [{}];
  }
  set clearColor(value) {
    this._clear.setValue(value);
  }
  get clearColor() {
    return this._clear.value;
  }
  get clear() {
    return this._clear;
  }
  resize(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
    this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }
  dispose() {
    this.framebuffer.dispose();
    super.dispose();
  }
  destroy() {
    super.destroy();
    this.framebuffer.destroyDepthTexture();
    this.framebuffer = null;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTexture
class BaseImageResource extends Resource {
  constructor(source) {
    const sourceAny = source;
    const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
    const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    super(width, height);
    this.source = source;
    this.noSubImage = false;
  }
  static crossOrigin(element, url3, crossorigin) {
    if (crossorigin === undefined && !url3.startsWith("data:")) {
      element.crossOrigin = determineCrossOrigin(url3);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  upload(renderer, baseTexture, glTexture, source) {
    const gl = renderer.gl;
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    source = source || this.source;
    if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement) {
      if (!source.complete || source.naturalWidth === 0) {
        return false;
      }
    } else if (typeof HTMLVideoElement !== "undefined" && source instanceof HTMLVideoElement) {
      if (source.readyState <= 1 && source.buffered.length === 0) {
        return false;
      }
    }
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
    }
    return true;
  }
  update() {
    if (this.destroyed) {
      return;
    }
    const source = this.source;
    const width = source.naturalWidth || source.videoWidth || source.width;
    const height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height);
    super.update();
  }
  dispose() {
    this.source = null;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTex
class ImageResource extends BaseImageResource {
  constructor(source, options) {
    options = options || {};
    if (typeof source === "string") {
      const imageElement = new Image;
      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
      imageElement.src = source;
      source = imageElement;
    }
    super(source);
    if (!source.complete && !!this._width && !!this._height) {
      this._width = 0;
      this._height = 0;
    }
    this.url = source.src;
    this._process = null;
    this.preserveBitmap = false;
    this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    this.bitmap = null;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load(createBitmap) {
    if (this._load) {
      return this._load;
    }
    if (createBitmap !== undefined) {
      this.createBitmap = createBitmap;
    }
    this._load = new Promise((resolve, reject) => {
      const source = this.source;
      this.url = source.src;
      const completed = () => {
        if (this.destroyed) {
          return;
        }
        source.onload = null;
        source.onerror = null;
        this.resize(source.width, source.height);
        this._load = null;
        if (this.createBitmap) {
          resolve(this.process());
        } else {
          resolve(this);
        }
      };
      if (source.complete && source.src) {
        completed();
      } else {
        source.onload = completed;
        source.onerror = (event) => {
          reject(event);
          this.onError.emit(event);
        };
      }
    });
    return this._load;
  }
  process() {
    const source = this.source;
    if (this._process !== null) {
      return this._process;
    }
    if (this.bitmap !== null || !globalThis.createImageBitmap) {
      return Promise.resolve(this);
    }
    const createImageBitmap2 = globalThis.createImageBitmap;
    const cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    this._process = fetch(source.src, {
      mode: cors ? "cors" : "no-cors"
    }).then((r4) => r4.blob()).then((blob) => createImageBitmap2(blob, 0, 0, source.width, source.height, {
      premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
    })).then((bitmap) => {
      if (this.destroyed) {
        return Promise.reject();
      }
      this.bitmap = bitmap;
      this.update();
      this._process = null;
      return Promise.resolve(this);
    });
    return this._process;
  }
  upload(renderer, baseTexture, glTexture) {
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    if (!this.createBitmap) {
      return super.upload(renderer, baseTexture, glTexture);
    }
    if (!this.bitmap) {
      this.process();
      if (!this.bitmap) {
        return false;
      }
    }
    super.upload(renderer, baseTexture, glTexture, this.bitmap);
    if (!this.preserveBitmap) {
      let flag = true;
      const glTextures = baseTexture._glTextures;
      for (const key in glTextures) {
        const otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      if (flag) {
        if (this.bitmap.close) {
          this.bitmap.close();
        }
        this.bitmap = null;
      }
    }
    return true;
  }
  dispose() {
    this.source.onload = null;
    this.source.onerror = null;
    super.dispose();
    if (this.bitmap) {
      this.bitmap.close();
      this.bitmap = null;
    }
    this._process = null;
    this._load = null;
  }
  static test(source) {
    return typeof HTMLImageElement !== "undefined" && (typeof source === "string" || source instanceof HTMLImageElement);
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle
class TextureUvs {
  constructor() {
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 1;
    this.y1 = 0;
    this.x2 = 1;
    this.y2 = 1;
    this.x3 = 0;
    this.y3 = 1;
    this.uvsFloat32 = new Float32Array(8);
  }
  set(frame, baseFrame, rotate2) {
    const tw = baseFrame.width;
    const th = baseFrame.height;
    if (rotate2) {
      const w22 = frame.width / 2 / tw;
      const h22 = frame.height / 2 / th;
      const cX = frame.x / tw + w22;
      const cY = frame.y / th + h22;
      rotate2 = groupD8.add(rotate2, groupD8.NW);
      this.x0 = cX + w22 * groupD8.uX(rotate2);
      this.y0 = cY + h22 * groupD8.uY(rotate2);
      rotate2 = groupD8.add(rotate2, 2);
      this.x1 = cX + w22 * groupD8.uX(rotate2);
      this.y1 = cY + h22 * groupD8.uY(rotate2);
      rotate2 = groupD8.add(rotate2, 2);
      this.x2 = cX + w22 * groupD8.uX(rotate2);
      this.y2 = cY + h22 * groupD8.uY(rotate2);
      rotate2 = groupD8.add(rotate2, 2);
      this.x3 = cX + w22 * groupD8.uX(rotate2);
      this.y3 = cY + h22 * groupD8.uY(rotate2);
    } else {
      this.x0 = frame.x / tw;
      this.y0 = frame.y / th;
      this.x1 = (frame.x + frame.width) / tw;
      this.y1 = frame.y / th;
      this.x2 = (frame.x + frame.width) / tw;
      this.y2 = (frame.y + frame.height) / th;
      this.x3 = frame.x / tw;
      this.y3 = (frame.y + frame.height) / th;
    }
    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
  }
  toString() {
    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjs
var removeAllHandlers = function(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
};
var DEFAULT_UVS = new TextureUvs;

class Texture extends import_eventemitter3.default {
  constructor(baseTexture, frame, orig, trim, rotate2, anchor, borders) {
    super();
    this.noFrame = false;
    if (!frame) {
      this.noFrame = true;
      frame = new Rectangle(0, 0, 1, 1);
    }
    if (baseTexture instanceof Texture) {
      baseTexture = baseTexture.baseTexture;
    }
    this.baseTexture = baseTexture;
    this._frame = frame;
    this.trim = trim;
    this.valid = false;
    this._uvs = DEFAULT_UVS;
    this.uvMatrix = null;
    this.orig = orig || frame;
    this._rotate = Number(rotate2 || 0);
    if (rotate2 === true) {
      this._rotate = 2;
    } else if (this._rotate % 2 !== 0) {
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    }
    this.defaultAnchor = anchor ? new Point3(anchor.x, anchor.y) : new Point3(0, 0);
    this.defaultBorders = borders;
    this._updateID = 0;
    this.textureCacheIds = [];
    if (!baseTexture.valid) {
      baseTexture.once("loaded", this.onBaseTextureUpdated, this);
    } else if (this.noFrame) {
      if (baseTexture.valid) {
        this.onBaseTextureUpdated(baseTexture);
      }
    } else {
      this.frame = frame;
    }
    if (this.noFrame) {
      baseTexture.on("update", this.onBaseTextureUpdated, this);
    }
  }
  update() {
    if (this.baseTexture.resource) {
      this.baseTexture.resource.update();
    }
  }
  onBaseTextureUpdated(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid) {
        return;
      }
      this._frame.width = baseTexture.width;
      this._frame.height = baseTexture.height;
      this.valid = true;
      this.updateUvs();
    } else {
      this.frame = this._frame;
    }
    this.emit("update", this);
  }
  destroy(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        const { resource } = this.baseTexture;
        if (resource?.url && TextureCache[resource.url]) {
          Texture.removeFromCache(resource.url);
        }
        this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
      this.baseTexture.off("update", this.onBaseTextureUpdated, this);
      this.baseTexture = null;
    }
    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.orig = null;
    this.valid = false;
    Texture.removeFromCache(this);
    this.textureCacheIds = null;
  }
  clone() {
    const clonedFrame = this._frame.clone();
    const clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
    const clonedTexture = new Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim?.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);
    if (this.noFrame) {
      clonedTexture._frame = clonedFrame;
    }
    return clonedTexture;
  }
  updateUvs() {
    if (this._uvs === DEFAULT_UVS) {
      this._uvs = new TextureUvs;
    }
    this._uvs.set(this._frame, this.baseTexture, this.rotate);
    this._updateID++;
  }
  static from(source, options = {}, strict = settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else if (source instanceof BaseTexture) {
      if (!source.cacheId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source.cacheId = `${prefix}-${uid()}`;
        BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix}_${uid()}`;
      }
      cacheId = source._pixiId;
    }
    let texture3 = TextureCache[cacheId];
    if (isFrame && strict && !texture3) {
      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
    }
    if (!texture3 && !(source instanceof BaseTexture)) {
      if (!options.resolution) {
        options.resolution = getResolutionOfUrl(source);
      }
      texture3 = new Texture(new BaseTexture(source, options));
      texture3.baseTexture.cacheId = cacheId;
      BaseTexture.addToCache(texture3.baseTexture, cacheId);
      Texture.addToCache(texture3, cacheId);
    } else if (!texture3 && source instanceof BaseTexture) {
      texture3 = new Texture(source);
      Texture.addToCache(texture3, cacheId);
    }
    return texture3;
  }
  static fromURL(url3, options) {
    const resourceOptions = Object.assign({ autoLoad: false }, options?.resourceOptions);
    const texture3 = Texture.from(url3, Object.assign({ resourceOptions }, options), false);
    const resource = texture3.baseTexture.resource;
    if (texture3.baseTexture.valid) {
      return Promise.resolve(texture3);
    }
    return resource.load().then(() => Promise.resolve(texture3));
  }
  static fromBuffer(buffer, width, height, options) {
    return new Texture(BaseTexture.fromBuffer(buffer, width, height, options));
  }
  static fromLoader(source, imageUrl, name, options) {
    const baseTexture = new BaseTexture(source, Object.assign({
      scaleMode: BaseTexture.defaultOptions.scaleMode,
      resolution: getResolutionOfUrl(imageUrl)
    }, options));
    const { resource } = baseTexture;
    if (resource instanceof ImageResource) {
      resource.url = imageUrl;
    }
    const texture3 = new Texture(baseTexture);
    if (!name) {
      name = imageUrl;
    }
    BaseTexture.addToCache(texture3.baseTexture, name);
    Texture.addToCache(texture3, name);
    if (name !== imageUrl) {
      BaseTexture.addToCache(texture3.baseTexture, imageUrl);
      Texture.addToCache(texture3, imageUrl);
    }
    if (texture3.baseTexture.valid) {
      return Promise.resolve(texture3);
    }
    return new Promise((resolve) => {
      texture3.baseTexture.once("loaded", () => resolve(texture3));
    });
  }
  static addToCache(texture3, id) {
    if (id) {
      if (!texture3.textureCacheIds.includes(id)) {
        texture3.textureCacheIds.push(id);
      }
      if (TextureCache[id] && TextureCache[id] !== texture3) {
        console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);
      }
      TextureCache[id] = texture3;
    }
  }
  static removeFromCache(texture3) {
    if (typeof texture3 === "string") {
      const textureFromCache = TextureCache[texture3];
      if (textureFromCache) {
        const index2 = textureFromCache.textureCacheIds.indexOf(texture3);
        if (index2 > -1) {
          textureFromCache.textureCacheIds.splice(index2, 1);
        }
        delete TextureCache[texture3];
        return textureFromCache;
      }
    } else if (texture3?.textureCacheIds) {
      for (let i3 = 0;i3 < texture3.textureCacheIds.length; ++i3) {
        if (TextureCache[texture3.textureCacheIds[i3]] === texture3) {
          delete TextureCache[texture3.textureCacheIds[i3]];
        }
      }
      texture3.textureCacheIds.length = 0;
      return texture3;
    }
    return null;
  }
  get resolution() {
    return this.baseTexture.resolution;
  }
  get frame() {
    return this._frame;
  }
  set frame(frame) {
    this._frame = frame;
    this.noFrame = false;
    const { x: x3, y: y3, width, height } = frame;
    const xNotFit = x3 + width > this.baseTexture.width;
    const yNotFit = y3 + height > this.baseTexture.height;
    if (xNotFit || yNotFit) {
      const relationship = xNotFit && yNotFit ? "and" : "or";
      const errorX = `X: ${x3} + ${width} = ${x3 + width} > ${this.baseTexture.width}`;
      const errorY = `Y: ${y3} + ${height} = ${y3 + height} > ${this.baseTexture.height}`;
      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
    }
    this.valid = width && height && this.baseTexture.valid;
    if (!this.trim && !this.rotate) {
      this.orig = frame;
    }
    if (this.valid) {
      this.updateUvs();
    }
  }
  get rotate() {
    return this._rotate;
  }
  set rotate(rotate2) {
    this._rotate = rotate2;
    if (this.valid) {
      this.updateUvs();
    }
  }
  get width() {
    return this.orig.width;
  }
  get height() {
    return this.orig.height;
  }
  castToBaseTexture() {
    return this.baseTexture;
  }
  static get EMPTY() {
    if (!Texture._EMPTY) {
      Texture._EMPTY = new Texture(new BaseTexture);
      removeAllHandlers(Texture._EMPTY);
      removeAllHandlers(Texture._EMPTY.baseTexture);
    }
    return Texture._EMPTY;
  }
  static get WHITE() {
    if (!Texture._WHITE) {
      const canvas = settings.ADAPTER.createCanvas(16, 16);
      const context2 = canvas.getContext("2d");
      canvas.width = 16;
      canvas.height = 16;
      context2.fillStyle = "white";
      context2.fillRect(0, 0, 16, 16);
      Texture._WHITE = new Texture(BaseTexture.from(canvas));
      removeAllHandlers(Texture._WHITE);
      removeAllHandlers(Texture._WHITE.baseTexture);
    }
    return Texture._WHITE;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
class RenderTexture extends Texture {
  constructor(baseRenderTexture, frame) {
    super(baseRenderTexture, frame);
    this.valid = true;
    this.filterFrame = null;
    this.filterPoolKey = null;
    this.updateUvs();
  }
  get framebuffer() {
    return this.baseTexture.framebuffer;
  }
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value) {
    this.framebuffer.multisample = value;
  }
  resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {
    const resolution = this.baseTexture.resolution;
    const width = Math.round(desiredWidth * resolution) / resolution;
    const height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0;
    this._frame.width = this.orig.width = width;
    this._frame.height = this.orig.height = height;
    if (resizeBaseTexture) {
      this.baseTexture.resize(width, height);
    }
    this.updateUvs();
  }
  setResolution(resolution) {
    const { baseTexture } = this;
    if (baseTexture.resolution === resolution) {
      return;
    }
    baseTexture.setResolution(resolution);
    this.resize(baseTexture.width, baseTexture.height, false);
  }
  static create(options) {
    return new RenderTexture(new BaseRenderTexture(options));
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTe
class RenderTexturePool {
  constructor(textureOptions) {
    this.texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this._pixelsWidth = 0;
    this._pixelsHeight = 0;
  }
  createTexture(realWidth, realHeight, multisample = MSAA_QUALITY.NONE) {
    const baseRenderTexture = new BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture(baseRenderTexture);
  }
  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
    let key;
    minWidth = Math.ceil(minWidth * resolution - 0.000001);
    minHeight = Math.ceil(minHeight * resolution - 0.000001);
    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
      minWidth = nextPow2(minWidth);
      minHeight = nextPow2(minHeight);
      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
      if (multisample > 1) {
        key += multisample * 4294967296;
      }
    } else {
      key = multisample > 1 ? -multisample : -1;
    }
    if (!this.texturePool[key]) {
      this.texturePool[key] = [];
    }
    let renderTexture = this.texturePool[key].pop();
    if (!renderTexture) {
      renderTexture = this.createTexture(minWidth, minHeight, multisample);
    }
    renderTexture.filterPoolKey = key;
    renderTexture.setResolution(resolution);
    return renderTexture;
  }
  getFilterTexture(input, resolution, multisample) {
    const filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnTexture(renderTexture) {
    const key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null;
    this.texturePool[key].push(renderTexture);
  }
  returnFilterTexture(renderTexture) {
    this.returnTexture(renderTexture);
  }
  clear(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (const i3 in this.texturePool) {
        const textures = this.texturePool[i3];
        if (textures) {
          for (let j3 = 0;j3 < textures.length; j3++) {
            textures[j3].destroy(true);
          }
        }
      }
    }
    this.texturePool = {};
  }
  setScreenSize(size) {
    if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
      return;
    }
    this.enableFullScreen = size.width > 0 && size.height > 0;
    for (const i3 in this.texturePool) {
      if (!(Number(i3) < 0)) {
        continue;
      }
      const textures = this.texturePool[i3];
      if (textures) {
        for (let j3 = 0;j3 < textures.length; j3++) {
          textures[j3].destroy(true);
        }
      }
      this.texturePool[i3] = [];
    }
    this._pixelsWidth = size.width;
    this._pixelsHeight = size.height;
  }
}
RenderTexturePool.SCREEN_KEY = -1;

// node_modules/colord/plugins/names.mjsisten
class Quad extends Geometry {
  constructor() {
    super();
    this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
  }
}

// node_modules/colord/plugins/names.mjsistener
class QuadUv extends Geometry {
  constructor() {
    super();
    this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    this.vertexBuffer = new Buffer(this.vertices);
    this.uvBuffer = new Buffer(this.uvs);
    this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
  }
  map(targetTextureFrame, destinationFrame) {
    let x3 = 0;
    let y3 = 0;
    this.uvs[0] = x3;
    this.uvs[1] = y3;
    this.uvs[2] = x3 + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y3;
    this.uvs[4] = x3 + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y3 + destinationFrame.height / targetTextureFrame.height;
    this.uvs[6] = x3;
    this.uvs[7] = y3 + destinationFrame.height / targetTextureFrame.height;
    x3 = destinationFrame.x;
    y3 = destinationFrame.y;
    this.vertices[0] = x3;
    this.vertices[1] = y3;
    this.vertices[2] = x3 + destinationFrame.width;
    this.vertices[3] = y3;
    this.vertices[4] = x3 + destinationFrame.width;
    this.vertices[5] = y3 + destinationFrame.height;
    this.vertices[6] = x3;
    this.vertices[7] = y3 + destinationFrame.height;
    this.invalidate();
    return this;
  }
  invalidate() {
    this.vertexBuffer._updateID++;
    this.uvBuffer._updateID++;
    return this;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle
class FilterState {
  constructor() {
    this.renderTexture = null;
    this.target = null;
    this.legacy = false;
    this.resolution = 1;
    this.multisample = MSAA_QUALITY.NONE;
    this.sourceFrame = new Rectangle;
    this.destinationFrame = new Rectangle;
    this.bindingSourceFrame = new Rectangle;
    this.bindingDestinationFrame = new Rectangle;
    this.filters = [];
    this.transform = null;
  }
  clear() {
    this.target = null;
    this.filters = null;
    this.renderTexture = null;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.
var tempPoints2 = [new Point3, new Point3, new Point3, new Point3];
var tempMatrix = new Matrix;

class FilterSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.defaultFilterStack = [{}];
    this.texturePool = new RenderTexturePool;
    this.statePool = [];
    this.quad = new Quad;
    this.quadUv = new QuadUv;
    this.tempRect = new Rectangle;
    this.activeState = {};
    this.globalUniforms = new UniformGroup({
      outputFrame: new Rectangle,
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true);
    this.forceClear = false;
    this.useMaxPadding = false;
  }
  init() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  push(target, filters) {
    const renderer = this.renderer;
    const filterStack = this.defaultFilterStack;
    const state = this.statePool.pop() || new FilterState;
    const renderTextureSystem = this.renderer.renderTexture;
    let resolution = filters[0].resolution;
    let multisample = filters[0].multisample;
    let padding = filters[0].padding;
    let autoFit = filters[0].autoFit;
    let legacy = filters[0].legacy ?? true;
    for (let i3 = 1;i3 < filters.length; i3++) {
      const filter = filters[i3];
      resolution = Math.min(resolution, filter.resolution);
      multisample = Math.min(multisample, filter.multisample);
      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
      autoFit = autoFit && filter.autoFit;
      legacy = legacy || (filter.legacy ?? true);
    }
    if (filterStack.length === 1) {
      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
    }
    filterStack.push(state);
    state.resolution = resolution;
    state.multisample = multisample;
    state.legacy = legacy;
    state.target = target;
    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
    state.sourceFrame.pad(padding);
    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
    if (renderer.projection.transform) {
      this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
    }
    if (autoFit) {
      state.sourceFrame.fit(sourceFrameProjected);
      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
      state.sourceFrame.width = 0;
      state.sourceFrame.height = 0;
    }
    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
    state.filters = filters;
    state.destinationFrame.width = state.renderTexture.width;
    state.destinationFrame.height = state.renderTexture.height;
    const destinationFrame = this.tempRect;
    destinationFrame.x = 0;
    destinationFrame.y = 0;
    destinationFrame.width = state.sourceFrame.width;
    destinationFrame.height = state.sourceFrame.height;
    state.renderTexture.filterFrame = state.sourceFrame;
    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
    state.transform = renderer.projection.transform;
    renderer.projection.transform = null;
    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
    renderer.framebuffer.clear(0, 0, 0, 0);
  }
  pop() {
    const filterStack = this.defaultFilterStack;
    const state = filterStack.pop();
    const filters = state.filters;
    this.activeState = state;
    const globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame;
    globalUniforms.resolution = state.resolution;
    const inputSize = globalUniforms.inputSize;
    const inputPixel = globalUniforms.inputPixel;
    const inputClamp = globalUniforms.inputClamp;
    inputSize[0] = state.destinationFrame.width;
    inputSize[1] = state.destinationFrame.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = Math.round(inputSize[0] * state.resolution);
    inputPixel[1] = Math.round(inputSize[1] * state.resolution);
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
    if (state.legacy) {
      const filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width;
      filterArea[1] = state.destinationFrame.height;
      filterArea[2] = state.sourceFrame.x;
      filterArea[3] = state.sourceFrame.y;
      globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    const lastState = filterStack[filterStack.length - 1];
    this.renderer.framebuffer.blit();
    if (filters.length === 1) {
      filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);
      this.returnFilterTexture(state.renderTexture);
    } else {
      let flip = state.renderTexture;
      let flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
      flop.filterFrame = flip.filterFrame;
      let i3 = 0;
      for (i3 = 0;i3 < filters.length - 1; ++i3) {
        if (i3 === 1 && state.multisample > 1) {
          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
        }
        filters[i3].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
        const t4 = flip;
        flip = flop;
        flop = t4;
      }
      filters[i3].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);
      if (i3 > 1 && state.multisample > 1) {
        this.returnFilterTexture(state.renderTexture);
      }
      this.returnFilterTexture(flip);
      this.returnFilterTexture(flop);
    }
    state.clear();
    this.statePool.push(state);
  }
  bindAndClear(filterTexture, clearMode = CLEAR_MODES.CLEAR) {
    const {
      renderTexture: renderTextureSystem,
      state: stateSystem
    } = this.renderer;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      this.renderer.projection.transform = this.activeState.transform;
    } else {
      this.renderer.projection.transform = null;
    }
    if (filterTexture?.filterFrame) {
      const destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = filterTexture.filterFrame.width;
      destinationFrame.height = filterTexture.filterFrame.height;
      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      renderTextureSystem.bind(filterTexture);
    } else {
      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    }
    const autoClear = stateSystem.stateId & 1 || this.forceClear;
    if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {
      this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
  }
  applyFilter(filter, input, output, clearMode) {
    const renderer = this.renderer;
    renderer.state.set(filter.state);
    this.bindAndClear(output, clearMode);
    filter.uniforms.uSampler = input;
    filter.uniforms.filterGlobals = this.globalUniforms;
    renderer.shader.bind(filter);
    filter.legacy = !!filter.program.attributeData.aTextureCoord;
    if (filter.legacy) {
      this.quadUv.map(input._frame, input.filterFrame);
      renderer.geometry.bind(this.quadUv);
      renderer.geometry.draw(DRAW_MODES.TRIANGLES);
    } else {
      renderer.geometry.bind(this.quad);
      renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);
    }
  }
  calculateSpriteMatrix(outputMatrix, sprite) {
    const { sourceFrame, destinationFrame } = this.activeState;
    const { orig } = sprite._texture;
    const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
    const worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1 / orig.width, 1 / orig.height);
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  }
  destroy() {
    this.renderer = null;
    this.texturePool.clear(false);
  }
  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  }
  getFilterTexture(input, resolution, multisample) {
    if (typeof input === "number") {
      const swap = input;
      input = resolution;
      resolution = swap;
    }
    input = input || this.activeState.renderTexture;
    const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnFilterTexture(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  }
  emptyPool() {
    this.texturePool.clear(true);
  }
  resize() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  transformAABB(matrix, rect) {
    const lt = tempPoints2[0];
    const lb = tempPoints2[1];
    const rt2 = tempPoints2[2];
    const rb = tempPoints2[3];
    lt.set(rect.left, rect.top);
    lb.set(rect.left, rect.bottom);
    rt2.set(rect.right, rect.top);
    rb.set(rect.right, rect.bottom);
    matrix.apply(lt, lt);
    matrix.apply(lb, lb);
    matrix.apply(rt2, rt2);
    matrix.apply(rb, rb);
    const x0 = Math.min(lt.x, lb.x, rt2.x, rb.x);
    const y0 = Math.min(lt.y, lb.y, rt2.y, rb.y);
    const x1 = Math.max(lt.x, lb.x, rt2.x, rb.x);
    const y1 = Math.max(lt.y, lb.y, rt2.y, rb.y);
    rect.x = x0;
    rect.y = y0;
    rect.width = x1 - x0;
    rect.height = y1 - y0;
  }
  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
      return;
    }
    if (transform) {
      const { a: a3, b: b3, c: c3, d: d3 } = transform;
      if ((Math.abs(b3) > 0.0001 || Math.abs(c3) > 0.0001) && (Math.abs(a3) > 0.0001 || Math.abs(d3) > 0.0001)) {
        return;
      }
    }
    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.transformAABB(transform, frame);
    frame.ceil(resolution);
    this.transformAABB(transform.invert(), frame);
  }
}
FilterSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "filter"
};
extensions.add(FilterSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
class GLFramebuffer {
  constructor(framebuffer) {
    this.framebuffer = framebuffer;
    this.stencil = null;
    this.dirtyId = -1;
    this.dirtyFormat = -1;
    this.dirtySize = -1;
    this.multisample = MSAA_QUALITY.NONE;
    this.msaaBuffer = null;
    this.blitFramebuffer = null;
    this.mipLevel = 0;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
var tempRectangle = new Rectangle;

class FramebufferSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.managedFramebuffers = [];
    this.unknownFramebuffer = new Framebuffer(10, 10);
    this.msaaSamples = null;
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle;
    this.hasMRT = true;
    this.writeDepthTexture = true;
    if (this.renderer.context.webGLVersion === 1) {
      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
      let nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        nativeDrawBuffersExtension = null;
        nativeDepthTextureExtension = null;
      }
      if (nativeDrawBuffersExtension) {
        gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures);
      } else {
        this.hasMRT = false;
        gl.drawBuffers = () => {
        };
      }
      if (!nativeDepthTextureExtension) {
        this.writeDepthTexture = false;
      }
    } else {
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
    }
  }
  bind(framebuffer, frame, mipLevel = 0) {
    const { gl } = this;
    if (framebuffer) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      if (this.current !== framebuffer) {
        this.current = framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
      }
      if (fbo.mipLevel !== mipLevel) {
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
        fbo.mipLevel = mipLevel;
      }
      if (fbo.dirtyId !== framebuffer.dirtyId) {
        fbo.dirtyId = framebuffer.dirtyId;
        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
          fbo.dirtyFormat = framebuffer.dirtyFormat;
          fbo.dirtySize = framebuffer.dirtySize;
          this.updateFramebuffer(framebuffer, mipLevel);
        } else if (fbo.dirtySize !== framebuffer.dirtySize) {
          fbo.dirtySize = framebuffer.dirtySize;
          this.resizeFramebuffer(framebuffer);
        }
      }
      for (let i3 = 0;i3 < framebuffer.colorTextures.length; i3++) {
        const tex = framebuffer.colorTextures[i3];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.unbind(framebuffer.depthTexture);
      }
      if (frame) {
        const mipWidth = frame.width >> mipLevel;
        const mipHeight = frame.height >> mipLevel;
        const scale3 = mipWidth / frame.width;
        this.setViewport(frame.x * scale3, frame.y * scale3, mipWidth, mipHeight);
      } else {
        const mipWidth = framebuffer.width >> mipLevel;
        const mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else {
      if (this.current) {
        this.current = null;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      if (frame) {
        this.setViewport(frame.x, frame.y, frame.width, frame.height);
      } else {
        this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }
    }
  }
  setViewport(x3, y3, width, height) {
    const v4 = this.viewport;
    x3 = Math.round(x3);
    y3 = Math.round(y3);
    width = Math.round(width);
    height = Math.round(height);
    if (v4.width !== width || v4.height !== height || v4.x !== x3 || v4.y !== y3) {
      v4.x = x3;
      v4.y = y3;
      v4.width = width;
      v4.height = height;
      this.gl.viewport(x3, y3, width, height);
    }
  }
  get size() {
    if (this.current) {
      return { x: 0, y: 0, width: this.current.width, height: this.current.height };
    }
    return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
  }
  clear(r4, g4, b3, a3, mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH) {
    const { gl } = this;
    gl.clearColor(r4, g4, b3, a3);
    gl.clear(mask);
  }
  initFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = new GLFramebuffer(gl.createFramebuffer());
    fbo.multisample = this.detectSamples(framebuffer.multisample);
    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
    this.managedFramebuffers.push(framebuffer);
    framebuffer.disposeRunner.add(this);
    return fbo;
  }
  resizeFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
    }
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    for (let i3 = 0;i3 < count; i3++) {
      const texture3 = colorTextures[i3];
      const parentTexture = texture3.parentTextureArray || texture3;
      this.renderer.texture.bind(parentTexture, 0);
      if (i3 === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
      }
    }
    if (framebuffer.depthTexture && this.writeDepthTexture) {
      this.renderer.texture.bind(framebuffer.depthTexture, 0);
    }
  }
  updateFramebuffer(framebuffer, mipLevel) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
    } else if (fbo.msaaBuffer) {
      gl.deleteRenderbuffer(fbo.msaaBuffer);
      fbo.msaaBuffer = null;
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
        fbo.blitFramebuffer = null;
      }
    }
    const activeTextures = [];
    for (let i3 = 0;i3 < count; i3++) {
      const texture3 = colorTextures[i3];
      const parentTexture = texture3.parentTextureArray || texture3;
      this.renderer.texture.bind(parentTexture, 0);
      if (i3 === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i3, texture3.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        activeTextures.push(gl.COLOR_ATTACHMENT0 + i3);
      }
    }
    if (activeTextures.length > 1) {
      gl.drawBuffers(activeTextures);
    }
    if (framebuffer.depthTexture) {
      const writeDepthTexture = this.writeDepthTexture;
      if (writeDepthTexture) {
        const depthTexture = framebuffer.depthTexture;
        this.renderer.texture.bind(depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      }
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
    } else if (fbo.stencil) {
      gl.deleteRenderbuffer(fbo.stencil);
      fbo.stencil = null;
    }
  }
  canMultisampleFramebuffer(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  }
  detectSamples(samples) {
    const { msaaSamples } = this;
    let res = MSAA_QUALITY.NONE;
    if (samples <= 1 || msaaSamples === null) {
      return res;
    }
    for (let i3 = 0;i3 < msaaSamples.length; i3++) {
      if (msaaSamples[i3] <= samples) {
        res = msaaSamples[i3];
        break;
      }
    }
    if (res === 1) {
      res = MSAA_QUALITY.NONE;
    }
    return res;
  }
  blit(framebuffer, sourcePixels, destPixels) {
    const { current, renderer, gl, CONTEXT_UID } = this;
    if (renderer.context.webGLVersion !== 2) {
      return;
    }
    if (!current) {
      return;
    }
    const fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo) {
      return;
    }
    if (!framebuffer) {
      if (!fbo.msaaBuffer) {
        return;
      }
      const colorTexture = current.colorTextures[0];
      if (!colorTexture) {
        return;
      }
      if (!fbo.blitFramebuffer) {
        fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
        fbo.blitFramebuffer.addColorTexture(0, colorTexture);
      }
      framebuffer = fbo.blitFramebuffer;
      if (framebuffer.colorTextures[0] !== colorTexture) {
        framebuffer.colorTextures[0] = colorTexture;
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
      }
      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
        framebuffer.width = current.width;
        framebuffer.height = current.height;
        framebuffer.dirtyId++;
        framebuffer.dirtySize++;
      }
    }
    if (!sourcePixels) {
      sourcePixels = tempRectangle;
      sourcePixels.width = current.width;
      sourcePixels.height = current.height;
    }
    if (!destPixels) {
      destPixels = sourcePixels;
    }
    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);
  }
  disposeFramebuffer(framebuffer, contextLost) {
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const gl = this.gl;
    if (!fbo) {
      return;
    }
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    const index2 = this.managedFramebuffers.indexOf(framebuffer);
    if (index2 >= 0) {
      this.managedFramebuffers.splice(index2, 1);
    }
    framebuffer.disposeRunner.remove(this);
    if (!contextLost) {
      gl.deleteFramebuffer(fbo.framebuffer);
      if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
      }
      if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
      }
    }
    if (fbo.blitFramebuffer) {
      this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);
    }
  }
  disposeAll(contextLost) {
    const list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (let i3 = 0;i3 < list.length; i3++) {
      this.disposeFramebuffer(list[i3], contextLost);
    }
  }
  forceStencil() {
    const framebuffer = this.current;
    if (!framebuffer) {
      return;
    }
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil) {
      return;
    }
    framebuffer.stencil = true;
    const w3 = framebuffer.width;
    const h3 = framebuffer.height;
    const gl = this.gl;
    const stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    if (fbo.msaaBuffer) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w3, h3);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w3, h3);
    }
    fbo.stencil = stencil;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
  }
  reset() {
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle;
  }
  destroy() {
    this.renderer = null;
  }
}
FramebufferSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "framebuffer"
};
extensions.add(FramebufferSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
var byteSizeMap2 = { 5126: 4, 5123: 2, 5121: 1 };

class GeometrySystem {
  constructor(renderer) {
    this.renderer = renderer;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this.canUseUInt32ElementIndex = false;
    this.managedGeometries = {};
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    const context2 = this.renderer.context;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    if (context2.webGLVersion !== 2) {
      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        nativeVaoExtension = null;
      }
      if (nativeVaoExtension) {
        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
        gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
        gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
      } else {
        this.hasVao = false;
        gl.createVertexArray = () => null;
        gl.bindVertexArray = () => null;
        gl.deleteVertexArray = () => null;
      }
    }
    if (context2.webGLVersion !== 2) {
      const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExt) {
        gl.vertexAttribDivisor = (a3, b3) => instanceExt.vertexAttribDivisorANGLE(a3, b3);
        gl.drawElementsInstanced = (a3, b3, c3, d3, e3) => instanceExt.drawElementsInstancedANGLE(a3, b3, c3, d3, e3);
        gl.drawArraysInstanced = (a3, b3, c3, d3) => instanceExt.drawArraysInstancedANGLE(a3, b3, c3, d3);
      } else {
        this.hasInstance = false;
      }
    }
    this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
  }
  bind(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    const { gl } = this;
    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let incRefCount = false;
    if (!vaos) {
      this.managedGeometries[geometry.id] = geometry;
      geometry.disposeRunner.add(this);
      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
      incRefCount = true;
    }
    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry;
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      if (this.hasVao) {
        gl.bindVertexArray(vao);
      } else {
        this.activateVao(geometry, shader.program);
      }
    }
    this.updateBuffers();
  }
  reset() {
    this.unbind();
  }
  updateBuffers() {
    const geometry = this._activeGeometry;
    const bufferSystem = this.renderer.buffer;
    for (let i3 = 0;i3 < geometry.buffers.length; i3++) {
      const buffer = geometry.buffers[i3];
      bufferSystem.update(buffer);
    }
  }
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes;
    const shaderAttributes = program.attributeData;
    for (const j3 in shaderAttributes) {
      if (!geometryAttributes[j3]) {
        throw new Error(`shader and geometry incompatible, geometry missing the "${j3}" attribute`);
      }
    }
  }
  getSignature(geometry, program) {
    const attribs = geometry.attributes;
    const shaderAttributes = program.attributeData;
    const strings = ["g", geometry.id];
    for (const i3 in attribs) {
      if (shaderAttributes[i3]) {
        strings.push(i3, shaderAttributes[i3].location);
      }
    }
    return strings.join("-");
  }
  initGeometryVao(geometry, shader, incRefCount = true) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const program = shader.program;
    if (!program.glPrograms[CONTEXT_UID]) {
      this.renderer.shader.generateProgram(shader);
    }
    this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program);
    const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program.id] = vao;
      return vao;
    }
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    const tempStride = {};
    const tempStart = {};
    for (const j3 in buffers) {
      tempStride[j3] = 0;
      tempStart[j3] = 0;
    }
    for (const j3 in attributes) {
      if (!attributes[j3].size && program.attributeData[j3]) {
        attributes[j3].size = program.attributeData[j3].size;
      } else if (!attributes[j3].size) {
        console.warn(`PIXI Geometry attribute '${j3}' size cannot be determined (likely the bound shader does not have the attribute)`);
      }
      tempStride[attributes[j3].buffer] += attributes[j3].size * byteSizeMap2[attributes[j3].type];
    }
    for (const j3 in attributes) {
      const attribute = attributes[j3];
      const attribSize = attribute.size;
      if (attribute.stride === undefined) {
        if (tempStride[attribute.buffer] === attribSize * byteSizeMap2[attribute.type]) {
          attribute.stride = 0;
        } else {
          attribute.stride = tempStride[attribute.buffer];
        }
      }
      if (attribute.start === undefined) {
        attribute.start = tempStart[attribute.buffer];
        tempStart[attribute.buffer] += attribSize * byteSizeMap2[attribute.type];
      }
    }
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (let i3 = 0;i3 < buffers.length; i3++) {
      const buffer = buffers[i3];
      bufferSystem.bind(buffer);
      if (incRefCount) {
        buffer._glBuffers[CONTEXT_UID].refCount++;
      }
    }
    this.activateVao(geometry, program);
    vaoObjectHash[program.id] = vao;
    vaoObjectHash[signature] = vao;
    gl.bindVertexArray(null);
    bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);
    return vao;
  }
  disposeGeometry(geometry, contextLost) {
    if (!this.managedGeometries[geometry.id]) {
      return;
    }
    delete this.managedGeometries[geometry.id];
    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    const gl = this.gl;
    const buffers = geometry.buffers;
    const bufferSystem = this.renderer?.buffer;
    geometry.disposeRunner.remove(this);
    if (!vaos) {
      return;
    }
    if (bufferSystem) {
      for (let i3 = 0;i3 < buffers.length; i3++) {
        const buf = buffers[i3]._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffers[i3], contextLost);
          }
        }
      }
    }
    if (!contextLost) {
      for (const vaoId in vaos) {
        if (vaoId[0] === "g") {
          const vao = vaos[vaoId];
          if (this._activeVao === vao) {
            this.unbind();
          }
          gl.deleteVertexArray(vao);
        }
      }
    }
    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all = Object.keys(this.managedGeometries);
    for (let i3 = 0;i3 < all.length; i3++) {
      this.disposeGeometry(this.managedGeometries[all[i3]], contextLost);
    }
  }
  activateVao(geometry, program) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    let lastBuffer = null;
    for (const j3 in attributes) {
      const attribute = attributes[j3];
      const buffer = buffers[attribute.buffer];
      const glBuffer = buffer._glBuffers[CONTEXT_UID];
      if (program.attributeData[j3]) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer);
          lastBuffer = glBuffer;
        }
        const location = program.attributeData[j3].location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
        if (attribute.instance) {
          if (this.hasInstance) {
            gl.vertexAttribDivisor(location, attribute.divisor);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  }
  draw(type, size, start, instanceCount) {
    const { gl } = this;
    const geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
        if (geometry.instanced) {
          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
        } else {
          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
        }
      } else {
        console.warn("unsupported index buffer type: uint32");
      }
    } else if (geometry.instanced) {
      gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
    } else {
      gl.drawArrays(type, start, size || geometry.getSize());
    }
    return this;
  }
  unbind() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  }
  destroy() {
    this.renderer = null;
  }
}
GeometrySystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "geometry"
};
extensions.add(GeometrySystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mj
var tempMat = new Matrix;

class TextureMatrix {
  constructor(texture3, clampMargin) {
    this._texture = texture3;
    this.mapCoord = new Matrix;
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
    this.isSimple = false;
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture = value;
    this._textureID = -1;
  }
  multiplyUvs(uvs, out) {
    if (out === undefined) {
      out = uvs;
    }
    const mat = this.mapCoord;
    for (let i3 = 0;i3 < uvs.length; i3 += 2) {
      const x3 = uvs[i3];
      const y3 = uvs[i3 + 1];
      out[i3] = x3 * mat.a + y3 * mat.c + mat.tx;
      out[i3 + 1] = x3 * mat.b + y3 * mat.d + mat.ty;
    }
    return out;
  }
  update(forceUpdate) {
    const tex = this._texture;
    if (!tex || !tex.valid) {
      return false;
    }
    if (!forceUpdate && this._textureID === tex._updateID) {
      return false;
    }
    this._textureID = tex._updateID;
    this._updateID++;
    const uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig;
    const trim = tex.trim;
    if (trim) {
      tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
      this.mapCoord.append(tempMat);
    }
    const texBase = tex.baseTexture;
    const frame = this.uClampFrame;
    const margin = this.clampMargin / texBase.resolution;
    const offset = this.clampOffset;
    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = offset / texBase.realWidth;
    this.uClampOffset[1] = offset / texBase.realHeight;
    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
    return true;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTexture
var fragment = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTexture
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextur
class SpriteMaskFilter extends Filter {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    let sprite = null;
    if (typeof vertexSrc !== "string" && fragmentSrc === undefined && uniforms === undefined) {
      sprite = vertexSrc;
      vertexSrc = undefined;
      fragmentSrc = undefined;
      uniforms = undefined;
    }
    super(vertexSrc || vertex, fragmentSrc || fragment, uniforms);
    this.maskSprite = sprite;
    this.maskMatrix = new Matrix;
  }
  get maskSprite() {
    return this._maskSprite;
  }
  set maskSprite(value) {
    this._maskSprite = value;
    if (this._maskSprite) {
      this._maskSprite.renderable = false;
    }
  }
  apply(filterManager, input, output, clearMode) {
    const maskSprite = this._maskSprite;
    const tex = maskSprite._texture;
    if (!tex.valid) {
      return;
    }
    if (!tex.uvMatrix) {
      tex.uvMatrix = new TextureMatrix(tex, 0);
    }
    tex.uvMatrix.update();
    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
    this.uniforms.mask = tex;
    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
    this.uniforms.alpha = maskSprite.worldAlpha;
    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
    filterManager.applyFilter(this, input, output, clearMode);
  }
}

// node_modules/colord/plugins/names.mjsistener.
class MaskData {
  constructor(maskObject = null) {
    this.type = MASK_TYPES.NONE;
    this.autoDetect = true;
    this.maskObject = maskObject || null;
    this.pooled = false;
    this.isMaskData = true;
    this.resolution = null;
    this.multisample = Filter.defaultMultisample;
    this.enabled = true;
    this.colorMask = 15;
    this._filters = null;
    this._stencilCounter = 0;
    this._scissorCounter = 0;
    this._scissorRect = null;
    this._scissorRectLocal = null;
    this._colorMask = 15;
    this._target = null;
  }
  get filter() {
    return this._filters ? this._filters[0] : null;
  }
  set filter(value) {
    if (value) {
      if (this._filters) {
        this._filters[0] = value;
      } else {
        this._filters = [value];
      }
    } else {
      this._filters = null;
    }
  }
  reset() {
    if (this.pooled) {
      this.maskObject = null;
      this.type = MASK_TYPES.NONE;
      this.autoDetect = true;
    }
    this._target = null;
    this._scissorRectLocal = null;
  }
  copyCountersOrReset(maskAbove) {
    if (maskAbove) {
      this._stencilCounter = maskAbove._stencilCounter;
      this._scissorCounter = maskAbove._scissorCounter;
      this._scissorRect = maskAbove._scissorRect;
    } else {
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
    }
  }
}

// node_modules/colord/plugins/names.mjsistener.mj
class MaskSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.enableScissor = true;
    this.alphaMaskPool = [];
    this.maskDataPool = [];
    this.maskStack = [];
    this.alphaMaskIndex = 0;
  }
  setMaskStack(maskStack) {
    this.maskStack = maskStack;
    this.renderer.scissor.setMaskStack(maskStack);
    this.renderer.stencil.setMaskStack(maskStack);
  }
  push(target, maskDataOrTarget) {
    let maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      const d3 = this.maskDataPool.pop() || new MaskData;
      d3.pooled = true;
      d3.maskObject = maskDataOrTarget;
      maskData = d3;
    }
    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    maskData.copyCountersOrReset(maskAbove);
    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;
    if (maskData.autoDetect) {
      this.detect(maskData);
    }
    maskData._target = target;
    if (maskData.type !== MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.pushColorMask(maskData);
          break;
        default:
          break;
      }
    }
    if (maskData.type === MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
  }
  pop(target) {
    const maskData = this.maskStack.pop();
    if (!maskData || maskData._target !== target) {
      return;
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.pop(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case MASK_TYPES.SPRITE:
          this.popSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.popColorMask(maskData);
          break;
        default:
          break;
      }
    }
    maskData.reset();
    if (maskData.pooled) {
      this.maskDataPool.push(maskData);
    }
    if (this.maskStack.length !== 0) {
      const maskCurrent = this.maskStack[this.maskStack.length - 1];
      if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {
        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
      }
    }
  }
  detect(maskData) {
    const maskObject = maskData.maskObject;
    if (!maskObject) {
      maskData.type = MASK_TYPES.COLOR;
    } else if (maskObject.isSprite) {
      maskData.type = MASK_TYPES.SPRITE;
    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
      maskData.type = MASK_TYPES.SCISSOR;
    } else {
      maskData.type = MASK_TYPES.STENCIL;
    }
  }
  pushSpriteMask(maskData) {
    const { maskObject } = maskData;
    const target = maskData._target;
    let alphaMaskFilter = maskData._filters;
    if (!alphaMaskFilter) {
      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter];
      }
    }
    const renderer = this.renderer;
    const renderTextureSystem = renderer.renderTexture;
    let resolution;
    let multisample;
    if (renderTextureSystem.current) {
      const renderTexture = renderTextureSystem.current;
      resolution = maskData.resolution || renderTexture.resolution;
      multisample = maskData.multisample ?? renderTexture.multisample;
    } else {
      resolution = maskData.resolution || renderer.resolution;
      multisample = maskData.multisample ?? renderer.multisample;
    }
    alphaMaskFilter[0].resolution = resolution;
    alphaMaskFilter[0].multisample = multisample;
    alphaMaskFilter[0].maskSprite = maskObject;
    const stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true);
    renderer.filter.push(target, alphaMaskFilter);
    target.filterArea = stashFilterArea;
    if (!maskData._filters) {
      this.alphaMaskIndex++;
    }
  }
  popSpriteMask(maskData) {
    this.renderer.filter.pop();
    if (maskData._filters) {
      maskData._filters[0].maskSprite = null;
    } else {
      this.alphaMaskIndex--;
      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
    }
  }
  pushColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  popColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  destroy() {
    this.renderer = null;
  }
}
MaskSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "mask"
};
extensions.add(MaskSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
class AbstractMaskSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.maskStack = [];
    this.glConst = 0;
  }
  getStackLength() {
    return this.maskStack.length;
  }
  setMaskStack(maskStack) {
    const { gl } = this.renderer;
    const curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    const newStackLen = this.getStackLength();
    if (newStackLen !== curStackLen) {
      if (newStackLen === 0) {
        gl.disable(this.glConst);
      } else {
        gl.enable(this.glConst);
        this._useCurrent();
      }
    }
  }
  _useCurrent() {
  }
  destroy() {
    this.renderer = null;
    this.maskStack = null;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgl
var tempMatrix2 = new Matrix;
var rectPool = [];
var _ScissorSystem = class extends AbstractMaskSystem {
  constructor(renderer) {
    super(renderer);
    this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._scissorCounter;
    }
    return 0;
  }
  calcScissorRect(maskData) {
    if (maskData._scissorRectLocal) {
      return;
    }
    const prevData = maskData._scissorRect;
    const { maskObject } = maskData;
    const { renderer } = this;
    const renderTextureSystem = renderer.renderTexture;
    const rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle);
    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    if (prevData) {
      rect.fit(prevData);
    }
    maskData._scissorRectLocal = rect;
  }
  static isMatrixRotated(matrix) {
    if (!matrix) {
      return false;
    }
    const { a: a3, b: b3, c: c3, d: d3 } = matrix;
    return (Math.abs(b3) > 0.0001 || Math.abs(c3) > 0.0001) && (Math.abs(a3) > 0.0001 || Math.abs(d3) > 0.0001);
  }
  testScissor(maskData) {
    const { maskObject } = maskData;
    if (!maskObject.isFastRect || !maskObject.isFastRect()) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {
      return false;
    }
    this.calcScissorRect(maskData);
    const rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  }
  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (_ScissorSystem.isMatrixRotated(transform)) {
      return;
    }
    transform = transform ? tempMatrix2.copyFrom(transform) : tempMatrix2.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.renderer.filter.transformAABB(transform, frame);
    frame.fit(bindingDestinationFrame);
    frame.x = Math.round(frame.x * resolution);
    frame.y = Math.round(frame.y * resolution);
    frame.width = Math.round(frame.width * resolution);
    frame.height = Math.round(frame.height * resolution);
  }
  push(maskData) {
    if (!maskData._scissorRectLocal) {
      this.calcScissorRect(maskData);
    }
    const { gl } = this.renderer;
    if (!maskData._scissorRect) {
      gl.enable(gl.SCISSOR_TEST);
    }
    maskData._scissorCounter++;
    maskData._scissorRect = maskData._scissorRectLocal;
    this._useCurrent();
  }
  pop(maskData) {
    const { gl } = this.renderer;
    if (maskData) {
      rectPool.push(maskData._scissorRectLocal);
    }
    if (this.getStackLength() > 0) {
      this._useCurrent();
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  }
  _useCurrent() {
    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    let y3;
    if (this.renderer.renderTexture.current) {
      y3 = rect.y;
    } else {
      y3 = this.renderer.height - rect.height - rect.y;
    }
    this.renderer.gl.scissor(rect.x, y3, rect.width, rect.height);
  }
};
var ScissorSystem = _ScissorSystem;
ScissorSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "scissor"
};
extensions.add(ScissorSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgl
class StencilSystem extends AbstractMaskSystem {
  constructor(renderer) {
    super(renderer);
    this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._stencilCounter;
    }
    return 0;
  }
  push(maskData) {
    const maskObject = maskData.maskObject;
    const { gl } = this.renderer;
    const prevMaskCount = maskData._stencilCounter;
    if (prevMaskCount === 0) {
      this.renderer.framebuffer.forceStencil();
      gl.clearStencil(0);
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.enable(gl.STENCIL_TEST);
    }
    maskData._stencilCounter++;
    const colorMask = maskData._colorMask;
    if (colorMask !== 0) {
      maskData._colorMask = 0;
      gl.colorMask(false, false, false, false);
    }
    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
    maskObject.renderable = true;
    maskObject.render(this.renderer);
    this.renderer.batch.flush();
    maskObject.renderable = false;
    if (colorMask !== 0) {
      maskData._colorMask = colorMask;
      gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
    }
    this._useCurrent();
  }
  pop(maskObject) {
    const gl = this.renderer.gl;
    if (this.getStackLength() === 0) {
      gl.disable(gl.STENCIL_TEST);
    } else {
      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      const colorMask = maskData ? maskData._colorMask : 15;
      if (colorMask !== 0) {
        maskData._colorMask = 0;
        gl.colorMask(false, false, false, false);
      }
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      if (colorMask !== 0) {
        maskData._colorMask = colorMask;
        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
      }
      this._useCurrent();
    }
  }
  _useCurrent() {
    const gl = this.renderer.gl;
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  }
}
StencilSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "stencil"
};
extensions.add(StencilSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle
class PluginSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.plugins = {};
    Object.defineProperties(this.plugins, {
      extract: {
        enumerable: false,
        get() {
          deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract");
          return renderer.extract;
        }
      },
      prepare: {
        enumerable: false,
        get() {
          deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare");
          return renderer.prepare;
        }
      },
      interaction: {
        enumerable: false,
        get() {
          deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events");
          return renderer.events;
        }
      }
    });
  }
  init() {
    const staticMap = this.rendererPlugins;
    for (const o3 in staticMap) {
      this.plugins[o3] = new staticMap[o3](this.renderer);
    }
  }
  destroy() {
    for (const o3 in this.plugins) {
      this.plugins[o3].destroy();
      this.plugins[o3] = null;
    }
  }
}
PluginSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "_plugin"
};
extensions.add(PluginSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
class ProjectionSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.destinationFrame = null;
    this.sourceFrame = null;
    this.defaultFrame = null;
    this.projectionMatrix = new Matrix;
    this.transform = null;
  }
  update(destinationFrame, sourceFrame, resolution, root) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }
    const renderer = this.renderer;
    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
    renderer.globalUniforms.update();
    if (renderer.shader.shader) {
      renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
    }
  }
  calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {
    const pm = this.projectionMatrix;
    const sign2 = !root ? 1 : -1;
    pm.identity();
    pm.a = 1 / sourceFrame.width * 2;
    pm.d = sign2 * (1 / sourceFrame.height * 2);
    pm.tx = -1 - sourceFrame.x * pm.a;
    pm.ty = -sign2 - sourceFrame.y * pm.d;
  }
  setTransform(_matrix) {
  }
  destroy() {
    this.renderer = null;
  }
}
ProjectionSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "projection"
};
extensions.add(ProjectionSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextur
var tempTransform = new Transform;

class GenerateTextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this._tempMatrix = new Matrix;
  }
  generateTexture(displayObject, options) {
    const { region: manualRegion, ...textureOptions } = options || {};
    const region = manualRegion || displayObject.getLocalBounds(null, true);
    if (region.width === 0)
      region.width = 1;
    if (region.height === 0)
      region.height = 1;
    const renderTexture = RenderTexture.create({
      width: region.width,
      height: region.height,
      ...textureOptions
    });
    this._tempMatrix.tx = -region.x;
    this._tempMatrix.ty = -region.y;
    const transform = displayObject.transform;
    displayObject.transform = tempTransform;
    this.renderer.render(displayObject, {
      renderTexture,
      transform: this._tempMatrix,
      skipUpdateTransform: !!displayObject.parent,
      blit: true
    });
    displayObject.transform = transform;
    return renderTexture;
  }
  destroy() {
  }
}
GenerateTextureSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "textureGenerator"
};
extensions.add(GenerateTextureSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsText
var tempRect = new Rectangle;
var tempRect2 = new Rectangle;

class RenderTextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.defaultMaskStack = [];
    this.current = null;
    this.sourceFrame = new Rectangle;
    this.destinationFrame = new Rectangle;
    this.viewportFrame = new Rectangle;
  }
  contextChange() {
    const attributes = this.renderer?.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
  }
  bind(renderTexture = null, sourceFrame, destinationFrame) {
    const renderer = this.renderer;
    this.current = renderTexture;
    let baseTexture;
    let framebuffer;
    let resolution;
    if (renderTexture) {
      baseTexture = renderTexture.baseTexture;
      resolution = baseTexture.resolution;
      if (!sourceFrame) {
        tempRect.width = renderTexture.frame.width;
        tempRect.height = renderTexture.frame.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        tempRect2.x = renderTexture.frame.x;
        tempRect2.y = renderTexture.frame.y;
        tempRect2.width = sourceFrame.width;
        tempRect2.height = sourceFrame.height;
        destinationFrame = tempRect2;
      }
      framebuffer = baseTexture.framebuffer;
    } else {
      resolution = renderer.resolution;
      if (!sourceFrame) {
        tempRect.width = renderer._view.screen.width;
        tempRect.height = renderer._view.screen.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        destinationFrame = tempRect;
        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;
      }
    }
    const viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution;
    viewportFrame.y = destinationFrame.y * resolution;
    viewportFrame.width = destinationFrame.width * resolution;
    viewportFrame.height = destinationFrame.height * resolution;
    if (!renderTexture) {
      viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
    }
    viewportFrame.ceil();
    this.renderer.framebuffer.bind(framebuffer, viewportFrame);
    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
    if (renderTexture) {
      this.renderer.mask.setMaskStack(baseTexture.maskStack);
    } else {
      this.renderer.mask.setMaskStack(this.defaultMaskStack);
    }
    this.sourceFrame.copyFrom(sourceFrame);
    this.destinationFrame.copyFrom(destinationFrame);
  }
  clear(clearColor, mask) {
    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor;
    const color7 = Color.shared.setValue(clearColor ? clearColor : fallbackColor);
    if (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) {
      color7.premultiply(color7.alpha);
    }
    const destinationFrame = this.destinationFrame;
    const baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;
    const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      let { x: x3, y: y3, width, height } = this.viewportFrame;
      x3 = Math.round(x3);
      y3 = Math.round(y3);
      width = Math.round(width);
      height = Math.round(height);
      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
      this.renderer.gl.scissor(x3, y3, width, height);
    }
    this.renderer.framebuffer.clear(color7.red, color7.green, color7.blue, color7.alpha, mask);
    if (clearMask) {
      this.renderer.scissor.pop();
    }
  }
  resize() {
    this.bind(null);
  }
  reset() {
    this.bind(null);
  }
  destroy() {
    this.renderer = null;
  }
}
RenderTextureSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "renderTexture"
};
extensions.add(RenderTextureSystem);
// node_modules/colord/plugins/names.mjsistener.mjs
class GLProgram {
  constructor(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBufferBindings = {};
  }
  destroy() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBufferBindings = null;
    this.program = null;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
var getAttributeData = function(program, gl) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i3 = 0;i3 < totalAttributes; i3++) {
    const attribData = gl.getActiveAttrib(program, i3);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const type = mapType(gl, attribData.type);
    const data = {
      type,
      name: attribData.name,
      size: mapSize(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
var getUniformData = function(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i3 = 0;i3 < totalUniforms; i3++) {
    const uniformData = gl.getActiveUniform(program, i3);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i3,
      type,
      size: uniformData.size,
      isArray,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mj
var generateProgram = function(gl, program) {
  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    const keys = Object.keys(program.attributeData);
    keys.sort((a3, b3) => a3 > b3 ? 1 : -1);
    for (let i3 = 0;i3 < keys.length; i3++) {
      program.attributeData[keys[i3]].location = i3;
      gl.bindAttribLocation(webGLProgram, i3, keys[i3]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i3 in program.uniformData) {
    const data = program.uniformData[i3];
    uniformData[i3] = {
      location: gl.getUniformLocation(webGLProgram, i3),
      value: defaultValue(data.type, data.size)
    };
  }
  const glProgram = new GLProgram(webGLProgram, uniformData);
  return glProgram;
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureEx
var uboUpdate = function(_ud, _uv, _renderer, _syncData, buffer) {
  _renderer.buffer.update(buffer);
};
var createUBOElements = function(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    dataLen: 0,
    dirty: 0
  }));
  let size = 0;
  let chunkSize = 0;
  let offset = 0;
  for (let i3 = 0;i3 < uboElements.length; i3++) {
    const uboElement = uboElements[i3];
    size = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size = Math.max(size, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size;
    if (chunkSize % size !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size;
      chunkSize = size;
    } else {
      uboElement.offset = offset;
      chunkSize += size;
      offset += size;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
};
var getUBOData = function(uniforms, uniformData) {
  const usedUniformDatas = [];
  for (const i3 in uniforms) {
    if (uniformData[i3]) {
      usedUniformDatas.push(uniformData[i3]);
    }
  }
  usedUniformDatas.sort((a3, b3) => a3.index - b3.index);
  return usedUniformDatas;
};
var generateUniformBufferSync = function(group, uniformData) {
  if (!group.autoManage) {
    return { size: 0, syncFunc: uboUpdate };
  }
  const usedUniformDatas = getUBOData(group.uniforms, uniformData);
  const { uboElements, size } = createUBOElements(usedUniformDatas);
  const funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
  for (let i3 = 0;i3 < uboElements.length; i3++) {
    const uboElement = uboElements[i3];
    const uniform = group.uniforms[uboElement.data.name];
    const name = uboElement.data.name;
    let parsed = false;
    for (let j3 = 0;j3 < uniformParsers.length; j3++) {
      const uniformParser = uniformParsers[j3];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push(`offset = ${uboElement.offset / 4};`, uniformParsers[j3].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        const size2 = mapSize(uboElement.data.type);
        const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        const elementSize = size2 / rowSize;
        const remainder = (4 - elementSize % 4) % 4;
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
      } else {
        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
      }
    }
  }
  funcFragments.push(`
       renderer.buffer.update(buffer);
    `);
  return {
    size,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
};
var UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
};
var GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};

// node_modules/colord/plugins/names.mjsistener.mjsgle
var UID5 = 0;
var defaultSyncData = { textureCount: 0, uboCount: 0 };

class ShaderSystem {
  constructor(renderer) {
    this.destroyed = false;
    this.renderer = renderer;
    this.systemCheck();
    this.gl = null;
    this.shader = null;
    this.program = null;
    this.cache = {};
    this._uboCache = {};
    this.id = UID5++;
  }
  systemCheck() {
    if (!unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }
  }
  contextChange(gl) {
    this.gl = gl;
    this.reset();
  }
  bind(shader, dontSync) {
    shader.disposeRunner.add(this);
    shader.uniforms.globals = this.renderer.globalUniforms;
    const program = shader.program;
    const glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    this.shader = shader;
    if (this.program !== program) {
      this.program = program;
      this.gl.useProgram(glProgram.program);
    }
    if (!dontSync) {
      defaultSyncData.textureCount = 0;
      defaultSyncData.uboCount = 0;
      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
    }
    return glProgram;
  }
  setUniforms(uniforms) {
    const shader = this.shader.program;
    const glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  }
  syncUniformGroup(group, syncData) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
      this.syncUniforms(group, glProgram, syncData);
    }
  }
  syncUniforms(group, glProgram, syncData) {
    const syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  }
  createSyncGroups(group) {
    const id = this.getSignature(group, this.shader.program.uniformData, "u");
    if (!this.cache[id]) {
      this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
    }
    group.syncUniforms[this.shader.program.id] = this.cache[id];
    return group.syncUniforms[this.shader.program.id];
  }
  syncUniformBufferGroup(group, name) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
      group.buffer.update();
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
  }
  createSyncBufferGroup(group, glProgram, name) {
    const { gl } = this.renderer;
    this.renderer.buffer.bind(group.buffer);
    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
    this.shader.uniformBindCount++;
    const id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    let uboData = this._uboCache[id];
    if (!uboData) {
      uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);
    }
    if (group.autoManage) {
      const data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    glProgram.uniformGroups[group.id] = uboData.syncFunc;
    return glProgram.uniformGroups[group.id];
  }
  getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms;
    const strings = [`${preFix}-`];
    for (const i3 in uniforms) {
      strings.push(i3);
      if (uniformData[i3]) {
        strings.push(uniformData[i3].type);
      }
    }
    return strings.join("-");
  }
  getGlProgram() {
    if (this.shader) {
      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
    }
    return null;
  }
  generateProgram(shader) {
    const gl = this.gl;
    const program = shader.program;
    const glProgram = generateProgram(gl, program);
    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
    return glProgram;
  }
  reset() {
    this.program = null;
    this.shader = null;
  }
  disposeShader(shader) {
    if (this.shader === shader) {
      this.shader = null;
    }
  }
  destroy() {
    this.renderer = null;
    this.destroyed = true;
  }
}
ShaderSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "shader"
};
extensions.add(ShaderSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.m
class StartupSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  run(options) {
    const { renderer } = this;
    renderer.runners.init.emit(renderer.options);
    if (options.hello) {
      console.log(`PixiJS ${"7.2.4"} - ${renderer.rendererLogId} - https://pixijs.com`);
    }
    renderer.resize(renderer.screen.width, renderer.screen.height);
  }
  destroy() {
  }
}
StartupSystem.defaultOptions = {
  hello: false
};
StartupSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "startup"
};
extensions.add(StartupSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTexture
var mapWebGLBlendModesToPixi = function(gl, array = []) {
  array[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
  array[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.NONE] = [0, 0];
  array[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array;
};

// node_modules/colord/plugins/names.mjsistener.mjsg
var BLEND2 = 0;
var OFFSET2 = 1;
var CULLING2 = 2;
var DEPTH_TEST2 = 3;
var WINDING2 = 4;
var DEPTH_MASK2 = 5;
var _StateSystem = class {
  constructor() {
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = BLEND_MODES.NONE;
    this._blendEq = false;
    this.map = [];
    this.map[BLEND2] = this.setBlend;
    this.map[OFFSET2] = this.setOffset;
    this.map[CULLING2] = this.setCullFace;
    this.map[DEPTH_TEST2] = this.setDepthTest;
    this.map[WINDING2] = this.setFrontFace;
    this.map[DEPTH_MASK2] = this.setDepthMask;
    this.checks = [];
    this.defaultState = new State;
    this.defaultState.blend = true;
  }
  contextChange(gl) {
    this.gl = gl;
    this.blendModes = mapWebGLBlendModesToPixi(gl);
    this.set(this.defaultState);
    this.reset();
  }
  set(state) {
    state = state || this.defaultState;
    if (this.stateId !== state.data) {
      let diff = this.stateId ^ state.data;
      let i3 = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i3].call(this, !!(state.data & 1 << i3));
        }
        diff = diff >> 1;
        i3++;
      }
      this.stateId = state.data;
    }
    for (let i3 = 0;i3 < this.checks.length; i3++) {
      this.checks[i3](this, state);
    }
  }
  forceState(state) {
    state = state || this.defaultState;
    for (let i3 = 0;i3 < this.map.length; i3++) {
      this.map[i3].call(this, !!(state.data & 1 << i3));
    }
    for (let i3 = 0;i3 < this.checks.length; i3++) {
      this.checks[i3](this, state);
    }
    this.stateId = state.data;
  }
  setBlend(value) {
    this.updateCheck(_StateSystem.checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  }
  setOffset(value) {
    this.updateCheck(_StateSystem.checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  setDepthTest(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  setDepthMask(value) {
    this.gl.depthMask(value);
  }
  setCullFace(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  }
  setFrontFace(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  }
  setBlendMode(value) {
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    const mode = this.blendModes[value];
    const gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  }
  setPolygonOffset(value, scale3) {
    this.gl.polygonOffset(value, scale3);
  }
  reset() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = -1;
    this.setBlendMode(0);
  }
  updateCheck(func, value) {
    const index2 = this.checks.indexOf(func);
    if (value && index2 === -1) {
      this.checks.push(func);
    } else if (!value && index2 !== -1) {
      this.checks.splice(index2, 1);
    }
  }
  static checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  static checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  destroy() {
    this.gl = null;
  }
};
var StateSystem = _StateSystem;
StateSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "state"
};
extensions.add(StateSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.
class SystemManager extends import_eventemitter3.default {
  constructor() {
    super(...arguments);
    this.runners = {};
    this._systemsHash = {};
  }
  setup(config) {
    this.addRunners(...config.runners);
    const priority = (config.priority ?? []).filter((key) => config.systems[key]);
    const orderByPriority = [
      ...priority,
      ...Object.keys(config.systems).filter((key) => !priority.includes(key))
    ];
    for (const i3 of orderByPriority) {
      this.addSystem(config.systems[i3], i3);
    }
  }
  addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new Runner(runnerId);
    });
  }
  addSystem(ClassRef, name) {
    const system = new ClassRef(this);
    if (this[name]) {
      throw new Error(`Whoops! The name "${name}" is already in use`);
    }
    this[name] = system;
    this._systemsHash[name] = system;
    for (const i3 in this.runners) {
      this.runners[i3].add(system);
    }
    return this;
  }
  emitWithCustomOptions(runner7, options) {
    const systemHashKeys = Object.keys(this._systemsHash);
    runner7.items.forEach((system) => {
      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
      system[runner7.name](options[systemName]);
    });
  }
  destroy() {
    Object.values(this.runners).forEach((runner7) => {
      runner7.destroy();
    });
    this._systemsHash = {};
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2
var _TextureGCSystem = class {
  constructor(renderer) {
    this.renderer = renderer;
    this.count = 0;
    this.checkCount = 0;
    this.maxIdle = _TextureGCSystem.defaultMaxIdle;
    this.checkCountMax = _TextureGCSystem.defaultCheckCountMax;
    this.mode = _TextureGCSystem.defaultMode;
  }
  postrender() {
    if (!this.renderer.objectRenderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (this.mode === GC_MODES.MANUAL) {
      return;
    }
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  }
  run() {
    const tm = this.renderer.texture;
    const managedTextures = tm.managedTextures;
    let wasRemoved = false;
    for (let i3 = 0;i3 < managedTextures.length; i3++) {
      const texture3 = managedTextures[i3];
      if (!texture3.framebuffer && this.count - texture3.touched > this.maxIdle) {
        tm.destroyTexture(texture3, true);
        managedTextures[i3] = null;
        wasRemoved = true;
      }
    }
    if (wasRemoved) {
      let j3 = 0;
      for (let i3 = 0;i3 < managedTextures.length; i3++) {
        if (managedTextures[i3] !== null) {
          managedTextures[j3++] = managedTextures[i3];
        }
      }
      managedTextures.length = j3;
    }
  }
  unload(displayObject) {
    const tm = this.renderer.texture;
    const texture3 = displayObject._texture;
    if (texture3 && !texture3.framebuffer) {
      tm.destroyTexture(texture3);
    }
    for (let i3 = displayObject.children.length - 1;i3 >= 0; i3--) {
      this.unload(displayObject.children[i3]);
    }
  }
  destroy() {
    this.renderer = null;
  }
};
var TextureGCSystem = _TextureGCSystem;
TextureGCSystem.defaultMode = GC_MODES.AUTO;
TextureGCSystem.defaultMaxIdle = 60 * 60;
TextureGCSystem.defaultCheckCountMax = 60 * 10;
TextureGCSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "textureGC"
};
extensions.add(TextureGCSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgl
class GLTexture {
  constructor(texture3) {
    this.texture = texture3;
    this.width = -1;
    this.height = -1;
    this.dirtyId = -1;
    this.dirtyStyleId = -1;
    this.mipmap = false;
    this.wrapMode = 33071;
    this.type = TYPES.UNSIGNED_BYTE;
    this.internalFormat = FORMATS.RGBA;
    this.samplerType = 0;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExtensions.
var mapTypeAndFormatToInternalFormat = function(gl) {
  let table;
  if (("WebGL2RenderingContext" in globalThis) && gl instanceof globalThis.WebGL2RenderingContext) {
    table = {
      [TYPES.UNSIGNED_BYTE]: {
        [FORMATS.RGBA]: gl.RGBA8,
        [FORMATS.RGB]: gl.RGB8,
        [FORMATS.RG]: gl.RG8,
        [FORMATS.RED]: gl.R8,
        [FORMATS.RGBA_INTEGER]: gl.RGBA8UI,
        [FORMATS.RGB_INTEGER]: gl.RGB8UI,
        [FORMATS.RG_INTEGER]: gl.RG8UI,
        [FORMATS.RED_INTEGER]: gl.R8UI,
        [FORMATS.ALPHA]: gl.ALPHA,
        [FORMATS.LUMINANCE]: gl.LUMINANCE,
        [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [TYPES.BYTE]: {
        [FORMATS.RGBA]: gl.RGBA8_SNORM,
        [FORMATS.RGB]: gl.RGB8_SNORM,
        [FORMATS.RG]: gl.RG8_SNORM,
        [FORMATS.RED]: gl.R8_SNORM,
        [FORMATS.RGBA_INTEGER]: gl.RGBA8I,
        [FORMATS.RGB_INTEGER]: gl.RGB8I,
        [FORMATS.RG_INTEGER]: gl.RG8I,
        [FORMATS.RED_INTEGER]: gl.R8I
      },
      [TYPES.UNSIGNED_SHORT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA16UI,
        [FORMATS.RGB_INTEGER]: gl.RGB16UI,
        [FORMATS.RG_INTEGER]: gl.RG16UI,
        [FORMATS.RED_INTEGER]: gl.R16UI,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16
      },
      [TYPES.SHORT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA16I,
        [FORMATS.RGB_INTEGER]: gl.RGB16I,
        [FORMATS.RG_INTEGER]: gl.RG16I,
        [FORMATS.RED_INTEGER]: gl.R16I
      },
      [TYPES.UNSIGNED_INT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA32UI,
        [FORMATS.RGB_INTEGER]: gl.RGB32UI,
        [FORMATS.RG_INTEGER]: gl.RG32UI,
        [FORMATS.RED_INTEGER]: gl.R32UI,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24
      },
      [TYPES.INT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA32I,
        [FORMATS.RGB_INTEGER]: gl.RGB32I,
        [FORMATS.RG_INTEGER]: gl.RG32I,
        [FORMATS.RED_INTEGER]: gl.R32I
      },
      [TYPES.FLOAT]: {
        [FORMATS.RGBA]: gl.RGBA32F,
        [FORMATS.RGB]: gl.RGB32F,
        [FORMATS.RG]: gl.RG32F,
        [FORMATS.RED]: gl.R32F,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F
      },
      [TYPES.HALF_FLOAT]: {
        [FORMATS.RGBA]: gl.RGBA16F,
        [FORMATS.RGB]: gl.RGB16F,
        [FORMATS.RG]: gl.RG16F,
        [FORMATS.RED]: gl.R16F
      },
      [TYPES.UNSIGNED_SHORT_5_6_5]: {
        [FORMATS.RGB]: gl.RGB565
      },
      [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [FORMATS.RGBA]: gl.RGBA4
      },
      [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [FORMATS.RGBA]: gl.RGB5_A1
      },
      [TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
        [FORMATS.RGBA]: gl.RGB10_A2,
        [FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI
      },
      [TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
        [FORMATS.RGB]: gl.R11F_G11F_B10F
      },
      [TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
        [FORMATS.RGB]: gl.RGB9_E5
      },
      [TYPES.UNSIGNED_INT_24_8]: {
        [FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8
      },
      [TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
        [FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8
      }
    };
  } else {
    table = {
      [TYPES.UNSIGNED_BYTE]: {
        [FORMATS.RGBA]: gl.RGBA,
        [FORMATS.RGB]: gl.RGB,
        [FORMATS.ALPHA]: gl.ALPHA,
        [FORMATS.LUMINANCE]: gl.LUMINANCE,
        [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [TYPES.UNSIGNED_SHORT_5_6_5]: {
        [FORMATS.RGB]: gl.RGB
      },
      [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [FORMATS.RGBA]: gl.RGBA
      },
      [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [FORMATS.RGBA]: gl.RGBA
      }
    };
  }
  return table;
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mj
class TextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.boundTextures = [];
    this.currentLocation = -1;
    this.managedTextures = [];
    this._unknownBoundTextures = false;
    this.unknownTexture = new BaseTexture;
    this.hasIntegerTextures = false;
  }
  contextChange() {
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.webGLVersion = this.renderer.context.webGLVersion;
    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (let i3 = 0;i3 < maxTextures; i3++) {
      this.boundTextures[i3] = null;
    }
    this.emptyTextures = {};
    const emptyTexture2D = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (let i3 = 0;i3 < 6; i3++) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (let i3 = 0;i3 < this.boundTextures.length; i3++) {
      this.bind(null, i3);
    }
  }
  bind(texture3, location = 0) {
    const { gl } = this;
    texture3 = texture3?.castToBaseTexture();
    if (texture3?.valid && !texture3.parentTextureArray) {
      texture3.touched = this.renderer.textureGC.count;
      const glTexture = texture3._glTextures[this.CONTEXT_UID] || this.initTexture(texture3);
      if (this.boundTextures[location] !== texture3) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(texture3.target, glTexture.texture);
      }
      if (glTexture.dirtyId !== texture3.dirtyId) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        this.updateTexture(texture3);
      } else if (glTexture.dirtyStyleId !== texture3.dirtyStyleId) {
        this.updateTextureStyle(texture3);
      }
      this.boundTextures[location] = texture3;
    } else {
      if (this.currentLocation !== location) {
        this.currentLocation = location;
        gl.activeTexture(gl.TEXTURE0 + location);
      }
      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
      this.boundTextures[location] = null;
    }
  }
  reset() {
    this._unknownBoundTextures = true;
    this.hasIntegerTextures = false;
    this.currentLocation = -1;
    for (let i3 = 0;i3 < this.boundTextures.length; i3++) {
      this.boundTextures[i3] = this.unknownTexture;
    }
  }
  unbind(texture3) {
    const { gl, boundTextures } = this;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (let i3 = 0;i3 < boundTextures.length; i3++) {
        if (boundTextures[i3] === this.unknownTexture) {
          this.bind(null, i3);
        }
      }
    }
    for (let i3 = 0;i3 < boundTextures.length; i3++) {
      if (boundTextures[i3] === texture3) {
        if (this.currentLocation !== i3) {
          gl.activeTexture(gl.TEXTURE0 + i3);
          this.currentLocation = i3;
        }
        gl.bindTexture(texture3.target, this.emptyTextures[texture3.target].texture);
        boundTextures[i3] = null;
      }
    }
  }
  ensureSamplerType(maxTextures) {
    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
    if (!hasIntegerTextures) {
      return;
    }
    for (let i3 = maxTextures - 1;i3 >= 0; --i3) {
      const tex = boundTextures[i3];
      if (tex) {
        const glTexture = tex._glTextures[CONTEXT_UID];
        if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
          this.renderer.texture.unbind(tex);
        }
      }
    }
  }
  initTexture(texture3) {
    const glTexture = new GLTexture(this.gl.createTexture());
    glTexture.dirtyId = -1;
    texture3._glTextures[this.CONTEXT_UID] = glTexture;
    this.managedTextures.push(texture3);
    texture3.on("dispose", this.destroyTexture, this);
    return glTexture;
  }
  initTextureType(texture3, glTexture) {
    glTexture.internalFormat = this.internalFormats[texture3.type]?.[texture3.format] ?? texture3.format;
    if (this.webGLVersion === 2 && texture3.type === TYPES.HALF_FLOAT) {
      glTexture.type = this.gl.HALF_FLOAT;
    } else {
      glTexture.type = texture3.type;
    }
  }
  updateTexture(texture3) {
    const glTexture = texture3._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    const renderer = this.renderer;
    this.initTextureType(texture3, glTexture);
    if (texture3.resource?.upload(renderer, texture3, glTexture)) {
      if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
        this.hasIntegerTextures = true;
      }
    } else {
      const width = texture3.realWidth;
      const height = texture3.realHeight;
      const gl = renderer.gl;
      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(texture3.target, 0, glTexture.internalFormat, width, height, 0, texture3.format, glTexture.type, null);
      }
    }
    if (texture3.dirtyStyleId !== glTexture.dirtyStyleId) {
      this.updateTextureStyle(texture3);
    }
    glTexture.dirtyId = texture3.dirtyId;
  }
  destroyTexture(texture3, skipRemove) {
    const { gl } = this;
    texture3 = texture3.castToBaseTexture();
    if (texture3._glTextures[this.CONTEXT_UID]) {
      this.unbind(texture3);
      gl.deleteTexture(texture3._glTextures[this.CONTEXT_UID].texture);
      texture3.off("dispose", this.destroyTexture, this);
      delete texture3._glTextures[this.CONTEXT_UID];
      if (!skipRemove) {
        const i3 = this.managedTextures.indexOf(texture3);
        if (i3 !== -1) {
          removeItems(this.managedTextures, i3, 1);
        }
      }
    }
  }
  updateTextureStyle(texture3) {
    const glTexture = texture3._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    if ((texture3.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture3.isPowerOfTwo) {
      glTexture.mipmap = false;
    } else {
      glTexture.mipmap = texture3.mipmap >= 1;
    }
    if (this.webGLVersion !== 2 && !texture3.isPowerOfTwo) {
      glTexture.wrapMode = WRAP_MODES.CLAMP;
    } else {
      glTexture.wrapMode = texture3.wrapMode;
    }
    if (texture3.resource?.style(this.renderer, texture3, glTexture)) {
    } else {
      this.setStyle(texture3, glTexture);
    }
    glTexture.dirtyStyleId = texture3.dirtyStyleId;
  }
  setStyle(texture3, glTexture) {
    const gl = this.gl;
    if (glTexture.mipmap && texture3.mipmap !== MIPMAP_MODES.ON_MANUAL) {
      gl.generateMipmap(texture3.target);
    }
    gl.texParameteri(texture3.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
    gl.texParameteri(texture3.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
    if (glTexture.mipmap) {
      gl.texParameteri(texture3.target, gl.TEXTURE_MIN_FILTER, texture3.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture3.anisotropicLevel > 0 && texture3.scaleMode === SCALE_MODES.LINEAR) {
        const level = Math.min(texture3.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture3.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else {
      gl.texParameteri(texture3.target, gl.TEXTURE_MIN_FILTER, texture3.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(texture3.target, gl.TEXTURE_MAG_FILTER, texture3.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
  }
  destroy() {
    this.renderer = null;
  }
}
TextureSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "texture"
};
extensions.add(TextureSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExten
class TransformFeedbackSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange() {
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(transformFeedback) {
    const { gl, CONTEXT_UID } = this;
    const glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
  }
  unbind() {
    const { gl } = this;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  }
  beginTransformFeedback(drawMode, shader) {
    const { gl, renderer } = this;
    if (shader) {
      renderer.shader.bind(shader);
    }
    gl.beginTransformFeedback(drawMode);
  }
  endTransformFeedback() {
    const { gl } = this;
    gl.endTransformFeedback();
  }
  createGLTransformFeedback(tf) {
    const { gl, renderer, CONTEXT_UID } = this;
    const glTransformFeedback = gl.createTransformFeedback();
    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
    for (let i3 = 0;i3 < tf.buffers.length; i3++) {
      const buffer = tf.buffers[i3];
      if (!buffer)
        continue;
      renderer.buffer.update(buffer);
      buffer._glBuffers[CONTEXT_UID].refCount++;
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i3, buffer._glBuffers[CONTEXT_UID].buffer || null);
    }
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    tf.disposeRunner.add(this);
    return glTransformFeedback;
  }
  disposeTransformFeedback(tf, contextLost) {
    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID];
    const gl = this.gl;
    tf.disposeRunner.remove(this);
    const bufferSystem = this.renderer.buffer;
    if (bufferSystem) {
      for (let i3 = 0;i3 < tf.buffers.length; i3++) {
        const buffer = tf.buffers[i3];
        if (!buffer)
          continue;
        const buf = buffer._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffer, contextLost);
          }
        }
      }
    }
    if (!glTF) {
      return;
    }
    if (!contextLost) {
      gl.deleteTransformFeedback(glTF);
    }
    delete tf._glTransformFeedbacks[this.CONTEXT_UID];
  }
  destroy() {
    this.renderer = null;
  }
}
TransformFeedbackSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "transformFeedback"
};
extensions.add(TransformFeedbackSystem);
// node_modules/colord/plugins/names.mjsistener.mj
class ViewSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  init(options) {
    this.screen = new Rectangle(0, 0, options.width, options.height);
    this.element = options.view || settings.ADAPTER.createCanvas();
    this.resolution = options.resolution || settings.RESOLUTION;
    this.autoDensity = !!options.autoDensity;
  }
  resizeView(desiredScreenWidth, desiredScreenHeight) {
    this.element.width = Math.round(desiredScreenWidth * this.resolution);
    this.element.height = Math.round(desiredScreenHeight * this.resolution);
    const screenWidth = this.element.width / this.resolution;
    const screenHeight = this.element.height / this.resolution;
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;
    if (this.autoDensity) {
      this.element.style.width = `${screenWidth}px`;
      this.element.style.height = `${screenHeight}px`;
    }
    this.renderer.emit("resize", screenWidth, screenHeight);
    this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
  }
  destroy(removeView) {
    if (removeView) {
      this.element.parentNode?.removeChild(this.element);
    }
    this.renderer = null;
    this.element = null;
    this.screen = null;
  }
}
ViewSystem.defaultOptions = {
  width: 800,
  height: 600,
  resolution: settings.RESOLUTION,
  autoDensity: false
};
ViewSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "_view"
};
extensions.add(ViewSystem);
// node_modules/colord/plugins/names.mjsist
settings.PREFER_ENV = ENV.WEBGL2;
settings.STRICT_TEXTURE_CACHE = false;
settings.RENDER_OPTIONS = {
  ...ContextSystem.defaultOptions,
  ...BackgroundSystem.defaultOptions,
  ...ViewSystem.defaultOptions,
  ...StartupSystem.defaultOptions
};
Object.defineProperties(settings, {
  WRAP_MODE: {
    get() {
      return BaseTexture.defaultOptions.wrapMode;
    },
    set(value) {
      deprecation("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode");
      BaseTexture.defaultOptions.wrapMode = value;
    }
  },
  SCALE_MODE: {
    get() {
      return BaseTexture.defaultOptions.scaleMode;
    },
    set(value) {
      deprecation("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode");
      BaseTexture.defaultOptions.scaleMode = value;
    }
  },
  MIPMAP_TEXTURES: {
    get() {
      return BaseTexture.defaultOptions.mipmap;
    },
    set(value) {
      deprecation("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap");
      BaseTexture.defaultOptions.mipmap = value;
    }
  },
  ANISOTROPIC_LEVEL: {
    get() {
      return BaseTexture.defaultOptions.anisotropicLevel;
    },
    set(value) {
      deprecation("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel");
      BaseTexture.defaultOptions.anisotropicLevel = value;
    }
  },
  FILTER_RESOLUTION: {
    get() {
      deprecation("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution");
      return Filter.defaultResolution;
    },
    set(value) {
      Filter.defaultResolution = value;
    }
  },
  FILTER_MULTISAMPLE: {
    get() {
      deprecation("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample");
      return Filter.defaultMultisample;
    },
    set(value) {
      Filter.defaultMultisample = value;
    }
  },
  SPRITE_MAX_TEXTURES: {
    get() {
      return BatchRenderer.defaultMaxTextures;
    },
    set(value) {
      deprecation("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures");
      BatchRenderer.defaultMaxTextures = value;
    }
  },
  SPRITE_BATCH_SIZE: {
    get() {
      return BatchRenderer.defaultBatchSize;
    },
    set(value) {
      deprecation("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize");
      BatchRenderer.defaultBatchSize = value;
    }
  },
  CAN_UPLOAD_SAME_BUFFER: {
    get() {
      return BatchRenderer.canUploadSameBuffer;
    },
    set(value) {
      deprecation("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer");
      BatchRenderer.canUploadSameBuffer = value;
    }
  },
  GC_MODE: {
    get() {
      return TextureGCSystem.defaultMode;
    },
    set(value) {
      deprecation("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode");
      TextureGCSystem.defaultMode = value;
    }
  },
  GC_MAX_IDLE: {
    get() {
      return TextureGCSystem.defaultMaxIdle;
    },
    set(value) {
      deprecation("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle");
      TextureGCSystem.defaultMaxIdle = value;
    }
  },
  GC_MAX_CHECK_COUNT: {
    get() {
      return TextureGCSystem.defaultCheckCountMax;
    },
    set(value) {
      deprecation("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax");
      TextureGCSystem.defaultCheckCountMax = value;
    }
  },
  PRECISION_VERTEX: {
    get() {
      return Program.defaultVertexPrecision;
    },
    set(value) {
      deprecation("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision");
      Program.defaultVertexPrecision = value;
    }
  },
  PRECISION_FRAGMENT: {
    get() {
      return Program.defaultFragmentPrecision;
    },
    set(value) {
      deprecation("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision");
      Program.defaultFragmentPrecision = value;
    }
  }
});
// node_modules/colord/plugins/names.mjsis
var UPDATE_PRIORITY = ((UPDATE_PRIORITY2) => {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
  return UPDATE_PRIORITY2;
})(UPDATE_PRIORITY || {});

// node_modules/colord/plugins/names.mjsistener.mjs
class TickerListener {
  constructor(fn, context2 = null, priority = 0, once = false) {
    this.next = null;
    this.previous = null;
    this._destroyed = false;
    this.fn = fn;
    this.context = context2;
    this.priority = priority;
    this.once = once;
  }
  match(fn, context2 = null) {
    return this.fn === fn && this.context === context2;
  }
  emit(deltaTime) {
    if (this.fn) {
      if (this.context) {
        this.fn.call(this.context, deltaTime);
      } else {
        this.fn(deltaTime);
      }
    }
    const redirect = this.next;
    if (this.once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  }
  connect(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  }
  destroy(hard = false) {
    this._destroyed = true;
    this.fn = null;
    this.context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    const redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  }
}

// node_modules/colord/plugins/names.mjsist
var _Ticker = class {
  constructor() {
    this.autoStart = false;
    this.deltaTime = 1;
    this.lastTime = -1;
    this.speed = 1;
    this.started = false;
    this._requestId = null;
    this._maxElapsedMS = 100;
    this._minElapsedMS = 0;
    this._protected = false;
    this._lastFrame = -1;
    this._head = new TickerListener(null, null, Infinity);
    this.deltaMS = 1 / _Ticker.targetFPMS;
    this.elapsedMS = 1 / _Ticker.targetFPMS;
    this._tick = (time) => {
      this._requestId = null;
      if (this.started) {
        this.update(time);
        if (this.started && this._requestId === null && this._head.next) {
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
    };
  }
  _requestIfNeeded() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  }
  _cancelIfNeeded() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  }
  _startIfPossible() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  }
  add(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context2, priority));
  }
  addOnce(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context2, priority, true));
  }
  _addListener(listener) {
    let current = this._head.next;
    let previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  }
  remove(fn, context2) {
    let listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context2)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  }
  get count() {
    if (!this._head) {
      return 0;
    }
    let count = 0;
    let current = this._head;
    while (current = current.next) {
      count++;
    }
    return count;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  }
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  }
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
      const head = this._head;
      let listener = head.next;
      while (listener) {
        listener = listener.emit(this.deltaTime);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  }
  get FPS() {
    return 1000 / this.elapsedMS;
  }
  get minFPS() {
    return 1000 / this._maxElapsedMS;
  }
  set minFPS(fps) {
    const minFPS = Math.min(this.maxFPS, fps);
    const minFPMS = Math.min(Math.max(0, minFPS) / 1000, _Ticker.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  get maxFPS() {
    if (this._minElapsedMS) {
      return Math.round(1000 / this._minElapsedMS);
    }
    return 0;
  }
  set maxFPS(fps) {
    if (fps === 0) {
      this._minElapsedMS = 0;
    } else {
      const maxFPS = Math.max(this.minFPS, fps);
      this._minElapsedMS = 1 / (maxFPS / 1000);
    }
  }
  static get shared() {
    if (!_Ticker._shared) {
      const shared = _Ticker._shared = new _Ticker;
      shared.autoStart = true;
      shared._protected = true;
    }
    return _Ticker._shared;
  }
  static get system() {
    if (!_Ticker._system) {
      const system = _Ticker._system = new _Ticker;
      system.autoStart = true;
      system._protected = true;
    }
    return _Ticker._system;
  }
};
var Ticker = _Ticker;
Ticker.targetFPMS = 0.06;

// node_modules/colord/plugins/names.mjsisten
Object.defineProperties(settings, {
  TARGET_FPMS: {
    get() {
      return Ticker.targetFPMS;
    },
    set(value) {
      deprecation("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS");
      Ticker.targetFPMS = value;
    }
  }
});
// node_modules/colord/plugins/names.mjsistener.m
class TickerPlugin {
  static init(options) {
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options);
    Object.defineProperty(this, "ticker", {
      set(ticker) {
        if (this._ticker) {
          this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
          ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
        }
      },
      get() {
        return this._ticker;
      }
    });
    this.stop = () => {
      this._ticker.stop();
    };
    this.start = () => {
      this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker;
    if (options.autoStart) {
      this.start();
    }
  }
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  }
}
TickerPlugin.extension = ExtensionType.Application;
extensions.add(TickerPlugin);
// node_modules/colord/plugins/names.mjsistener.mjsgl
var autoDetectRenderer = function(options) {
  for (const RendererType of renderers) {
    if (RendererType.test(options)) {
      return new RendererType(options);
    }
  }
  throw new Error("Unable to auto-detect a suitable renderer.");
};
var renderers = [];
extensions.handleByList(ExtensionType.Renderer, renderers);
// node_modules/colord/plugins/names.mjsistener.mjsg
var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

// node_modules/colord/plugins/names.mjsistener.mj
var defaultVertex4 = $defaultVertex;
var defaultFilterVertex = $defaultFilterVertex;
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
class MultisampleSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange(gl) {
    let samples;
    if (this.renderer.context.webGLVersion === 1) {
      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    if (samples >= MSAA_QUALITY.HIGH) {
      this.multisample = MSAA_QUALITY.HIGH;
    } else if (samples >= MSAA_QUALITY.MEDIUM) {
      this.multisample = MSAA_QUALITY.MEDIUM;
    } else if (samples >= MSAA_QUALITY.LOW) {
      this.multisample = MSAA_QUALITY.LOW;
    } else {
      this.multisample = MSAA_QUALITY.NONE;
    }
  }
  destroy() {
  }
}
MultisampleSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "_multisample"
};
extensions.add(MultisampleSystem);
// node_modules/colord/plugins/names.mjsistener.mjsg
class GLBuffer {
  constructor(buffer) {
    this.buffer = buffer || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.refCount = 0;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.m
class BufferSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.managedBuffers = {};
    this.boundBufferBases = {};
  }
  destroy() {
    this.renderer = null;
  }
  contextChange() {
    this.disposeAll(true);
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(buffer) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBuffer(buffer.type, glBuffer.buffer);
  }
  unbind(type) {
    const { gl } = this;
    gl.bindBuffer(type, null);
  }
  bindBufferBase(buffer, index2) {
    const { gl, CONTEXT_UID } = this;
    if (this.boundBufferBases[index2] !== buffer) {
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      this.boundBufferBases[index2] = buffer;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index2, glBuffer.buffer);
    }
  }
  bindBufferRange(buffer, index2, offset) {
    const { gl, CONTEXT_UID } = this;
    offset = offset || 0;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index2 || 0, glBuffer.buffer, offset * 256, 256);
  }
  update(buffer) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    if (buffer._updateID === glBuffer.updateID) {
      return;
    }
    glBuffer.updateID = buffer._updateID;
    gl.bindBuffer(buffer.type, glBuffer.buffer);
    if (glBuffer.byteLength >= buffer.data.byteLength) {
      gl.bufferSubData(buffer.type, 0, buffer.data);
    } else {
      const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      glBuffer.byteLength = buffer.data.byteLength;
      gl.bufferData(buffer.type, buffer.data, drawType);
    }
  }
  dispose(buffer, contextLost) {
    if (!this.managedBuffers[buffer.id]) {
      return;
    }
    delete this.managedBuffers[buffer.id];
    const glBuffer = buffer._glBuffers[this.CONTEXT_UID];
    const gl = this.gl;
    buffer.disposeRunner.remove(this);
    if (!glBuffer) {
      return;
    }
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    delete buffer._glBuffers[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all = Object.keys(this.managedBuffers);
    for (let i3 = 0;i3 < all.length; i3++) {
      this.dispose(this.managedBuffers[all[i3]], contextLost);
    }
  }
  createGLBuffer(buffer) {
    const { CONTEXT_UID, gl } = this;
    buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
    this.managedBuffers[buffer.id] = buffer;
    buffer.disposeRunner.add(this);
    return buffer._glBuffers[CONTEXT_UID];
  }
}
BufferSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "buffer"
};
extensions.add(BufferSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
class ObjectRendererSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  render(displayObject, options) {
    const renderer = this.renderer;
    let renderTexture;
    let clear;
    let transform;
    let skipUpdateTransform;
    if (options) {
      renderTexture = options.renderTexture;
      clear = options.clear;
      transform = options.transform;
      skipUpdateTransform = options.skipUpdateTransform;
    }
    this.renderingToScreen = !renderTexture;
    renderer.runners.prerender.emit();
    renderer.emit("prerender");
    renderer.projection.transform = transform;
    if (renderer.context.isLost) {
      return;
    }
    if (!renderTexture) {
      this.lastObjectRendered = displayObject;
    }
    if (!skipUpdateTransform) {
      const cacheParent = displayObject.enableTempParent();
      displayObject.updateTransform();
      displayObject.disableTempParent(cacheParent);
    }
    renderer.renderTexture.bind(renderTexture);
    renderer.batch.currentRenderer.start();
    if (clear ?? renderer.background.clearBeforeRender) {
      renderer.renderTexture.clear();
    }
    displayObject.render(renderer);
    renderer.batch.currentRenderer.flush();
    if (renderTexture) {
      if (options.blit) {
        renderer.framebuffer.blit();
      }
      renderTexture.baseTexture.update();
    }
    renderer.runners.postrender.emit();
    renderer.projection.transform = null;
    renderer.emit("postrender");
  }
  destroy() {
    this.renderer = null;
    this.lastObjectRendered = null;
  }
}
ObjectRendererSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "objectRenderer"
};
extensions.add(ObjectRendererSystem);
// node_modules/colord/plugins/names.mjsist
var _Renderer = class extends SystemManager {
  constructor(options) {
    super();
    this.type = RENDERER_TYPE.WEBGL;
    options = Object.assign({}, settings.RENDER_OPTIONS, options);
    this.gl = null;
    this.CONTEXT_UID = 0;
    this.globalUniforms = new UniformGroup({
      projectionMatrix: new Matrix
    }, true);
    const systemConfig = {
      runners: [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "update",
        "postrender",
        "prerender",
        "resize"
      ],
      systems: _Renderer.__systems,
      priority: [
        "_view",
        "textureGenerator",
        "background",
        "_plugin",
        "startup",
        "context",
        "state",
        "texture",
        "buffer",
        "geometry",
        "framebuffer",
        "transformFeedback",
        "mask",
        "scissor",
        "stencil",
        "projection",
        "textureGC",
        "filter",
        "renderTexture",
        "batch",
        "objectRenderer",
        "_multisample"
      ]
    };
    this.setup(systemConfig);
    if ("useContextAlpha" in options) {
      deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead");
      options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied";
      options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha;
    }
    this._plugin.rendererPlugins = _Renderer.__plugins;
    this.options = options;
    this.startup.run(this.options);
  }
  static test(options) {
    if (options?.forceCanvas) {
      return false;
    }
    return isWebGLSupported();
  }
  render(displayObject, options) {
    this.objectRenderer.render(displayObject, options);
  }
  resize(desiredScreenWidth, desiredScreenHeight) {
    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
  }
  reset() {
    this.runners.reset.emit();
    return this;
  }
  clear() {
    this.renderTexture.bind();
    this.renderTexture.clear();
  }
  destroy(removeView = false) {
    this.runners.destroy.items.reverse();
    this.emitWithCustomOptions(this.runners.destroy, {
      _view: removeView
    });
    super.destroy();
  }
  get plugins() {
    return this._plugin.plugins;
  }
  get multisample() {
    return this._multisample.multisample;
  }
  get width() {
    return this._view.element.width;
  }
  get height() {
    return this._view.element.height;
  }
  get resolution() {
    return this._view.resolution;
  }
  set resolution(value) {
    this._view.resolution = value;
    this.runners.resolutionChange.emit(value);
  }
  get autoDensity() {
    return this._view.autoDensity;
  }
  get view() {
    return this._view.element;
  }
  get screen() {
    return this._view.screen;
  }
  get lastObjectRendered() {
    return this.objectRenderer.lastObjectRendered;
  }
  get renderingToScreen() {
    return this.objectRenderer.renderingToScreen;
  }
  get rendererLogId() {
    return `WebGL ${this.context.webGLVersion}`;
  }
  get clearBeforeRender() {
    deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.");
    return this.background.clearBeforeRender;
  }
  get useContextAlpha() {
    deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.");
    return this.context.useContextAlpha;
  }
  get preserveDrawingBuffer() {
    deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context");
    return this.context.preserveDrawingBuffer;
  }
  get backgroundColor() {
    deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    return this.background.color;
  }
  set backgroundColor(value) {
    deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    this.background.color = value;
  }
  get backgroundAlpha() {
    deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    return this.background.alpha;
  }
  set backgroundAlpha(value) {
    deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    this.background.alpha = value;
  }
  get powerPreference() {
    deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context");
    return this.context.powerPreference;
  }
  generateTexture(displayObject, options) {
    return this.textureGenerator.generateTexture(displayObject, options);
  }
};
var Renderer = _Renderer;
Renderer.extension = {
  type: ExtensionType.Renderer,
  priority: 1
};
Renderer.__plugins = {};
Renderer.__systems = {};
extensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
extensions.handleByMap(ExtensionType.RendererSystem, Renderer.__systems);
extensions.add(Renderer);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExte
class AbstractMultiResource extends Resource {
  constructor(length2, options) {
    const { width, height } = options || {};
    super(width, height);
    this.items = [];
    this.itemDirtyIds = [];
    for (let i3 = 0;i3 < length2; i3++) {
      const partTexture = new BaseTexture;
      this.items.push(partTexture);
      this.itemDirtyIds.push(-2);
    }
    this.length = length2;
    this._load = null;
    this.baseTexture = null;
  }
  initFromArray(resources, options) {
    for (let i3 = 0;i3 < this.length; i3++) {
      if (!resources[i3]) {
        continue;
      }
      if (resources[i3].castToBaseTexture) {
        this.addBaseTextureAt(resources[i3].castToBaseTexture(), i3);
      } else if (resources[i3] instanceof Resource) {
        this.addResourceAt(resources[i3], i3);
      } else {
        this.addResourceAt(autoDetectResource(resources[i3], options), i3);
      }
    }
  }
  dispose() {
    for (let i3 = 0, len = this.length;i3 < len; i3++) {
      this.items[i3].destroy();
    }
    this.items = null;
    this.itemDirtyIds = null;
    this._load = null;
  }
  addResourceAt(resource, index2) {
    if (!this.items[index2]) {
      throw new Error(`Index ${index2} is out of bounds`);
    }
    if (resource.valid && !this.valid) {
      this.resize(resource.width, resource.height);
    }
    this.items[index2].setResource(resource);
    return this;
  }
  bind(baseTexture) {
    if (this.baseTexture !== null) {
      throw new Error("Only one base texture per TextureArray is allowed");
    }
    super.bind(baseTexture);
    for (let i3 = 0;i3 < this.length; i3++) {
      this.items[i3].parentTextureArray = baseTexture;
      this.items[i3].on("update", baseTexture.update, baseTexture);
    }
  }
  unbind(baseTexture) {
    super.unbind(baseTexture);
    for (let i3 = 0;i3 < this.length; i3++) {
      this.items[i3].parentTextureArray = null;
      this.items[i3].off("update", baseTexture.update, baseTexture);
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const resources = this.items.map((item) => item.resource).filter((item) => item);
    const promises = resources.map((item) => item.load());
    this._load = Promise.all(promises).then(() => {
      const { realWidth, realHeight } = this.items[0];
      this.resize(realWidth, realHeight);
      return Promise.resolve(this);
    });
    return this._load;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTex
class ArrayResource extends AbstractMultiResource {
  constructor(source, options) {
    const { width, height } = options || {};
    let urls;
    let length2;
    if (Array.isArray(source)) {
      urls = source;
      length2 = source.length;
    } else {
      length2 = source;
    }
    super(length2, { width, height });
    if (urls) {
      this.initFromArray(urls, options);
    }
  }
  addBaseTextureAt(baseTexture, index2) {
    if (baseTexture.resource) {
      this.addResourceAt(baseTexture.resource, index2);
    } else {
      throw new Error("ArrayResource does not support RenderTexture");
    }
    return this;
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
  }
  upload(renderer, texture3, glTexture) {
    const { length: length2, itemDirtyIds, items } = this;
    const { gl } = renderer;
    if (glTexture.dirtyId < 0) {
      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length2, 0, texture3.format, glTexture.type, null);
    }
    for (let i3 = 0;i3 < length2; i3++) {
      const item = items[i3];
      if (itemDirtyIds[i3] < item.dirtyId) {
        itemDirtyIds[i3] = item.dirtyId;
        if (item.valid) {
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i3, item.resource.width, item.resource.height, 1, texture3.format, glTexture.type, item.resource.source);
        }
      }
    }
    return true;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsText
class CanvasResource extends BaseImageResource {
  constructor(source) {
    super(source);
  }
  static test(source) {
    const { OffscreenCanvas: OffscreenCanvas2 } = globalThis;
    if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
      return true;
    }
    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTe
var _CubeResource = class extends AbstractMultiResource {
  constructor(source, options) {
    const { width, height, autoLoad, linkBaseTexture } = options || {};
    if (source && source.length !== _CubeResource.SIDES) {
      throw new Error(`Invalid length. Got ${source.length}, expected 6`);
    }
    super(6, { width, height });
    for (let i3 = 0;i3 < _CubeResource.SIDES; i3++) {
      this.items[i3].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i3;
    }
    this.linkBaseTexture = linkBaseTexture !== false;
    if (source) {
      this.initFromArray(source, options);
    }
    if (autoLoad !== false) {
      this.load();
    }
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
  }
  addBaseTextureAt(baseTexture, index2, linkBaseTexture) {
    if (linkBaseTexture === undefined) {
      linkBaseTexture = this.linkBaseTexture;
    }
    if (!this.items[index2]) {
      throw new Error(`Index ${index2} is out of bounds`);
    }
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index2);
      } else {
        throw new Error(`CubeResource does not support copying of renderTexture.`);
      }
    } else {
      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index2;
      baseTexture.parentTextureArray = this.baseTexture;
      this.items[index2] = baseTexture;
    }
    if (baseTexture.valid && !this.valid) {
      this.resize(baseTexture.realWidth, baseTexture.realHeight);
    }
    this.items[index2] = baseTexture;
    return this;
  }
  upload(renderer, _baseTexture, glTexture) {
    const dirty = this.itemDirtyIds;
    for (let i3 = 0;i3 < _CubeResource.SIDES; i3++) {
      const side = this.items[i3];
      if (dirty[i3] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {
        if (side.valid && side.resource) {
          side.resource.upload(renderer, side, glTexture);
          dirty[i3] = side.dirtyId;
        } else if (dirty[i3] < -1) {
          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
          dirty[i3] = -1;
        }
      }
    }
    return true;
  }
  static test(source) {
    return Array.isArray(source) && source.length === _CubeResource.SIDES;
  }
};
var CubeResource = _CubeResource;
CubeResource.SIDES = 6;
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureEx
class ImageBitmapResource extends BaseImageResource {
  constructor(source, options) {
    options = options || {};
    let baseSource;
    let url3;
    if (typeof source === "string") {
      baseSource = ImageBitmapResource.EMPTY;
      url3 = source;
    } else {
      baseSource = source;
      url3 = null;
    }
    super(baseSource);
    this.url = url3;
    this.crossOrigin = options.crossOrigin ?? true;
    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise(async (resolve, reject) => {
      if (this.url === null) {
        resolve(this);
        return;
      }
      try {
        const response = await settings.ADAPTER.fetch(this.url, {
          mode: this.crossOrigin ? "cors" : "no-cors"
        });
        if (this.destroyed)
          return;
        const imageBlob = await response.blob();
        if (this.destroyed)
          return;
        const imageBitmap = await createImageBitmap(imageBlob, {
          premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
        if (this.destroyed)
          return;
        this.source = imageBitmap;
        this.update();
        resolve(this);
      } catch (e3) {
        if (this.destroyed)
          return;
        reject(e3);
        this.onError.emit(e3);
      }
    });
    return this._load;
  }
  upload(renderer, baseTexture, glTexture) {
    if (!(this.source instanceof ImageBitmap)) {
      this.load();
      return false;
    }
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    return super.upload(renderer, baseTexture, glTexture);
  }
  dispose() {
    if (this.source instanceof ImageBitmap) {
      this.source.close();
    }
    super.dispose();
    this._load = null;
  }
  static test(source) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && (typeof source === "string" || source instanceof ImageBitmap);
  }
  static get EMPTY() {
    ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.ADAPTER.createCanvas(0, 0);
    return ImageBitmapResource._EMPTY;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsT
var _SVGResource = class extends BaseImageResource {
  constructor(sourceBase64, options) {
    options = options || {};
    super(settings.ADAPTER.createCanvas());
    this._width = 0;
    this._height = 0;
    this.svg = sourceBase64;
    this.scale = options.scale || 1;
    this._overrideWidth = options.width;
    this._overrideHeight = options.height;
    this._resolve = null;
    this._crossorigin = options.crossorigin;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise((resolve) => {
      this._resolve = () => {
        this.resize(this.source.width, this.source.height);
        resolve(this);
      };
      if (_SVGResource.SVG_XML.test(this.svg.trim())) {
        if (!btoa) {
          throw new Error("Your browser doesn't support base64 conversions.");
        }
        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
      }
      this._loadSvg();
    });
    return this._load;
  }
  _loadSvg() {
    const tempImage = new Image;
    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
    tempImage.src = this.svg;
    tempImage.onerror = (event) => {
      if (!this._resolve) {
        return;
      }
      tempImage.onerror = null;
      this.onError.emit(event);
    };
    tempImage.onload = () => {
      if (!this._resolve) {
        return;
      }
      const svgWidth = tempImage.width;
      const svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight) {
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      }
      let width = svgWidth * this.scale;
      let height = svgHeight * this.scale;
      if (this._overrideWidth || this._overrideHeight) {
        width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;
        height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;
      }
      width = Math.round(width);
      height = Math.round(height);
      const canvas = this.source;
      canvas.width = width;
      canvas.height = height;
      canvas._pixiId = `canvas_${uid()}`;
      canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
      this._resolve();
      this._resolve = null;
    };
  }
  static getSize(svgString) {
    const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);
    const size = {};
    if (sizeMatch) {
      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }
    return size;
  }
  dispose() {
    super.dispose();
    this._resolve = null;
    this._crossorigin = null;
  }
  static test(source, extension) {
    return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && _SVGResource.SVG_XML.test(source);
  }
};
var SVGResource = _SVGResource;
SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTex
var _VideoResource = class extends BaseImageResource {
  constructor(source, options) {
    options = options || {};
    if (!(source instanceof HTMLVideoElement)) {
      const videoElement = document.createElement("video");
      videoElement.setAttribute("preload", "auto");
      videoElement.setAttribute("webkit-playsinline", "");
      videoElement.setAttribute("playsinline", "");
      if (typeof source === "string") {
        source = [source];
      }
      const firstSrc = source[0].src || source[0];
      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (let i3 = 0;i3 < source.length; ++i3) {
        const sourceElement = document.createElement("source");
        let { src, mime } = source[i3];
        src = src || source[i3];
        const baseSrc = src.split("?").shift().toLowerCase();
        const ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
        mime = mime || _VideoResource.MIME_TYPES[ext] || `video/${ext}`;
        sourceElement.src = src;
        sourceElement.type = mime;
        videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    super(source);
    this.noSubImage = true;
    this._autoUpdate = true;
    this._isConnectedToTicker = false;
    this._updateFPS = options.updateFPS || 0;
    this._msToNextUpdate = 0;
    this.autoPlay = options.autoPlay !== false;
    this._load = null;
    this._resolve = null;
    this._onCanPlay = this._onCanPlay.bind(this);
    this._onError = this._onError.bind(this);
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  update(_deltaTime = 0) {
    if (!this.destroyed) {
      const elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        super.update();
        this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;
      }
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const source = this.source;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart.bind(this));
    source.addEventListener("pause", this._onPlayStop.bind(this));
    if (!this._isSourceReady()) {
      source.addEventListener("canplay", this._onCanPlay);
      source.addEventListener("canplaythrough", this._onCanPlay);
      source.addEventListener("error", this._onError, true);
    } else {
      this._onCanPlay();
    }
    this._load = new Promise((resolve) => {
      if (this.valid) {
        resolve(this);
      } else {
        this._resolve = resolve;
        source.load();
      }
    });
    return this._load;
  }
  _onError(event) {
    this.source.removeEventListener("error", this._onError, true);
    this.onError.emit(event);
  }
  _isSourcePlaying() {
    const source = this.source;
    return !source.paused && !source.ended && this._isSourceReady();
  }
  _isSourceReady() {
    const source = this.source;
    return source.readyState > 2;
  }
  _onPlayStart() {
    if (!this.valid) {
      this._onCanPlay();
    }
    if (this.autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this);
      this._isConnectedToTicker = true;
    }
  }
  _onPlayStop() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  _onCanPlay() {
    const source = this.source;
    source.removeEventListener("canplay", this._onCanPlay);
    source.removeEventListener("canplaythrough", this._onCanPlay);
    const valid = this.valid;
    this.resize(source.videoWidth, source.videoHeight);
    if (!valid && this._resolve) {
      this._resolve(this);
      this._resolve = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      source.play();
    }
  }
  dispose() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
    const source = this.source;
    if (source) {
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    super.dispose();
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value) {
    if (value !== this._updateFPS) {
      this._updateFPS = value;
    }
  }
  static test(source, extension) {
    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);
  }
};
var VideoResource = _VideoResource;
VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
VideoResource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2
INSTALLED.push(ImageBitmapResource, ImageResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
// node_modules/colord/plugins/names.mjsiste
class Bounds {
  constructor() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = (-Infinity);
    this.maxY = (-Infinity);
    this.rect = null;
    this.updateID = -1;
  }
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  clear() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = (-Infinity);
    this.maxY = (-Infinity);
  }
  getRectangle(rect) {
    if (this.minX > this.maxX || this.minY > this.maxY) {
      return Rectangle.EMPTY;
    }
    rect = rect || new Rectangle(0, 0, 1, 1);
    rect.x = this.minX;
    rect.y = this.minY;
    rect.width = this.maxX - this.minX;
    rect.height = this.maxY - this.minY;
    return rect;
  }
  addPoint(point) {
    this.minX = Math.min(this.minX, point.x);
    this.maxX = Math.max(this.maxX, point.x);
    this.minY = Math.min(this.minY, point.y);
    this.maxY = Math.max(this.maxY, point.y);
  }
  addPointMatrix(matrix, point) {
    const { a: a3, b: b3, c: c3, d: d3, tx, ty } = matrix;
    const x3 = a3 * point.x + c3 * point.y + tx;
    const y3 = b3 * point.x + d3 * point.y + ty;
    this.minX = Math.min(this.minX, x3);
    this.maxX = Math.max(this.maxX, x3);
    this.minY = Math.min(this.minY, y3);
    this.maxY = Math.max(this.maxY, y3);
  }
  addQuad(vertices) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x3 = vertices[0];
    let y3 = vertices[1];
    minX = x3 < minX ? x3 : minX;
    minY = y3 < minY ? y3 : minY;
    maxX = x3 > maxX ? x3 : maxX;
    maxY = y3 > maxY ? y3 : maxY;
    x3 = vertices[2];
    y3 = vertices[3];
    minX = x3 < minX ? x3 : minX;
    minY = y3 < minY ? y3 : minY;
    maxX = x3 > maxX ? x3 : maxX;
    maxY = y3 > maxY ? y3 : maxY;
    x3 = vertices[4];
    y3 = vertices[5];
    minX = x3 < minX ? x3 : minX;
    minY = y3 < minY ? y3 : minY;
    maxX = x3 > maxX ? x3 : maxX;
    maxY = y3 > maxY ? y3 : maxY;
    x3 = vertices[6];
    y3 = vertices[7];
    minX = x3 < minX ? x3 : minX;
    minY = y3 < minY ? y3 : minY;
    maxX = x3 > maxX ? x3 : maxX;
    maxY = y3 > maxY ? y3 : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addFrame(transform, x0, y0, x1, y1) {
    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
  }
  addFrameMatrix(matrix, x0, y0, x1, y1) {
    const a3 = matrix.a;
    const b3 = matrix.b;
    const c3 = matrix.c;
    const d3 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x3 = a3 * x0 + c3 * y0 + tx;
    let y3 = b3 * x0 + d3 * y0 + ty;
    minX = x3 < minX ? x3 : minX;
    minY = y3 < minY ? y3 : minY;
    maxX = x3 > maxX ? x3 : maxX;
    maxY = y3 > maxY ? y3 : maxY;
    x3 = a3 * x1 + c3 * y0 + tx;
    y3 = b3 * x1 + d3 * y0 + ty;
    minX = x3 < minX ? x3 : minX;
    minY = y3 < minY ? y3 : minY;
    maxX = x3 > maxX ? x3 : maxX;
    maxY = y3 > maxY ? y3 : maxY;
    x3 = a3 * x0 + c3 * y1 + tx;
    y3 = b3 * x0 + d3 * y1 + ty;
    minX = x3 < minX ? x3 : minX;
    minY = y3 < minY ? y3 : minY;
    maxX = x3 > maxX ? x3 : maxX;
    maxY = y3 > maxY ? y3 : maxY;
    x3 = a3 * x1 + c3 * y1 + tx;
    y3 = b3 * x1 + d3 * y1 + ty;
    minX = x3 < minX ? x3 : minX;
    minY = y3 < minY ? y3 : minY;
    maxX = x3 > maxX ? x3 : maxX;
    maxY = y3 > maxY ? y3 : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertexData(vertexData, beginOffset, endOffset) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i3 = beginOffset;i3 < endOffset; i3 += 2) {
      const x3 = vertexData[i3];
      const y3 = vertexData[i3 + 1];
      minX = x3 < minX ? x3 : minX;
      minY = y3 < minY ? y3 : minY;
      maxX = x3 > maxX ? x3 : maxX;
      maxY = y3 > maxY ? y3 : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertices(transform, vertices, beginOffset, endOffset) {
    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
  }
  addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
    const a3 = matrix.a;
    const b3 = matrix.b;
    const c3 = matrix.c;
    const d3 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i3 = beginOffset;i3 < endOffset; i3 += 2) {
      const rawX = vertices[i3];
      const rawY = vertices[i3 + 1];
      const x3 = a3 * rawX + c3 * rawY + tx;
      const y3 = d3 * rawY + b3 * rawX + ty;
      minX = Math.min(minX, x3 - padX);
      maxX = Math.max(maxX, x3 + padX);
      minY = Math.min(minY, y3 - padY);
      maxY = Math.max(maxY, y3 + padY);
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addBounds(bounds) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    this.minX = bounds.minX < minX ? bounds.minX : minX;
    this.minY = bounds.minY < minY ? bounds.minY : minY;
    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
  }
  addBoundsMask(bounds, mask) {
    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
    const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
    const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
    const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  addBoundsMatrix(bounds, matrix) {
    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
  }
  addBoundsArea(bounds, area) {
    const _minX = bounds.minX > area.x ? bounds.minX : area.x;
    const _minY = bounds.minY > area.y ? bounds.minY : area.y;
    const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
    const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  pad(paddingX = 0, paddingY = paddingX) {
    if (!this.isEmpty()) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
    }
  }
  addFramePad(x0, y0, x1, y1, padX, padY) {
    x0 -= padX;
    y0 -= padY;
    x1 += padX;
    y1 += padY;
    this.minX = this.minX < x0 ? this.minX : x0;
    this.maxX = this.maxX > x1 ? this.maxX : x1;
    this.minY = this.minY < y0 ? this.minY : y0;
    this.maxY = this.maxY > y1 ? this.maxY : y1;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjs
class DisplayObject extends exports_lib.EventEmitter {
  constructor() {
    super();
    this.tempDisplayObjectParent = null;
    this.transform = new Transform;
    this.alpha = 1;
    this.visible = true;
    this.renderable = true;
    this.cullable = false;
    this.cullArea = null;
    this.parent = null;
    this.worldAlpha = 1;
    this._lastSortedIndex = 0;
    this._zIndex = 0;
    this.filterArea = null;
    this.filters = null;
    this._enabledFilters = null;
    this._bounds = new Bounds;
    this._localBounds = null;
    this._boundsID = 0;
    this._boundsRect = null;
    this._localBoundsRect = null;
    this._mask = null;
    this._maskRefCount = 0;
    this._destroyed = false;
    this.isSprite = false;
    this.isMask = false;
  }
  static mixin(source) {
    const keys = Object.keys(source);
    for (let i3 = 0;i3 < keys.length; ++i3) {
      const propertyName = keys[i3];
      Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get destroyed() {
    return this._destroyed;
  }
  _recursivePostUpdateTransform() {
    if (this.parent) {
      this.parent._recursivePostUpdateTransform();
      this.transform.updateTransform(this.parent.transform);
    } else {
      this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }
  }
  updateTransform() {
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
  }
  getBounds(skipUpdate, rect) {
    if (!skipUpdate) {
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this._recursivePostUpdateTransform();
        this.updateTransform();
      }
    }
    if (this._bounds.updateID !== this._boundsID) {
      this.calculateBounds();
      this._bounds.updateID = this._boundsID;
    }
    if (!rect) {
      if (!this._boundsRect) {
        this._boundsRect = new Rectangle;
      }
      rect = this._boundsRect;
    }
    return this._bounds.getRectangle(rect);
  }
  getLocalBounds(rect) {
    if (!rect) {
      if (!this._localBoundsRect) {
        this._localBoundsRect = new Rectangle;
      }
      rect = this._localBoundsRect;
    }
    if (!this._localBounds) {
      this._localBounds = new Bounds;
    }
    const transformRef = this.transform;
    const parentRef = this.parent;
    this.parent = null;
    this.transform = this._tempDisplayObjectParent.transform;
    const worldBounds = this._bounds;
    const worldBoundsID = this._boundsID;
    this._bounds = this._localBounds;
    const bounds = this.getBounds(false, rect);
    this.parent = parentRef;
    this.transform = transformRef;
    this._bounds = worldBounds;
    this._bounds.updateID += this._boundsID - worldBoundsID;
    return bounds;
  }
  toGlobal(position, point, skipUpdate = false) {
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.apply(position, point);
  }
  toLocal(position, from, point, skipUpdate) {
    if (from) {
      position = from.toGlobal(position, point, skipUpdate);
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.applyInverse(position, point);
  }
  setParent(container) {
    if (!container || !container.addChild) {
      throw new Error("setParent: Argument must be a Container");
    }
    container.addChild(this);
    return container;
  }
  removeFromParent() {
    this.parent?.removeChild(this);
  }
  setTransform(x3 = 0, y3 = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
    this.position.x = x3;
    this.position.y = y3;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation;
    this.skew.x = skewX;
    this.skew.y = skewY;
    this.pivot.x = pivotX;
    this.pivot.y = pivotY;
    return this;
  }
  destroy(_options) {
    this.removeFromParent();
    this._destroyed = true;
    this.transform = null;
    this.parent = null;
    this._bounds = null;
    this.mask = null;
    this.cullArea = null;
    this.filters = null;
    this.filterArea = null;
    this.hitArea = null;
    this.eventMode = "auto";
    this.interactiveChildren = false;
    this.emit("destroyed");
    this.removeAllListeners();
  }
  get _tempDisplayObjectParent() {
    if (this.tempDisplayObjectParent === null) {
      this.tempDisplayObjectParent = new TemporaryDisplayObject;
    }
    return this.tempDisplayObjectParent;
  }
  enableTempParent() {
    const myParent = this.parent;
    this.parent = this._tempDisplayObjectParent;
    return myParent;
  }
  disableTempParent(cacheParent) {
    this.parent = cacheParent;
  }
  get x() {
    return this.position.x;
  }
  set x(value) {
    this.transform.position.x = value;
  }
  get y() {
    return this.position.y;
  }
  set y(value) {
    this.transform.position.y = value;
  }
  get worldTransform() {
    return this.transform.worldTransform;
  }
  get localTransform() {
    return this.transform.localTransform;
  }
  get position() {
    return this.transform.position;
  }
  set position(value) {
    this.transform.position.copyFrom(value);
  }
  get scale() {
    return this.transform.scale;
  }
  set scale(value) {
    this.transform.scale.copyFrom(value);
  }
  get pivot() {
    return this.transform.pivot;
  }
  set pivot(value) {
    this.transform.pivot.copyFrom(value);
  }
  get skew() {
    return this.transform.skew;
  }
  set skew(value) {
    this.transform.skew.copyFrom(value);
  }
  get rotation() {
    return this.transform.rotation;
  }
  set rotation(value) {
    this.transform.rotation = value;
  }
  get angle() {
    return this.transform.rotation * RAD_TO_DEG;
  }
  set angle(value) {
    this.transform.rotation = value * DEG_TO_RAD;
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    if (this.parent) {
      this.parent.sortDirty = true;
    }
  }
  get worldVisible() {
    let item = this;
    do {
      if (!item.visible) {
        return false;
      }
      item = item.parent;
    } while (item);
    return true;
  }
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask === value) {
      return;
    }
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        maskObject._maskRefCount--;
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = true;
          maskObject.isMask = false;
        }
      }
    }
    this._mask = value;
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = false;
          maskObject.isMask = true;
        }
        maskObject._maskRefCount++;
      }
    }
  }
}

class TemporaryDisplayObject extends DisplayObject {
  constructor() {
    super(...arguments);
    this.sortDirty = null;
  }
}
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;

// node_modules/colord/plugins/names.mjsistener
var sortChildren = function(a3, b3) {
  if (a3.zIndex === b3.zIndex) {
    return a3._lastSortedIndex - b3._lastSortedIndex;
  }
  return a3.zIndex - b3.zIndex;
};
var tempMatrix3 = new Matrix;
var _Container = class extends DisplayObject {
  constructor() {
    super();
    this.children = [];
    this.sortableChildren = _Container.defaultSortableChildren;
    this.sortDirty = false;
  }
  onChildrenChange(_length) {
  }
  addChild(...children) {
    if (children.length > 1) {
      for (let i3 = 0;i3 < children.length; i3++) {
        this.addChild(children[i3]);
      }
    } else {
      const child = children[0];
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.push(child);
      this._boundsID++;
      this.onChildrenChange(this.children.length - 1);
      this.emit("childAdded", child, this, this.children.length - 1);
      child.emit("added", this);
    }
    return children[0];
  }
  addChildAt(child, index2) {
    if (index2 < 0 || index2 > this.children.length) {
      throw new Error(`${child}addChildAt: The index ${index2} supplied is out of bounds ${this.children.length}`);
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.sortDirty = true;
    child.transform._parentID = -1;
    this.children.splice(index2, 0, child);
    this._boundsID++;
    this.onChildrenChange(index2);
    child.emit("added", this);
    this.emit("childAdded", child, this, index2);
    return child;
  }
  swapChildren(child, child2) {
    if (child === child2) {
      return;
    }
    const index1 = this.getChildIndex(child);
    const index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
  }
  getChildIndex(child) {
    const index2 = this.children.indexOf(child);
    if (index2 === -1) {
      throw new Error("The supplied DisplayObject must be a child of the caller");
    }
    return index2;
  }
  setChildIndex(child, index2) {
    if (index2 < 0 || index2 >= this.children.length) {
      throw new Error(`The index ${index2} supplied is out of bounds ${this.children.length}`);
    }
    const currentIndex = this.getChildIndex(child);
    exports_lib.removeItems(this.children, currentIndex, 1);
    this.children.splice(index2, 0, child);
    this.onChildrenChange(index2);
  }
  getChildAt(index2) {
    if (index2 < 0 || index2 >= this.children.length) {
      throw new Error(`getChildAt: Index (${index2}) does not exist.`);
    }
    return this.children[index2];
  }
  removeChild(...children) {
    if (children.length > 1) {
      for (let i3 = 0;i3 < children.length; i3++) {
        this.removeChild(children[i3]);
      }
    } else {
      const child = children[0];
      const index2 = this.children.indexOf(child);
      if (index2 === -1)
        return null;
      child.parent = null;
      child.transform._parentID = -1;
      exports_lib.removeItems(this.children, index2, 1);
      this._boundsID++;
      this.onChildrenChange(index2);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index2);
    }
    return children[0];
  }
  removeChildAt(index2) {
    const child = this.getChildAt(index2);
    child.parent = null;
    child.transform._parentID = -1;
    exports_lib.removeItems(this.children, index2, 1);
    this._boundsID++;
    this.onChildrenChange(index2);
    child.emit("removed", this);
    this.emit("childRemoved", child, this, index2);
    return child;
  }
  removeChildren(beginIndex = 0, endIndex = this.children.length) {
    const begin = beginIndex;
    const end = endIndex;
    const range = end - begin;
    let removed;
    if (range > 0 && range <= end) {
      removed = this.children.splice(begin, range);
      for (let i3 = 0;i3 < removed.length; ++i3) {
        removed[i3].parent = null;
        if (removed[i3].transform) {
          removed[i3].transform._parentID = -1;
        }
      }
      this._boundsID++;
      this.onChildrenChange(beginIndex);
      for (let i3 = 0;i3 < removed.length; ++i3) {
        removed[i3].emit("removed", this);
        this.emit("childRemoved", removed[i3], this, i3);
      }
      return removed;
    } else if (range === 0 && this.children.length === 0) {
      return [];
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }
  sortChildren() {
    let sortRequired = false;
    for (let i3 = 0, j3 = this.children.length;i3 < j3; ++i3) {
      const child = this.children[i3];
      child._lastSortedIndex = i3;
      if (!sortRequired && child.zIndex !== 0) {
        sortRequired = true;
      }
    }
    if (sortRequired && this.children.length > 1) {
      this.children.sort(sortChildren);
    }
    this.sortDirty = false;
  }
  updateTransform() {
    if (this.sortableChildren && this.sortDirty) {
      this.sortChildren();
    }
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (let i3 = 0, j3 = this.children.length;i3 < j3; ++i3) {
      const child = this.children[i3];
      if (child.visible) {
        child.updateTransform();
      }
    }
  }
  calculateBounds() {
    this._bounds.clear();
    this._calculateBounds();
    for (let i3 = 0;i3 < this.children.length; i3++) {
      const child = this.children[i3];
      if (!child.visible || !child.renderable) {
        continue;
      }
      child.calculateBounds();
      if (child._mask) {
        const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
        if (maskObject) {
          maskObject.calculateBounds();
          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      } else if (child.filterArea) {
        this._bounds.addBoundsArea(child._bounds, child.filterArea);
      } else {
        this._bounds.addBounds(child._bounds);
      }
    }
    this._bounds.updateID = this._boundsID;
  }
  getLocalBounds(rect, skipChildrenUpdate = false) {
    const result = super.getLocalBounds(rect);
    if (!skipChildrenUpdate) {
      for (let i3 = 0, j3 = this.children.length;i3 < j3; ++i3) {
        const child = this.children[i3];
        if (child.visible) {
          child.updateTransform();
        }
      }
    }
    return result;
  }
  _calculateBounds() {
  }
  _renderWithCulling(renderer) {
    const sourceFrame = renderer.renderTexture.sourceFrame;
    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
      return;
    }
    let bounds;
    let transform;
    if (this.cullArea) {
      bounds = this.cullArea;
      transform = this.worldTransform;
    } else if (this._render !== _Container.prototype._render) {
      bounds = this.getBounds(true);
    }
    const projectionTransform = renderer.projection.transform;
    if (projectionTransform) {
      if (transform) {
        transform = tempMatrix3.copyFrom(transform);
        transform.prepend(projectionTransform);
      } else {
        transform = projectionTransform;
      }
    }
    if (bounds && sourceFrame.intersects(bounds, transform)) {
      this._render(renderer);
    } else if (this.cullArea) {
      return;
    }
    for (let i3 = 0, j3 = this.children.length;i3 < j3; ++i3) {
      const child = this.children[i3];
      const childCullable = child.cullable;
      child.cullable = childCullable || !this.cullArea;
      child.render(renderer);
      child.cullable = childCullable;
    }
  }
  render(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    if (this._mask || this.filters?.length) {
      this.renderAdvanced(renderer);
    } else if (this.cullable) {
      this._renderWithCulling(renderer);
    } else {
      this._render(renderer);
      for (let i3 = 0, j3 = this.children.length;i3 < j3; ++i3) {
        this.children[i3].render(renderer);
      }
    }
  }
  renderAdvanced(renderer) {
    const filters = this.filters;
    const mask = this._mask;
    if (filters) {
      if (!this._enabledFilters) {
        this._enabledFilters = [];
      }
      this._enabledFilters.length = 0;
      for (let i3 = 0;i3 < filters.length; i3++) {
        if (filters[i3].enabled) {
          this._enabledFilters.push(filters[i3]);
        }
      }
    }
    const flush = filters && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE));
    if (flush) {
      renderer.batch.flush();
    }
    if (filters && this._enabledFilters?.length) {
      renderer.filter.push(this, this._enabledFilters);
    }
    if (mask) {
      renderer.mask.push(this, this._mask);
    }
    if (this.cullable) {
      this._renderWithCulling(renderer);
    } else {
      this._render(renderer);
      for (let i3 = 0, j3 = this.children.length;i3 < j3; ++i3) {
        this.children[i3].render(renderer);
      }
    }
    if (flush) {
      renderer.batch.flush();
    }
    if (mask) {
      renderer.mask.pop(this);
    }
    if (filters && this._enabledFilters?.length) {
      renderer.filter.pop();
    }
  }
  _render(_renderer) {
  }
  destroy(options) {
    super.destroy();
    this.sortDirty = false;
    const destroyChildren = typeof options === "boolean" ? options : options?.children;
    const oldChildren = this.removeChildren(0, this.children.length);
    if (destroyChildren) {
      for (let i3 = 0;i3 < oldChildren.length; ++i3) {
        oldChildren[i3].destroy(options);
      }
    }
  }
  get width() {
    return this.scale.x * this.getLocalBounds().width;
  }
  set width(value) {
    const width = this.getLocalBounds().width;
    if (width !== 0) {
      this.scale.x = value / width;
    } else {
      this.scale.x = 1;
    }
    this._width = value;
  }
  get height() {
    return this.scale.y * this.getLocalBounds().height;
  }
  set height(value) {
    const height = this.getLocalBounds().height;
    if (height !== 0) {
      this.scale.y = value / height;
    } else {
      this.scale.y = 1;
    }
    this._height = value;
  }
};
var Container = _Container;
Container.defaultSortableChildren = false;
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;

// node_modules/colord/plugins/names.mjsistene
Object.defineProperties(settings, {
  SORTABLE_CHILDREN: {
    get() {
      return Container.defaultSortableChildren;
    },
    set(value) {
      exports_lib.deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren");
      Container.defaultSortableChildren = value;
    }
  }
});
// node_modules/colord/plugins/names.mjsist
var tempPoint = new Point3;
var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);

class Sprite extends Container {
  constructor(texture3) {
    super();
    this._anchor = new ObservablePoint(this._onAnchorUpdate, this, texture3 ? texture3.defaultAnchor.x : 0, texture3 ? texture3.defaultAnchor.y : 0);
    this._texture = null;
    this._width = 0;
    this._height = 0;
    this._tintColor = new Color(16777215);
    this._tintRGB = null;
    this.tint = 16777215;
    this.blendMode = BLEND_MODES.NORMAL;
    this._cachedTint = 16777215;
    this.uvs = null;
    this.texture = texture3 || Texture.EMPTY;
    this.vertexData = new Float32Array(8);
    this.vertexTrimmedData = null;
    this._transformID = -1;
    this._textureID = -1;
    this._transformTrimmedID = -1;
    this._textureTrimmedID = -1;
    this.indices = indices;
    this.pluginName = "batch";
    this.isSprite = true;
    this._roundPixels = settings.ROUND_PIXELS;
  }
  _onTextureUpdate() {
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    if (this._width) {
      this.scale.x = exports_lib.sign(this.scale.x) * this._width / this._texture.orig.width;
    }
    if (this._height) {
      this.scale.y = exports_lib.sign(this.scale.y) * this._height / this._texture.orig.height;
    }
  }
  _onAnchorUpdate() {
    this._transformID = -1;
    this._transformTrimmedID = -1;
  }
  calculateVertices() {
    const texture3 = this._texture;
    if (this._transformID === this.transform._worldID && this._textureID === texture3._updateID) {
      return;
    }
    if (this._textureID !== texture3._updateID) {
      this.uvs = this._texture._uvs.uvsFloat32;
    }
    this._transformID = this.transform._worldID;
    this._textureID = texture3._updateID;
    const wt = this.transform.worldTransform;
    const a3 = wt.a;
    const b3 = wt.b;
    const c3 = wt.c;
    const d3 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    const trim = texture3.trim;
    const orig = texture3.orig;
    const anchor = this._anchor;
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    if (trim) {
      w1 = trim.x - anchor._x * orig.width;
      w0 = w1 + trim.width;
      h1 = trim.y - anchor._y * orig.height;
      h0 = h1 + trim.height;
    } else {
      w1 = -anchor._x * orig.width;
      w0 = w1 + orig.width;
      h1 = -anchor._y * orig.height;
      h0 = h1 + orig.height;
    }
    vertexData[0] = a3 * w1 + c3 * h1 + tx;
    vertexData[1] = d3 * h1 + b3 * w1 + ty;
    vertexData[2] = a3 * w0 + c3 * h1 + tx;
    vertexData[3] = d3 * h1 + b3 * w0 + ty;
    vertexData[4] = a3 * w0 + c3 * h0 + tx;
    vertexData[5] = d3 * h0 + b3 * w0 + ty;
    vertexData[6] = a3 * w1 + c3 * h0 + tx;
    vertexData[7] = d3 * h0 + b3 * w1 + ty;
    if (this._roundPixels) {
      const resolution = settings.RESOLUTION;
      for (let i3 = 0;i3 < vertexData.length; ++i3) {
        vertexData[i3] = Math.round(vertexData[i3] * resolution) / resolution;
      }
    }
  }
  calculateTrimmedVertices() {
    if (!this.vertexTrimmedData) {
      this.vertexTrimmedData = new Float32Array(8);
    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
      return;
    }
    this._transformTrimmedID = this.transform._worldID;
    this._textureTrimmedID = this._texture._updateID;
    const texture3 = this._texture;
    const vertexData = this.vertexTrimmedData;
    const orig = texture3.orig;
    const anchor = this._anchor;
    const wt = this.transform.worldTransform;
    const a3 = wt.a;
    const b3 = wt.b;
    const c3 = wt.c;
    const d3 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const w1 = -anchor._x * orig.width;
    const w0 = w1 + orig.width;
    const h1 = -anchor._y * orig.height;
    const h0 = h1 + orig.height;
    vertexData[0] = a3 * w1 + c3 * h1 + tx;
    vertexData[1] = d3 * h1 + b3 * w1 + ty;
    vertexData[2] = a3 * w0 + c3 * h1 + tx;
    vertexData[3] = d3 * h1 + b3 * w0 + ty;
    vertexData[4] = a3 * w0 + c3 * h0 + tx;
    vertexData[5] = d3 * h0 + b3 * w0 + ty;
    vertexData[6] = a3 * w1 + c3 * h0 + tx;
    vertexData[7] = d3 * h0 + b3 * w1 + ty;
  }
  _render(renderer) {
    this.calculateVertices();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const trim = this._texture.trim;
    const orig = this._texture.orig;
    if (!trim || trim.width === orig.width && trim.height === orig.height) {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    } else {
      this.calculateTrimmedVertices();
      this._bounds.addQuad(this.vertexTrimmedData);
    }
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      if (!this._localBounds) {
        this._localBounds = new Bounds;
      }
      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle;
        }
        rect = this._localBoundsRect;
      }
      return this._localBounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint);
    const width = this._texture.orig.width;
    const height = this._texture.orig.height;
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    this._texture.off("update", this._onTextureUpdate, this);
    this._anchor = null;
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyBaseTexture = typeof options === "boolean" ? options : options?.baseTexture;
      this._texture.destroy(!!destroyBaseTexture);
    }
    this._texture = null;
  }
  static from(source, options) {
    const texture3 = source instanceof Texture ? source : Texture.from(source, options);
    return new Sprite(texture3);
  }
  set roundPixels(value) {
    if (this._roundPixels !== value) {
      this._transformID = -1;
    }
    this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    const s3 = exports_lib.sign(this.scale.x) || 1;
    this.scale.x = s3 * value / this._texture.orig.width;
    this._width = value;
  }
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    const s3 = exports_lib.sign(this.scale.y) || 1;
    this.scale.y = s3 * value / this._texture.orig.height;
    this._height = value;
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor.copyFrom(value);
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    if (this._texture === value) {
      return;
    }
    if (this._texture) {
      this._texture.off("update", this._onTextureUpdate, this);
    }
    this._texture = value || Texture.EMPTY;
    this._cachedTint = 16777215;
    this._textureID = -1;
    this._textureTrimmedID = -1;
    if (value) {
      if (value.baseTexture.valid) {
        this._onTextureUpdate();
      } else {
        value.once("update", this._onTextureUpdate, this);
      }
    }
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mj
var _tempMatrix = new Matrix;
DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = null;

class CacheData {
  constructor() {
    this.textureCacheId = null;
    this.originalRender = null;
    this.originalRenderCanvas = null;
    this.originalCalculateBounds = null;
    this.originalGetLocalBounds = null;
    this.originalUpdateTransform = null;
    this.originalDestroy = null;
    this.originalMask = null;
    this.originalFilterArea = null;
    this.originalContainsPoint = null;
    this.sprite = null;
  }
}
Object.defineProperties(DisplayObject.prototype, {
  cacheAsBitmapResolution: {
    get() {
      return this._cacheAsBitmapResolution;
    },
    set(resolution) {
      if (resolution === this._cacheAsBitmapResolution) {
        return;
      }
      this._cacheAsBitmapResolution = resolution;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmapMultisample: {
    get() {
      return this._cacheAsBitmapMultisample;
    },
    set(multisample) {
      if (multisample === this._cacheAsBitmapMultisample) {
        return;
      }
      this._cacheAsBitmapMultisample = multisample;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmap: {
    get() {
      return this._cacheAsBitmap;
    },
    set(value) {
      if (this._cacheAsBitmap === value) {
        return;
      }
      this._cacheAsBitmap = value;
      let data;
      if (value) {
        if (!this._cacheData) {
          this._cacheData = new CacheData;
        }
        data = this._cacheData;
        data.originalRender = this.render;
        data.originalRenderCanvas = this.renderCanvas;
        data.originalUpdateTransform = this.updateTransform;
        data.originalCalculateBounds = this.calculateBounds;
        data.originalGetLocalBounds = this.getLocalBounds;
        data.originalDestroy = this.destroy;
        data.originalContainsPoint = this.containsPoint;
        data.originalMask = this._mask;
        data.originalFilterArea = this.filterArea;
        this.render = this._renderCached;
        this.renderCanvas = this._renderCachedCanvas;
        this.destroy = this._cacheAsBitmapDestroy;
      } else {
        data = this._cacheData;
        if (data.sprite) {
          this._destroyCachedDisplayObject();
        }
        this.render = data.originalRender;
        this.renderCanvas = data.originalRenderCanvas;
        this.calculateBounds = data.originalCalculateBounds;
        this.getLocalBounds = data.originalGetLocalBounds;
        this.destroy = data.originalDestroy;
        this.updateTransform = data.originalUpdateTransform;
        this.containsPoint = data.originalContainsPoint;
        this._mask = data.originalMask;
        this.filterArea = data.originalFilterArea;
      }
    }
  }
});
DisplayObject.prototype._renderCached = function _renderCached(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObject(renderer);
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._render(renderer);
};
DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
  if (this._cacheData?.sprite) {
    return;
  }
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  renderer.batch.flush();
  const bounds = this.getLocalBounds(null, true).clone();
  if (this.filters?.length) {
    const padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  bounds.ceil(settings.RESOLUTION);
  const cachedRenderTexture = renderer.renderTexture.current;
  const cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
  const cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
  const cachedProjectionTransform = renderer.projection.transform;
  const renderTexture = RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution: this.cacheAsBitmapResolution || renderer.resolution,
    multisample: this.cacheAsBitmapMultisample ?? renderer.multisample
  });
  const textureCacheId = `cacheAsBitmap_${exports_lib.uid()}`;
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  const m4 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender;
  renderer.render(this, { renderTexture, clear: true, transform: m4, skipUpdateTransform: false });
  renderer.framebuffer.blit();
  renderer.projection.transform = cachedProjectionTransform;
  renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
  this.render = this._renderCached;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.enableTempParent();
    this.updateTransform();
    this.disableTempParent(null);
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObjectCanvas(renderer);
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._renderCanvas(renderer);
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
  if (this._cacheData?.sprite) {
    return;
  }
  const bounds = this.getLocalBounds(null, true);
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  const cachedRenderTarget = renderer.canvasContext.activeContext;
  const cachedProjectionTransform = renderer._projTransform;
  bounds.ceil(settings.RESOLUTION);
  const renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
  const textureCacheId = `cacheAsBitmap_${exports_lib.uid()}`;
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  const m4 = _tempMatrix;
  this.transform.localTransform.copyTo(m4);
  m4.invert();
  m4.tx -= bounds.x;
  m4.ty -= bounds.y;
  this.renderCanvas = this._cacheData.originalRenderCanvas;
  renderer.render(this, { renderTexture, clear: true, transform: m4, skipUpdateTransform: false });
  renderer.canvasContext.activeContext = cachedRenderTarget;
  renderer._projTransform = cachedProjectionTransform;
  this.renderCanvas = this._renderCachedCanvas;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.parent = renderer._tempDisplayObjectParent;
    this.updateTransform();
    this.parent = null;
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
  this._bounds.clear();
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite._calculateBounds();
  this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
  this._cacheData.sprite._texture.destroy(true);
  this._cacheData.sprite = null;
  BaseTexture.removeFromCache(this._cacheData.textureCacheId);
  Texture.removeFromCache(this._cacheData.textureCacheId);
  this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
  this.cacheAsBitmap = false;
  this.destroy(options);
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2
DisplayObject.prototype.name = null;
Container.prototype.getChildByName = function getChildByName(name, deep) {
  for (let i3 = 0, j3 = this.children.length;i3 < j3; i3++) {
    if (this.children[i3].name === name) {
      return this.children[i3];
    }
  }
  if (deep) {
    for (let i3 = 0, j3 = this.children.length;i3 < j3; i3++) {
      const child = this.children[i3];
      if (!child.getChildByName) {
        continue;
      }
      const target = child.getChildByName(name, true);
      if (target) {
        return target;
      }
    }
  }
  return null;
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.
DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point = new Point3, skipUpdate = false) {
  if (this.parent) {
    this.parent.toGlobal(this.position, point, skipUpdate);
  } else {
    point.x = this.position.x;
    point.y = this.position.y;
  }
  return point;
};

// node_modules/colord/plugins/names.mjsistener.
var fragment2 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle
class AlphaFilter extends Filter {
  constructor(alpha2 = 1) {
    super(defaultVertex4, fragment2, { uAlpha: 1 });
    this.alpha = alpha2;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
var generateBlurFragSource = function(kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  let fragSource = fragTemplate2;
  let blurLoop = "";
  const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  let value;
  for (let i3 = 0;i3 < kernelSize; i3++) {
    let blur = template.replace("%index%", i3.toString());
    value = i3;
    if (i3 >= halfLength) {
      value = kernelSize - i3 - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
};
var GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [0.000489, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
var fragTemplate2 = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
var generateBlurVertSource = function(kernelSize, x3) {
  const halfLength = Math.ceil(kernelSize / 2);
  let vertSource = vertTemplate;
  let blurLoop = "";
  let template;
  if (x3) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  }
  for (let i3 = 0;i3 < kernelSize; i3++) {
    let blur = template.replace("%index%", i3.toString());
    blur = blur.replace("%sampleIndex%", `${i3 - (halfLength - 1)}.0`);
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  return vertSource;
};
var vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;

// node_modules/colord/plugins/names.mjsistener.mjsgle.m
class BlurFilterPass extends Filter {
  constructor(horizontal, strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
    const vertSrc = generateBlurVertSource(kernelSize, horizontal);
    const fragSrc = generateBlurFragSource(kernelSize);
    super(vertSrc, fragSrc);
    this.horizontal = horizontal;
    this.resolution = resolution;
    this._quality = 0;
    this.quality = quality;
    this.blur = strength;
  }
  apply(filterManager, input, output, clearMode) {
    if (output) {
      if (this.horizontal) {
        this.uniforms.strength = 1 / output.width * (output.width / input.width);
      } else {
        this.uniforms.strength = 1 / output.height * (output.height / input.height);
      }
    } else {
      if (this.horizontal) {
        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
      } else {
        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
      }
    }
    this.uniforms.strength *= this.strength;
    this.uniforms.strength /= this.passes;
    if (this.passes === 1) {
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      const renderTarget = filterManager.getFilterTexture();
      const renderer = filterManager.renderer;
      let flip = input;
      let flop = renderTarget;
      this.state.blend = false;
      filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);
      for (let i3 = 1;i3 < this.passes - 1; i3++) {
        filterManager.bindAndClear(flip, CLEAR_MODES.BLIT);
        this.uniforms.uSampler = flop;
        const temp = flop;
        flop = flip;
        flip = temp;
        renderer.shader.bind(this);
        renderer.geometry.draw(5);
      }
      this.state.blend = true;
      filterManager.applyFilter(this, flop, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    }
  }
  get blur() {
    return this.strength;
  }
  set blur(value) {
    this.padding = 1 + Math.abs(value) * 2;
    this.strength = value;
  }
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = value;
    this.passes = value;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsg
class BlurFilter extends Filter {
  constructor(strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
    super();
    this._repeatEdgePixels = false;
    this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
    this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
    this.resolution = resolution;
    this.quality = quality;
    this.blur = strength;
    this.repeatEdgePixels = false;
  }
  apply(filterManager, input, output, clearMode) {
    const xStrength = Math.abs(this.blurXFilter.strength);
    const yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      const renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR);
      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    } else if (yStrength) {
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  }
  updatePadding() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
  }
  get blur() {
    return this.blurXFilter.blur;
  }
  set blur(value) {
    this.blurXFilter.blur = this.blurYFilter.blur = value;
    this.updatePadding();
  }
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(value) {
    this.blurXFilter.quality = this.blurYFilter.quality = value;
  }
  get blurX() {
    return this.blurXFilter.blur;
  }
  set blurX(value) {
    this.blurXFilter.blur = value;
    this.updatePadding();
  }
  get blurY() {
    return this.blurYFilter.blur;
  }
  set blurY(value) {
    this.blurYFilter.blur = value;
    this.updatePadding();
  }
  get blendMode() {
    return this.blurYFilter.blendMode;
  }
  set blendMode(value) {
    this.blurYFilter.blendMode = value;
  }
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(value) {
    this._repeatEdgePixels = value;
    this.updatePadding();
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.
var fragment3 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTex
class ColorMatrixFilter extends Filter {
  constructor() {
    const uniforms = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    super(defaultFilterVertex, fragment3, uniforms);
    this.alpha = 1;
  }
  _loadMatrix(matrix, multiply2 = false) {
    let newMatrix = matrix;
    if (multiply2) {
      this._multiply(newMatrix, this.uniforms.m, matrix);
      newMatrix = this._colorMatrix(newMatrix);
    }
    this.uniforms.m = newMatrix;
  }
  _multiply(out, a3, b3) {
    out[0] = a3[0] * b3[0] + a3[1] * b3[5] + a3[2] * b3[10] + a3[3] * b3[15];
    out[1] = a3[0] * b3[1] + a3[1] * b3[6] + a3[2] * b3[11] + a3[3] * b3[16];
    out[2] = a3[0] * b3[2] + a3[1] * b3[7] + a3[2] * b3[12] + a3[3] * b3[17];
    out[3] = a3[0] * b3[3] + a3[1] * b3[8] + a3[2] * b3[13] + a3[3] * b3[18];
    out[4] = a3[0] * b3[4] + a3[1] * b3[9] + a3[2] * b3[14] + a3[3] * b3[19] + a3[4];
    out[5] = a3[5] * b3[0] + a3[6] * b3[5] + a3[7] * b3[10] + a3[8] * b3[15];
    out[6] = a3[5] * b3[1] + a3[6] * b3[6] + a3[7] * b3[11] + a3[8] * b3[16];
    out[7] = a3[5] * b3[2] + a3[6] * b3[7] + a3[7] * b3[12] + a3[8] * b3[17];
    out[8] = a3[5] * b3[3] + a3[6] * b3[8] + a3[7] * b3[13] + a3[8] * b3[18];
    out[9] = a3[5] * b3[4] + a3[6] * b3[9] + a3[7] * b3[14] + a3[8] * b3[19] + a3[9];
    out[10] = a3[10] * b3[0] + a3[11] * b3[5] + a3[12] * b3[10] + a3[13] * b3[15];
    out[11] = a3[10] * b3[1] + a3[11] * b3[6] + a3[12] * b3[11] + a3[13] * b3[16];
    out[12] = a3[10] * b3[2] + a3[11] * b3[7] + a3[12] * b3[12] + a3[13] * b3[17];
    out[13] = a3[10] * b3[3] + a3[11] * b3[8] + a3[12] * b3[13] + a3[13] * b3[18];
    out[14] = a3[10] * b3[4] + a3[11] * b3[9] + a3[12] * b3[14] + a3[13] * b3[19] + a3[14];
    out[15] = a3[15] * b3[0] + a3[16] * b3[5] + a3[17] * b3[10] + a3[18] * b3[15];
    out[16] = a3[15] * b3[1] + a3[16] * b3[6] + a3[17] * b3[11] + a3[18] * b3[16];
    out[17] = a3[15] * b3[2] + a3[16] * b3[7] + a3[17] * b3[12] + a3[18] * b3[17];
    out[18] = a3[15] * b3[3] + a3[16] * b3[8] + a3[17] * b3[13] + a3[18] * b3[18];
    out[19] = a3[15] * b3[4] + a3[16] * b3[9] + a3[17] * b3[14] + a3[18] * b3[19] + a3[19];
    return out;
  }
  _colorMatrix(matrix) {
    const m4 = new Float32Array(matrix);
    m4[4] /= 255;
    m4[9] /= 255;
    m4[14] /= 255;
    m4[19] /= 255;
    return m4;
  }
  brightness(b3, multiply2) {
    const matrix = [
      b3,
      0,
      0,
      0,
      0,
      0,
      b3,
      0,
      0,
      0,
      0,
      0,
      b3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  tint(color8, multiply2) {
    const [r4, g4, b3] = Color.shared.setValue(color8).toArray();
    const matrix = [
      r4,
      0,
      0,
      0,
      0,
      0,
      g4,
      0,
      0,
      0,
      0,
      0,
      b3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  greyscale(scale3, multiply2) {
    const matrix = [
      scale3,
      scale3,
      scale3,
      0,
      0,
      scale3,
      scale3,
      scale3,
      0,
      0,
      scale3,
      scale3,
      scale3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  blackAndWhite(multiply2) {
    const matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  hue(rotation, multiply2) {
    rotation = (rotation || 0) / 180 * Math.PI;
    const cosR = Math.cos(rotation);
    const sinR = Math.sin(rotation);
    const sqrt = Math.sqrt;
    const w3 = 1 / 3;
    const sqrW = sqrt(w3);
    const a00 = cosR + (1 - cosR) * w3;
    const a01 = w3 * (1 - cosR) - sqrW * sinR;
    const a02 = w3 * (1 - cosR) + sqrW * sinR;
    const a10 = w3 * (1 - cosR) + sqrW * sinR;
    const a11 = cosR + w3 * (1 - cosR);
    const a12 = w3 * (1 - cosR) - sqrW * sinR;
    const a20 = w3 * (1 - cosR) - sqrW * sinR;
    const a21 = w3 * (1 - cosR) + sqrW * sinR;
    const a22 = cosR + w3 * (1 - cosR);
    const matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a22,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  contrast(amount, multiply2) {
    const v4 = (amount || 0) + 1;
    const o3 = -0.5 * (v4 - 1);
    const matrix = [
      v4,
      0,
      0,
      0,
      o3,
      0,
      v4,
      0,
      0,
      o3,
      0,
      0,
      v4,
      0,
      o3,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  saturate(amount = 0, multiply2) {
    const x3 = amount * 2 / 3 + 1;
    const y3 = (x3 - 1) * -0.5;
    const matrix = [
      x3,
      y3,
      y3,
      0,
      0,
      y3,
      x3,
      y3,
      0,
      0,
      y3,
      y3,
      x3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  desaturate() {
    this.saturate(-1);
  }
  negative(multiply2) {
    const matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  sepia(multiply2) {
    const matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  technicolor(multiply2) {
    const matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  polaroid(multiply2) {
    const matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  toBGR(multiply2) {
    const matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  kodachrome(multiply2) {
    const matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  browni(multiply2) {
    const matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  vintage(multiply2) {
    const matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  colorTone(desaturation, toned, lightColor, darkColor, multiply2) {
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 16770432;
    darkColor = darkColor || 3375104;
    const temp = Color.shared;
    const [lR, lG, lB] = temp.setValue(lightColor).toArray();
    const [dR, dG, dB] = temp.setValue(darkColor).toArray();
    const matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  night(intensity, multiply2) {
    intensity = intensity || 0.1;
    const matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  predator(amount, multiply2) {
    const matrix = [
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  lsd(multiply2) {
    const matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  reset() {
    const matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, false);
  }
  get matrix() {
    return this.uniforms.m;
  }
  set matrix(value) {
    this.uniforms.m = value;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.m
var fragment4 = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mj
var vertex2 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsText
class DisplacementFilter extends Filter {
  constructor(sprite2, scale3) {
    const maskMatrix = new Matrix;
    sprite2.renderable = false;
    super(vertex2, fragment4, {
      mapSampler: sprite2._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    });
    this.maskSprite = sprite2;
    this.maskMatrix = maskMatrix;
    if (scale3 === null || scale3 === undefined) {
      scale3 = 20;
    }
    this.scale = new Point3(scale3, scale3);
  }
  apply(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
    this.uniforms.scale.x = this.scale.x;
    this.uniforms.scale.y = this.scale.y;
    const wt = this.maskSprite.worldTransform;
    const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
    const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    if (lenX !== 0 && lenY !== 0) {
      this.uniforms.rotation[0] = wt.a / lenX;
      this.uniforms.rotation[1] = wt.b / lenX;
      this.uniforms.rotation[2] = wt.c / lenY;
      this.uniforms.rotation[3] = wt.d / lenY;
    }
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get map() {
    return this.uniforms.mapSampler;
  }
  set map(value) {
    this.uniforms.mapSampler = value;
  }
}
// node_modules/colord/plugins/names.mjsistene
var fragment5 = "varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it's\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n";

// node_modules/colord/plugins/names.mjsistener
var vertex3 = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsg
class FXAAFilter extends Filter {
  constructor() {
    super(vertex3, fragment5);
  }
}
// node_modules/colord/plugins/names.mjsistener.
var fragment6 = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle
class NoiseFilter extends Filter {
  constructor(noise2 = 0.5, seed = Math.random()) {
    super(defaultFilterVertex, fragment6, {
      uNoise: 0,
      uSeed: 0
    });
    this.noise = noise2;
    this.seed = seed;
  }
  get noise() {
    return this.uniforms.uNoise;
  }
  set noise(value) {
    this.uniforms.uNoise = value;
  }
  get seed() {
    return this.uniforms.uSeed;
  }
  set seed(value) {
    this.uniforms.uSeed = value;
  }
}
// node_modules/colord/plugins/names.mj
var filters = {
  AlphaFilter,
  BlurFilter,
  BlurFilterPass,
  ColorMatrixFilter,
  DisplacementFilter,
  FXAAFilter,
  NoiseFilter
};
Object.entries(filters).forEach(([key, FilterClass]) => {
  Object.defineProperty(filters, key, {
    get() {
      exports_lib.deprecation("7.1.0", `filters.${key} has moved to ${key}`);
      return FilterClass;
    }
  });
});
// node_modules/colord/plugins/names.mjsistener.
class EventsTickerClass {
  constructor() {
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  init(events) {
    this.removeTickerListener();
    this.events = events;
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(paused) {
    this._pauseUpdate = paused;
  }
  addTickerListener() {
    if (this.tickerAdded || !this.domElement) {
      return;
    }
    Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
    this.tickerAdded = true;
  }
  removeTickerListener() {
    if (!this.tickerAdded) {
      return;
    }
    Ticker.system.remove(this.tickerUpdate, this);
    this.tickerAdded = false;
  }
  pointerMoved() {
    this._didMove = true;
  }
  update() {
    if (!this.domElement || this._pauseUpdate) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    const rootPointerEvent = this.events["rootPointerEvent"];
    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
      return;
    }
    globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY
    }));
  }
  tickerUpdate(deltaTime) {
    this._deltaTime += deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this.update();
  }
}
var EventsTicker = new EventsTickerClass;

// node_modules/colord/plugins/names.mjsistener.mjs
class FederatedEvent {
  constructor(manager) {
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.composed = false;
    this.defaultPrevented = false;
    this.eventPhase = FederatedEvent.prototype.NONE;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.layer = new Point3;
    this.page = new Point3;
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get data() {
    return this;
  }
  composedPath() {
    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  }
  initEvent(_type, _bubbles, _cancelable) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.m
class FederatedMouseEvent extends FederatedEvent {
  constructor() {
    super(...arguments);
    this.client = new Point3;
    this.movement = new Point3;
    this.offset = new Point3;
    this.global = new Point3;
    this.screen = new Point3;
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get x() {
    return this.clientX;
  }
  get y() {
    return this.clientY;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getLocalPosition(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  }
  getModifierState(key) {
    return ("getModifierState" in this.nativeEvent) && this.nativeEvent.getModifierState(key);
  }
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
class FederatedPointerEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.height = 0;
    this.isPrimary = false;
  }
  getCoalescedEvents() {
    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
      return [this];
    }
    return [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.m
class FederatedWheelEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.DOM_DELTA_PIXEL = 0;
    this.DOM_DELTA_LINE = 1;
    this.DOM_DELTA_PAGE = 2;
  }
}
FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
FederatedWheelEvent.DOM_DELTA_LINE = 1;
FederatedWheelEvent.DOM_DELTA_PAGE = 2;

// node_modules/colord/plugins/names.mjsistener.mj
var PROPAGATION_LIMIT = 2048;
var tempHitLocation = new Point3;
var tempLocalMapping = new Point3;

class EventBoundary {
  constructor(rootTarget) {
    this.dispatch = new exports_lib.EventEmitter;
    this.moveOnAll = false;
    this.enableGlobalMoveEvents = true;
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = new Map;
    this._allInteractiveElements = [];
    this._hitElements = [];
    this._isPointerMoveEvent = false;
    this.rootTarget = rootTarget;
    this.hitPruneFn = this.hitPruneFn.bind(this);
    this.hitTestFn = this.hitTestFn.bind(this);
    this.mapPointerDown = this.mapPointerDown.bind(this);
    this.mapPointerMove = this.mapPointerMove.bind(this);
    this.mapPointerOut = this.mapPointerOut.bind(this);
    this.mapPointerOver = this.mapPointerOver.bind(this);
    this.mapPointerUp = this.mapPointerUp.bind(this);
    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
    this.mapWheel = this.mapWheel.bind(this);
    this.mappingTable = {};
    this.addEventMapping("pointerdown", this.mapPointerDown);
    this.addEventMapping("pointermove", this.mapPointerMove);
    this.addEventMapping("pointerout", this.mapPointerOut);
    this.addEventMapping("pointerleave", this.mapPointerOut);
    this.addEventMapping("pointerover", this.mapPointerOver);
    this.addEventMapping("pointerup", this.mapPointerUp);
    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
    this.addEventMapping("wheel", this.mapWheel);
  }
  addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn,
      priority: 0
    });
    this.mappingTable[type].sort((a3, b3) => a3.priority - b3.priority);
  }
  dispatchEvent(e3, type) {
    e3.propagationStopped = false;
    e3.propagationImmediatelyStopped = false;
    this.propagate(e3, type);
    this.dispatch.emit(type || e3.type, e3);
  }
  mapEvent(e3) {
    if (!this.rootTarget) {
      return;
    }
    const mappers = this.mappingTable[e3.type];
    if (mappers) {
      for (let i3 = 0, j3 = mappers.length;i3 < j3; i3++) {
        mappers[i3].fn(e3);
      }
    } else {
      console.warn(`[EventBoundary]: Event mapping not defined for ${e3.type}`);
    }
  }
  hitTest(x3, y3) {
    EventsTicker.pauseUpdate = true;
    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
    const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x3, y3), this.hitTestFn, this.hitPruneFn);
    return invertedPath && invertedPath[0];
  }
  propagate(e3, type) {
    if (!e3.target) {
      return;
    }
    const composedPath = e3.composedPath();
    e3.eventPhase = e3.CAPTURING_PHASE;
    for (let i3 = 0, j3 = composedPath.length - 1;i3 < j3; i3++) {
      e3.currentTarget = composedPath[i3];
      this.notifyTarget(e3, type);
      if (e3.propagationStopped || e3.propagationImmediatelyStopped)
        return;
    }
    e3.eventPhase = e3.AT_TARGET;
    e3.currentTarget = e3.target;
    this.notifyTarget(e3, type);
    if (e3.propagationStopped || e3.propagationImmediatelyStopped)
      return;
    e3.eventPhase = e3.BUBBLING_PHASE;
    for (let i3 = composedPath.length - 2;i3 >= 0; i3--) {
      e3.currentTarget = composedPath[i3];
      this.notifyTarget(e3, type);
      if (e3.propagationStopped || e3.propagationImmediatelyStopped)
        return;
    }
  }
  all(e3, type, targets = this._allInteractiveElements) {
    if (targets.length === 0)
      return;
    e3.eventPhase = e3.BUBBLING_PHASE;
    const events = Array.isArray(type) ? type : [type];
    for (let i3 = targets.length - 1;i3 >= 0; i3--) {
      events.forEach((event) => {
        e3.currentTarget = targets[i3];
        this.notifyTarget(e3, event);
      });
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i3 = 0;i3 < PROPAGATION_LIMIT && target !== this.rootTarget; i3++) {
      if (!target.parent) {
        throw new Error("Cannot find propagation path to disconnected target");
      }
      propagationPath.push(target.parent);
      target = target.parent;
    }
    propagationPath.reverse();
    return propagationPath;
  }
  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
    let shouldReturn = false;
    if (this._interactivePrune(currentTarget))
      return null;
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i3 = children.length - 1;i3 >= 0; i3--) {
        const child = children[i3];
        const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location));
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive) {
            if (isInteractive)
              this._allInteractiveElements.push(currentTarget);
            nestedHit.push(currentTarget);
          }
          if (this._hitElements.length === 0)
            this._hitElements = nestedHit;
          shouldReturn = true;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveTarget && isInteractiveTarget)
      this._allInteractiveElements.push(currentTarget);
    if (ignore || this._hitElements.length > 0)
      return null;
    if (shouldReturn)
      return this._hitElements;
    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
      return null;
    }
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i3 = children.length - 1;i3 >= 0; i3--) {
        const child = children[i3];
        const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn);
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive)
            nestedHit.push(currentTarget);
          return nestedHit;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveMode && testFn(currentTarget, location)) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  _isInteractive(int) {
    return int === "static" || int === "dynamic";
  }
  _interactivePrune(displayObject) {
    if (!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable) {
      return true;
    }
    if (displayObject.eventMode === "none") {
      return true;
    }
    if (displayObject.eventMode === "passive" && !displayObject.interactiveChildren) {
      return true;
    }
    if (displayObject.isMask) {
      return true;
    }
    return false;
  }
  hitPruneFn(displayObject, location) {
    if (displayObject.hitArea) {
      displayObject.worldTransform.applyInverse(location, tempLocalMapping);
      if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
        return true;
      }
    }
    if (displayObject._mask) {
      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
      if (maskObject && !maskObject.containsPoint?.(location)) {
        return true;
      }
    }
    return false;
  }
  hitTestFn(displayObject, location) {
    if (displayObject.eventMode === "passive") {
      return false;
    }
    if (displayObject.hitArea) {
      return true;
    }
    if (displayObject.containsPoint) {
      return displayObject.containsPoint(location);
    }
    return false;
  }
  notifyTarget(e3, type) {
    type = type ?? e3.type;
    const handlerKey = `on${type}`;
    e3.currentTarget[handlerKey]?.(e3);
    const key = e3.eventPhase === e3.CAPTURING_PHASE || e3.eventPhase === e3.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e3, key);
    if (e3.eventPhase === e3.AT_TARGET) {
      this.notifyListeners(e3, type);
    }
  }
  mapPointerDown(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e3 = this.createPointerEvent(from);
    this.dispatchEvent(e3, "pointerdown");
    if (e3.pointerType === "touch") {
      this.dispatchEvent(e3, "touchstart");
    } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
      const isRightButton = e3.button === 2;
      this.dispatchEvent(e3, isRightButton ? "rightdown" : "mousedown");
    }
    const trackingData = this.trackingData(from.pointerId);
    trackingData.pressTargetsByButton[from.button] = e3.composedPath();
    this.freeEvent(e3);
  }
  mapPointerMove(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    this._isPointerMoveEvent = true;
    const e3 = this.createPointerEvent(from);
    this._isPointerMoveEvent = false;
    const isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
    const trackingData = this.trackingData(from.pointerId);
    const outTarget = this.findMountedTarget(trackingData.overTargets);
    if (trackingData.overTargets?.length > 0 && outTarget !== e3.target) {
      const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
      const outEvent = this.createPointerEvent(from, outType, outTarget);
      this.dispatchEvent(outEvent, "pointerout");
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      if (!e3.composedPath().includes(outTarget)) {
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && !e3.composedPath().includes(leaveEvent.target)) {
          leaveEvent.currentTarget = leaveEvent.target;
          this.notifyTarget(leaveEvent);
          if (isMouse)
            this.notifyTarget(leaveEvent, "mouseleave");
          leaveEvent.target = leaveEvent.target.parent;
        }
        this.freeEvent(leaveEvent);
      }
      this.freeEvent(outEvent);
    }
    if (outTarget !== e3.target) {
      const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
      const overEvent = this.clonePointerEvent(e3, overType);
      this.dispatchEvent(overEvent, "pointerover");
      if (isMouse)
        this.dispatchEvent(overEvent, "mouseover");
      let overTargetAncestor = outTarget?.parent;
      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
        if (overTargetAncestor === e3.target)
          break;
        overTargetAncestor = overTargetAncestor.parent;
      }
      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
      if (didPointerEnter) {
        const enterEvent = this.clonePointerEvent(e3, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        this.freeEvent(enterEvent);
      }
      this.freeEvent(overEvent);
    }
    const allMethods = [];
    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e3, "pointermove");
    allowGlobalPointerEvents && allMethods.push("globalpointermove");
    if (e3.pointerType === "touch") {
      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e3, "touchmove");
      allowGlobalPointerEvents && allMethods.push("globaltouchmove");
    }
    if (isMouse) {
      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e3, "mousemove");
      allowGlobalPointerEvents && allMethods.push("globalmousemove");
      this.cursor = e3.target?.cursor;
    }
    if (allMethods.length > 0) {
      this.all(e3, allMethods);
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    trackingData.overTargets = e3.composedPath();
    this.freeEvent(e3);
  }
  mapPointerOver(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const e3 = this.createPointerEvent(from);
    const isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
    this.dispatchEvent(e3, "pointerover");
    if (isMouse)
      this.dispatchEvent(e3, "mouseover");
    if (e3.pointerType === "mouse")
      this.cursor = e3.target?.cursor;
    const enterEvent = this.clonePointerEvent(e3, "pointerenter");
    enterEvent.eventPhase = enterEvent.AT_TARGET;
    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
      enterEvent.currentTarget = enterEvent.target;
      this.notifyTarget(enterEvent);
      if (isMouse)
        this.notifyTarget(enterEvent, "mouseenter");
      enterEvent.target = enterEvent.target.parent;
    }
    trackingData.overTargets = e3.composedPath();
    this.freeEvent(e3);
    this.freeEvent(enterEvent);
  }
  mapPointerOut(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    if (trackingData.overTargets) {
      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
      const outTarget = this.findMountedTarget(trackingData.overTargets);
      const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
      this.dispatchEvent(outEvent);
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
      leaveEvent.eventPhase = leaveEvent.AT_TARGET;
      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
        leaveEvent.currentTarget = leaveEvent.target;
        this.notifyTarget(leaveEvent);
        if (isMouse)
          this.notifyTarget(leaveEvent, "mouseleave");
        leaveEvent.target = leaveEvent.target.parent;
      }
      trackingData.overTargets = null;
      this.freeEvent(outEvent);
      this.freeEvent(leaveEvent);
    }
    this.cursor = null;
  }
  mapPointerUp(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const now = performance.now();
    const e3 = this.createPointerEvent(from);
    this.dispatchEvent(e3, "pointerup");
    if (e3.pointerType === "touch") {
      this.dispatchEvent(e3, "touchend");
    } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
      const isRightButton = e3.button === 2;
      this.dispatchEvent(e3, isRightButton ? "rightup" : "mouseup");
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    let clickTarget = pressTarget;
    if (pressTarget && !e3.composedPath().includes(pressTarget)) {
      let currentTarget = pressTarget;
      while (currentTarget && !e3.composedPath().includes(currentTarget)) {
        e3.currentTarget = currentTarget;
        this.notifyTarget(e3, "pointerupoutside");
        if (e3.pointerType === "touch") {
          this.notifyTarget(e3, "touchendoutside");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          const isRightButton = e3.button === 2;
          this.notifyTarget(e3, isRightButton ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
      clickTarget = currentTarget;
    }
    if (clickTarget) {
      const clickEvent = this.clonePointerEvent(e3, "click");
      clickEvent.target = clickTarget;
      clickEvent.path = null;
      if (!trackingData.clicksByButton[from.button]) {
        trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        };
      }
      const clickHistory = trackingData.clicksByButton[from.button];
      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
        ++clickHistory.clickCount;
      } else {
        clickHistory.clickCount = 1;
      }
      clickHistory.target = clickEvent.target;
      clickHistory.timeStamp = now;
      clickEvent.detail = clickHistory.clickCount;
      if (clickEvent.pointerType === "mouse") {
        const isRightButton = clickEvent.button === 2;
        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
      } else if (clickEvent.pointerType === "touch") {
        this.dispatchEvent(clickEvent, "tap");
      }
      this.dispatchEvent(clickEvent, "pointertap");
      this.freeEvent(clickEvent);
    }
    this.freeEvent(e3);
  }
  mapPointerUpOutside(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    const e3 = this.createPointerEvent(from);
    if (pressTarget) {
      let currentTarget = pressTarget;
      while (currentTarget) {
        e3.currentTarget = currentTarget;
        this.notifyTarget(e3, "pointerupoutside");
        if (e3.pointerType === "touch") {
          this.notifyTarget(e3, "touchendoutside");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          this.notifyTarget(e3, e3.button === 2 ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
    }
    this.freeEvent(e3);
  }
  mapWheel(from) {
    if (!(from instanceof FederatedWheelEvent)) {
      console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const wheelEvent = this.createWheelEvent(from);
    this.dispatchEvent(wheelEvent);
    this.freeEvent(wheelEvent);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    let currentTarget = propagationPath[0];
    for (let i3 = 1;i3 < propagationPath.length; i3++) {
      if (propagationPath[i3].parent === currentTarget) {
        currentTarget = propagationPath[i3];
      } else {
        break;
      }
    }
    return currentTarget;
  }
  createPointerEvent(from, type, target) {
    const event = this.allocateEvent(FederatedPointerEvent);
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
    if (typeof type === "string") {
      event.type = type;
    }
    return event;
  }
  createWheelEvent(from) {
    const event = this.allocateEvent(FederatedWheelEvent);
    this.copyWheelData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = this.hitTest(event.global.x, event.global.y);
    return event;
  }
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = type ?? event.type;
    return event;
  }
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode;
    to.deltaX = from.deltaX;
    to.deltaY = from.deltaY;
    to.deltaZ = from.deltaZ;
  }
  copyPointerData(from, to) {
    if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
      return;
    to.pointerId = from.pointerId;
    to.width = from.width;
    to.height = from.height;
    to.isPrimary = from.isPrimary;
    to.pointerType = from.pointerType;
    to.pressure = from.pressure;
    to.tangentialPressure = from.tangentialPressure;
    to.tiltX = from.tiltX;
    to.tiltY = from.tiltY;
    to.twist = from.twist;
  }
  copyMouseData(from, to) {
    if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
      return;
    to.altKey = from.altKey;
    to.button = from.button;
    to.buttons = from.buttons;
    to.client.copyFrom(from.client);
    to.ctrlKey = from.ctrlKey;
    to.metaKey = from.metaKey;
    to.movement.copyFrom(from.movement);
    to.screen.copyFrom(from.screen);
    to.shiftKey = from.shiftKey;
    to.global.copyFrom(from.global);
  }
  copyData(from, to) {
    to.isTrusted = from.isTrusted;
    to.srcElement = from.srcElement;
    to.timeStamp = performance.now();
    to.type = from.type;
    to.detail = from.detail;
    to.view = from.view;
    to.which = from.which;
    to.layer.copyFrom(from.layer);
    to.page.copyFrom(from.page);
  }
  trackingData(id) {
    if (!this.mappingState.trackingData[id]) {
      this.mappingState.trackingData[id] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id];
  }
  allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    const event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.path = null;
    event.target = null;
    return event;
  }
  freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    this.eventPool.get(constructor).push(event);
  }
  notifyListeners(e3, type) {
    const listeners = e3.currentTarget._events[type];
    if (!listeners)
      return;
    if (!e3.currentTarget.isInteractive())
      return;
    if ("fn" in listeners) {
      if (listeners.once)
        e3.currentTarget.removeListener(type, listeners.fn, undefined, true);
      listeners.fn.call(listeners.context, e3);
    } else {
      for (let i3 = 0, j3 = listeners.length;i3 < j3 && !e3.propagationImmediatelyStopped; i3++) {
        if (listeners[i3].once)
          e3.currentTarget.removeListener(type, listeners[i3].fn, undefined, true);
        listeners[i3].fn.call(listeners[i3].context, e3);
      }
    }
  }
}
// node_modules/colord/plugins/names.mjsistener.
var MOUSE_POINTER_ID = 1;
var TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
var _EventSystem = class {
  constructor(renderer) {
    this.supportsTouchEvents = ("ontouchstart" in globalThis);
    this.supportsPointerEvents = !!globalThis.PointerEvent;
    this.domElement = null;
    this.resolution = 1;
    this.renderer = renderer;
    this.rootBoundary = new EventBoundary(null);
    EventsTicker.init(this);
    this.autoPreventDefault = true;
    this.eventsAdded = false;
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);
    this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
      set: (target, key, value) => {
        if (key === "globalMove") {
          this.rootBoundary.enableGlobalMoveEvents = value;
        }
        target[key] = value;
        return true;
      }
    });
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.onPointerOverOut = this.onPointerOverOut.bind(this);
    this.onWheel = this.onWheel.bind(this);
  }
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  init(options) {
    const { view, resolution } = this.renderer;
    this.setTargetElement(view);
    this.resolution = resolution;
    _EventSystem._defaultEventMode = options.eventMode ?? "auto";
    Object.assign(this.features, options.eventFeatures ?? {});
    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  resolutionChange(resolution) {
    this.resolution = resolution;
  }
  destroy() {
    this.setTargetElement(null);
    this.renderer = null;
  }
  setCursor(mode) {
    mode = mode || "default";
    let applyStyles = true;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this.currentCursor === mode) {
      return;
    }
    this.currentCursor = mode;
    const style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.domElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.domElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.domElement.style.cursor = mode;
    }
  }
  get pointer() {
    return this.rootPointerEvent;
  }
  onPointerDown(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const events = this.normalizeToPointerData(nativeEvent);
    if (this.autoPreventDefault && events[0].isNormalized) {
      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
      if (cancelable) {
        nativeEvent.preventDefault();
      }
    }
    for (let i3 = 0, j3 = events.length;i3 < j3; i3++) {
      const nativeEvent2 = events[i3];
      const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
      this.rootBoundary.mapEvent(federatedEvent);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerMove(nativeEvent) {
    if (!this.features.move)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    EventsTicker.pointerMoved();
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i3 = 0, j3 = normalizedEvents.length;i3 < j3; i3++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i3]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerUp(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    let target = nativeEvent.target;
    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
      target = nativeEvent.composedPath()[0];
    }
    const outside = target !== this.domElement ? "outside" : "";
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i3 = 0, j3 = normalizedEvents.length;i3 < j3; i3++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i3]);
      event.type += outside;
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerOverOut(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i3 = 0, j3 = normalizedEvents.length;i3 < j3; i3++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i3]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onWheel(nativeEvent) {
    if (!this.features.wheel)
      return;
    const wheelEvent = this.normalizeWheelEvent(nativeEvent);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    this.rootBoundary.mapEvent(wheelEvent);
  }
  setTargetElement(element) {
    this.removeEvents();
    this.domElement = element;
    EventsTicker.domElement = element;
    this.addEvents();
  }
  addEvents() {
    if (this.eventsAdded || !this.domElement) {
      return;
    }
    EventsTicker.addTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "none";
        style.msTouchAction = "none";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "none";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this.onPointerMove, true);
      this.domElement.addEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.addEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.addEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.addEventListener("mousemove", this.onPointerMove, true);
      this.domElement.addEventListener("mousedown", this.onPointerDown, true);
      this.domElement.addEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.addEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.addEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.addEventListener("touchstart", this.onPointerDown, true);
      this.domElement.addEventListener("touchend", this.onPointerUp, true);
      this.domElement.addEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.addEventListener("wheel", this.onWheel, {
      passive: true,
      capture: true
    });
    this.eventsAdded = true;
  }
  removeEvents() {
    if (!this.eventsAdded || !this.domElement) {
      return;
    }
    EventsTicker.removeTickerListener();
    const style = this.domElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "";
      style.msTouchAction = "";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this.onPointerMove, true);
      this.domElement.removeEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.removeEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.removeEventListener("mousemove", this.onPointerMove, true);
      this.domElement.removeEventListener("mousedown", this.onPointerDown, true);
      this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.removeEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.removeEventListener("touchstart", this.onPointerDown, true);
      this.domElement.removeEventListener("touchend", this.onPointerUp, true);
      this.domElement.removeEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.removeEventListener("wheel", this.onWheel, true);
    this.domElement = null;
    this.eventsAdded = false;
  }
  mapPositionToPoint(point, x3, y3) {
    let rect;
    if (!this.domElement.parentElement) {
      rect = {
        x: 0,
        y: 0,
        width: this.domElement.width,
        height: this.domElement.height,
        left: 0,
        top: 0
      };
    } else {
      rect = this.domElement.getBoundingClientRect();
    }
    const resolutionMultiplier = 1 / this.resolution;
    point.x = (x3 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
    point.y = (y3 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
  }
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (let i3 = 0, li = event.changedTouches.length;i3 < li; i3++) {
        const touch = event.changedTouches[i3];
        if (typeof touch.button === "undefined")
          touch.button = 0;
        if (typeof touch.buttons === "undefined")
          touch.buttons = 1;
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined")
          touch.width = touch.radiusX || 1;
        if (typeof touch.height === "undefined")
          touch.height = touch.radiusY || 1;
        if (typeof touch.tiltX === "undefined")
          touch.tiltX = 0;
        if (typeof touch.tiltY === "undefined")
          touch.tiltY = 0;
        if (typeof touch.pointerType === "undefined")
          touch.pointerType = "touch";
        if (typeof touch.pointerId === "undefined")
          touch.pointerId = touch.identifier || 0;
        if (typeof touch.pressure === "undefined")
          touch.pressure = touch.force || 0.5;
        if (typeof touch.twist === "undefined")
          touch.twist = 0;
        if (typeof touch.tangentialPressure === "undefined")
          touch.tangentialPressure = 0;
        if (typeof touch.layerX === "undefined")
          touch.layerX = touch.offsetX = touch.clientX;
        if (typeof touch.layerY === "undefined")
          touch.layerY = touch.offsetY = touch.clientY;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      const tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined")
        tempEvent.isPrimary = true;
      if (typeof tempEvent.width === "undefined")
        tempEvent.width = 1;
      if (typeof tempEvent.height === "undefined")
        tempEvent.height = 1;
      if (typeof tempEvent.tiltX === "undefined")
        tempEvent.tiltX = 0;
      if (typeof tempEvent.tiltY === "undefined")
        tempEvent.tiltY = 0;
      if (typeof tempEvent.pointerType === "undefined")
        tempEvent.pointerType = "mouse";
      if (typeof tempEvent.pointerId === "undefined")
        tempEvent.pointerId = MOUSE_POINTER_ID;
      if (typeof tempEvent.pressure === "undefined")
        tempEvent.pressure = 0.5;
      if (typeof tempEvent.twist === "undefined")
        tempEvent.twist = 0;
      if (typeof tempEvent.tangentialPressure === "undefined")
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent);
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    event.deltaMode = nativeEvent.deltaMode;
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  }
  bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this.transferMouseData(event, nativeEvent);
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    if (event.type.startsWith("mouse")) {
      event.type = event.type.replace("mouse", "pointer");
    }
    if (event.type.startsWith("touch")) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.metaKey = nativeEvent.metaKey;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.relatedTarget = null;
    event.shiftKey = nativeEvent.shiftKey;
  }
};
var EventSystem = _EventSystem;
EventSystem.extension = {
  name: "events",
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ]
};
EventSystem.defaultEventFeatures = {
  move: true,
  globalMove: true,
  click: true,
  wheel: true
};
extensions.add(EventSystem);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mj
var convertEventModeToInteractiveMode = function(mode) {
  return mode === "dynamic" || mode === "static";
};
var FederatedDisplayObject = {
  onclick: null,
  onmousedown: null,
  onmouseenter: null,
  onmouseleave: null,
  onmousemove: null,
  onglobalmousemove: null,
  onmouseout: null,
  onmouseover: null,
  onmouseup: null,
  onmouseupoutside: null,
  onpointercancel: null,
  onpointerdown: null,
  onpointerenter: null,
  onpointerleave: null,
  onpointermove: null,
  onglobalpointermove: null,
  onpointerout: null,
  onpointerover: null,
  onpointertap: null,
  onpointerup: null,
  onpointerupoutside: null,
  onrightclick: null,
  onrightdown: null,
  onrightup: null,
  onrightupoutside: null,
  ontap: null,
  ontouchcancel: null,
  ontouchend: null,
  ontouchendoutside: null,
  ontouchmove: null,
  onglobaltouchmove: null,
  ontouchstart: null,
  onwheel: null,
  _internalInteractive: undefined,
  get interactive() {
    return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.defaultEventMode);
  },
  set interactive(value) {
    exports_lib.deprecation("7.2.0", `Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead.`);
    this._internalInteractive = value;
    this.eventMode = value ? "static" : "auto";
  },
  _internalEventMode: undefined,
  get eventMode() {
    return this._internalEventMode ?? EventSystem.defaultEventMode;
  },
  set eventMode(value) {
    this._internalInteractive = convertEventModeToInteractiveMode(value);
    this._internalEventMode = value;
  },
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  interactiveChildren: true,
  hitArea: null,
  addEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context2 = typeof listener === "function" ? undefined : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.on(type, listener, context2);
  },
  removeEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context2 = typeof listener === "function" ? undefined : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.off(type, listener, context2);
  },
  dispatchEvent(e3) {
    if (!(e3 instanceof FederatedEvent)) {
      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    }
    e3.defaultPrevented = false;
    e3.path = null;
    e3.target = this;
    e3.manager.dispatchEvent(e3);
    return !e3.defaultPrevented;
  }
};
DisplayObject.mixin(FederatedDisplayObject);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
var accessibleTarget = {
  accessible: false,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: false,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: true,
  renderId: -1
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
DisplayObject.mixin(accessibleTarget);
var KEY_CODE_TAB = 9;
var DIV_TOUCH_SIZE = 100;
var DIV_TOUCH_POS_X = 0;
var DIV_TOUCH_POS_Y = 0;
var DIV_TOUCH_ZINDEX = 2;
var DIV_HOOK_SIZE = 1;
var DIV_HOOK_POS_X = -1000;
var DIV_HOOK_POS_Y = -1000;
var DIV_HOOK_ZINDEX = 2;

class AccessibilityManager {
  constructor(renderer) {
    this.debug = false;
    this._isActive = false;
    this._isMobileAccessibility = false;
    this.pool = [];
    this.renderId = 0;
    this.children = [];
    this.androidUpdateCount = 0;
    this.androidUpdateFrequency = 500;
    this._hookDiv = null;
    if (exports_lib.isMobile.tablet || exports_lib.isMobile.phone) {
      this.createTouchHook();
    }
    const div = document.createElement("div");
    div.style.width = `${DIV_TOUCH_SIZE}px`;
    div.style.height = `${DIV_TOUCH_SIZE}px`;
    div.style.position = "absolute";
    div.style.top = `${DIV_TOUCH_POS_X}px`;
    div.style.left = `${DIV_TOUCH_POS_Y}px`;
    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
    this.div = div;
    this.renderer = renderer;
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
  }
  get isActive() {
    return this._isActive;
  }
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  createTouchHook() {
    const hookDiv = document.createElement("button");
    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.position = "absolute";
    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", () => {
      this._isMobileAccessibility = true;
      this.activate();
      this.destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  }
  destroyTouchHook() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  }
  activate() {
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown, false);
    this.renderer.on("postrender", this.update, this);
    this.renderer.view.parentNode?.appendChild(this.div);
  }
  deactivate() {
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
    this.renderer.off("postrender", this.update);
    this.div.parentNode?.removeChild(this.div);
  }
  updateAccessibleObjects(displayObject) {
    if (!displayObject.visible || !displayObject.accessibleChildren) {
      return;
    }
    if (displayObject.accessible && displayObject.isInteractive()) {
      if (!displayObject._accessibleActive) {
        this.addChild(displayObject);
      }
      displayObject.renderId = this.renderId;
    }
    const children = displayObject.children;
    if (children) {
      for (let i3 = 0;i3 < children.length; i3++) {
        this.updateAccessibleObjects(children[i3]);
      }
    }
  }
  update() {
    const now = performance.now();
    if (exports_lib.isMobile.android.device && now < this.androidUpdateCount) {
      return;
    }
    this.androidUpdateCount = now + this.androidUpdateFrequency;
    if (!this.renderer.renderingToScreen) {
      return;
    }
    if (this.renderer.lastObjectRendered) {
      this.updateAccessibleObjects(this.renderer.lastObjectRendered);
    }
    const { x: x3, y: y3, width, height } = this.renderer.view.getBoundingClientRect();
    const { width: viewWidth, height: viewHeight, resolution } = this.renderer;
    const sx = width / viewWidth * resolution;
    const sy = height / viewHeight * resolution;
    let div = this.div;
    div.style.left = `${x3}px`;
    div.style.top = `${y3}px`;
    div.style.width = `${viewWidth}px`;
    div.style.height = `${viewHeight}px`;
    for (let i3 = 0;i3 < this.children.length; i3++) {
      const child = this.children[i3];
      if (child.renderId !== this.renderId) {
        child._accessibleActive = false;
        exports_lib.removeItems(this.children, i3, 1);
        this.div.removeChild(child._accessibleDiv);
        this.pool.push(child._accessibleDiv);
        child._accessibleDiv = null;
        i3--;
      } else {
        div = child._accessibleDiv;
        let hitArea = child.hitArea;
        const wt = child.worldTransform;
        if (child.hitArea) {
          div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
          div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
          div.style.width = `${hitArea.width * wt.a * sx}px`;
          div.style.height = `${hitArea.height * wt.d * sy}px`;
        } else {
          hitArea = child.getBounds();
          this.capHitArea(hitArea);
          div.style.left = `${hitArea.x * sx}px`;
          div.style.top = `${hitArea.y * sy}px`;
          div.style.width = `${hitArea.width * sx}px`;
          div.style.height = `${hitArea.height * sy}px`;
          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
            div.title = child.accessibleTitle;
          }
          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
            div.setAttribute("aria-label", child.accessibleHint);
          }
        }
        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
          div.title = child.accessibleTitle;
          div.tabIndex = child.tabIndex;
          if (this.debug)
            this.updateDebugHTML(div);
        }
      }
    }
    this.renderId++;
  }
  updateDebugHTML(div) {
    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
  }
  capHitArea(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    const { width: viewWidth, height: viewHeight } = this.renderer;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  }
  addChild(displayObject) {
    let div = this.pool.pop();
    if (!div) {
      div = document.createElement("button");
      div.style.width = `${DIV_TOUCH_SIZE}px`;
      div.style.height = `${DIV_TOUCH_SIZE}px`;
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().includes("chrome")) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = displayObject.accessiblePointerEvents;
    div.type = displayObject.accessibleType;
    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
      div.title = displayObject.accessibleTitle;
    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
      div.title = `displayObject ${displayObject.tabIndex}`;
    }
    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
      div.setAttribute("aria-label", displayObject.accessibleHint);
    }
    if (this.debug)
      this.updateDebugHTML(div);
    displayObject._accessibleActive = true;
    displayObject._accessibleDiv = div;
    div.displayObject = displayObject;
    this.children.push(displayObject);
    this.div.appendChild(displayObject._accessibleDiv);
    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
  }
  _dispatchEvent(e3, type) {
    const { displayObject: target } = e3.target;
    const boundry = this.renderer.events.rootBoundary;
    const event = Object.assign(new FederatedEvent(boundry), { target });
    boundry.rootTarget = this.renderer.lastObjectRendered;
    type.forEach((type2) => boundry.dispatchEvent(event, type2));
  }
  _onClick(e3) {
    this._dispatchEvent(e3, ["click", "pointertap", "tap"]);
  }
  _onFocus(e3) {
    if (!e3.target.getAttribute("aria-live")) {
      e3.target.setAttribute("aria-live", "assertive");
    }
    this._dispatchEvent(e3, ["mouseover"]);
  }
  _onFocusOut(e3) {
    if (!e3.target.getAttribute("aria-live")) {
      e3.target.setAttribute("aria-live", "polite");
    }
    this._dispatchEvent(e3, ["mouseout"]);
  }
  _onKeyDown(e3) {
    if (e3.keyCode !== KEY_CODE_TAB) {
      return;
    }
    this.activate();
  }
  _onMouseMove(e3) {
    if (e3.movementX === 0 && e3.movementY === 0) {
      return;
    }
    this.deactivate();
  }
  destroy() {
    this.destroyTouchHook();
    this.div = null;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown);
    this.pool = null;
    this.children = null;
    this.renderer = null;
  }
}
AccessibilityManager.extension = {
  name: "accessibility",
  type: [
    ExtensionType.RendererPlugin,
    ExtensionType.CanvasRendererPlugin
  ]
};
extensions.add(AccessibilityManager);
// node_modules/colord/plugins/names.mjsisten
var _Application = class {
  constructor(options) {
    this.stage = new Container;
    options = Object.assign({
      forceCanvas: false
    }, options);
    this.renderer = autoDetectRenderer(options);
    _Application._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  render() {
    this.renderer.render(this.stage);
  }
  get view() {
    return this.renderer.view;
  }
  get screen() {
    return this.renderer.screen;
  }
  destroy(removeView, stageOptions) {
    const plugins = _Application._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(stageOptions);
    this.stage = null;
    this.renderer.destroy(removeView);
    this.renderer = null;
  }
};
var Application = _Application;
Application._plugins = [];
extensions.handleByList(ExtensionType.Application, Application._plugins);
// node_modules/colord/plugins/names.mjsistene
class ResizePlugin {
  static init(options) {
    Object.defineProperty(this, "resizeTo", {
      set(dom) {
        globalThis.removeEventListener("resize", this.queueResize);
        this._resizeTo = dom;
        if (dom) {
          globalThis.addEventListener("resize", this.queueResize);
          this.resize();
        }
      },
      get() {
        return this._resizeTo;
      }
    });
    this.queueResize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      this._resizeId = requestAnimationFrame(() => this.resize());
    };
    this.cancelResize = () => {
      if (this._resizeId) {
        cancelAnimationFrame(this._resizeId);
        this._resizeId = null;
      }
    };
    this.resize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      let width;
      let height;
      if (this._resizeTo === globalThis.window) {
        width = globalThis.innerWidth;
        height = globalThis.innerHeight;
      } else {
        const { clientWidth, clientHeight } = this._resizeTo;
        width = clientWidth;
        height = clientHeight;
      }
      this.renderer.resize(width, height);
      this.render();
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
  }
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize);
    this.cancelResize();
    this.cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  }
}
ResizePlugin.extension = ExtensionType.Application;
extensions.add(ResizePlugin);
// node_modules/colord/plugins/names.mjsistener.mjs
var assetKeyMap = {
  loader: ExtensionType.LoadParser,
  resolver: ExtensionType.ResolveParser,
  cache: ExtensionType.CacheParser,
  detection: ExtensionType.DetectionParser
};
extensions.handle(ExtensionType.Asset, (extension) => {
  const ref = extension.ref;
  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(ref[key], { extension: ref[key].extension ?? type })));
}, (extension) => {
  const ref = extension.ref;
  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
});

// node_modules/colord/plugins/names.mjsistener.mjsgl
class BackgroundLoader {
  constructor(loader, verbose = false) {
    this._loader = loader;
    this._assetList = [];
    this._isLoading = false;
    this._maxConcurrent = 1;
    this.verbose = verbose;
  }
  add(assetUrls) {
    assetUrls.forEach((a3) => {
      this._assetList.push(a3);
    });
    if (this.verbose)
      console.log("[BackgroundLoader] assets: ", this._assetList);
    if (this._isActive && !this._isLoading) {
      this._next();
    }
  }
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [];
      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i3 = 0;i3 < toLoadAmount; i3++) {
        toLoad.push(this._assetList.pop());
      }
      await this._loader.load(toLoad);
      this._isLoading = false;
      this._next();
    }
  }
  get active() {
    return this._isActive;
  }
  set active(value) {
    if (this._isActive === value)
      return;
    this._isActive = value;
    if (value && !this._isLoading) {
      this._next();
    }
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.
var checkDataUrl = function(url3, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url3.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url3.startsWith(`data:${mimes}`);
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mj
var checkExtension = function(url3, extension) {
  const tempURL = url3.split("?")[0];
  const ext = exports_lib.path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.m
var convertToList = (input, transform) => {
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!transform) {
    return input;
  }
  return input.map((item) => {
    if (typeof item === "string") {
      return transform(item);
    }
    return item;
  });
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2
var copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  if (searchParams) {
    targetUrl += `?${searchParams}`;
  }
  return targetUrl;
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsT
var processX = function(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i3 = 0;i3 < id.length; i3++) {
    const value = id[i3];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
};
var createStringVariations = function(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.
var isSingleItem = (item) => !Array.isArray(item);
// node_modules/colord/plugins/names.mjsistener.
class CacheClass {
  constructor() {
    this._parsers = [];
    this._cache = new Map;
    this._cacheMap = new Map;
  }
  reset() {
    this._cacheMap.clear();
    this._cache.clear();
  }
  has(key) {
    return this._cache.has(key);
  }
  get(key) {
    const result = this._cache.get(key);
    if (!result) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
    }
    return result;
  }
  set(key, value) {
    const keys = convertToList(key);
    let cacheableAssets;
    for (let i3 = 0;i3 < this.parsers.length; i3++) {
      const parser = this.parsers[i3];
      if (parser.test(value)) {
        cacheableAssets = parser.getCacheableAssets(keys, value);
        break;
      }
    }
    if (!cacheableAssets) {
      cacheableAssets = {};
      keys.forEach((key2) => {
        cacheableAssets[key2] = value;
      });
    }
    const cacheKeys = Object.keys(cacheableAssets);
    const cachedAssets = {
      cacheKeys,
      keys
    };
    keys.forEach((key2) => {
      this._cacheMap.set(key2, cachedAssets);
    });
    cacheKeys.forEach((key2) => {
      if (this._cache.has(key2) && this._cache.get(key2) !== value) {
        console.warn("[Cache] already has key:", key2);
      }
      this._cache.set(key2, cacheableAssets[key2]);
    });
    if (value instanceof Texture) {
      const texture3 = value;
      keys.forEach((key2) => {
        if (texture3.baseTexture !== Texture.EMPTY.baseTexture) {
          BaseTexture.addToCache(texture3.baseTexture, key2);
        }
        Texture.addToCache(texture3, key2);
      });
    }
  }
  remove(key) {
    this._cacheMap.get(key);
    if (!this._cacheMap.has(key)) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
      return;
    }
    const cacheMap = this._cacheMap.get(key);
    const cacheKeys = cacheMap.cacheKeys;
    cacheKeys.forEach((key2) => {
      this._cache.delete(key2);
    });
    cacheMap.keys.forEach((key2) => {
      this._cacheMap.delete(key2);
    });
  }
  get parsers() {
    return this._parsers;
  }
}
var Cache = new CacheClass;

// node_modules/colord/plugins/names.mjsistener.mj
class Loader {
  constructor() {
    this._parsers = [];
    this._parsersValidated = false;
    this.parsers = new Proxy(this._parsers, {
      set: (target, key, value) => {
        this._parsersValidated = false;
        target[key] = value;
        return true;
      }
    });
    this.promiseCache = {};
  }
  reset() {
    this._parsersValidated = false;
    this.promiseCache = {};
  }
  _getLoadPromiseAndParser(url3, data) {
    const result = {
      promise: null,
      parser: null
    };
    result.promise = (async () => {
      let asset = null;
      let parser = null;
      if (data.loadParser) {
        parser = this._parserHash[data.loadParser];
        if (!parser) {
          console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url3}`);
        }
      }
      if (!parser) {
        for (let i3 = 0;i3 < this.parsers.length; i3++) {
          const parserX = this.parsers[i3];
          if (parserX.load && parserX.test?.(url3, data, this)) {
            parser = parserX;
            break;
          }
        }
        if (!parser) {
          console.warn(`[Assets] ${url3} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
          return null;
        }
      }
      asset = await parser.load(url3, data, this);
      result.parser = parser;
      for (let i3 = 0;i3 < this.parsers.length; i3++) {
        const parser2 = this.parsers[i3];
        if (parser2.parse) {
          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
            asset = await parser2.parse(asset, data, this) || asset;
            result.parser = parser2;
          }
        }
      }
      return asset;
    })();
    return result;
  }
  async load(assetsToLoadIn, onProgress) {
    if (!this._parsersValidated) {
      this._validateParsers();
    }
    let count = 0;
    const assets = {};
    const singleAsset = isSingleItem(assetsToLoadIn);
    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
      src: item
    }));
    const total = assetsToLoad.length;
    const promises = assetsToLoad.map(async (asset) => {
      const url3 = exports_lib.path.toAbsolute(asset.src);
      if (!assets[asset.src]) {
        try {
          if (!this.promiseCache[url3]) {
            this.promiseCache[url3] = this._getLoadPromiseAndParser(url3, asset);
          }
          assets[asset.src] = await this.promiseCache[url3].promise;
          if (onProgress)
            onProgress(++count / total);
        } catch (e3) {
          delete this.promiseCache[url3];
          delete assets[asset.src];
          throw new Error(`[Loader.load] Failed to load ${url3}.
${e3}`);
        }
      }
    });
    await Promise.all(promises);
    return singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  async unload(assetsToUnloadIn) {
    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
      src: item
    }));
    const promises = assetsToUnload.map(async (asset) => {
      const url3 = exports_lib.path.toAbsolute(asset.src);
      const loadPromise = this.promiseCache[url3];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        loadPromise.parser?.unload?.(loadedAsset, asset, this);
        delete this.promiseCache[url3];
      }
    });
    await Promise.all(promises);
  }
  _validateParsers() {
    this._parsersValidated = true;
    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
      if (hash[parser.name]) {
        console.warn(`[Assets] loadParser name conflict "${parser.name}"`);
      }
      return { ...hash, [parser.name]: parser };
    }, {});
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
var LoaderParserPriority = ((LoaderParserPriority2) => {
  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
  return LoaderParserPriority2;
})(LoaderParserPriority || {});
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
var validJSONExtension = ".json";
var validJSONMIME = "application/json";
var loadJson = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  name: "loadJson",
  test(url3) {
    return checkDataUrl(url3, validJSONMIME) || checkExtension(url3, validJSONExtension);
  },
  async load(url3) {
    const response = await settings.ADAPTER.fetch(url3);
    const json = await response.json();
    return json;
  }
};
extensions.add(loadJson);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2
var validTXTExtension = ".txt";
var validTXTMIME = "text/plain";
var loadTxt = {
  name: "loadTxt",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  test(url3) {
    return checkDataUrl(url3, validTXTMIME) || checkExtension(url3, validTXTExtension);
  },
  async load(url3) {
    const response = await settings.ADAPTER.fetch(url3);
    const txt = await response.text();
    return txt;
  }
};
extensions.add(loadTxt);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mj
var getFontFamilyName = function(url3) {
  const ext = exports_lib.path.extname(url3);
  const name = exports_lib.path.basename(url3, ext);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
};
var validWeights = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
];
var validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
var validFontMIMEs = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
];
var CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
var loadWebFont = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  name: "loadWebFont",
  test(url3) {
    return checkDataUrl(url3, validFontMIMEs) || checkExtension(url3, validFontExtensions);
  },
  async load(url3, options) {
    const fonts = settings.ADAPTER.getFontFaceSet();
    if (fonts) {
      const fontFaces = [];
      const name = options.data?.family ?? getFontFamilyName(url3);
      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
      const data = options.data ?? {};
      for (let i3 = 0;i3 < weights.length; i3++) {
        const weight = weights[i3];
        const font = new FontFace(name, `url(${encodeURI(url3)})`, {
          ...data,
          weight
        });
        await font.load();
        fonts.add(font);
        fontFaces.push(font);
      }
      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
    }
    console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
    return null;
  },
  unload(font) {
    (Array.isArray(font) ? font : [font]).forEach((t4) => settings.ADAPTER.getFontFaceSet().delete(t4));
  }
};
extensions.add(loadWebFont);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsT
var UUID = 0;
var MAX_WORKERS;
var WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
var checkImageBitmapCode = {
  id: "checkImageBitmap",
  code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
};
var workerCode = {
  id: "loadImageBitmap",
  code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
};
var workerURL;

class WorkerManagerClass {
  constructor() {
    this._initialized = false;
    this._createdWorkers = 0;
    this.workerPool = [];
    this.queue = [];
    this.resolveHash = {};
  }
  isImageBitmapSupported() {
    if (this._isImageBitmapSupported !== undefined)
      return this._isImageBitmapSupported;
    this._isImageBitmapSupported = new Promise((resolve) => {
      const workerURL2 = URL.createObjectURL(new Blob([checkImageBitmapCode.code], { type: "application/javascript" }));
      const worker = new Worker(workerURL2);
      worker.addEventListener("message", (event) => {
        worker.terminate();
        URL.revokeObjectURL(workerURL2);
        resolve(event.data);
      });
    });
    return this._isImageBitmapSupported;
  }
  loadImageBitmap(src) {
    return this._run("loadImageBitmap", [src]);
  }
  async _initWorkers() {
    if (this._initialized)
      return;
    this._initialized = true;
  }
  getWorker() {
    if (MAX_WORKERS === undefined) {
      MAX_WORKERS = navigator.hardwareConcurrency || 4;
    }
    let worker = this.workerPool.pop();
    if (!worker && this._createdWorkers < MAX_WORKERS) {
      if (!workerURL) {
        workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
      }
      this._createdWorkers++;
      worker = new Worker(workerURL);
      worker.addEventListener("message", (event) => {
        this.complete(event.data);
        this.returnWorker(event.target);
        this.next();
      });
    }
    return worker;
  }
  returnWorker(worker) {
    this.workerPool.push(worker);
  }
  complete(data) {
    if (data.error !== undefined) {
      this.resolveHash[data.uuid].reject(data.error);
    } else {
      this.resolveHash[data.uuid].resolve(data.data);
    }
    this.resolveHash[data.uuid] = null;
  }
  async _run(id, args) {
    await this._initWorkers();
    const promise = new Promise((resolve, reject) => {
      this.queue.push({ id, arguments: args, resolve, reject });
    });
    this.next();
    return promise;
  }
  next() {
    if (!this.queue.length)
      return;
    const worker = this.getWorker();
    if (!worker) {
      return;
    }
    const toDo = this.queue.pop();
    const id = toDo.id;
    this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
    worker.postMessage({
      data: toDo.arguments,
      uuid: UUID++,
      id
    });
  }
}
var WorkerManager = new WorkerManagerClass;

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExtension
var createTexture = function(base, loader, url3) {
  const texture3 = new Texture(base);
  texture3.baseTexture.on("dispose", () => {
    delete loader.promiseCache[url3];
  });
  return texture3;
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureEx
async function loadImageBitmap(url3) {
  const response = await settings.ADAPTER.fetch(url3);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url3}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  const imageBitmap = await createImageBitmap(imageBlob);
  return imageBitmap;
}
var validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
var validImageMIMEs = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
var loadTextures = {
  name: "loadTextures",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  config: {
    preferWorkers: true,
    preferCreateImageBitmap: true,
    crossOrigin: "anonymous"
  },
  test(url3) {
    return checkDataUrl(url3, validImageMIMEs) || checkExtension(url3, validImageExtensions);
  },
  async load(url3, asset, loader) {
    let src = null;
    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
        src = await WorkerManager.loadImageBitmap(url3);
      } else {
        src = await loadImageBitmap(url3);
      }
    } else {
      src = await new Promise((resolve) => {
        src = new Image;
        src.crossOrigin = this.config.crossOrigin;
        src.src = url3;
        if (src.complete) {
          resolve(src);
        } else {
          src.onload = () => {
            resolve(src);
          };
        }
      });
    }
    const base = new BaseTexture(src, {
      resolution: exports_lib.getResolutionOfUrl(url3),
      ...asset.data
    });
    base.resource.src = url3;
    return createTexture(base, loader, url3);
  },
  unload(texture3) {
    texture3.destroy(true);
  }
};
extensions.add(loadTextures);

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsText
var validSVGExtension = ".svg";
var validSVGMIME = "image/svg+xml";
var loadSVG = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadSVG",
  test(url3) {
    return checkDataUrl(url3, validSVGMIME) || checkExtension(url3, validSVGExtension);
  },
  async testParse(data) {
    return SVGResource.test(data);
  },
  async parse(asset, data, loader) {
    const src = new SVGResource(asset, data?.data?.resourceOptions);
    await src.load();
    const base = new BaseTexture(src, {
      resolution: exports_lib.getResolutionOfUrl(asset),
      ...data?.data
    });
    base.resource.src = asset;
    const texture3 = createTexture(base, loader, asset);
    return texture3;
  },
  async load(url3, _options) {
    const response = await settings.ADAPTER.fetch(url3);
    return response.text();
  },
  unload: loadTextures.unload
};
extensions.add(loadSVG);
// node_modules/colord/plugins/names.mjsistener.mjsgle
class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  get parsers() {
    return this._parsers;
  }
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  addManifest(manifest) {
    if (this._manifest) {
      console.warn("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  addBundle(bundleId, assets) {
    const assetNames = [];
    if (Array.isArray(assets)) {
      assets.forEach((asset) => {
        if (typeof asset.name === "string") {
          const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);
          assetNames.push(bundleAssetId);
          this.add([asset.name, bundleAssetId], asset.srcs, asset.data);
        } else {
          const bundleIds = asset.name.map((name) => this._createBundleAssetId(bundleId, name));
          bundleIds.forEach((bundleId2) => {
            assetNames.push(bundleId2);
          });
          this.add([...asset.name, ...bundleIds], asset.srcs);
        }
      });
    } else {
      Object.keys(assets).forEach((key) => {
        assetNames.push(this._createBundleAssetId(bundleId, key));
        this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);
      });
    }
    this._bundles[bundleId] = assetNames;
  }
  add(keysIn, assetsIn, data) {
    const keys = convertToList(keysIn);
    keys.forEach((key) => {
      if (this.hasKey(key)) {
        console.warn(`[Resolver] already has key: ${key} overwriting`);
      }
    });
    if (!Array.isArray(assetsIn)) {
      if (typeof assetsIn === "string") {
        assetsIn = createStringVariations(assetsIn);
      } else {
        assetsIn = [assetsIn];
      }
    }
    const assetMap = assetsIn.map((asset) => {
      let formattedAsset = asset;
      if (typeof asset === "string") {
        let parsed = false;
        for (let i3 = 0;i3 < this._parsers.length; i3++) {
          const parser = this._parsers[i3];
          if (parser.test(asset)) {
            formattedAsset = parser.parse(asset);
            parsed = true;
            break;
          }
        }
        if (!parsed) {
          formattedAsset = {
            src: asset
          };
        }
      }
      if (!formattedAsset.format) {
        formattedAsset.format = formattedAsset.src.split(".").pop();
      }
      if (!formattedAsset.alias) {
        formattedAsset.alias = keys;
      }
      if (this._basePath || this._rootPath) {
        formattedAsset.src = exports_lib.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
      }
      formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
      formattedAsset.data = formattedAsset.data ?? data;
      return formattedAsset;
    });
    keys.forEach((key) => {
      this._assetMap[key] = assetMap;
    });
  }
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem(bundleIds);
    bundleIds = convertToList(bundleIds);
    const out = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out[bundleId] = assets;
      }
    });
    return singleAsset ? out[bundleIds[0]] : out;
  }
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key !== "string") {
      const out = {};
      for (const i3 in result) {
        out[i3] = result[i3].src;
      }
      return out;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = isSingleItem(keys);
    keys = convertToList(keys);
    const result = {};
    keys.forEach((key) => {
      if (!this._resolverHash[key]) {
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const preferredOrder = this._getPreferredOrder(assets);
          const bestAsset = assets[0];
          preferredOrder?.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key] = assets[0] ?? bestAsset;
        } else {
          let src = key;
          if (this._basePath || this._rootPath) {
            src = exports_lib.path.toAbsolute(src, this._basePath, this._rootPath);
          }
          src = this._appendDefaultSearchParams(src);
          this._resolverHash[key] = {
            src
          };
        }
      }
      result[key] = this._resolverHash[key];
    });
    return singleAsset ? result[keys[0]] : result;
  }
  hasKey(key) {
    return !!this._assetMap[key];
  }
  hasBundle(key) {
    return !!this._bundles[key];
  }
  _getPreferredOrder(assets) {
    for (let i3 = 0;i3 < assets.length; i3++) {
      const asset = assets[0];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  _appendDefaultSearchParams(url3) {
    if (!this._defaultSearchParams)
      return url3;
    const paramConnector = /\?/.test(url3) ? "&" : "?";
    return `${url3}${paramConnector}${this._defaultSearchParams}`;
  }
}

// node_modules/colord/plugins/names.mjsist
class AssetsClass {
  constructor() {
    this._detections = [];
    this._initialized = false;
    this.resolver = new Resolver;
    this.loader = new Loader;
    this.cache = Cache;
    this._backgroundLoader = new BackgroundLoader(this.loader);
    this._backgroundLoader.active = true;
    this.reset();
  }
  async init(options = {}) {
    if (this._initialized) {
      console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
      return;
    }
    this._initialized = true;
    if (options.defaultSearchParams) {
      this.resolver.setDefaultSearchParams(options.defaultSearchParams);
    }
    if (options.basePath) {
      this.resolver.basePath = options.basePath;
    }
    if (options.bundleIdentifier) {
      this.resolver.setBundleIdentifier(options.bundleIdentifier);
    }
    if (options.manifest) {
      let manifest = options.manifest;
      if (typeof manifest === "string") {
        manifest = await this.load(manifest);
      }
      this.resolver.addManifest(manifest);
    }
    const resolutionPref = options.texturePreference?.resolution ?? 1;
    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
    let formats = [];
    if (options.texturePreference?.format) {
      const formatPref = options.texturePreference?.format;
      formats = typeof formatPref === "string" ? [formatPref] : formatPref;
      for (const detection of this._detections) {
        if (!await detection.test()) {
          formats = await detection.remove(formats);
        }
      }
    } else {
      for (const detection of this._detections) {
        if (await detection.test()) {
          formats = await detection.add(formats);
        }
      }
    }
    this.resolver.prefer({
      params: {
        format: formats,
        resolution
      }
    });
    if (options.preferences) {
      this.setPreferences(options.preferences);
    }
  }
  add(keysIn, assetsIn, data) {
    this.resolver.add(keysIn, assetsIn, data);
  }
  async load(urls, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    const singleAsset = isSingleItem(urls);
    const urlArray = convertToList(urls).map((url3) => {
      if (typeof url3 !== "string") {
        this.resolver.add(url3.src, url3);
        return url3.src;
      }
      if (!this.resolver.hasKey(url3)) {
        this.resolver.add(url3, url3);
      }
      return url3;
    });
    const resolveResults = this.resolver.resolve(urlArray);
    const out = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out[urlArray[0]] : out;
  }
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  async loadBundle(bundleIds, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    let singleAsset = false;
    if (typeof bundleIds === "string") {
      singleAsset = true;
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const out = {};
    const keys = Object.keys(resolveResults);
    let count = 0;
    let total = 0;
    const _onProgress = () => {
      onProgress?.(++count / total);
    };
    const promises = keys.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      total += Object.keys(resolveResult).length;
      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out[bundleId] = resolveResult2;
      });
    });
    await Promise.all(promises);
    return singleAsset ? out[bundleIds[0]] : out;
  }
  async backgroundLoad(urls) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof urls === "string") {
      urls = [urls];
    }
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  async backgroundLoadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof bundleIds === "string") {
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  reset() {
    this.resolver.reset();
    this.loader.reset();
    this.cache.reset();
    this._initialized = false;
  }
  get(keys) {
    if (typeof keys === "string") {
      return Cache.get(keys);
    }
    const assets = {};
    for (let i3 = 0;i3 < keys.length; i3++) {
      assets[i3] = Cache.get(keys[i3]);
    }
    return assets;
  }
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = Object.values(resolveResults);
    const resolveKeys = Object.keys(resolveResults);
    this._backgroundLoader.active = false;
    const loadedAssets = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = true;
    const out = {};
    resolveArray.forEach((resolveResult, i3) => {
      const asset = loadedAssets[resolveResult.src];
      const keys = [resolveResult.src];
      if (resolveResult.alias) {
        keys.push(...resolveResult.alias);
      }
      out[resolveKeys[i3]] = asset;
      Cache.set(keys, asset);
    });
    return out;
  }
  async unload(urls) {
    if (!this._initialized) {
      await this.init();
    }
    const urlArray = convertToList(urls).map((url3) => typeof url3 !== "string" ? url3.src : url3);
    const resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  async unloadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    bundleIds = convertToList(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      Cache.remove(resolveResult2.src);
    });
    await this.loader.unload(resolveArray);
  }
  get detections() {
    return this._detections;
  }
  get preferWorkers() {
    return loadTextures.config.preferWorkers;
  }
  set preferWorkers(value) {
    exports_lib.deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.");
    this.setPreferences({ preferWorkers: value });
  }
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      if (!parser.config)
        return;
      Object.keys(parser.config).filter((key) => (key in preferences)).forEach((key) => {
        parser.config[key] = preferences[key];
      });
    });
  }
}
var Assets = new AssetsClass;
extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsText
var cacheTextureArray = {
  extension: ExtensionType.CacheParser,
  test: (asset) => Array.isArray(asset) && asset.every((t4) => t4 instanceof Texture),
  getCacheableAssets: (keys, asset) => {
    const out = {};
    keys.forEach((key) => {
      asset.forEach((item, i3) => {
        out[key + (i3 === 0 ? "" : i3 + 1)] = item;
      });
    });
    return out;
  }
};
extensions.add(cacheTextureArray);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTe
var detectAvif = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 1
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
    const blob = await settings.ADAPTER.fetch(avifData).then((r4) => r4.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats) => [...formats, "avif"],
  remove: async (formats) => formats.filter((f3) => f3 !== "avif")
};
extensions.add(detectAvif);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTe
var detectWebp = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
    const blob = await settings.ADAPTER.fetch(webpData).then((r4) => r4.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats) => [...formats, "webp"],
  remove: async (formats) => formats.filter((f3) => f3 !== "webp")
};
extensions.add(detectWebp);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextur
var imageFormats = ["png", "jpg", "jpeg"];
var detectDefaults = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(true),
  add: async (formats) => [...formats, ...imageFormats],
  remove: async (formats) => formats.filter((f3) => !imageFormats.includes(f3))
};
extensions.add(detectDefaults);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTexture
var resolveTextureUrl = {
  extension: ExtensionType.ResolveParser,
  test: loadTextures.test,
  parse: (value) => ({
    resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
    format: value.split(".").pop(),
    src: value
  })
};
extensions.add(resolveTextureUrl);
// node_modules/colord/plugins/names.mjsistener.mjsgle.
var INTERNAL_FORMATS = ((INTERNAL_FORMATS2) => {
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
  return INTERNAL_FORMATS2;
})(INTERNAL_FORMATS || {});
var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
  [33776]: 0.5,
  [33777]: 0.5,
  [33778]: 1,
  [33779]: 1,
  [35916]: 0.5,
  [35917]: 0.5,
  [35918]: 1,
  [35919]: 1,
  [37488]: 0.5,
  [37489]: 0.5,
  [37490]: 1,
  [37491]: 1,
  [37492]: 0.5,
  [37496]: 1,
  [37493]: 0.5,
  [37497]: 1,
  [37494]: 0.5,
  [37495]: 0.5,
  [35840]: 0.5,
  [35842]: 0.5,
  [35841]: 0.25,
  [35843]: 0.25,
  [36196]: 0.5,
  [35986]: 0.5,
  [35986]: 1,
  [34798]: 1,
  [37808]: 1
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExtensions.
var getCompressedTextureExtensions = function() {
  extensions30 = {
    s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),
    s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
    etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),
    etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),
    pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
    atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),
    astc: storedGl.getExtension("WEBGL_compressed_texture_astc")
  };
};
var storedGl;
var extensions30;
var detectCompressedTextures = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 2
  },
  test: async () => {
    const canvas = settings.ADAPTER.createCanvas();
    const gl = canvas.getContext("webgl");
    if (!gl) {
      console.warn("WebGL not available for compressed textures.");
      return false;
    }
    storedGl = gl;
    return true;
  },
  add: async (formats) => {
    if (!extensions30)
      getCompressedTextureExtensions();
    const textureFormats = [];
    for (const extensionName in extensions30) {
      const extension = extensions30[extensionName];
      if (!extension) {
        continue;
      }
      textureFormats.push(extensionName);
    }
    return [...textureFormats, ...formats];
  },
  remove: async (formats) => {
    if (!extensions30)
      getCompressedTextureExtensions();
    return formats.filter((f3) => !(f3 in extensions30));
  }
};
extensions.add(detectCompressedTextures);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureE
class BlobResource extends BufferResource {
  constructor(source, options = { width: 1, height: 1, autoLoad: true }) {
    let origin;
    let data;
    if (typeof source === "string") {
      origin = source;
      data = new Uint8Array;
    } else {
      origin = null;
      data = source;
    }
    super(data, options);
    this.origin = origin;
    this.buffer = data ? new ViewableBuffer(data) : null;
    this._load = null;
    this.loaded = false;
    if (this.origin !== null && options.autoLoad !== false) {
      this.load();
    }
    if (this.origin === null && this.buffer) {
      this._load = Promise.resolve(this);
      this.loaded = true;
      this.onBlobLoaded(this.buffer.rawBinaryData);
    }
  }
  onBlobLoaded(_data) {
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = fetch(this.origin).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => {
      this.data = new Uint32Array(arrayBuffer);
      this.buffer = new ViewableBuffer(arrayBuffer);
      this.loaded = true;
      this.onBlobLoaded(arrayBuffer);
      this.update();
      return this;
    });
    return this._load;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExtensions.mjs
class CompressedTextureResource extends BlobResource {
  constructor(source, options) {
    super(source, options);
    this.format = options.format;
    this.levels = options.levels || 1;
    this._width = options.width;
    this._height = options.height;
    this._extension = CompressedTextureResource._formatToExtension(this.format);
    if (options.levelBuffers || this.buffer) {
      this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
    }
  }
  upload(renderer, _texture, _glTexture) {
    const gl = renderer.gl;
    const extension = renderer.context.extensions[this._extension];
    if (!extension) {
      throw new Error(`${this._extension} textures are not supported on the current machine`);
    }
    if (!this._levelBuffers) {
      return false;
    }
    for (let i3 = 0, j3 = this.levels;i3 < j3; i3++) {
      const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i3];
      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
    }
    return true;
  }
  onBlobLoaded() {
    this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
  }
  static _formatToExtension(format) {
    if (format >= 33776 && format <= 33779) {
      return "s3tc";
    } else if (format >= 37488 && format <= 37497) {
      return "etc";
    } else if (format >= 35840 && format <= 35843) {
      return "pvrtc";
    } else if (format >= 36196) {
      return "etc1";
    } else if (format >= 35986 && format <= 34798) {
      return "atc";
    }
    throw new Error("Invalid (compressed) texture format given!");
  }
  static _createLevelBuffers(buffer, format, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
    const buffers = new Array(levels);
    let offset = buffer.byteOffset;
    let levelWidth = imageWidth;
    let levelHeight = imageHeight;
    let alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
    let alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
    let levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
    for (let i3 = 0;i3 < levels; i3++) {
      buffers[i3] = {
        levelID: i3,
        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
        levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
      };
      offset += levelSize;
      levelWidth = levelWidth >> 1 || 1;
      levelHeight = levelHeight >> 1 || 1;
      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
    }
    return buffers;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTe
var parseDDS = function(arrayBuffer) {
  const data = new Uint32Array(arrayBuffer);
  const magicWord = data[0];
  if (magicWord !== DDS_MAGIC) {
    throw new Error("Invalid DDS file magic word");
  }
  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const height = header[DDS_FIELDS.HEIGHT];
  const width = header[DDS_FIELDS.WIDTH];
  const mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
  const pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const formatFlags = pixelFormat[PF_FLAGS];
  if (formatFlags & DDPF_FOURCC) {
    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
    if (fourCC !== FOURCC_DX10) {
      const internalFormat2 = FOURCC_TO_FORMAT[fourCC];
      const dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      const texData = new Uint8Array(arrayBuffer, dataOffset2);
      const resource = new CompressedTextureResource(texData, {
        format: internalFormat2,
        width,
        height,
        levels: mipmapCount
      });
      return [resource];
    }
    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
    const dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    const dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
    const resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
    const miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
    const arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
    const internalFormat = DXGI_TO_FORMAT[dxgiFormat];
    if (internalFormat === undefined) {
      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
    }
    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
      throw new Error("DDSParser does not support cubemap textures");
    }
    if (resourceDimension === 6) {
      throw new Error("DDSParser does not supported 3D texture data");
    }
    const imageBuffers = new Array;
    const dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (arraySize === 1) {
      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
    } else {
      const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];
      let imageSize = 0;
      let levelWidth = width;
      let levelHeight = height;
      for (let i3 = 0;i3 < mipmapCount; i3++) {
        const alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
        const alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
        const levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
        imageSize += levelSize;
        levelWidth = levelWidth >>> 1;
        levelHeight = levelHeight >>> 1;
      }
      let imageOffset = dataOffset;
      for (let i3 = 0;i3 < arraySize; i3++) {
        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
        imageOffset += imageSize;
      }
    }
    return imageBuffers.map((buffer) => new CompressedTextureResource(buffer, {
      format: internalFormat,
      width,
      height,
      levels: mipmapCount
    }));
  }
  if (formatFlags & DDPF_RGB) {
    throw new Error("DDSParser does not support uncompressed texture data.");
  }
  if (formatFlags & DDPF_YUV) {
    throw new Error("DDSParser does not supported YUV uncompressed texture data.");
  }
  if (formatFlags & DDPF_LUMINANCE) {
    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
  }
  if (formatFlags & DDPF_ALPHA) {
    throw new Error("DDSParser does not support single-channel (alpha) texture data!");
  }
  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
};
var DDS_MAGIC_SIZE = 4;
var DDS_HEADER_SIZE = 124;
var DDS_HEADER_PF_SIZE = 32;
var DDS_HEADER_DX10_SIZE = 20;
var DDS_MAGIC = 542327876;
var DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
};
var DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
};
var DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
var PF_FLAGS = 1;
var DDPF_ALPHA = 2;
var DDPF_FOURCC = 4;
var DDPF_RGB = 64;
var DDPF_YUV = 512;
var DDPF_LUMINANCE = 131072;
var FOURCC_DXT1 = 827611204;
var FOURCC_DXT3 = 861165636;
var FOURCC_DXT5 = 894720068;
var FOURCC_DX10 = 808540228;
var DDS_RESOURCE_MISC_TEXTURECUBE = 4;
var FOURCC_TO_FORMAT = {
  [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
};
var DXGI_TO_FORMAT = {
  [70]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [71]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [73]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [74]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [76]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [77]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [72]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  [75]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  [78]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTe
var parseKTX = function(url3, arrayBuffer, loadKeyValueData = false) {
  const dataView = new DataView(arrayBuffer);
  if (!validate(url3, dataView)) {
    return null;
  }
  const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
  const glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
  const glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
  const glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
  const pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
  const pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
  const pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
  const numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
  const numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
  const numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
  const bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1) {
    throw new Error("Only 2D textures are supported");
  }
  if (numberOfFaces !== 1) {
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  }
  if (numberOfArrayElements !== 1) {
    throw new Error("WebGL does not support array textures");
  }
  const blockWidth = 4;
  const blockHeight = 4;
  const alignedWidth = pixelWidth + 3 & ~3;
  const alignedHeight = pixelHeight + 3 & ~3;
  const imageBuffers = new Array(numberOfArrayElements);
  let imagePixels = pixelWidth * pixelHeight;
  if (glType === 0) {
    imagePixels = alignedWidth * alignedHeight;
  }
  let imagePixelByteSize;
  if (glType !== 0) {
    if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
      imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
    } else {
      imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
    }
  } else {
    imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
  }
  if (imagePixelByteSize === undefined) {
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  }
  const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
  const imageByteSize = imagePixels * imagePixelByteSize;
  let mipByteSize = imageByteSize;
  let mipWidth = pixelWidth;
  let mipHeight = pixelHeight;
  let alignedMipWidth = alignedWidth;
  let alignedMipHeight = alignedHeight;
  let imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
  for (let mipmapLevel = 0;mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    const imageSize = dataView.getUint32(imageOffset, littleEndian);
    let elementOffset = imageOffset + 4;
    for (let arrayElement = 0;arrayElement < numberOfArrayElements; arrayElement++) {
      let mips = imageBuffers[arrayElement];
      if (!mips) {
        mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
      }
      mips[mipmapLevel] = {
        levelID: mipmapLevel,
        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
      };
      elementOffset += mipByteSize;
    }
    imageOffset += imageSize + 4;
    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
    mipWidth = mipWidth >> 1 || 1;
    mipHeight = mipHeight >> 1 || 1;
    alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
    alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  if (glType !== 0) {
    return {
      uncompressed: imageBuffers.map((levelBuffers) => {
        let buffer = levelBuffers[0].levelBuffer;
        let convertToInt = false;
        if (glType === TYPES.FLOAT) {
          buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === TYPES.UNSIGNED_INT) {
          convertToInt = true;
          buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === TYPES.INT) {
          convertToInt = true;
          buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        }
        return {
          resource: new BufferResource(buffer, {
            width: levelBuffers[0].levelWidth,
            height: levelBuffers[0].levelHeight
          }),
          type: glType,
          format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
        };
      }),
      kvData
    };
  }
  return {
    compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource(null, {
      format: glInternalFormat,
      width: pixelWidth,
      height: pixelHeight,
      levels: numberOfMipmapLevels,
      levelBuffers
    })),
    kvData
  };
};
var validate = function(url3, dataView) {
  for (let i3 = 0;i3 < FILE_IDENTIFIER.length; i3++) {
    if (dataView.getUint8(i3) !== FILE_IDENTIFIER[i3]) {
      console.error(`${url3} is not a valid *.ktx file!`);
      return false;
    }
  }
  return true;
};
var convertFormatToInteger = function(format) {
  switch (format) {
    case FORMATS.RGBA:
      return FORMATS.RGBA_INTEGER;
    case FORMATS.RGB:
      return FORMATS.RGB_INTEGER;
    case FORMATS.RG:
      return FORMATS.RG_INTEGER;
    case FORMATS.RED:
      return FORMATS.RED_INTEGER;
    default:
      return format;
  }
};
var parseKvData = function(dataView, bytesOfKeyValueData, littleEndian) {
  const kvData = new Map;
  let bytesIntoKeyValueData = 0;
  while (bytesIntoKeyValueData < bytesOfKeyValueData) {
    const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);
    const keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;
    const valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    let keyNulByte = 0;
    for (;keyNulByte < keyAndValueByteSize; keyNulByte++) {
      if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {
        break;
      }
    }
    if (keyNulByte === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    const key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
    const value = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
    kvData.set(key, value);
    bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
  }
  return kvData;
};
var FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
var ENDIANNESS = 67305985;
var KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
var FILE_HEADER_SIZE = 64;
var TYPES_TO_BYTES_PER_COMPONENT = {
  [TYPES.UNSIGNED_BYTE]: 1,
  [TYPES.UNSIGNED_SHORT]: 2,
  [TYPES.INT]: 4,
  [TYPES.UNSIGNED_INT]: 4,
  [TYPES.FLOAT]: 4,
  [TYPES.HALF_FLOAT]: 8
};
var FORMATS_TO_COMPONENTS = {
  [FORMATS.RGBA]: 4,
  [FORMATS.RGB]: 3,
  [FORMATS.RG]: 2,
  [FORMATS.RED]: 1,
  [FORMATS.LUMINANCE]: 1,
  [FORMATS.LUMINANCE_ALPHA]: 2,
  [FORMATS.ALPHA]: 1
};
var TYPES_TO_BYTES_PER_PIXEL = {
  [TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
  [TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
  [TYPES.UNSIGNED_SHORT_5_6_5]: 2
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsT
var loadDDS = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadDDS",
  test(url3) {
    return checkExtension(url3, ".dds");
  },
  async load(url3, asset, loader3) {
    const response = await settings.ADAPTER.fetch(url3);
    const arrayBuffer = await response.arrayBuffer();
    const resources4 = parseDDS(arrayBuffer);
    const textures2 = resources4.map((resource) => {
      const base = new BaseTexture(resource, {
        mipmap: MIPMAP_MODES.OFF,
        alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        resolution: exports_lib.getResolutionOfUrl(url3),
        ...asset.data
      });
      return createTexture(base, loader3, url3);
    });
    return textures2.length === 1 ? textures2[0] : textures2;
  },
  unload(texture3) {
    if (Array.isArray(texture3)) {
      texture3.forEach((t4) => t4.destroy(true));
    } else {
      texture3.destroy(true);
    }
  }
};
extensions.add(loadDDS);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsT
var loadKTX = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadKTX",
  test(url3) {
    return checkExtension(url3, ".ktx");
  },
  async load(url3, asset, loader3) {
    const response = await settings.ADAPTER.fetch(url3);
    const arrayBuffer = await response.arrayBuffer();
    const { compressed, uncompressed, kvData } = parseKTX(url3, arrayBuffer);
    const resources4 = compressed ?? uncompressed;
    const options = {
      mipmap: MIPMAP_MODES.OFF,
      alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
      resolution: exports_lib.getResolutionOfUrl(url3),
      ...asset.data
    };
    const textures2 = resources4.map((resource) => {
      if (resources4 === uncompressed) {
        Object.assign(options, {
          type: resource.type,
          format: resource.format
        });
      }
      const base = new BaseTexture(resource, options);
      base.ktxKeyValueData = kvData;
      return createTexture(base, loader3, url3);
    });
    return textures2.length === 1 ? textures2[0] : textures2;
  },
  unload(texture3) {
    if (Array.isArray(texture3)) {
      texture3.forEach((t4) => t4.destroy(true));
    } else {
      texture3.destroy(true);
    }
  }
};
extensions.add(loadKTX);
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExtensions.mjs
var resolveCompressedTextureUrl = {
  extension: ExtensionType.ResolveParser,
  test: (value) => {
    const temp = value.split("?")[0];
    const extension = temp.split(".").pop();
    return ["basis", "ktx", "dds"].includes(extension);
  },
  parse: (value) => {
    const temp = value.split("?")[0];
    const extension = temp.split(".").pop();
    if (extension === "ktx") {
      const extensions210 = [
        ".s3tc.ktx",
        ".s3tc_sRGB.ktx",
        ".etc.ktx",
        ".etc1.ktx",
        ".pvrt.ktx",
        ".atc.ktx",
        ".astc.ktx"
      ];
      if (extensions210.some((ext) => value.endsWith(ext))) {
        return {
          resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: extensions210.find((ext) => value.endsWith(ext)),
          src: value
        };
      }
    }
    return {
      resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
      format: value.split(".").pop(),
      src: value
    };
  }
};
extensions.add(resolveCompressedTextureUrl);
// node_modules/colord/plugins/names.mjsisten
var TEMP_RECT = new Rectangle;
var BYTES_PER_PIXEL = 4;
var _Extract = class {
  constructor(renderer) {
    this.renderer = renderer;
  }
  async image(target, format, quality) {
    const image = new Image;
    image.src = await this.base64(target, format, quality);
    return image;
  }
  async base64(target, format, quality) {
    const canvas = this.canvas(target);
    if (canvas.toBlob !== undefined) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader;
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        }, format, quality);
      });
    }
    if (canvas.toDataURL !== undefined) {
      return canvas.toDataURL(format, quality);
    }
    if (canvas.convertToBlob !== undefined) {
      const blob = await canvas.convertToBlob({ type: format, quality });
      return new Promise((resolve, reject) => {
        const reader = new FileReader;
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  canvas(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    const canvasBuffer = new exports_lib.CanvasRenderTarget(width, height, 1);
    const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);
    canvasBuffer.context.putImageData(imageData, 0, 0);
    return canvasBuffer.canvas;
  }
  pixels(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    return pixels;
  }
  _rawPixels(target, frame) {
    const renderer = this.renderer;
    if (!renderer) {
      throw new Error("The Extract has already been destroyed");
    }
    let resolution;
    let flipY = false;
    let renderTexture;
    let generated = false;
    if (target) {
      if (target instanceof RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = renderer.generateTexture(target, {
          resolution: renderer.resolution,
          multisample: renderer.multisample
        });
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = frame ?? renderTexture.frame;
      flipY = false;
      if (!generated) {
        renderer.renderTexture.bind(renderTexture);
        const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];
        if (fbo.blitFramebuffer) {
          renderer.framebuffer.bind(fbo.blitFramebuffer);
        }
      }
    } else {
      resolution = renderer.resolution;
      if (!frame) {
        frame = TEMP_RECT;
        frame.width = renderer.width / resolution;
        frame.height = renderer.height / resolution;
      }
      flipY = true;
      renderer.renderTexture.bind();
    }
    const width = Math.round(frame.width * resolution);
    const height = Math.round(frame.height * resolution);
    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    const gl = renderer.gl;
    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    if (generated) {
      renderTexture?.destroy(true);
    }
    return { pixels, width, height, flipY };
  }
  destroy() {
    this.renderer = null;
  }
  static _flipY(pixels, width, height) {
    const w3 = width << 2;
    const h3 = height >> 1;
    const temp = new Uint8Array(w3);
    for (let y3 = 0;y3 < h3; y3++) {
      const t4 = y3 * w3;
      const b3 = (height - y3 - 1) * w3;
      temp.set(pixels.subarray(t4, t4 + w3));
      pixels.copyWithin(t4, b3, b3 + w3);
      pixels.set(temp, b3);
    }
  }
  static _unpremultiplyAlpha(pixels) {
    if (pixels instanceof Uint8ClampedArray) {
      pixels = new Uint8Array(pixels.buffer);
    }
    const n4 = pixels.length;
    for (let i3 = 0;i3 < n4; i3 += 4) {
      const alpha2 = pixels[i3 + 3];
      if (alpha2 !== 0) {
        const a3 = 255.001 / alpha2;
        pixels[i3] = pixels[i3] * a3 + 0.5;
        pixels[i3 + 1] = pixels[i3 + 1] * a3 + 0.5;
        pixels[i3 + 2] = pixels[i3 + 2] * a3 + 0.5;
      }
    }
  }
};
var Extract = _Extract;
Extract.extension = {
  name: "extract",
  type: ExtensionType.RendererSystem
};
extensions.add(Extract);
// node_modules/colord/plugins/names.mjsistener.mjsgle.m
var buildCircle = {
  build(graphicsData) {
    const points2 = graphicsData.points;
    let x3;
    let y3;
    let dx;
    let dy;
    let rx;
    let ry;
    if (graphicsData.type === SHAPES.CIRC) {
      const circle = graphicsData.shape;
      x3 = circle.x;
      y3 = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (graphicsData.type === SHAPES.ELIP) {
      const ellipse = graphicsData.shape;
      x3 = ellipse.x;
      y3 = ellipse.y;
      rx = ellipse.width;
      ry = ellipse.height;
      dx = dy = 0;
    } else {
      const roundedRect = graphicsData.shape;
      const halfWidth = roundedRect.width / 2;
      const halfHeight = roundedRect.height / 2;
      x3 = roundedRect.x + halfWidth;
      y3 = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points2.length = 0;
      return;
    }
    const n4 = Math.ceil(2.3 * Math.sqrt(rx + ry));
    const m4 = n4 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    points2.length = m4;
    if (m4 === 0) {
      return;
    }
    if (n4 === 0) {
      points2.length = 8;
      points2[0] = points2[6] = x3 + dx;
      points2[1] = points2[3] = y3 + dy;
      points2[2] = points2[4] = x3 - dx;
      points2[5] = points2[7] = y3 - dy;
      return;
    }
    let j1 = 0;
    let j22 = n4 * 4 + (dx ? 2 : 0) + 2;
    let j3 = j22;
    let j4 = m4;
    {
      const x0 = dx + rx;
      const y0 = dy;
      const x1 = x3 + x0;
      const x22 = x3 - x0;
      const y1 = y3 + y0;
      points2[j1++] = x1;
      points2[j1++] = y1;
      points2[--j22] = y1;
      points2[--j22] = x22;
      if (dy) {
        const y22 = y3 - y0;
        points2[j3++] = x22;
        points2[j3++] = y22;
        points2[--j4] = y22;
        points2[--j4] = x1;
      }
    }
    for (let i3 = 1;i3 < n4; i3++) {
      const a3 = Math.PI / 2 * (i3 / n4);
      const x0 = dx + Math.cos(a3) * rx;
      const y0 = dy + Math.sin(a3) * ry;
      const x1 = x3 + x0;
      const x22 = x3 - x0;
      const y1 = y3 + y0;
      const y22 = y3 - y0;
      points2[j1++] = x1;
      points2[j1++] = y1;
      points2[--j22] = y1;
      points2[--j22] = x22;
      points2[j3++] = x22;
      points2[j3++] = y22;
      points2[--j4] = y22;
      points2[--j4] = x1;
    }
    {
      const x0 = dx;
      const y0 = dy + ry;
      const x1 = x3 + x0;
      const x22 = x3 - x0;
      const y1 = y3 + y0;
      const y22 = y3 - y0;
      points2[j1++] = x1;
      points2[j1++] = y1;
      points2[--j4] = y22;
      points2[--j4] = x1;
      if (dx) {
        points2[j1++] = x22;
        points2[j1++] = y1;
        points2[--j4] = y22;
        points2[--j4] = x22;
      }
    }
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points2 = graphicsData.points;
    const verts = graphicsGeometry.points;
    const indices2 = graphicsGeometry.indices;
    if (points2.length === 0) {
      return;
    }
    let vertPos = verts.length / 2;
    const center = vertPos;
    let x3;
    let y3;
    if (graphicsData.type !== SHAPES.RREC) {
      const circle = graphicsData.shape;
      x3 = circle.x;
      y3 = circle.y;
    } else {
      const roundedRect = graphicsData.shape;
      x3 = roundedRect.x + roundedRect.width / 2;
      y3 = roundedRect.y + roundedRect.height / 2;
    }
    const matrix = graphicsData.matrix;
    verts.push(graphicsData.matrix ? matrix.a * x3 + matrix.c * y3 + matrix.tx : x3, graphicsData.matrix ? matrix.b * x3 + matrix.d * y3 + matrix.ty : y3);
    vertPos++;
    verts.push(points2[0], points2[1]);
    for (let i3 = 2;i3 < points2.length; i3 += 2) {
      verts.push(points2[i3], points2[i3 + 1]);
      indices2.push(vertPos++, center, vertPos);
    }
    indices2.push(center + 1, center, vertPos);
  }
};
// node_modules/colord/plugins/names.mjsistener.mjsgle
var fixOrientation = function(points2, hole = false) {
  const m4 = points2.length;
  if (m4 < 6) {
    return;
  }
  let area = 0;
  for (let i3 = 0, x1 = points2[m4 - 2], y1 = points2[m4 - 1];i3 < m4; i3 += 2) {
    const x22 = points2[i3];
    const y22 = points2[i3 + 1];
    area += (x22 - x1) * (y22 + y1);
    x1 = x22;
    y1 = y22;
  }
  if (!hole && area > 0 || hole && area <= 0) {
    const n4 = m4 / 2;
    for (let i3 = n4 + n4 % 2;i3 < m4; i3 += 2) {
      const i1 = m4 - i3 - 2;
      const i22 = m4 - i3 - 1;
      const i32 = i3;
      const i4 = i3 + 1;
      [points2[i1], points2[i32]] = [points2[i32], points2[i1]];
      [points2[i22], points2[i4]] = [points2[i4], points2[i22]];
    }
  }
};
var buildPoly = {
  build(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate(graphicsData, graphicsGeometry) {
    let points2 = graphicsData.points;
    const holes = graphicsData.holes;
    const verts = graphicsGeometry.points;
    const indices2 = graphicsGeometry.indices;
    if (points2.length >= 6) {
      fixOrientation(points2, false);
      const holeArray = [];
      for (let i3 = 0;i3 < holes.length; i3++) {
        const hole = holes[i3];
        fixOrientation(hole.points, true);
        holeArray.push(points2.length / 2);
        points2 = points2.concat(hole.points);
      }
      const triangles = exports_lib.earcut(points2, holeArray, 2);
      if (!triangles) {
        return;
      }
      const vertPos = verts.length / 2;
      for (let i3 = 0;i3 < triangles.length; i3 += 3) {
        indices2.push(triangles[i3] + vertPos);
        indices2.push(triangles[i3 + 1] + vertPos);
        indices2.push(triangles[i3 + 2] + vertPos);
      }
      for (let i3 = 0;i3 < points2.length; i3++) {
        verts.push(points2[i3]);
      }
    }
  }
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2
var buildRectangle = {
  build(graphicsData) {
    const rectData = graphicsData.shape;
    const x3 = rectData.x;
    const y3 = rectData.y;
    const width = rectData.width;
    const height = rectData.height;
    const points2 = graphicsData.points;
    points2.length = 0;
    if (!(width >= 0 && height >= 0)) {
      return;
    }
    points2.push(x3, y3, x3 + width, y3, x3 + width, y3 + height, x3, y3 + height);
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points2 = graphicsData.points;
    const verts = graphicsGeometry.points;
    if (points2.length === 0) {
      return;
    }
    const vertPos = verts.length / 2;
    verts.push(points2[0], points2[1], points2[2], points2[3], points2[6], points2[7], points2[4], points2[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTe
var buildRoundedRectangle = {
  build(graphicsData) {
    buildCircle.build(graphicsData);
  },
  triangulate(graphicsData, graphicsGeometry) {
    buildCircle.triangulate(graphicsData, graphicsGeometry);
  }
};
// node_modules/colord/plugins/names.mjsiste
var LINE_JOIN = ((LINE_JOIN2) => {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
  return LINE_JOIN2;
})(LINE_JOIN || {});
var LINE_CAP = ((LINE_CAP2) => {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
  return LINE_CAP2;
})(LINE_CAP || {});
var curves = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 0.0001,
  _segmentsCount(length2, defaultSegments = 20) {
    if (!this.adaptive || !length2 || isNaN(length2)) {
      return defaultSegments;
    }
    let result = Math.ceil(length2 / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};

// node_modules/colord/plugins/names.mjsistener.mjsgl
class ArcUtils {
  static curveTo(x1, y1, x22, y22, radius, points2) {
    const fromX = points2[points2.length - 2];
    const fromY = points2[points2.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a22 = y22 - y1;
    const b22 = x22 - x1;
    const mm = Math.abs(a1 * b22 - b1 * a22);
    if (mm < 0.00000001 || radius === 0) {
      if (points2[points2.length - 2] !== x1 || points2[points2.length - 1] !== y1) {
        points2.push(x1, y1);
      }
      return null;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc2 = a22 * a22 + b22 * b22;
    const tt2 = a1 * a22 + b1 * b22;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k22 = radius * Math.sqrt(cc2) / mm;
    const j1 = k1 * tt2 / dd;
    const j22 = k22 * tt2 / cc2;
    const cx = k1 * b22 + k22 * b1;
    const cy = k1 * a22 + k22 * a1;
    const px = b1 * (k22 + j1);
    const py = a1 * (k22 + j1);
    const qx = b22 * (k1 + j22);
    const qy = a22 * (k1 + j22);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    return {
      cx: cx + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b1 * a22 > b22 * a1
    };
  }
  static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points2) {
    const sweep = endAngle - startAngle;
    const n4 = curves._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
    const theta = sweep / (n4 * 2);
    const theta2 = theta * 2;
    const cTheta = Math.cos(theta);
    const sTheta = Math.sin(theta);
    const segMinus = n4 - 1;
    const remainder = segMinus % 1 / segMinus;
    for (let i3 = 0;i3 <= segMinus; ++i3) {
      const real = i3 + remainder * i3;
      const angle = theta + startAngle + theta2 * real;
      const c3 = Math.cos(angle);
      const s3 = -Math.sin(angle);
      points2.push((cTheta * c3 + sTheta * s3) * radius + cx, (cTheta * -s3 + sTheta * c3) * radius + cy);
    }
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle
class BatchPart {
  constructor() {
    this.reset();
  }
  begin(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
  }
  end(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  }
  reset() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.m
class BezierUtils {
  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    const n4 = 10;
    let result = 0;
    let t4 = 0;
    let t22 = 0;
    let t32 = 0;
    let nt2 = 0;
    let nt22 = 0;
    let nt3 = 0;
    let x3 = 0;
    let y3 = 0;
    let dx = 0;
    let dy = 0;
    let prevX = fromX;
    let prevY = fromY;
    for (let i3 = 1;i3 <= n4; ++i3) {
      t4 = i3 / n4;
      t22 = t4 * t4;
      t32 = t22 * t4;
      nt2 = 1 - t4;
      nt22 = nt2 * nt2;
      nt3 = nt22 * nt2;
      x3 = nt3 * fromX + 3 * nt22 * t4 * cpX + 3 * nt2 * t22 * cpX2 + t32 * toX;
      y3 = nt3 * fromY + 3 * nt22 * t4 * cpY + 3 * nt2 * t22 * cpY2 + t32 * toY;
      dx = prevX - x3;
      dy = prevY - y3;
      prevX = x3;
      prevY = y3;
      result += Math.sqrt(dx * dx + dy * dy);
    }
    return result;
  }
  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points2) {
    const fromX = points2[points2.length - 2];
    const fromY = points2[points2.length - 1];
    points2.length -= 2;
    const n4 = curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
    let dt = 0;
    let dt2 = 0;
    let dt3 = 0;
    let t22 = 0;
    let t32 = 0;
    points2.push(fromX, fromY);
    for (let i3 = 1, j3 = 0;i3 <= n4; ++i3) {
      j3 = i3 / n4;
      dt = 1 - j3;
      dt2 = dt * dt;
      dt3 = dt2 * dt;
      t22 = j3 * j3;
      t32 = t22 * j3;
      points2.push(dt3 * fromX + 3 * dt2 * j3 * cpX + 3 * dt * t22 * cpX2 + t32 * toX, dt3 * fromY + 3 * dt2 * j3 * cpY + 3 * dt * t22 * cpY2 + t32 * toY);
    }
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle
var square = function(x3, y3, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x3 - nx * innerWeight;
  const iy = y3 - ny * innerWeight;
  const ox = x3 + nx * outerWeight;
  const oy = y3 + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy, eox, eoy);
  return 2;
};
var round = function(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy, sx, sy);
    for (let i3 = 1, angle = startAngle;i3 < segCount; i3++, angle += angleInc) {
      verts.push(cx, cy, cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts.push(cx, cy, ex, ey);
  } else {
    verts.push(sx, sy, cx, cy);
    for (let i3 = 1, angle = startAngle;i3 < segCount; i3++, angle += angleInc) {
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius, cx, cy);
    }
    verts.push(ex, ey, cx, cy);
  }
  return segCount * 2;
};
var buildNonNativeLine = function(graphicsData, graphicsGeometry) {
  const shape = graphicsData.shape;
  let points2 = graphicsData.points || shape.points.slice();
  const eps = graphicsGeometry.closePointEps;
  if (points2.length === 0) {
    return;
  }
  const style = graphicsData.lineStyle;
  const firstPoint = new Point3(points2[0], points2[1]);
  const lastPoint = new Point3(points2[points2.length - 2], points2[points2.length - 1]);
  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points2 = points2.slice();
    if (closedPath) {
      points2.pop();
      points2.pop();
      lastPoint.set(points2[points2.length - 2], points2[points2.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points2.unshift(midPointX, midPointY);
    points2.push(midPointX, midPointY);
  }
  const verts = graphicsGeometry.points;
  const length2 = points2.length / 2;
  let indexCount = points2.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points2[0];
  let y0 = points2[1];
  let x1 = points2[2];
  let y1 = points2[3];
  let x22 = 0;
  let y22 = 0;
  let perpx = -(y0 - y1);
  let perpy = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  const ratio = style.alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (let i3 = 1;i3 < length2 - 1; ++i3) {
    x0 = points2[(i3 - 1) * 2];
    y0 = points2[(i3 - 1) * 2 + 1];
    x1 = points2[i3 * 2];
    y1 = points2[i3 * 2 + 1];
    x22 = points2[(i3 + 1) * 2];
    y22 = points2[(i3 + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y22);
    perp1y = x1 - x22;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x22;
    const dy1 = y22 - y1;
    const dot2 = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 0.001 * Math.abs(dot2)) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (dot2 >= 0) {
        if (style.join === LINE_JOIN.ROUND) {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight, x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
      }
      continue;
    }
    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    const c22 = (-perp1x + x22) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y22);
    const px = (dx0 * c22 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c22) / cross;
    const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pdist <= smallerInsideDiagonalSq;
    let join = style.join;
    if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared) {
      join = LINE_JOIN.BEVEL;
    }
    if (insideMiterOk) {
      switch (join) {
        case LINE_JOIN.MITER: {
          verts.push(imx, imy, omx, omy);
          break;
        }
        case LINE_JOIN.BEVEL: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight, imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          indexCount += 2;
          break;
        }
        case LINE_JOIN.ROUND: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy);
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          break;
        }
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      switch (join) {
        case LINE_JOIN.MITER: {
          if (clockwise) {
            verts.push(omx, omy, omx, omy);
          } else {
            verts.push(imx, imy, imx, imy);
          }
          indexCount += 2;
          break;
        }
        case LINE_JOIN.ROUND: {
          if (clockwise) {
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
          } else {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
          }
          break;
        }
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points2[(length2 - 2) * 2];
  y0 = points2[(length2 - 2) * 2 + 1];
  x1 = points2[(length2 - 1) * 2];
  y1 = points2[(length2 - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  const indices2 = graphicsGeometry.indices;
  const eps2 = curves.epsilon * curves.epsilon;
  for (let i3 = indexStart;i3 < indexCount + indexStart - 2; ++i3) {
    x0 = verts[i3 * 2];
    y0 = verts[i3 * 2 + 1];
    x1 = verts[(i3 + 1) * 2];
    y1 = verts[(i3 + 1) * 2 + 1];
    x22 = verts[(i3 + 2) * 2];
    y22 = verts[(i3 + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y22) + x1 * (y22 - y0) + x22 * (y0 - y1)) < eps2) {
      continue;
    }
    indices2.push(i3, i3 + 1, i3 + 2);
  }
};
var buildNativeLine = function(graphicsData, graphicsGeometry) {
  let i3 = 0;
  const shape = graphicsData.shape;
  const points2 = graphicsData.points || shape.points;
  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  if (points2.length === 0)
    return;
  const verts = graphicsGeometry.points;
  const indices2 = graphicsGeometry.indices;
  const length2 = points2.length / 2;
  const startIndex = verts.length / 2;
  let currentIndex = startIndex;
  verts.push(points2[0], points2[1]);
  for (i3 = 1;i3 < length2; i3++) {
    verts.push(points2[i3 * 2], points2[i3 * 2 + 1]);
    indices2.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices2.push(currentIndex, startIndex);
  }
};
var buildLine = function(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2
class QuadraticUtils {
  static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
    const ax = fromX - 2 * cpX + toX;
    const ay = fromY - 2 * cpY + toY;
    const bx = 2 * cpX - 2 * fromX;
    const by = 2 * cpY - 2 * fromY;
    const a3 = 4 * (ax * ax + ay * ay);
    const b3 = 4 * (ax * bx + ay * by);
    const c3 = bx * bx + by * by;
    const s3 = 2 * Math.sqrt(a3 + b3 + c3);
    const a22 = Math.sqrt(a3);
    const a32 = 2 * a3 * a22;
    const c22 = 2 * Math.sqrt(c3);
    const ba = b3 / a22;
    return (a32 * s3 + a22 * b3 * (s3 - c22) + (4 * c3 * a3 - b3 * b3) * Math.log((2 * a22 + ba + s3) / (ba + c22))) / (4 * a32);
  }
  static curveTo(cpX, cpY, toX, toY, points2) {
    const fromX = points2[points2.length - 2];
    const fromY = points2[points2.length - 1];
    const n4 = curves._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
    let xa = 0;
    let ya = 0;
    for (let i3 = 1;i3 <= n4; ++i3) {
      const j3 = i3 / n4;
      xa = fromX + (cpX - fromX) * j3;
      ya = fromY + (cpY - fromY) * j3;
      points2.push(xa + (cpX + (toX - cpX) * j3 - xa) * j3, ya + (cpY + (toY - cpY) * j3 - ya) * j3);
    }
  }
}

// node_modules/colord/plugins/names.mjsistener.mj
var FILL_COMMANDS = {
  [SHAPES.POLY]: buildPoly,
  [SHAPES.CIRC]: buildCircle,
  [SHAPES.ELIP]: buildCircle,
  [SHAPES.RECT]: buildRectangle,
  [SHAPES.RREC]: buildRoundedRectangle
};
var BATCH_POOL = [];
var DRAW_CALL_POOL = [];
// node_modules/colord/plugins/names.mjsistener.mjs
class GraphicsData {
  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
    this.points = [];
    this.holes = [];
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
  }
  clone() {
    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  }
  destroy() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.
var tmpPoint = new Point3;
var _GraphicsGeometry = class extends BatchGeometry {
  constructor() {
    super();
    this.closePointEps = 0.0001;
    this.boundsPadding = 0;
    this.uvsFloat32 = null;
    this.indicesUint16 = null;
    this.batchable = false;
    this.points = [];
    this.colors = [];
    this.uvs = [];
    this.indices = [];
    this.textureIds = [];
    this.graphicsData = [];
    this.drawCalls = [];
    this.batchDirty = -1;
    this.batches = [];
    this.dirty = 0;
    this.cacheDirty = -1;
    this.clearDirty = 0;
    this.shapeIndex = 0;
    this._bounds = new Bounds;
    this.boundsDirty = -1;
  }
  get bounds() {
    this.updateBatches();
    if (this.boundsDirty !== this.dirty) {
      this.boundsDirty = this.dirty;
      this.calculateBounds();
    }
    return this._bounds;
  }
  invalidate() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeIndex = 0;
    this.points.length = 0;
    this.colors.length = 0;
    this.uvs.length = 0;
    this.indices.length = 0;
    this.textureIds.length = 0;
    for (let i3 = 0;i3 < this.drawCalls.length; i3++) {
      this.drawCalls[i3].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i3]);
    }
    this.drawCalls.length = 0;
    for (let i3 = 0;i3 < this.batches.length; i3++) {
      const batchPart = this.batches[i3];
      batchPart.reset();
      BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  }
  clear() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  }
  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
    const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  }
  drawHole(shape, matrix = null) {
    if (!this.graphicsData.length) {
      return null;
    }
    const data = new GraphicsData(shape, null, null, matrix);
    const lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  }
  destroy() {
    super.destroy();
    for (let i3 = 0;i3 < this.graphicsData.length; ++i3) {
      this.graphicsData[i3].destroy();
    }
    this.points.length = 0;
    this.points = null;
    this.colors.length = 0;
    this.colors = null;
    this.uvs.length = 0;
    this.uvs = null;
    this.indices.length = 0;
    this.indices = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  }
  containsPoint(point) {
    const graphicsData = this.graphicsData;
    for (let i3 = 0;i3 < graphicsData.length; ++i3) {
      const data = graphicsData[i3];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint);
        } else {
          tmpPoint.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
          let hitHole = false;
          if (data.holes) {
            for (let i22 = 0;i22 < data.holes.length; i22++) {
              const hole = data.holes[i22];
              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  }
  updateBatches() {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    if (!this.validateBatching()) {
      return;
    }
    this.cacheDirty = this.dirty;
    const uvs = this.uvs;
    const graphicsData = this.graphicsData;
    let batchPart = null;
    let currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (let i3 = this.shapeIndex;i3 < graphicsData.length; i3++) {
      this.shapeIndex++;
      const data = graphicsData[i3];
      const fillStyle = data.fillStyle;
      const lineStyle = data.lineStyle;
      const command = FILL_COMMANDS[data.type];
      command.build(data);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      if (fillStyle.visible || lineStyle.visible) {
        this.processHoles(data.holes);
      }
      for (let j3 = 0;j3 < 2; j3++) {
        const style = j3 === 0 ? fillStyle : lineStyle;
        if (!style.visible)
          continue;
        const nextTexture = style.texture.baseTexture;
        const index22 = this.indices.length;
        const attribIndex = this.points.length / 2;
        nextTexture.wrapMode = WRAP_MODES.REPEAT;
        if (j3 === 0) {
          this.processFill(data);
        } else {
          this.processLine(data);
        }
        const size = this.points.length / 2 - attribIndex;
        if (size === 0)
          continue;
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(index22, attribIndex);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = BATCH_POOL.pop() || new BatchPart;
          batchPart.begin(style, index22, attribIndex);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
      }
    }
    const index2 = this.indices.length;
    const attrib = this.points.length / 2;
    if (batchPart) {
      batchPart.end(index2, attrib);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    const need32 = attrib > 65535;
    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {
      this.indicesUint16.set(this.indices);
    } else {
      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls();
    }
  }
  _compareStyles(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (!!styleA.native !== !!styleB.native) {
      return false;
    }
    return true;
  }
  validateBatching() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (let i3 = 0, l4 = this.graphicsData.length;i3 < l4; i3++) {
      const data = this.graphicsData[i3];
      const fill = data.fillStyle;
      const line = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid)
        return false;
      if (line && !line.texture.baseTexture.valid)
        return false;
    }
    return true;
  }
  packBatches() {
    this.batchDirty++;
    this.uvsFloat32 = new Float32Array(this.uvs);
    const batches = this.batches;
    for (let i3 = 0, l4 = batches.length;i3 < l4; i3++) {
      const batch = batches[i3];
      for (let j3 = 0;j3 < batch.size; j3++) {
        const index2 = batch.start + j3;
        this.indicesUint16[index2] = this.indicesUint16[index2] - batch.attribStart;
      }
    }
  }
  isBatchable() {
    if (this.points.length > 65535 * 2) {
      return false;
    }
    const batches = this.batches;
    for (let i3 = 0;i3 < batches.length; i3++) {
      if (batches[i3].style.native) {
        return false;
      }
    }
    return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;
  }
  buildDrawCalls() {
    let TICK = ++BaseTexture._globalBatch;
    for (let i3 = 0;i3 < this.drawCalls.length; i3++) {
      this.drawCalls[i3].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i3]);
    }
    this.drawCalls.length = 0;
    const colors = this.colors;
    const textureIds = this.textureIds;
    let currentGroup = DRAW_CALL_POOL.pop();
    if (!currentGroup) {
      currentGroup = new BatchDrawCall;
      currentGroup.texArray = new BatchTextureArray;
    }
    currentGroup.texArray.count = 0;
    currentGroup.start = 0;
    currentGroup.size = 0;
    currentGroup.type = DRAW_MODES.TRIANGLES;
    let textureCount = 0;
    let currentTexture = null;
    let textureId = 0;
    let native = false;
    let drawMode = DRAW_MODES.TRIANGLES;
    let index2 = 0;
    this.drawCalls.push(currentGroup);
    for (let i3 = 0;i3 < this.batches.length; i3++) {
      const data = this.batches[i3];
      const maxTextures = 8;
      const style = data.style;
      const nextTexture = style.texture.baseTexture;
      if (native !== !!style.native) {
        native = !!style.native;
        drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;
        currentTexture = null;
        textureCount = maxTextures;
        TICK++;
      }
      if (currentTexture !== nextTexture) {
        currentTexture = nextTexture;
        if (nextTexture._batchEnabled !== TICK) {
          if (textureCount === maxTextures) {
            TICK++;
            textureCount = 0;
            if (currentGroup.size > 0) {
              currentGroup = DRAW_CALL_POOL.pop();
              if (!currentGroup) {
                currentGroup = new BatchDrawCall;
                currentGroup.texArray = new BatchTextureArray;
              }
              this.drawCalls.push(currentGroup);
            }
            currentGroup.start = index2;
            currentGroup.size = 0;
            currentGroup.texArray.count = 0;
            currentGroup.type = drawMode;
          }
          nextTexture.touched = 1;
          nextTexture._batchEnabled = TICK;
          nextTexture._batchLocation = textureCount;
          nextTexture.wrapMode = WRAP_MODES.REPEAT;
          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
          textureCount++;
        }
      }
      currentGroup.size += data.size;
      index2 += data.size;
      textureId = nextTexture._batchLocation;
      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    BaseTexture._globalBatch = TICK;
    this.packAttributes();
  }
  packAttributes() {
    const verts = this.points;
    const uvs = this.uvs;
    const colors = this.colors;
    const textureIds = this.textureIds;
    const glPoints = new ArrayBuffer(verts.length * 3 * 4);
    const f32 = new Float32Array(glPoints);
    const u32 = new Uint32Array(glPoints);
    let p3 = 0;
    for (let i3 = 0;i3 < verts.length / 2; i3++) {
      f32[p3++] = verts[i3 * 2];
      f32[p3++] = verts[i3 * 2 + 1];
      f32[p3++] = uvs[i3 * 2];
      f32[p3++] = uvs[i3 * 2 + 1];
      u32[p3++] = colors[i3];
      f32[p3++] = textureIds[i3];
    }
    this._buffer.update(glPoints);
    this._indexBuffer.update(this.indicesUint16);
  }
  processFill(data) {
    if (data.holes.length) {
      buildPoly.triangulate(data, this);
    } else {
      const command = FILL_COMMANDS[data.type];
      command.triangulate(data, this);
    }
  }
  processLine(data) {
    buildLine(data, this);
    for (let i3 = 0;i3 < data.holes.length; i3++) {
      buildLine(data.holes[i3], this);
    }
  }
  processHoles(holes) {
    for (let i3 = 0;i3 < holes.length; i3++) {
      const hole = holes[i3];
      const command = FILL_COMMANDS[hole.type];
      command.build(hole);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  }
  calculateBounds() {
    const bounds = this._bounds;
    bounds.clear();
    bounds.addVertexData(this.points, 0, this.points.length);
    bounds.pad(this.boundsPadding, this.boundsPadding);
  }
  transformPoints(points2, matrix) {
    for (let i3 = 0;i3 < points2.length / 2; i3++) {
      const x3 = points2[i3 * 2];
      const y3 = points2[i3 * 2 + 1];
      points2[i3 * 2] = matrix.a * x3 + matrix.c * y3 + matrix.tx;
      points2[i3 * 2 + 1] = matrix.b * x3 + matrix.d * y3 + matrix.ty;
    }
  }
  addColors(colors, color8, alpha2, size, offset = 0) {
    const bgr = Color.shared.setValue(color8).toLittleEndianNumber();
    const result = Color.shared.setValue(bgr).toPremultiplied(alpha2);
    colors.length = Math.max(colors.length, offset + size);
    for (let i3 = 0;i3 < size; i3++) {
      colors[offset + i3] = result;
    }
  }
  addTextureIds(textureIds, id, size, offset = 0) {
    textureIds.length = Math.max(textureIds.length, offset + size);
    for (let i3 = 0;i3 < size; i3++) {
      textureIds[offset + i3] = id;
    }
  }
  addUvs(verts, uvs, texture3, start, size, matrix = null) {
    let index2 = 0;
    const uvsStart = uvs.length;
    const frame = texture3.frame;
    while (index2 < size) {
      let x3 = verts[(start + index2) * 2];
      let y3 = verts[(start + index2) * 2 + 1];
      if (matrix) {
        const nx = matrix.a * x3 + matrix.c * y3 + matrix.tx;
        y3 = matrix.b * x3 + matrix.d * y3 + matrix.ty;
        x3 = nx;
      }
      index2++;
      uvs.push(x3 / frame.width, y3 / frame.height);
    }
    const baseTexture = texture3.baseTexture;
    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
      this.adjustUvs(uvs, texture3, uvsStart, size);
    }
  }
  adjustUvs(uvs, texture3, start, size) {
    const baseTexture = texture3.baseTexture;
    const eps = 0.000001;
    const finish = start + size * 2;
    const frame = texture3.frame;
    const scaleX = frame.width / baseTexture.width;
    const scaleY = frame.height / baseTexture.height;
    let offsetX = frame.x / frame.width;
    let offsetY = frame.y / frame.height;
    let minX = Math.floor(uvs[start] + eps);
    let minY = Math.floor(uvs[start + 1] + eps);
    for (let i3 = start + 2;i3 < finish; i3 += 2) {
      minX = Math.min(minX, Math.floor(uvs[i3] + eps));
      minY = Math.min(minY, Math.floor(uvs[i3 + 1] + eps));
    }
    offsetX -= minX;
    offsetY -= minY;
    for (let i3 = start;i3 < finish; i3 += 2) {
      uvs[i3] = (uvs[i3] + offsetX) * scaleX;
      uvs[i3 + 1] = (uvs[i3 + 1] + offsetY) * scaleY;
    }
  }
};
var GraphicsGeometry = _GraphicsGeometry;
GraphicsGeometry.BATCHABLE_SIZE = 100;

// node_modules/colord/plugins/names.mjsistener.mjsgle.
class FillStyle {
  constructor() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
    this.reset();
  }
  clone() {
    const obj = new FillStyle;
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    return obj;
  }
  reset() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
  }
  destroy() {
    this.texture = null;
    this.matrix = null;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.
class LineStyle extends FillStyle {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.alignment = 0.5;
    this.native = false;
    this.cap = LINE_CAP.BUTT;
    this.join = LINE_JOIN.MITER;
    this.miterLimit = 10;
  }
  clone() {
    const obj = new LineStyle;
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.native = this.native;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    return obj;
  }
  reset() {
    super.reset();
    this.color = 0;
    this.alignment = 0.5;
    this.width = 0;
    this.native = false;
  }
}

// node_modules/colord/plugins/names.mjsistener
var DEFAULT_SHADERS = {};
var _Graphics = class extends Container {
  constructor(geometry = null) {
    super();
    this.shader = null;
    this.pluginName = "batch";
    this.currentPath = null;
    this.batches = [];
    this.batchTint = -1;
    this.batchDirty = -1;
    this.vertexData = null;
    this._fillStyle = new FillStyle;
    this._lineStyle = new LineStyle;
    this._matrix = null;
    this._holeMode = false;
    this.state = State.for2d();
    this._geometry = geometry || new GraphicsGeometry;
    this._geometry.refCount++;
    this._transformID = -1;
    this._tintColor = new Color(16777215);
    this.blendMode = BLEND_MODES.NORMAL;
  }
  get geometry() {
    return this._geometry;
  }
  clone() {
    this.finishPoly();
    return new _Graphics(this._geometry);
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
  }
  get fill() {
    return this._fillStyle;
  }
  get line() {
    return this._lineStyle;
  }
  lineStyle(options = null, color8 = 0, alpha2, alignment = 0.5, native = false) {
    if (typeof options === "number") {
      options = { width: options, color: color8, alpha: alpha2, alignment, native };
    }
    return this.lineTextureStyle(options);
  }
  lineTextureStyle(options) {
    const defaultLineStyleOptions = {
      width: 0,
      texture: Texture.WHITE,
      color: options?.texture ? 16777215 : 0,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10
    };
    options = Object.assign(defaultLineStyleOptions, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.width > 0 && options.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options);
    }
    return this;
  }
  startPoly() {
    if (this.currentPath) {
      const points2 = this.currentPath.points;
      const len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new Polygon;
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points2[len - 2], points2[len - 1]);
      }
    } else {
      this.currentPath = new Polygon;
      this.currentPath.closeStroke = false;
    }
  }
  finishPoly() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  }
  moveTo(x3, y3) {
    this.startPoly();
    this.currentPath.points[0] = x3;
    this.currentPath.points[1] = y3;
    return this;
  }
  lineTo(x3, y3) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    const points2 = this.currentPath.points;
    const fromX = points2[points2.length - 2];
    const fromY = points2[points2.length - 1];
    if (fromX !== x3 || fromY !== y3) {
      points2.push(x3, y3);
    }
    return this;
  }
  _initCurve(x3 = 0, y3 = 0) {
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x3, y3];
      }
    } else {
      this.moveTo(x3, y3);
    }
  }
  quadraticCurveTo(cpX, cpY, toX, toY) {
    this._initCurve();
    const points2 = this.currentPath.points;
    if (points2.length === 0) {
      this.moveTo(0, 0);
    }
    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points2);
    return this;
  }
  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  }
  arcTo(x1, y1, x22, y22, radius) {
    this._initCurve(x1, y1);
    const points2 = this.currentPath.points;
    const result = ArcUtils.curveTo(x1, y1, x22, y22, radius, points2);
    if (result) {
      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
    }
    return this;
  }
  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += PI_2;
    }
    const sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    const startX = cx + Math.cos(startAngle) * radius;
    const startY = cy + Math.sin(startAngle) * radius;
    const eps = this._geometry.closePointEps;
    let points2 = this.currentPath ? this.currentPath.points : null;
    if (points2) {
      const xDiff = Math.abs(points2[points2.length - 2] - startX);
      const yDiff = Math.abs(points2[points2.length - 1] - startY);
      if (xDiff < eps && yDiff < eps) {
      } else {
        points2.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points2 = this.currentPath.points;
    }
    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points2);
    return this;
  }
  beginFill(color8 = 0, alpha2) {
    return this.beginTextureFill({ texture: Texture.WHITE, color: color8, alpha: alpha2 });
  }
  normalizeColor(options) {
    const temp = Color.shared.setValue(options.color ?? 0);
    options.color = temp.toNumber();
    options.alpha ?? (options.alpha = temp.alpha);
  }
  beginTextureFill(options) {
    const defaultOptions = {
      texture: Texture.WHITE,
      color: 16777215,
      matrix: null
    };
    options = Object.assign(defaultOptions, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options);
    }
    return this;
  }
  endFill() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  }
  drawRect(x3, y3, width, height) {
    return this.drawShape(new Rectangle(x3, y3, width, height));
  }
  drawRoundedRect(x3, y3, width, height, radius) {
    return this.drawShape(new RoundedRectangle(x3, y3, width, height, radius));
  }
  drawCircle(x3, y3, radius) {
    return this.drawShape(new Circle2(x3, y3, radius));
  }
  drawEllipse(x3, y3, width, height) {
    return this.drawShape(new Ellipse(x3, y3, width, height));
  }
  drawPolygon(...path2) {
    let points2;
    let closeStroke = true;
    const poly = path2[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points2 = poly.points;
    } else if (Array.isArray(path2[0])) {
      points2 = path2[0];
    } else {
      points2 = path2;
    }
    const shape = new Polygon(points2);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  }
  drawShape(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  }
  clear() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  }
  isFastRect() {
    const data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  }
  _render(renderer) {
    this.finishPoly();
    const geometry = this._geometry;
    geometry.updateBatches();
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer);
    } else {
      renderer.batch.flush();
      this._renderDirect(renderer);
    }
  }
  _populateBatches() {
    const geometry = this._geometry;
    const blendMode = this.blendMode;
    const len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (let i3 = 0;i3 < len; i3++) {
      const gI2 = geometry.batches[i3];
      const color8 = gI2.style.color;
      const vertexData = new Float32Array(this.vertexData.buffer, gI2.attribStart * 4 * 2, gI2.attribSize * 2);
      const uvs = new Float32Array(geometry.uvsFloat32.buffer, gI2.attribStart * 4 * 2, gI2.attribSize * 2);
      const indices2 = new Uint16Array(geometry.indicesUint16.buffer, gI2.start * 2, gI2.size);
      const batch = {
        vertexData,
        blendMode,
        indices: indices2,
        uvs,
        _batchRGB: Color.shared.setValue(color8).toRgbArray(),
        _tintRGB: color8,
        _texture: gI2.style.texture,
        alpha: gI2.style.alpha,
        worldAlpha: 1
      };
      this.batches[i3] = batch;
    }
  }
  _renderBatched(renderer) {
    if (!this.batches.length) {
      return;
    }
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (let i3 = 0, l4 = this.batches.length;i3 < l4; i3++) {
      const batch = this.batches[i3];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer.plugins[this.pluginName].render(batch);
    }
  }
  _renderDirect(renderer) {
    const shader = this._resolveDirectShader(renderer);
    const geometry = this._geometry;
    const worldAlpha = this.worldAlpha;
    const uniforms = shader.uniforms;
    const drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint);
    renderer.shader.bind(shader);
    renderer.geometry.bind(geometry, shader);
    renderer.state.set(this.state);
    for (let i3 = 0, l4 = drawCalls.length;i3 < l4; i3++) {
      this._renderDrawCallDirect(renderer, geometry.drawCalls[i3]);
    }
  }
  _renderDrawCallDirect(renderer, drawCall) {
    const { texArray, type, size, start } = drawCall;
    const groupTextureCount = texArray.count;
    for (let j3 = 0;j3 < groupTextureCount; j3++) {
      renderer.texture.bind(texArray.elements[j3], j3);
    }
    renderer.geometry.draw(type, size, start);
  }
  _resolveDirectShader(renderer) {
    let shader = this.shader;
    const pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        const { maxTextures } = renderer.plugins[pluginName];
        const sampleValues = new Int32Array(maxTextures);
        for (let i3 = 0;i3 < maxTextures; i3++) {
          sampleValues[i3] = i3;
        }
        const uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix,
          default: UniformGroup.from({ uSamplers: sampleValues }, true)
        };
        const program = renderer.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  }
  _calculateBounds() {
    this.finishPoly();
    const geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    const { minX, minY, maxX, maxY } = geometry.bounds;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);
    return this._geometry.containsPoint(_Graphics._TEMP_POINT);
  }
  calculateTints() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this._tintColor.toNumber();
      for (let i3 = 0;i3 < this.batches.length; i3++) {
        const batch = this.batches[i3];
        batch._tintRGB = Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
      }
    }
  }
  calculateVertices() {
    const wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    const wt = this.transform.worldTransform;
    const a3 = wt.a;
    const b3 = wt.b;
    const c3 = wt.c;
    const d3 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const data = this._geometry.points;
    const vertexData = this.vertexData;
    let count = 0;
    for (let i3 = 0;i3 < data.length; i3 += 2) {
      const x3 = data[i3];
      const y3 = data[i3 + 1];
      vertexData[count++] = a3 * x3 + c3 * y3 + tx;
      vertexData[count++] = d3 * y3 + b3 * x3 + ty;
    }
  }
  closePath() {
    const currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
      this.finishPoly();
    }
    return this;
  }
  setMatrix(matrix) {
    this._matrix = matrix;
    return this;
  }
  beginHole() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  }
  endHole() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  }
  destroy(options) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    super.destroy(options);
  }
};
var Graphics = _Graphics;
Graphics.curves = curves;
Graphics._TEMP_POINT = new Point3;
// node_modules/colord/plugins/names.mjsiste
var graphicsUtils = {
  buildPoly,
  buildCircle,
  buildRectangle,
  buildRoundedRectangle,
  buildLine,
  ArcUtils,
  BezierUtils,
  QuadraticUtils,
  BatchPart,
  FILL_COMMANDS,
  BATCH_POOL,
  DRAW_CALL_POOL
};
// node_modules/colord/plugins/names.mjsistener
class MeshBatchUvs {
  constructor(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer;
    this.uvMatrix = uvMatrix;
    this.data = null;
    this._bufferUpdateId = -1;
    this._textureUpdateId = -1;
    this._updateID = 0;
  }
  update(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
      return;
    }
    this._bufferUpdateId = this.uvBuffer._updateID;
    this._textureUpdateId = this.uvMatrix._updateID;
    const data = this.uvBuffer.data;
    if (!this.data || this.data.length !== data.length) {
      this.data = new Float32Array(data.length);
    }
    this.uvMatrix.multiplyUvs(data, this.data);
    this._updateID++;
  }
}

// node_modules/colord/plugins/names.mj
var tempPoint2 = new Point3;
var tempPolygon = new Polygon;
var _Mesh = class extends Container {
  constructor(geometry, shader, state, drawMode = DRAW_MODES.TRIANGLES) {
    super();
    this.geometry = geometry;
    this.shader = shader;
    this.state = state || State.for2d();
    this.drawMode = drawMode;
    this.start = 0;
    this.size = 0;
    this.uvs = null;
    this.indices = null;
    this.vertexData = new Float32Array(1);
    this.vertexDirty = -1;
    this._transformID = -1;
    this._roundPixels = settings.ROUND_PIXELS;
    this.batchUvs = null;
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(value) {
    if (this._geometry === value) {
      return;
    }
    if (this._geometry) {
      this._geometry.refCount--;
      if (this._geometry.refCount === 0) {
        this._geometry.dispose();
      }
    }
    this._geometry = value;
    if (this._geometry) {
      this._geometry.refCount++;
    }
    this.vertexDirty = -1;
  }
  get uvBuffer() {
    return this.geometry.buffers[1];
  }
  get verticesBuffer() {
    return this.geometry.buffers[0];
  }
  set material(value) {
    this.shader = value;
  }
  get material() {
    return this.shader;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set roundPixels(value) {
    if (this._roundPixels !== value) {
      this._transformID = -1;
    }
    this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get tint() {
    return "tint" in this.shader ? this.shader.tint : null;
  }
  set tint(value) {
    this.shader.tint = value;
  }
  get tintValue() {
    return this.shader.tintValue;
  }
  get texture() {
    return "texture" in this.shader ? this.shader.texture : null;
  }
  set texture(value) {
    this.shader.texture = value;
  }
  _render(renderer) {
    const vertices = this.geometry.buffers[0].data;
    const shader = this.shader;
    if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {
      this._renderToBatch(renderer);
    } else {
      this._renderDefault(renderer);
    }
  }
  _renderDefault(renderer) {
    const shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    renderer.shader.bind(shader);
    renderer.state.set(this.state);
    renderer.geometry.bind(this.geometry, shader);
    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }
  _renderToBatch(renderer) {
    const geometry = this.geometry;
    const shader = this.shader;
    if (shader.uvMatrix) {
      shader.uvMatrix.update();
      this.calculateUvs();
    }
    this.calculateVertices();
    this.indices = geometry.indexBuffer.data;
    this._tintRGB = shader._tintRGB;
    this._texture = shader.texture;
    const pluginName = this.material.pluginName;
    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
    renderer.plugins[pluginName].render(this);
  }
  calculateVertices() {
    const geometry = this.geometry;
    const verticesBuffer = geometry.buffers[0];
    const vertices = verticesBuffer.data;
    const vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
      return;
    }
    this._transformID = this.transform._worldID;
    if (this.vertexData.length !== vertices.length) {
      this.vertexData = new Float32Array(vertices.length);
    }
    const wt = this.transform.worldTransform;
    const a3 = wt.a;
    const b3 = wt.b;
    const c3 = wt.c;
    const d3 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    for (let i3 = 0;i3 < vertexData.length / 2; i3++) {
      const x3 = vertices[i3 * 2];
      const y3 = vertices[i3 * 2 + 1];
      vertexData[i3 * 2] = a3 * x3 + c3 * y3 + tx;
      vertexData[i3 * 2 + 1] = b3 * x3 + d3 * y3 + ty;
    }
    if (this._roundPixels) {
      const resolution = settings.RESOLUTION;
      for (let i3 = 0;i3 < vertexData.length; ++i3) {
        vertexData[i3] = Math.round(vertexData[i3] * resolution) / resolution;
      }
    }
    this.vertexDirty = vertexDirtyId;
  }
  calculateUvs() {
    const geomUvs = this.geometry.buffers[1];
    const shader = this.shader;
    if (!shader.uvMatrix.isSimple) {
      if (!this.batchUvs) {
        this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
      }
      this.batchUvs.update();
      this.uvs = this.batchUvs.data;
    } else {
      this.uvs = geomUvs.data;
    }
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  }
  containsPoint(point) {
    if (!this.getBounds().contains(point.x, point.y)) {
      return false;
    }
    this.worldTransform.applyInverse(point, tempPoint2);
    const vertices = this.geometry.getBuffer("aVertexPosition").data;
    const points2 = tempPolygon.points;
    const indices2 = this.geometry.getIndex().data;
    const len = indices2.length;
    const step = this.drawMode === 4 ? 3 : 1;
    for (let i3 = 0;i3 + 2 < len; i3 += step) {
      const ind0 = indices2[i3] * 2;
      const ind1 = indices2[i3 + 1] * 2;
      const ind2 = indices2[i3 + 2] * 2;
      points2[0] = vertices[ind0];
      points2[1] = vertices[ind0 + 1];
      points2[2] = vertices[ind1];
      points2[3] = vertices[ind1 + 1];
      points2[4] = vertices[ind2];
      points2[5] = vertices[ind2 + 1];
      if (tempPolygon.contains(tempPoint2.x, tempPoint2.y)) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    if (this._cachedTexture) {
      this._cachedTexture.destroy();
      this._cachedTexture = null;
    }
    this.geometry = null;
    this.shader = null;
    this.state = null;
    this.uvs = null;
    this.indices = null;
    this.vertexData = null;
  }
};
var Mesh = _Mesh;
Mesh.BATCHABLE_SIZE = 100;
// node_modules/colord/plugins/names.mjsistener
class MeshGeometry extends Geometry {
  constructor(vertices, uvs, index2) {
    super();
    const verticesBuffer = new Buffer(vertices);
    const uvsBuffer = new Buffer(uvs, true);
    const indexBuffer = new Buffer(index2, true, true);
    this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer);
    this._updateId = -1;
  }
  get vertexDirtyId() {
    return this.buffers[0]._updateID;
  }
}
// node_modules/colord/plugins/names.mjsistene
var fragment7 = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";

// node_modules/colord/plugins/names.mjsistener
var vertex4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";

// node_modules/colord/plugins/names.mjsistener
class MeshMaterial extends Shader {
  constructor(uSampler, options) {
    const uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options);
    if (options.uniforms) {
      Object.assign(uniforms, options.uniforms);
    }
    super(options.program || Program.from(vertex4, fragment7), uniforms);
    this._colorDirty = false;
    this.uvMatrix = new TextureMatrix(uSampler);
    this.batchable = options.program === undefined;
    this.pluginName = options.pluginName;
    this._tintColor = new Color(options.tint);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
    this.alpha = options.alpha;
  }
  get texture() {
    return this.uniforms.uSampler;
  }
  set texture(value) {
    if (this.uniforms.uSampler !== value) {
      if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {
        this._colorDirty = true;
      }
      this.uniforms.uSampler = value;
      this.uvMatrix.texture = value;
    }
  }
  set alpha(value) {
    if (value === this._alpha)
      return;
    this._alpha = value;
    this._colorDirty = true;
  }
  get alpha() {
    return this._alpha;
  }
  set tint(value) {
    if (value === this.tint)
      return;
    this._tintColor.setValue(value);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
  }
  get tint() {
    return this._tintColor.value;
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  update() {
    if (this._colorDirty) {
      this._colorDirty = false;
      const baseTexture = this.texture.baseTexture;
      const applyToChannels = baseTexture.alphaMode;
      Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);
    }
    if (this.uvMatrix.update()) {
      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
    }
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mj
class ParticleBuffer {
  constructor(properties, dynamicPropertyFlags, size) {
    this.geometry = new Geometry;
    this.indexBuffer = null;
    this.size = size;
    this.dynamicProperties = [];
    this.staticProperties = [];
    for (let i3 = 0;i3 < properties.length; ++i3) {
      let property = properties[i3];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || TYPES.FLOAT,
        offset: property.offset
      };
      if (dynamicPropertyFlags[i3]) {
        this.dynamicProperties.push(property);
      } else {
        this.staticProperties.push(property);
      }
    }
    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this._updateID = 0;
    this.initBuffers();
  }
  initBuffers() {
    const geometry = this.geometry;
    let dynamicOffset = 0;
    this.indexBuffer = new Buffer(exports_lib.createIndicesForQuads(this.size), true, true);
    geometry.addIndex(this.indexBuffer);
    this.dynamicStride = 0;
    for (let i3 = 0;i3 < this.dynamicProperties.length; ++i3) {
      const property = this.dynamicProperties[i3];
      property.offset = dynamicOffset;
      dynamicOffset += property.size;
      this.dynamicStride += property.size;
    }
    const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer);
    this.dynamicDataUint32 = new Uint32Array(dynBuffer);
    this.dynamicBuffer = new Buffer(this.dynamicData, false, false);
    let staticOffset = 0;
    this.staticStride = 0;
    for (let i3 = 0;i3 < this.staticProperties.length; ++i3) {
      const property = this.staticProperties[i3];
      property.offset = staticOffset;
      staticOffset += property.size;
      this.staticStride += property.size;
    }
    const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer);
    this.staticDataUint32 = new Uint32Array(statBuffer);
    this.staticBuffer = new Buffer(this.staticData, true, false);
    for (let i3 = 0;i3 < this.dynamicProperties.length; ++i3) {
      const property = this.dynamicProperties[i3];
      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
    }
    for (let i3 = 0;i3 < this.staticProperties.length; ++i3) {
      const property = this.staticProperties[i3];
      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
    }
  }
  uploadDynamic(children, startIndex, amount) {
    for (let i3 = 0;i3 < this.dynamicProperties.length; i3++) {
      const property = this.dynamicProperties[i3];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
    }
    this.dynamicBuffer._updateID++;
  }
  uploadStatic(children, startIndex, amount) {
    for (let i3 = 0;i3 < this.staticProperties.length; i3++) {
      const property = this.staticProperties[i3];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
    }
    this.staticBuffer._updateID++;
  }
  destroy() {
    this.indexBuffer = null;
    this.dynamicProperties = null;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this.staticProperties = null;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.geometry.destroy();
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
var fragment8 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2
var vertex5 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsT
class ParticleRenderer extends ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    this.shader = null;
    this.properties = null;
    this.tempMatrix = new Matrix;
    this.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: this.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: this.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: this.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: this.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: TYPES.UNSIGNED_BYTE,
        uploadFunction: this.uploadTint,
        offset: 0
      }
    ];
    this.shader = Shader.from(vertex5, fragment8, {});
    this.state = State.for2d();
  }
  render(container) {
    const children = container.children;
    const maxSize = container._maxSize;
    const batchSize = container._batchSize;
    const renderer = this.renderer;
    let totalChildren = children.length;
    if (totalChildren === 0) {
      return;
    } else if (totalChildren > maxSize && !container.autoResize) {
      totalChildren = maxSize;
    }
    let buffers = container._buffers;
    if (!buffers) {
      buffers = container._buffers = this.generateBuffers(container);
    }
    const baseTexture = children[0]._texture.baseTexture;
    const premultiplied = baseTexture.alphaMode > 0;
    this.state.blendMode = exports_lib.correctBlendMode(container.blendMode, premultiplied);
    renderer.state.set(this.state);
    const gl = renderer.gl;
    const m4 = container.worldTransform.copyTo(this.tempMatrix);
    m4.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
    this.shader.uniforms.translationMatrix = m4.toArray(true);
    this.shader.uniforms.uColor = Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor);
    this.shader.uniforms.uSampler = baseTexture;
    this.renderer.shader.bind(this.shader);
    let updateStatic = false;
    for (let i3 = 0, j3 = 0;i3 < totalChildren; i3 += batchSize, j3 += 1) {
      let amount = totalChildren - i3;
      if (amount > batchSize) {
        amount = batchSize;
      }
      if (j3 >= buffers.length) {
        buffers.push(this._generateOneMoreBuffer(container));
      }
      const buffer = buffers[j3];
      buffer.uploadDynamic(children, i3, amount);
      const bid = container._bufferUpdateIDs[j3] || 0;
      updateStatic = updateStatic || buffer._updateID < bid;
      if (updateStatic) {
        buffer._updateID = container._updateID;
        buffer.uploadStatic(children, i3, amount);
      }
      renderer.geometry.bind(buffer.geometry);
      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
    }
  }
  generateBuffers(container) {
    const buffers = [];
    const size = container._maxSize;
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    for (let i3 = 0;i3 < size; i3 += batchSize) {
      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    }
    return buffers;
  }
  _generateOneMoreBuffer(container) {
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  }
  uploadVertices(children, startIndex, amount, array, stride, offset) {
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    for (let i3 = 0;i3 < amount; ++i3) {
      const sprite2 = children[startIndex + i3];
      const texture3 = sprite2._texture;
      const sx = sprite2.scale.x;
      const sy = sprite2.scale.y;
      const trim = texture3.trim;
      const orig = texture3.orig;
      if (trim) {
        w1 = trim.x - sprite2.anchor.x * orig.width;
        w0 = w1 + trim.width;
        h1 = trim.y - sprite2.anchor.y * orig.height;
        h0 = h1 + trim.height;
      } else {
        w0 = orig.width * (1 - sprite2.anchor.x);
        w1 = orig.width * -sprite2.anchor.x;
        h0 = orig.height * (1 - sprite2.anchor.y);
        h1 = orig.height * -sprite2.anchor.y;
      }
      array[offset] = w1 * sx;
      array[offset + 1] = h1 * sy;
      array[offset + stride] = w0 * sx;
      array[offset + stride + 1] = h1 * sy;
      array[offset + stride * 2] = w0 * sx;
      array[offset + stride * 2 + 1] = h0 * sy;
      array[offset + stride * 3] = w1 * sx;
      array[offset + stride * 3 + 1] = h0 * sy;
      offset += stride * 4;
    }
  }
  uploadPosition(children, startIndex, amount, array, stride, offset) {
    for (let i3 = 0;i3 < amount; i3++) {
      const spritePosition = children[startIndex + i3].position;
      array[offset] = spritePosition.x;
      array[offset + 1] = spritePosition.y;
      array[offset + stride] = spritePosition.x;
      array[offset + stride + 1] = spritePosition.y;
      array[offset + stride * 2] = spritePosition.x;
      array[offset + stride * 2 + 1] = spritePosition.y;
      array[offset + stride * 3] = spritePosition.x;
      array[offset + stride * 3 + 1] = spritePosition.y;
      offset += stride * 4;
    }
  }
  uploadRotation(children, startIndex, amount, array, stride, offset) {
    for (let i3 = 0;i3 < amount; i3++) {
      const spriteRotation = children[startIndex + i3].rotation;
      array[offset] = spriteRotation;
      array[offset + stride] = spriteRotation;
      array[offset + stride * 2] = spriteRotation;
      array[offset + stride * 3] = spriteRotation;
      offset += stride * 4;
    }
  }
  uploadUvs(children, startIndex, amount, array, stride, offset) {
    for (let i3 = 0;i3 < amount; ++i3) {
      const textureUvs = children[startIndex + i3]._texture._uvs;
      if (textureUvs) {
        array[offset] = textureUvs.x0;
        array[offset + 1] = textureUvs.y0;
        array[offset + stride] = textureUvs.x1;
        array[offset + stride + 1] = textureUvs.y1;
        array[offset + stride * 2] = textureUvs.x2;
        array[offset + stride * 2 + 1] = textureUvs.y2;
        array[offset + stride * 3] = textureUvs.x3;
        array[offset + stride * 3 + 1] = textureUvs.y3;
        offset += stride * 4;
      } else {
        array[offset] = 0;
        array[offset + 1] = 0;
        array[offset + stride] = 0;
        array[offset + stride + 1] = 0;
        array[offset + stride * 2] = 0;
        array[offset + stride * 2 + 1] = 0;
        array[offset + stride * 3] = 0;
        array[offset + stride * 3 + 1] = 0;
        offset += stride * 4;
      }
    }
  }
  uploadTint(children, startIndex, amount, array, stride, offset) {
    for (let i3 = 0;i3 < amount; ++i3) {
      const sprite2 = children[startIndex + i3];
      const result = Color.shared.setValue(sprite2._tintRGB).toPremultiplied(sprite2.alpha, sprite2.texture.baseTexture.alphaMode > 0);
      array[offset] = result;
      array[offset + stride] = result;
      array[offset + stride * 2] = result;
      array[offset + stride * 3] = result;
      offset += stride * 4;
    }
  }
  destroy() {
    super.destroy();
    if (this.shader) {
      this.shader.destroy();
      this.shader = null;
    }
    this.tempMatrix = null;
  }
}
ParticleRenderer.extension = {
  name: "particle",
  type: ExtensionType.RendererPlugin
};
extensions.add(ParticleRenderer);
// node_modules/colord/plugins/names.mjs
var TEXT_GRADIENT = ((TEXT_GRADIENT2) => {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
  return TEXT_GRADIENT2;
})(TEXT_GRADIENT || {});
// node_modules/colord/plugins/names.mjsistene
var contextSettings = {
  willReadFrequently: true
};
var _TextMetrics = class {
  static get experimentalLetterSpacingSupported() {
    let result = _TextMetrics._experimentalLetterSpacingSupported;
    if (result !== undefined) {
      const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;
      result = _TextMetrics._experimentalLetterSpacingSupported = ("letterSpacing" in proto) || ("textLetterSpacing" in proto);
    }
    return result;
  }
  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  static measureText(text, style, wordWrap, canvas = _TextMetrics._canvas) {
    wordWrap = wordWrap === undefined || wordWrap === null ? style.wordWrap : wordWrap;
    const font = style.toFontString();
    const fontProperties = _TextMetrics.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    const context2 = canvas.getContext("2d", contextSettings);
    context2.font = font;
    const outputText = wordWrap ? _TextMetrics.wordWrap(text, style, canvas) : text;
    const lines = outputText.split(/(?:\r\n|\r|\n)/);
    const lineWidths = new Array(lines.length);
    let maxLineWidth = 0;
    for (let i3 = 0;i3 < lines.length; i3++) {
      const lineWidth = _TextMetrics._measureText(lines[i3], style.letterSpacing, context2);
      lineWidths[i3] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    let width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow) {
      width += style.dropShadowDistance;
    }
    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadowDistance;
    }
    return new _TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
  }
  static _measureText(text, letterSpacing, context2) {
    let useExperimentalLetterSpacing = false;
    if (_TextMetrics.experimentalLetterSpacingSupported) {
      if (_TextMetrics.experimentalLetterSpacing) {
        context2.letterSpacing = `${letterSpacing}px`;
        context2.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context2.letterSpacing = "0px";
        context2.textLetterSpacing = "0px";
      }
    }
    let width = context2.measureText(text).width;
    if (width > 0) {
      if (useExperimentalLetterSpacing) {
        width -= letterSpacing;
      } else {
        width += (_TextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
      }
    }
    return width;
  }
  static wordWrap(text, style, canvas = _TextMetrics._canvas) {
    const context2 = canvas.getContext("2d", contextSettings);
    let width = 0;
    let line = "";
    let lines = "";
    const cache2 = Object.create(null);
    const { letterSpacing, whiteSpace } = style;
    const collapseSpaces = _TextMetrics.collapseSpaces(whiteSpace);
    const collapseNewlines = _TextMetrics.collapseNewlines(whiteSpace);
    let canPrependSpaces = !collapseSpaces;
    const wordWrapWidth = style.wordWrapWidth + letterSpacing;
    const tokens = _TextMetrics.tokenize(text);
    for (let i3 = 0;i3 < tokens.length; i3++) {
      let token = tokens[i3];
      if (_TextMetrics.isNewline(token)) {
        if (!collapseNewlines) {
          lines += _TextMetrics.addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        const currIsBreakingSpace = _TextMetrics.isBreakingSpace(token);
        const lastIsBreakingSpace = _TextMetrics.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      const tokenWidth = _TextMetrics.getFromCache(token, letterSpacing, cache2, context2);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (_TextMetrics.canBreakWords(token, style.breakWords)) {
          const characters = _TextMetrics.wordWrapSplit(token);
          for (let j3 = 0;j3 < characters.length; j3++) {
            let char = characters[j3];
            let lastChar = char;
            let k4 = 1;
            while (characters[j3 + k4]) {
              const nextChar = characters[j3 + k4];
              if (!_TextMetrics.canBreakChars(lastChar, nextChar, token, j3, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              lastChar = nextChar;
              k4++;
            }
            j3 += k4 - 1;
            const characterWidth = _TextMetrics.getFromCache(char, letterSpacing, cache2, context2);
            if (characterWidth + width > wordWrapWidth) {
              lines += _TextMetrics.addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += _TextMetrics.addLine(line);
            line = "";
            width = 0;
          }
          const isLastToken = i3 === tokens.length - 1;
          lines += _TextMetrics.addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !_TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += _TextMetrics.addLine(line, false);
    return lines;
  }
  static addLine(line, newLine = true) {
    line = _TextMetrics.trimRight(line);
    line = newLine ? `${line}
` : line;
    return line;
  }
  static getFromCache(key, letterSpacing, cache2, context2) {
    let width = cache2[key];
    if (typeof width !== "number") {
      width = _TextMetrics._measureText(key, letterSpacing, context2) + letterSpacing;
      cache2[key] = width;
    }
    return width;
  }
  static collapseSpaces(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  }
  static collapseNewlines(whiteSpace) {
    return whiteSpace === "normal";
  }
  static trimRight(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (let i3 = text.length - 1;i3 >= 0; i3--) {
      const char = text[i3];
      if (!_TextMetrics.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  }
  static isNewline(char) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._newlines.includes(char.charCodeAt(0));
  }
  static isBreakingSpace(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._breakingSpaces.includes(char.charCodeAt(0));
  }
  static tokenize(text) {
    const tokens = [];
    let token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (let i3 = 0;i3 < text.length; i3++) {
      const char = text[i3];
      const nextChar = text[i3 + 1];
      if (_TextMetrics.isBreakingSpace(char, nextChar) || _TextMetrics.isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        tokens.push(char);
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  }
  static canBreakWords(_token, breakWords) {
    return breakWords;
  }
  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  }
  static wordWrapSplit(token) {
    return _TextMetrics.graphemeSegmenter(token);
  }
  static measureFont(font) {
    if (_TextMetrics._fonts[font]) {
      return _TextMetrics._fonts[font];
    }
    const properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    const canvas = _TextMetrics._canvas;
    const context2 = _TextMetrics._context;
    context2.font = font;
    const metricsString = _TextMetrics.METRICS_STRING + _TextMetrics.BASELINE_SYMBOL;
    const width = Math.ceil(context2.measureText(metricsString).width);
    let baseline = Math.ceil(context2.measureText(_TextMetrics.BASELINE_SYMBOL).width);
    const height = Math.ceil(_TextMetrics.HEIGHT_MULTIPLIER * baseline);
    baseline = baseline * _TextMetrics.BASELINE_MULTIPLIER | 0;
    if (width === 0 || height === 0) {
      _TextMetrics._fonts[font] = properties;
      return properties;
    }
    canvas.width = width;
    canvas.height = height;
    context2.fillStyle = "#f00";
    context2.fillRect(0, 0, width, height);
    context2.font = font;
    context2.textBaseline = "alphabetic";
    context2.fillStyle = "#000";
    context2.fillText(metricsString, 0, baseline);
    const imagedata = context2.getImageData(0, 0, width, height).data;
    const pixels = imagedata.length;
    const line = width * 4;
    let i3 = 0;
    let idx = 0;
    let stop = false;
    for (i3 = 0;i3 < baseline; ++i3) {
      for (let j3 = 0;j3 < line; j3 += 4) {
        if (imagedata[idx + j3] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i3;
    idx = pixels - line;
    stop = false;
    for (i3 = height;i3 > baseline; --i3) {
      for (let j3 = 0;j3 < line; j3 += 4) {
        if (imagedata[idx + j3] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    properties.descent = i3 - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    _TextMetrics._fonts[font] = properties;
    return properties;
  }
  static clearMetrics(font = "") {
    if (font) {
      delete _TextMetrics._fonts[font];
    } else {
      _TextMetrics._fonts = {};
    }
  }
  static get _canvas() {
    if (!_TextMetrics.__canvas) {
      let canvas;
      try {
        const c3 = new OffscreenCanvas(0, 0);
        const context2 = c3.getContext("2d", contextSettings);
        if (context2?.measureText) {
          _TextMetrics.__canvas = c3;
          return c3;
        }
        canvas = settings.ADAPTER.createCanvas();
      } catch (ex) {
        canvas = settings.ADAPTER.createCanvas();
      }
      canvas.width = canvas.height = 10;
      _TextMetrics.__canvas = canvas;
    }
    return _TextMetrics.__canvas;
  }
  static get _context() {
    if (!_TextMetrics.__context) {
      _TextMetrics.__context = _TextMetrics._canvas.getContext("2d", contextSettings);
    }
    return _TextMetrics.__context;
  }
};
var TextMetrics = _TextMetrics;
TextMetrics.METRICS_STRING = "|\xC9q\xC5";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics.graphemeSegmenter = (() => {
  if (typeof Intl?.Segmenter === "function") {
    const segmenter = new Intl.Segmenter;
    return (s3) => [...segmenter.segment(s3)].map((x3) => x3.segment);
  }
  return (s3) => [...s3];
})();
TextMetrics.experimentalLetterSpacing = false;
TextMetrics._fonts = {};
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];

// node_modules/colord/plugins/names.mjsiste
var getColor = function(color8) {
  const temp = Color.shared;
  if (!Array.isArray(color8)) {
    return temp.setValue(color8).toHex();
  } else {
    return color8.map((c3) => temp.setValue(c3).toHex());
  }
};
var areArraysEqual = function(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i3 = 0;i3 < array1.length; ++i3) {
    if (array1[i3] !== array2[i3]) {
      return false;
    }
  }
  return true;
};
var deepCopyProperties = function(target, source, propertyObj) {
  for (const prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
};
var genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
var _TextStyle = class {
  constructor(style) {
    this.styleID = 0;
    this.reset();
    deepCopyProperties(this, style, style);
  }
  clone() {
    const clonedProperties = {};
    deepCopyProperties(clonedProperties, this, _TextStyle.defaultStyle);
    return new _TextStyle(clonedProperties);
  }
  reset() {
    deepCopyProperties(this, _TextStyle.defaultStyle, _TextStyle.defaultStyle);
  }
  get align() {
    return this._align;
  }
  set align(align) {
    if (this._align !== align) {
      this._align = align;
      this.styleID++;
    }
  }
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(breakWords) {
    if (this._breakWords !== breakWords) {
      this._breakWords = breakWords;
      this.styleID++;
    }
  }
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(dropShadow) {
    if (this._dropShadow !== dropShadow) {
      this._dropShadow = dropShadow;
      this.styleID++;
    }
  }
  get dropShadowAlpha() {
    return this._dropShadowAlpha;
  }
  set dropShadowAlpha(dropShadowAlpha) {
    if (this._dropShadowAlpha !== dropShadowAlpha) {
      this._dropShadowAlpha = dropShadowAlpha;
      this.styleID++;
    }
  }
  get dropShadowAngle() {
    return this._dropShadowAngle;
  }
  set dropShadowAngle(dropShadowAngle) {
    if (this._dropShadowAngle !== dropShadowAngle) {
      this._dropShadowAngle = dropShadowAngle;
      this.styleID++;
    }
  }
  get dropShadowBlur() {
    return this._dropShadowBlur;
  }
  set dropShadowBlur(dropShadowBlur) {
    if (this._dropShadowBlur !== dropShadowBlur) {
      this._dropShadowBlur = dropShadowBlur;
      this.styleID++;
    }
  }
  get dropShadowColor() {
    return this._dropShadowColor;
  }
  set dropShadowColor(dropShadowColor) {
    const outputColor = getColor(dropShadowColor);
    if (this._dropShadowColor !== outputColor) {
      this._dropShadowColor = outputColor;
      this.styleID++;
    }
  }
  get dropShadowDistance() {
    return this._dropShadowDistance;
  }
  set dropShadowDistance(dropShadowDistance) {
    if (this._dropShadowDistance !== dropShadowDistance) {
      this._dropShadowDistance = dropShadowDistance;
      this.styleID++;
    }
  }
  get fill() {
    return this._fill;
  }
  set fill(fill) {
    const outputColor = getColor(fill);
    if (this._fill !== outputColor) {
      this._fill = outputColor;
      this.styleID++;
    }
  }
  get fillGradientType() {
    return this._fillGradientType;
  }
  set fillGradientType(fillGradientType) {
    if (this._fillGradientType !== fillGradientType) {
      this._fillGradientType = fillGradientType;
      this.styleID++;
    }
  }
  get fillGradientStops() {
    return this._fillGradientStops;
  }
  set fillGradientStops(fillGradientStops) {
    if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
      this._fillGradientStops = fillGradientStops;
      this.styleID++;
    }
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(fontFamily) {
    if (this.fontFamily !== fontFamily) {
      this._fontFamily = fontFamily;
      this.styleID++;
    }
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(fontSize) {
    if (this._fontSize !== fontSize) {
      this._fontSize = fontSize;
      this.styleID++;
    }
  }
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(fontStyle) {
    if (this._fontStyle !== fontStyle) {
      this._fontStyle = fontStyle;
      this.styleID++;
    }
  }
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(fontVariant) {
    if (this._fontVariant !== fontVariant) {
      this._fontVariant = fontVariant;
      this.styleID++;
    }
  }
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(fontWeight) {
    if (this._fontWeight !== fontWeight) {
      this._fontWeight = fontWeight;
      this.styleID++;
    }
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(letterSpacing) {
    if (this._letterSpacing !== letterSpacing) {
      this._letterSpacing = letterSpacing;
      this.styleID++;
    }
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(lineHeight) {
    if (this._lineHeight !== lineHeight) {
      this._lineHeight = lineHeight;
      this.styleID++;
    }
  }
  get leading() {
    return this._leading;
  }
  set leading(leading) {
    if (this._leading !== leading) {
      this._leading = leading;
      this.styleID++;
    }
  }
  get lineJoin() {
    return this._lineJoin;
  }
  set lineJoin(lineJoin) {
    if (this._lineJoin !== lineJoin) {
      this._lineJoin = lineJoin;
      this.styleID++;
    }
  }
  get miterLimit() {
    return this._miterLimit;
  }
  set miterLimit(miterLimit) {
    if (this._miterLimit !== miterLimit) {
      this._miterLimit = miterLimit;
      this.styleID++;
    }
  }
  get padding() {
    return this._padding;
  }
  set padding(padding) {
    if (this._padding !== padding) {
      this._padding = padding;
      this.styleID++;
    }
  }
  get stroke() {
    return this._stroke;
  }
  set stroke(stroke) {
    const outputColor = getColor(stroke);
    if (this._stroke !== outputColor) {
      this._stroke = outputColor;
      this.styleID++;
    }
  }
  get strokeThickness() {
    return this._strokeThickness;
  }
  set strokeThickness(strokeThickness) {
    if (this._strokeThickness !== strokeThickness) {
      this._strokeThickness = strokeThickness;
      this.styleID++;
    }
  }
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(textBaseline) {
    if (this._textBaseline !== textBaseline) {
      this._textBaseline = textBaseline;
      this.styleID++;
    }
  }
  get trim() {
    return this._trim;
  }
  set trim(trim) {
    if (this._trim !== trim) {
      this._trim = trim;
      this.styleID++;
    }
  }
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(whiteSpace) {
    if (this._whiteSpace !== whiteSpace) {
      this._whiteSpace = whiteSpace;
      this.styleID++;
    }
  }
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(wordWrap) {
    if (this._wordWrap !== wordWrap) {
      this._wordWrap = wordWrap;
      this.styleID++;
    }
  }
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(wordWrapWidth) {
    if (this._wordWrapWidth !== wordWrapWidth) {
      this._wordWrapWidth = wordWrapWidth;
      this.styleID++;
    }
  }
  toFontString() {
    const fontSizeString = typeof this.fontSize === "number" ? `${this.fontSize}px` : this.fontSize;
    let fontFamilies = this.fontFamily;
    if (!Array.isArray(this.fontFamily)) {
      fontFamilies = this.fontFamily.split(",");
    }
    for (let i3 = fontFamilies.length - 1;i3 >= 0; i3--) {
      let fontFamily = fontFamilies[i3].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i3] = fontFamily;
    }
    return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
};
var TextStyle = _TextStyle;
TextStyle.defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  leading: 0,
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100
};

// node_modules/colord/plugins/names.mj
var defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
var _Text = class extends Sprite {
  constructor(text, style, canvas) {
    let ownCanvas = false;
    if (!canvas) {
      canvas = settings.ADAPTER.createCanvas();
      ownCanvas = true;
    }
    canvas.width = 3;
    canvas.height = 3;
    const texture3 = Texture.from(canvas);
    texture3.orig = new Rectangle;
    texture3.trim = new Rectangle;
    super(texture3);
    this._ownCanvas = ownCanvas;
    this.canvas = canvas;
    this.context = canvas.getContext("2d", {
      willReadFrequently: true
    });
    this._resolution = _Text.defaultResolution ?? settings.RESOLUTION;
    this._autoResolution = _Text.defaultAutoResolution;
    this._text = null;
    this._style = null;
    this._styleListener = null;
    this._font = "";
    this.text = text;
    this.style = style;
    this.localStyleID = -1;
  }
  static get experimentalLetterSpacing() {
    return TextMetrics.experimentalLetterSpacing;
  }
  static set experimentalLetterSpacing(value) {
    exports_lib.deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing");
    TextMetrics.experimentalLetterSpacing = value;
  }
  updateText(respectDirty) {
    const style = this._style;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    this._font = this._style.toFontString();
    const context2 = this.context;
    const measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
    const width = measured.width;
    const height = measured.height;
    const lines = measured.lines;
    const lineHeight = measured.lineHeight;
    const lineWidths = measured.lineWidths;
    const maxLineWidth = measured.maxLineWidth;
    const fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
    context2.scale(this._resolution, this._resolution);
    context2.clearRect(0, 0, this.canvas.width, this.canvas.height);
    context2.font = this._font;
    context2.lineWidth = style.strokeThickness;
    context2.textBaseline = style.textBaseline;
    context2.lineJoin = style.lineJoin;
    context2.miterLimit = style.miterLimit;
    let linePositionX;
    let linePositionY;
    const passesCount = style.dropShadow ? 2 : 1;
    for (let i3 = 0;i3 < passesCount; ++i3) {
      const isShadowPass = style.dropShadow && i3 === 0;
      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
      const dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context2.fillStyle = "black";
        context2.strokeStyle = "black";
        const dropShadowColor = style.dropShadowColor;
        const dropShadowBlur = style.dropShadowBlur * this._resolution;
        const dropShadowDistance = style.dropShadowDistance * this._resolution;
        context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
        context2.shadowBlur = dropShadowBlur;
        context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
        context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context2.fillStyle = this._generateFillStyle(style, lines, measured);
        context2.strokeStyle = style.stroke;
        context2.shadowColor = "black";
        context2.shadowBlur = 0;
        context2.shadowOffsetX = 0;
        context2.shadowOffsetY = 0;
      }
      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      for (let i22 = 0;i22 < lines.length; i22++) {
        linePositionX = style.strokeThickness / 2;
        linePositionY = style.strokeThickness / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i22];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
        }
        if (style.stroke && style.strokeThickness) {
          this.drawLetterSpacing(lines[i22], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
        }
        if (style.fill) {
          this.drawLetterSpacing(lines[i22], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
        }
      }
    }
    this.updateTexture();
  }
  drawLetterSpacing(text, x3, y3, isStroke = false) {
    const style = this._style;
    const letterSpacing = style.letterSpacing;
    let useExperimentalLetterSpacing = false;
    if (TextMetrics.experimentalLetterSpacingSupported) {
      if (TextMetrics.experimentalLetterSpacing) {
        this.context.letterSpacing = `${letterSpacing}px`;
        this.context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        this.context.letterSpacing = "0px";
        this.context.textLetterSpacing = "0px";
      }
    }
    if (letterSpacing === 0 || useExperimentalLetterSpacing) {
      if (isStroke) {
        this.context.strokeText(text, x3, y3);
      } else {
        this.context.fillText(text, x3, y3);
      }
      return;
    }
    let currentPosition = x3;
    const stringArray = TextMetrics.graphemeSegmenter(text);
    let previousWidth = this.context.measureText(text).width;
    let currentWidth = 0;
    for (let i3 = 0;i3 < stringArray.length; ++i3) {
      const currentChar = stringArray[i3];
      if (isStroke) {
        this.context.strokeText(currentChar, currentPosition, y3);
      } else {
        this.context.fillText(currentChar, currentPosition, y3);
      }
      let textStr = "";
      for (let j3 = i3 + 1;j3 < stringArray.length; ++j3) {
        textStr += stringArray[j3];
      }
      currentWidth = this.context.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  }
  updateTexture() {
    const canvas = this.canvas;
    if (this._style.trim) {
      const trimmed = exports_lib.trimCanvas(canvas);
      if (trimmed.data) {
        canvas.width = trimmed.width;
        canvas.height = trimmed.height;
        this.context.putImageData(trimmed.data, 0, 0);
      }
    }
    const texture3 = this._texture;
    const style = this._style;
    const padding = style.trim ? 0 : style.padding;
    const baseTexture = texture3.baseTexture;
    texture3.trim.width = texture3._frame.width = canvas.width / this._resolution;
    texture3.trim.height = texture3._frame.height = canvas.height / this._resolution;
    texture3.trim.x = -padding;
    texture3.trim.y = -padding;
    texture3.orig.width = texture3._frame.width - padding * 2;
    texture3.orig.height = texture3._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
    texture3.updateUvs();
    this.dirty = false;
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer);
  }
  updateTransform() {
    this.updateText(true);
    super.updateTransform();
  }
  getBounds(skipUpdate, rect) {
    this.updateText(true);
    if (this._textureID === -1) {
      skipUpdate = false;
    }
    return super.getBounds(skipUpdate, rect);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds.call(this, rect);
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _generateFillStyle(style, lines, metrics) {
    const fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    let gradient;
    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    const padding = style.padding || 0;
    const width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
    const height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
    const fill = fillStyle.slice();
    const fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      const lengthPlus1 = fill.length + 1;
      for (let i3 = 1;i3 < lengthPlus1; ++i3) {
        fillGradientStops.push(i3 / lengthPlus1);
      }
    }
    fill.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (let i3 = 0;i3 < lines.length; i3++) {
        const lastLineBottom = metrics.lineHeight * (i3 - 1) + textHeight;
        const thisLineTop = metrics.lineHeight * i3;
        let thisLineGradientStart = thisLineTop;
        if (i3 > 0 && lastLineBottom > thisLineTop) {
          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
        }
        const thisLineBottom = thisLineTop + textHeight;
        const nextLineTop = metrics.lineHeight * (i3 + 1);
        let thisLineGradientEnd = thisLineBottom;
        if (i3 + 1 < lines.length && nextLineTop < thisLineBottom) {
          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
        }
        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (let j3 = 0;j3 < fill.length; j3++) {
          let lineStop = 0;
          if (typeof fillGradientStops[j3] === "number") {
            lineStop = fillGradientStops[j3];
          } else {
            lineStop = j3 / fill.length;
          }
          let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
          globalStop = Number(globalStop.toFixed(5));
          gradient.addColorStop(globalStop, fill[j3]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      const totalIterations = fill.length + 1;
      let currentIteration = 1;
      for (let i3 = 0;i3 < fill.length; i3++) {
        let stop;
        if (typeof fillGradientStops[i3] === "number") {
          stop = fillGradientStops[i3];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill[i3]);
        currentIteration++;
      }
    }
    return gradient;
  }
  destroy(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, defaultDestroyOptions, options);
    super.destroy(options);
    if (this._ownCanvas) {
      this.canvas.height = this.canvas.width = 0;
    }
    this.context = null;
    this.canvas = null;
    this._style = null;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    this.updateText(true);
    const s3 = exports_lib.sign(this.scale.x) || 1;
    this.scale.x = s3 * value / this._texture.orig.width;
    this._width = value;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    this.updateText(true);
    const s3 = exports_lib.sign(this.scale.y) || 1;
    this.scale.y = s3 * value / this._texture.orig.height;
    this._height = value;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    style = style || {};
    if (style instanceof TextStyle) {
      this._style = style;
    } else {
      this._style = new TextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === undefined ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
};
var Text = _Text;
Text.defaultAutoResolution = true;
// node_modules/colord/plugins/names.mjsistener.mj
class CountLimiter {
  constructor(maxItemsPerFrame) {
    this.maxItemsPerFrame = maxItemsPerFrame;
    this.itemsLeft = 0;
  }
  beginFrame() {
    this.itemsLeft = this.maxItemsPerFrame;
  }
  allowedToUpload() {
    return this.itemsLeft-- > 0;
  }
}

// node_modules/colord/plugins/names.mjsistener.m
var findMultipleBaseTextures = function(item, queue) {
  let result = false;
  if (item?._textures?.length) {
    for (let i3 = 0;i3 < item._textures.length; i3++) {
      if (item._textures[i3] instanceof Texture) {
        const baseTexture = item._textures[i3].baseTexture;
        if (!queue.includes(baseTexture)) {
          queue.push(baseTexture);
          result = true;
        }
      }
    }
  }
  return result;
};
var findBaseTexture = function(item, queue) {
  if (item.baseTexture instanceof BaseTexture) {
    const texture3 = item.baseTexture;
    if (!queue.includes(texture3)) {
      queue.push(texture3);
    }
    return true;
  }
  return false;
};
var findTexture = function(item, queue) {
  if (item._texture && item._texture instanceof Texture) {
    const texture3 = item._texture.baseTexture;
    if (!queue.includes(texture3)) {
      queue.push(texture3);
    }
    return true;
  }
  return false;
};
var drawText = function(_helper, item) {
  if (item instanceof Text) {
    item.updateText(true);
    return true;
  }
  return false;
};
var calculateTextStyle = function(_helper, item) {
  if (item instanceof TextStyle) {
    const font = item.toFontString();
    TextMetrics.measureFont(font);
    return true;
  }
  return false;
};
var findText = function(item, queue) {
  if (item instanceof Text) {
    if (!queue.includes(item.style)) {
      queue.push(item.style);
    }
    if (!queue.includes(item)) {
      queue.push(item);
    }
    const texture3 = item._texture.baseTexture;
    if (!queue.includes(texture3)) {
      queue.push(texture3);
    }
    return true;
  }
  return false;
};
var findTextStyle = function(item, queue) {
  if (item instanceof TextStyle) {
    if (!queue.includes(item)) {
      queue.push(item);
    }
    return true;
  }
  return false;
};
var _BasePrepare = class {
  constructor(renderer) {
    this.limiter = new CountLimiter(_BasePrepare.uploadsPerFrame);
    this.renderer = renderer;
    this.uploadHookHelper = null;
    this.queue = [];
    this.addHooks = [];
    this.uploadHooks = [];
    this.completes = [];
    this.ticking = false;
    this.delayedTick = () => {
      if (!this.queue) {
        return;
      }
      this.prepareItems();
    };
    this.registerFindHook(findText);
    this.registerFindHook(findTextStyle);
    this.registerFindHook(findMultipleBaseTextures);
    this.registerFindHook(findBaseTexture);
    this.registerFindHook(findTexture);
    this.registerUploadHook(drawText);
    this.registerUploadHook(calculateTextStyle);
  }
  upload(item) {
    return new Promise((resolve) => {
      if (item) {
        this.add(item);
      }
      if (this.queue.length) {
        this.completes.push(resolve);
        if (!this.ticking) {
          this.ticking = true;
          Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
        }
      } else {
        resolve();
      }
    });
  }
  tick() {
    setTimeout(this.delayedTick, 0);
  }
  prepareItems() {
    this.limiter.beginFrame();
    while (this.queue.length && this.limiter.allowedToUpload()) {
      const item = this.queue[0];
      let uploaded = false;
      if (item && !item._destroyed) {
        for (let i3 = 0, len = this.uploadHooks.length;i3 < len; i3++) {
          if (this.uploadHooks[i3](this.uploadHookHelper, item)) {
            this.queue.shift();
            uploaded = true;
            break;
          }
        }
      }
      if (!uploaded) {
        this.queue.shift();
      }
    }
    if (!this.queue.length) {
      this.ticking = false;
      const completes = this.completes.slice(0);
      this.completes.length = 0;
      for (let i3 = 0, len = completes.length;i3 < len; i3++) {
        completes[i3]();
      }
    } else {
      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
    }
  }
  registerFindHook(addHook) {
    if (addHook) {
      this.addHooks.push(addHook);
    }
    return this;
  }
  registerUploadHook(uploadHook) {
    if (uploadHook) {
      this.uploadHooks.push(uploadHook);
    }
    return this;
  }
  add(item) {
    for (let i3 = 0, len = this.addHooks.length;i3 < len; i3++) {
      if (this.addHooks[i3](item, this.queue)) {
        break;
      }
    }
    if (item instanceof Container) {
      for (let i3 = item.children.length - 1;i3 >= 0; i3--) {
        this.add(item.children[i3]);
      }
    }
    return this;
  }
  destroy() {
    if (this.ticking) {
      Ticker.system.remove(this.tick, this);
    }
    this.ticking = false;
    this.addHooks = null;
    this.uploadHooks = null;
    this.renderer = null;
    this.completes = null;
    this.queue = null;
    this.limiter = null;
    this.uploadHookHelper = null;
  }
};
var BasePrepare = _BasePrepare;
BasePrepare.uploadsPerFrame = 4;

// node_modules/colord/plugins/names.mjsistene
Object.defineProperties(settings, {
  UPLOADS_PER_FRAME: {
    get() {
      return BasePrepare.uploadsPerFrame;
    },
    set(value) {
      exports_lib.deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame");
      BasePrepare.uploadsPerFrame = value;
    }
  }
});
// node_modules/colord/plugins/names.mjsisten
var uploadBaseTextures = function(renderer, item) {
  if (item instanceof BaseTexture) {
    if (!item._glTextures[renderer.CONTEXT_UID]) {
      renderer.texture.bind(item);
    }
    return true;
  }
  return false;
};
var uploadGraphics = function(renderer, item) {
  if (!(item instanceof Graphics)) {
    return false;
  }
  const { geometry } = item;
  item.finishPoly();
  geometry.updateBatches();
  const { batches } = geometry;
  for (let i3 = 0;i3 < batches.length; i3++) {
    const { texture: texture3 } = batches[i3].style;
    if (texture3) {
      uploadBaseTextures(renderer, texture3.baseTexture);
    }
  }
  if (!geometry.batchable) {
    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
  }
  return true;
};
var findGraphics = function(item, queue) {
  if (item instanceof Graphics) {
    queue.push(item);
    return true;
  }
  return false;
};

class Prepare extends BasePrepare {
  constructor(renderer) {
    super(renderer);
    this.uploadHookHelper = this.renderer;
    this.registerFindHook(findGraphics);
    this.registerUploadHook(uploadBaseTextures);
    this.registerUploadHook(uploadGraphics);
  }
}
Prepare.extension = {
  name: "prepare",
  type: ExtensionType.RendererSystem
};
extensions.add(Prepare);
// node_modules/colord/plugins/names.mjsistener.mjsgle.m
var tempPoint3 = new Point3;
// node_modules/colord/plugins/names.mjsistener.mjsgle.mj
var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTe
var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTex
var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
var tempMat2 = new Matrix;

class TilingSpriteRenderer extends ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    renderer.runners.contextChange.add(this);
    this.quad = new QuadUv;
    this.state = State.for2d();
  }
  contextChange() {
    const renderer = this.renderer;
    const uniforms = { globals: renderer.globalUniforms };
    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
    this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
  }
  render(ts) {
    const renderer = this.renderer;
    const quad = this.quad;
    let vertices = quad.vertices;
    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
    const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
    vertices = quad.uvs;
    vertices[0] = vertices[6] = -anchorX;
    vertices[1] = vertices[3] = -anchorY;
    vertices[2] = vertices[4] = 1 - anchorX;
    vertices[5] = vertices[7] = 1 - anchorY;
    quad.invalidate();
    const tex = ts._texture;
    const baseTex = tex.baseTexture;
    const premultiplied = baseTex.alphaMode > 0;
    const lt = ts.tileTransform.localTransform;
    const uv = ts.uvMatrix;
    let isSimple2 = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
    if (isSimple2) {
      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
        if (baseTex.wrapMode === WRAP_MODES.CLAMP) {
          baseTex.wrapMode = WRAP_MODES.REPEAT;
        }
      } else {
        isSimple2 = baseTex.wrapMode !== WRAP_MODES.CLAMP;
      }
    }
    const shader = isSimple2 ? this.simpleShader : this.shader;
    const w3 = tex.width;
    const h3 = tex.height;
    const W3 = ts._width;
    const H4 = ts._height;
    tempMat2.set(lt.a * w3 / W3, lt.b * w3 / H4, lt.c * h3 / W3, lt.d * h3 / H4, lt.tx / W3, lt.ty / H4);
    tempMat2.invert();
    if (isSimple2) {
      tempMat2.prepend(uv.mapCoord);
    } else {
      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
      shader.uniforms.uClampFrame = uv.uClampFrame;
      shader.uniforms.uClampOffset = uv.uClampOffset;
    }
    shader.uniforms.uTransform = tempMat2.toArray(true);
    shader.uniforms.uColor = Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor);
    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
    shader.uniforms.uSampler = tex;
    renderer.shader.bind(shader);
    renderer.geometry.bind(quad);
    this.state.blendMode = exports_lib.correctBlendMode(ts.blendMode, premultiplied);
    renderer.state.set(this.state);
    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  }
}
TilingSpriteRenderer.extension = {
  name: "tilingSprite",
  type: ExtensionType.RendererPlugin
};
extensions.add(TilingSpriteRenderer);
// node_modules/colord/plugins/names.mjsistener.mjsgl
var _Spritesheet = class {
  constructor(texture3, data, resolutionFilename = null) {
    this.linkedSheets = [];
    this._texture = texture3 instanceof Texture ? texture3 : null;
    this.baseTexture = texture3 instanceof BaseTexture ? texture3 : this._texture.baseTexture;
    this.textures = {};
    this.animations = {};
    this.data = data;
    const resource = this.baseTexture.resource;
    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  _updateResolution(resolutionFilename = null) {
    const { scale: scale3 } = this.data.meta;
    let resolution = exports_lib.getResolutionOfUrl(resolutionFilename, null);
    if (resolution === null) {
      resolution = parseFloat(scale3 ?? "1");
    }
    if (resolution !== 1) {
      this.baseTexture.setResolution(resolution);
    }
    return resolution;
  }
  parse() {
    return new Promise((resolve) => {
      this._callback = resolve;
      this._batchIndex = 0;
      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
        this._processFrames(0);
        this._processAnimations();
        this._parseComplete();
      } else {
        this._nextBatch();
      }
    });
  }
  _processFrames(initialFrameIndex) {
    let frameIndex = initialFrameIndex;
    const maxFrames = _Spritesheet.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      const i3 = this._frameKeys[frameIndex];
      const data = this._frames[i3];
      const rect = data.frame;
      if (rect) {
        let frame = null;
        let trim = null;
        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        const orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
        if (data.rotated) {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
        } else {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        this.textures[i3] = new Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor, data.borders);
        Texture.addToCache(this.textures[i3], i3);
      }
      frameIndex++;
    }
  }
  _processAnimations() {
    const animations = this.data.animations || {};
    for (const animName in animations) {
      this.animations[animName] = [];
      for (let i3 = 0;i3 < animations[animName].length; i3++) {
        const frameName = animations[animName][i3];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  _parseComplete() {
    const callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  }
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(() => {
      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
        this._nextBatch();
      } else {
        this._processAnimations();
        this._parseComplete();
      }
    }, 0);
  }
  destroy(destroyBase = false) {
    for (const i3 in this.textures) {
      this.textures[i3].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      this._texture?.destroy();
      this.baseTexture.destroy();
    }
    this._texture = null;
    this.baseTexture = null;
    this.linkedSheets = [];
  }
};
var Spritesheet = _Spritesheet;
Spritesheet.BATCH_SIZE = 1000;
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
var getCacheableAssets = function(keys, asset, ignoreMultiPack) {
  const out = {};
  keys.forEach((key) => {
    out[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out[key] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = exports_lib.path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i3) => {
      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i3]}`], item, true);
      Object.assign(out, out2);
    });
  }
  return out;
};
var validImages = ["jpg", "png", "jpeg", "avif", "webp"];
var spritesheetAsset = {
  extension: ExtensionType.Asset,
  cache: {
    test: (asset) => asset instanceof Spritesheet,
    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
  },
  resolver: {
    test: (value) => {
      const tempURL = value.split("?")[0];
      const split = tempURL.split(".");
      const extension = split.pop();
      const format = split.pop();
      return extension === "json" && validImages.includes(format);
    },
    parse: (value) => {
      const split = value.split(".");
      return {
        resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: split[split.length - 2],
        src: value
      };
    }
  },
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal
    },
    async testParse(asset, options) {
      return exports_lib.path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
    },
    async parse(asset, options, loader3) {
      let basePath = exports_lib.path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let imagePath = basePath + asset.meta.image;
      imagePath = copySearchParams(imagePath, options.src);
      const assets4 = await loader3.load([imagePath]);
      const texture3 = assets4[imagePath];
      const spritesheet = new Spritesheet(texture3.baseTexture, asset, options.src);
      await spritesheet.parse();
      const multiPacks = asset?.meta?.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        const promises = [];
        for (const item of multiPacks) {
          if (typeof item !== "string") {
            continue;
          }
          let itemUrl = basePath + item;
          if (options.data?.ignoreMultiPack) {
            continue;
          }
          itemUrl = copySearchParams(itemUrl, options.src);
          promises.push(loader3.load({
            src: itemUrl,
            data: {
              ignoreMultiPack: true
            }
          }));
        }
        const res = await Promise.all(promises);
        spritesheet.linkedSheets = res;
        res.forEach((item) => {
          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
        });
      }
      return spritesheet;
    },
    unload(spritesheet) {
      spritesheet.destroy(true);
    }
  }
};
extensions.add(spritesheetAsset);
// node_modules/colord/plugins/names.mjsistener.mjsgle.m
class BitmapFontData {
  constructor() {
    this.info = [];
    this.common = [];
    this.page = [];
    this.char = [];
    this.kerning = [];
    this.distanceField = [];
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
class TextFormat {
  static test(data) {
    return typeof data === "string" && data.startsWith("info face=");
  }
  static parse(txt) {
    const items = txt.match(/^[a-z]+\s+.+$/gm);
    const rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const i3 in items) {
      const name = items[i3].match(/^[a-z]+/gm)[0];
      const attributeList = items[i3].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      const itemData = {};
      for (const i22 in attributeList) {
        const split = attributeList[i22].split("=");
        const key = split[0];
        const strValue = split[1].replace(/"/gm, "");
        const floatValue = parseFloat(strValue);
        const value = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value;
      }
      rawData[name].push(itemData);
    }
    const font = new BitmapFontData;
    rawData.info.forEach((info) => font.info.push({
      face: info.face,
      size: parseInt(info.size, 10)
    }));
    rawData.common.forEach((common) => font.common.push({
      lineHeight: parseInt(common.lineHeight, 10)
    }));
    rawData.page.forEach((page) => font.page.push({
      id: parseInt(page.id, 10),
      file: page.file
    }));
    rawData.char.forEach((char) => font.char.push({
      id: parseInt(char.id, 10),
      page: parseInt(char.page, 10),
      x: parseInt(char.x, 10),
      y: parseInt(char.y, 10),
      width: parseInt(char.width, 10),
      height: parseInt(char.height, 10),
      xoffset: parseInt(char.xoffset, 10),
      yoffset: parseInt(char.yoffset, 10),
      xadvance: parseInt(char.xadvance, 10)
    }));
    rawData.kerning.forEach((kerning) => font.kerning.push({
      first: parseInt(kerning.first, 10),
      second: parseInt(kerning.second, 10),
      amount: parseInt(kerning.amount, 10)
    }));
    rawData.distanceField.forEach((df) => font.distanceField.push({
      distanceRange: parseInt(df.distanceRange, 10),
      fieldType: df.fieldType
    }));
    return font;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2
class XMLFormat {
  static test(data) {
    const xml = data;
    return ("getElementsByTagName" in xml) && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }
  static parse(xml) {
    const data = new BitmapFontData;
    const info = xml.getElementsByTagName("info");
    const common = xml.getElementsByTagName("common");
    const page = xml.getElementsByTagName("page");
    const char = xml.getElementsByTagName("char");
    const kerning = xml.getElementsByTagName("kerning");
    const distanceField = xml.getElementsByTagName("distanceField");
    for (let i3 = 0;i3 < info.length; i3++) {
      data.info.push({
        face: info[i3].getAttribute("face"),
        size: parseInt(info[i3].getAttribute("size"), 10)
      });
    }
    for (let i3 = 0;i3 < common.length; i3++) {
      data.common.push({
        lineHeight: parseInt(common[i3].getAttribute("lineHeight"), 10)
      });
    }
    for (let i3 = 0;i3 < page.length; i3++) {
      data.page.push({
        id: parseInt(page[i3].getAttribute("id"), 10) || 0,
        file: page[i3].getAttribute("file")
      });
    }
    for (let i3 = 0;i3 < char.length; i3++) {
      const letter = char[i3];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (let i3 = 0;i3 < kerning.length; i3++) {
      data.kerning.push({
        first: parseInt(kerning[i3].getAttribute("first"), 10),
        second: parseInt(kerning[i3].getAttribute("second"), 10),
        amount: parseInt(kerning[i3].getAttribute("amount"), 10)
      });
    }
    for (let i3 = 0;i3 < distanceField.length; i3++) {
      data.distanceField.push({
        fieldType: distanceField[i3].getAttribute("fieldType"),
        distanceRange: parseInt(distanceField[i3].getAttribute("distanceRange"), 10)
      });
    }
    return data;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsT
class XMLStringFormat {
  static test(data) {
    if (typeof data === "string" && data.includes("<font>")) {
      return XMLFormat.test(settings.ADAPTER.parseXML(data));
    }
    return false;
  }
  static parse(xmlTxt) {
    return XMLFormat.parse(settings.ADAPTER.parseXML(xmlTxt));
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.
var autoDetectFormat = function(data) {
  for (let i3 = 0;i3 < formats.length; i3++) {
    if (formats[i3].test(data)) {
      return formats[i3];
    }
  }
  return null;
};
var formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsT
var generateFillStyle = function(canvas, context2, style, resolution, lines, metrics) {
  const fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  let gradient;
  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  const padding = style.padding || 0;
  const width = canvas.width / resolution - dropShadowCorrection - padding * 2;
  const height = canvas.height / resolution - dropShadowCorrection - padding * 2;
  const fill = fillStyle.slice();
  const fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    const lengthPlus1 = fill.length + 1;
    for (let i3 = 1;i3 < lengthPlus1; ++i3) {
      fillGradientStops.push(i3 / lengthPlus1);
    }
  }
  fill.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context2.createLinearGradient(width / 2, padding, width / 2, height + padding);
    let lastIterationStop = 0;
    const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    const gradStopLineHeight = textHeight / height;
    for (let i3 = 0;i3 < lines.length; i3++) {
      const thisLineTop = metrics.lineHeight * i3;
      for (let j3 = 0;j3 < fill.length; j3++) {
        let lineStop = 0;
        if (typeof fillGradientStops[j3] === "number") {
          lineStop = fillGradientStops[j3];
        } else {
          lineStop = j3 / fill.length;
        }
        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        let clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill[j3]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context2.createLinearGradient(padding, height / 2, width + padding, height / 2);
    const totalIterations = fill.length + 1;
    let currentIteration = 1;
    for (let i3 = 0;i3 < fill.length; i3++) {
      let stop;
      if (typeof fillGradientStops[i3] === "number") {
        stop = fillGradientStops[i3];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill[i3]);
      currentIteration++;
    }
  }
  return gradient;
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mj
var drawGlyph = function(canvas, context2, metrics, x3, y3, resolution, style) {
  const char = metrics.text;
  const fontProperties = metrics.fontProperties;
  context2.translate(x3, y3);
  context2.scale(resolution, resolution);
  const tx = style.strokeThickness / 2;
  const ty = -(style.strokeThickness / 2);
  context2.font = style.toFontString();
  context2.lineWidth = style.strokeThickness;
  context2.textBaseline = style.textBaseline;
  context2.lineJoin = style.lineJoin;
  context2.miterLimit = style.miterLimit;
  context2.fillStyle = generateFillStyle(canvas, context2, style, resolution, [char], metrics);
  context2.strokeStyle = style.stroke;
  if (style.dropShadow) {
    const dropShadowColor = style.dropShadowColor;
    const dropShadowBlur = style.dropShadowBlur * resolution;
    const dropShadowDistance = style.dropShadowDistance * resolution;
    context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
    context2.shadowBlur = dropShadowBlur;
    context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context2.shadowColor = "black";
    context2.shadowBlur = 0;
    context2.shadowOffsetX = 0;
    context2.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context2.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context2.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context2.setTransform(1, 0, 0, 1, 0, 0);
  context2.fillStyle = "rgba(0, 0, 0, 0)";
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mj
var extractCharCode = function(str2) {
  return str2.codePointAt ? str2.codePointAt(0) : str2.charCodeAt(0);
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextu
var splitTextToCharacters = function(text3) {
  return Array.from ? Array.from(text3) : text3.split("");
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsT
var resolveCharacters = function(chars) {
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i3 = 0, j3 = chars.length;i3 < j3; i3++) {
    const item = chars[i3];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i22 = startCode, j22 = endCode;i22 <= j22; i22++) {
        result.push(String.fromCharCode(i22));
      }
    } else {
      result.push(...splitTextToCharacters(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
};
// node_modules/colord/plugins/names.mjsistener.mjsg
var _BitmapFont = class {
  constructor(data, textures2, ownsTextures) {
    const [info] = data.info;
    const [common] = data.common;
    const [page] = data.page;
    const [distanceField] = data.distanceField;
    const res = exports_lib.getResolutionOfUrl(page.file);
    const pageTextures = {};
    this._ownsTextures = ownsTextures;
    this.font = info.face;
    this.size = info.size;
    this.lineHeight = common.lineHeight / res;
    this.chars = {};
    this.pageTextures = pageTextures;
    for (let i3 = 0;i3 < data.page.length; i3++) {
      const { id, file } = data.page[i3];
      pageTextures[id] = textures2 instanceof Array ? textures2[i3] : textures2[file];
      if (distanceField?.fieldType && distanceField.fieldType !== "none") {
        pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
        pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF;
      }
    }
    for (let i3 = 0;i3 < data.char.length; i3++) {
      const { id, page: page2 } = data.char[i3];
      let { x: x3, y: y3, width, height, xoffset, yoffset, xadvance } = data.char[i3];
      x3 /= res;
      y3 /= res;
      width /= res;
      height /= res;
      xoffset /= res;
      yoffset /= res;
      xadvance /= res;
      const rect = new Rectangle(x3 + pageTextures[page2].frame.x / res, y3 + pageTextures[page2].frame.y / res, width, height);
      this.chars[id] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new Texture(pageTextures[page2].baseTexture, rect),
        page: page2
      };
    }
    for (let i3 = 0;i3 < data.kerning.length; i3++) {
      let { first, second, amount } = data.kerning[i3];
      first /= res;
      second /= res;
      amount /= res;
      if (this.chars[second]) {
        this.chars[second].kerning[first] = amount;
      }
    }
    this.distanceFieldRange = distanceField?.distanceRange;
    this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";
  }
  destroy() {
    for (const id in this.chars) {
      this.chars[id].texture.destroy();
      this.chars[id].texture = null;
    }
    for (const id in this.pageTextures) {
      if (this._ownsTextures) {
        this.pageTextures[id].destroy(true);
      }
      this.pageTextures[id] = null;
    }
    this.chars = null;
    this.pageTextures = null;
  }
  static install(data, textures2, ownsTextures) {
    let fontData;
    if (data instanceof BitmapFontData) {
      fontData = data;
    } else {
      const format = autoDetectFormat(data);
      if (!format) {
        throw new Error("Unrecognized data format for font.");
      }
      fontData = format.parse(data);
    }
    if (textures2 instanceof Texture) {
      textures2 = [textures2];
    }
    const font = new _BitmapFont(fontData, textures2, ownsTextures);
    _BitmapFont.available[font.font] = font;
    return font;
  }
  static uninstall(name) {
    const font = _BitmapFont.available[name];
    if (!font) {
      throw new Error(`No font found named '${name}'`);
    }
    font.destroy();
    delete _BitmapFont.available[name];
  }
  static from(name, textStyle, options) {
    if (!name) {
      throw new Error("[BitmapFont] Property `name` is required.");
    }
    const {
      chars,
      padding,
      resolution,
      textureWidth,
      textureHeight,
      ...baseOptions
    } = Object.assign({}, _BitmapFont.defaultOptions, options);
    const charsList = resolveCharacters(chars);
    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
    const lineWidth = textureWidth;
    const fontData = new BitmapFontData;
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    };
    fontData.common[0] = {
      lineHeight: style.fontSize
    };
    let positionX = 0;
    let positionY = 0;
    let canvas;
    let context2;
    let baseTexture;
    let maxCharHeight = 0;
    const baseTextures = [];
    const textures2 = [];
    for (let i3 = 0;i3 < charsList.length; i3++) {
      if (!canvas) {
        canvas = settings.ADAPTER.createCanvas();
        canvas.width = textureWidth;
        canvas.height = textureHeight;
        context2 = canvas.getContext("2d");
        baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions });
        baseTextures.push(baseTexture);
        textures2.push(new Texture(baseTexture));
        fontData.page.push({
          id: textures2.length - 1,
          file: ""
        });
      }
      const character = charsList[i3];
      const metrics = TextMetrics.measureText(character, style, false, canvas);
      const width = metrics.width;
      const height = Math.ceil(metrics.height);
      const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0) {
          throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i3;
        canvas = null;
        context2 = null;
        baseTexture = null;
        positionY = 0;
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
      if (textureGlyphWidth * resolution + positionX >= lineWidth) {
        if (positionX === 0) {
          throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i3;
        positionY += maxCharHeight * resolution;
        positionY = Math.ceil(positionY);
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      drawGlyph(canvas, context2, metrics, positionX, positionY, resolution, style);
      const id = extractCharCode(metrics.text);
      fontData.char.push({
        id,
        page: textures2.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)
      });
      positionX += (textureGlyphWidth + 2 * padding) * resolution;
      positionX = Math.ceil(positionX);
    }
    for (let i3 = 0, len = charsList.length;i3 < len; i3++) {
      const first = charsList[i3];
      for (let j3 = 0;j3 < len; j3++) {
        const second = charsList[j3];
        const c1 = context2.measureText(first).width;
        const c22 = context2.measureText(second).width;
        const total = context2.measureText(first + second).width;
        const amount = total - (c1 + c22);
        if (amount) {
          fontData.kerning.push({
            first: extractCharCode(first),
            second: extractCharCode(second),
            amount
          });
        }
      }
    }
    const font = new _BitmapFont(fontData, textures2, true);
    if (_BitmapFont.available[name] !== undefined) {
      _BitmapFont.uninstall(name);
    }
    _BitmapFont.available[name] = font;
    return font;
  }
};
var BitmapFont = _BitmapFont;
BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "];
BitmapFont.NUMERIC = [["0", "9"]];
BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
BitmapFont.ASCII = [[" ", "~"]];
BitmapFont.defaultOptions = {
  resolution: 1,
  textureWidth: 512,
  textureHeight: 512,
  padding: 4,
  chars: _BitmapFont.ALPHANUMERIC
};
BitmapFont.available = {};
// node_modules/colord/plugins/names.mjsistener.mjsgl
var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n";

// node_modules/colord/plugins/names.mjsistener.mjsgle
var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";

// node_modules/colord/plugins/names.mjsistener.mjsg
var pageMeshDataDefaultPageMeshData = [];
var pageMeshDataMSDFPageMeshData = [];
var charRenderDataPool = [];
var _BitmapText = class extends Container {
  constructor(text4, style = {}) {
    super();
    const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign({}, _BitmapText.styleDefaults, style);
    if (!BitmapFont.available[fontName]) {
      throw new Error(`Missing BitmapFont "${fontName}"`);
    }
    this._activePagesMeshData = [];
    this._textWidth = 0;
    this._textHeight = 0;
    this._align = align;
    this._tintColor = new Color(tint);
    this._font = undefined;
    this._fontName = fontName;
    this._fontSize = fontSize;
    this.text = text4;
    this._maxWidth = maxWidth;
    this._maxLineHeight = 0;
    this._letterSpacing = letterSpacing;
    this._anchor = new ObservablePoint(() => {
      this.dirty = true;
    }, this, 0, 0);
    this._roundPixels = settings.ROUND_PIXELS;
    this.dirty = true;
    this._resolution = settings.RESOLUTION;
    this._autoResolution = true;
    this._textureCache = {};
  }
  updateText() {
    const data = BitmapFont.available[this._fontName];
    const fontSize = this.fontSize;
    const scale3 = fontSize / data.size;
    const pos = new Point3;
    const chars = [];
    const lineWidths = [];
    const lineSpaces = [];
    const text4 = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
    const charsInput = splitTextToCharacters(text4);
    const maxWidth = this._maxWidth * data.size / fontSize;
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    let prevCharCode = null;
    let lastLineWidth = 0;
    let maxLineWidth = 0;
    let line = 0;
    let lastBreakPos = -1;
    let lastBreakWidth = 0;
    let spacesRemoved = 0;
    let maxLineHeight = 0;
    let spaceCount = 0;
    for (let i3 = 0;i3 < charsInput.length; i3++) {
      const char = charsInput[i3];
      const charCode = extractCharCode(char);
      if (/(?:\s)/.test(char)) {
        lastBreakPos = i3;
        lastBreakWidth = lastLineWidth;
        spaceCount++;
      }
      if (char === "\r" || char === "\n") {
        lineWidths.push(lastLineWidth);
        lineSpaces.push(-1);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        ++line;
        ++spacesRemoved;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
        continue;
      }
      const charData = data.chars[charCode];
      if (!charData) {
        continue;
      }
      if (prevCharCode && charData.kerning[prevCharCode]) {
        pos.x += charData.kerning[prevCharCode];
      }
      const charRenderData = charRenderDataPool.pop() || {
        texture: Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new Point3
      };
      charRenderData.texture = charData.texture;
      charRenderData.line = line;
      charRenderData.charCode = charCode;
      charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);
      charRenderData.position.y = Math.round(pos.y + charData.yOffset);
      charRenderData.prevSpaces = spaceCount;
      chars.push(charRenderData);
      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);
      pos.x += charData.xAdvance + this._letterSpacing;
      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
      prevCharCode = charCode;
      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
        ++spacesRemoved;
        exports_lib.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i3 - lastBreakPos);
        i3 = lastBreakPos;
        lastBreakPos = -1;
        lineWidths.push(lastBreakWidth);
        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
        line++;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
      }
    }
    const lastChar = charsInput[charsInput.length - 1];
    if (lastChar !== "\r" && lastChar !== "\n") {
      if (/(?:\s)/.test(lastChar)) {
        lastLineWidth = lastBreakWidth;
      }
      lineWidths.push(lastLineWidth);
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lineSpaces.push(-1);
    }
    const lineAlignOffsets = [];
    for (let i3 = 0;i3 <= line; i3++) {
      let alignOffset = 0;
      if (this._align === "right") {
        alignOffset = maxLineWidth - lineWidths[i3];
      } else if (this._align === "center") {
        alignOffset = (maxLineWidth - lineWidths[i3]) / 2;
      } else if (this._align === "justify") {
        alignOffset = lineSpaces[i3] < 0 ? 0 : (maxLineWidth - lineWidths[i3]) / lineSpaces[i3];
      }
      lineAlignOffsets.push(alignOffset);
    }
    const lenChars = chars.length;
    const pagesMeshData = {};
    const newPagesMeshData = [];
    const activePagesMeshData = this._activePagesMeshData;
    pageMeshDataPool.push(...activePagesMeshData);
    for (let i3 = 0;i3 < lenChars; i3++) {
      const texture3 = chars[i3].texture;
      const baseTextureUid = texture3.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        let pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          const geometry = new MeshGeometry;
          let material;
          let meshBlendMode;
          if (data.distanceFieldType === "none") {
            material = new MeshMaterial(Texture.EMPTY);
            meshBlendMode = BLEND_MODES.NORMAL;
          } else {
            material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
            meshBlendMode = BLEND_MODES.NORMAL_NPM;
          }
          const mesh4 = new Mesh(geometry, material);
          mesh4.blendMode = meshBlendMode;
          pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh: mesh4,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0;
        pageMeshData.indexCount = 0;
        pageMeshData.vertexCount = 0;
        pageMeshData.uvsCount = 0;
        pageMeshData.total = 0;
        const { _textureCache } = this;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture3.baseTexture);
        pageMeshData.mesh.texture = _textureCache[baseTextureUid];
        pageMeshData.mesh.tint = this._tintColor.value;
        newPagesMeshData.push(pageMeshData);
        pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (let i3 = 0;i3 < activePagesMeshData.length; i3++) {
      if (!newPagesMeshData.includes(activePagesMeshData[i3])) {
        this.removeChild(activePagesMeshData[i3].mesh);
      }
    }
    for (let i3 = 0;i3 < newPagesMeshData.length; i3++) {
      if (newPagesMeshData[i3].mesh.parent !== this) {
        this.addChild(newPagesMeshData[i3].mesh);
      }
    }
    this._activePagesMeshData = newPagesMeshData;
    for (const i3 in pagesMeshData) {
      const pageMeshData = pagesMeshData[i3];
      const total = pageMeshData.total;
      if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
        pageMeshData.vertices = new Float32Array(4 * 2 * total);
        pageMeshData.uvs = new Float32Array(4 * 2 * total);
        pageMeshData.indices = new Uint16Array(6 * total);
      } else {
        const total2 = pageMeshData.total;
        const vertices = pageMeshData.vertices;
        for (let i22 = total2 * 4 * 2;i22 < vertices.length; i22++) {
          vertices[i22] = 0;
        }
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (let i3 = 0;i3 < lenChars; i3++) {
      const char = chars[i3];
      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      if (this._roundPixels) {
        offset = Math.round(offset);
      }
      const xPos = offset * scale3;
      const yPos = char.position.y * scale3;
      const texture3 = char.texture;
      const pageMesh = pagesMeshData[texture3.baseTexture.uid];
      const textureFrame = texture3.frame;
      const textureUvs = texture3._uvs;
      const index2 = pageMesh.index++;
      pageMesh.indices[index2 * 6 + 0] = 0 + index2 * 4;
      pageMesh.indices[index2 * 6 + 1] = 1 + index2 * 4;
      pageMesh.indices[index2 * 6 + 2] = 2 + index2 * 4;
      pageMesh.indices[index2 * 6 + 3] = 0 + index2 * 4;
      pageMesh.indices[index2 * 6 + 4] = 2 + index2 * 4;
      pageMesh.indices[index2 * 6 + 5] = 3 + index2 * 4;
      pageMesh.vertices[index2 * 8 + 0] = xPos;
      pageMesh.vertices[index2 * 8 + 1] = yPos;
      pageMesh.vertices[index2 * 8 + 2] = xPos + textureFrame.width * scale3;
      pageMesh.vertices[index2 * 8 + 3] = yPos;
      pageMesh.vertices[index2 * 8 + 4] = xPos + textureFrame.width * scale3;
      pageMesh.vertices[index2 * 8 + 5] = yPos + textureFrame.height * scale3;
      pageMesh.vertices[index2 * 8 + 6] = xPos;
      pageMesh.vertices[index2 * 8 + 7] = yPos + textureFrame.height * scale3;
      pageMesh.uvs[index2 * 8 + 0] = textureUvs.x0;
      pageMesh.uvs[index2 * 8 + 1] = textureUvs.y0;
      pageMesh.uvs[index2 * 8 + 2] = textureUvs.x1;
      pageMesh.uvs[index2 * 8 + 3] = textureUvs.y1;
      pageMesh.uvs[index2 * 8 + 4] = textureUvs.x2;
      pageMesh.uvs[index2 * 8 + 5] = textureUvs.y2;
      pageMesh.uvs[index2 * 8 + 6] = textureUvs.x3;
      pageMesh.uvs[index2 * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale3;
    this._textHeight = (pos.y + data.lineHeight) * scale3;
    for (const i3 in pagesMeshData) {
      const pageMeshData = pagesMeshData[i3];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        let vertexCount = 0;
        const anchorOffsetX = this._textWidth * this.anchor.x;
        const anchorOffsetY = this._textHeight * this.anchor.y;
        for (let i22 = 0;i22 < pageMeshData.total; i22++) {
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
        }
      }
      this._maxLineHeight = maxLineHeight * scale3;
      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
      const textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
      const indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices;
      textureBuffer.data = pageMeshData.uvs;
      indexBuffer.data = pageMeshData.indices;
      vertexBuffer.update();
      textureBuffer.update();
      indexBuffer.update();
    }
    for (let i3 = 0;i3 < chars.length; i3++) {
      charRenderDataPool.push(chars[i3]);
    }
    this._font = data;
    this.dirty = false;
  }
  updateTransform() {
    this.validate();
    this.containerUpdateTransform();
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];
    if (distanceFieldType !== "none") {
      const { a: a3, b: b3, c: c3, d: d3 } = this.worldTransform;
      const dx = Math.sqrt(a3 * a3 + b3 * b3);
      const dy = Math.sqrt(c3 * c3 + d3 * d3);
      const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
      const fontScale = this.fontSize / size;
      const resolution = renderer._view.resolution;
      for (const mesh4 of this._activePagesMeshData) {
        mesh4.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
      }
    }
    super._render(renderer);
  }
  getLocalBounds() {
    this.validate();
    return super.getLocalBounds();
  }
  validate() {
    const font = BitmapFont.available[this._fontName];
    if (!font) {
      throw new Error(`Missing BitmapFont "${this._fontName}"`);
    }
    if (this._font !== font) {
      this.dirty = true;
    }
    if (this.dirty) {
      this.updateText();
    }
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    if (this.tint === value)
      return;
    this._tintColor.setValue(value);
    for (let i3 = 0;i3 < this._activePagesMeshData.length; i3++) {
      this._activePagesMeshData[i3].mesh.tint = value;
    }
  }
  get align() {
    return this._align;
  }
  set align(value) {
    if (this._align !== value) {
      this._align = value;
      this.dirty = true;
    }
  }
  get fontName() {
    return this._fontName;
  }
  set fontName(value) {
    if (!BitmapFont.available[value]) {
      throw new Error(`Missing BitmapFont "${value}"`);
    }
    if (this._fontName !== value) {
      this._fontName = value;
      this.dirty = true;
    }
  }
  get fontSize() {
    return this._fontSize ?? BitmapFont.available[this._fontName].size;
  }
  set fontSize(value) {
    if (this._fontSize !== value) {
      this._fontSize = value;
      this.dirty = true;
    }
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    if (typeof value === "number") {
      this._anchor.set(value);
    } else {
      this._anchor.copyFrom(value);
    }
  }
  get text() {
    return this._text;
  }
  set text(text4) {
    text4 = String(text4 === null || text4 === undefined ? "" : text4);
    if (this._text === text4) {
      return;
    }
    this._text = text4;
    this.dirty = true;
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(value) {
    if (this._maxWidth === value) {
      return;
    }
    this._maxWidth = value;
    this.dirty = true;
  }
  get maxLineHeight() {
    this.validate();
    return this._maxLineHeight;
  }
  get textWidth() {
    this.validate();
    return this._textWidth;
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(value) {
    if (this._letterSpacing !== value) {
      this._letterSpacing = value;
      this.dirty = true;
    }
  }
  get roundPixels() {
    return this._roundPixels;
  }
  set roundPixels(value) {
    if (value !== this._roundPixels) {
      this._roundPixels = value;
      this.dirty = true;
    }
  }
  get textHeight() {
    this.validate();
    return this._textHeight;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
  destroy(options) {
    const { _textureCache } = this;
    const data = BitmapFont.available[this._fontName];
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    pageMeshDataPool.push(...this._activePagesMeshData);
    for (const pageMeshData of this._activePagesMeshData) {
      this.removeChild(pageMeshData.mesh);
    }
    this._activePagesMeshData = [];
    pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
      page.mesh.texture = Texture.EMPTY;
    });
    for (const id in _textureCache) {
      const texture3 = _textureCache[id];
      texture3.destroy();
      delete _textureCache[id];
    }
    this._font = null;
    this._tintColor = null;
    this._textureCache = null;
    super.destroy(options);
  }
};
var BitmapText = _BitmapText;
BitmapText.styleDefaults = {
  align: "left",
  tint: 16777215,
  maxWidth: 0,
  letterSpacing: 0
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.m
var validExtensions = [".xml", ".fnt"];
var loadBitmapFont = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Normal
  },
  name: "loadBitmapFont",
  test(url3) {
    return validExtensions.includes(exports_lib.path.extname(url3).toLowerCase());
  },
  async testParse(data) {
    return TextFormat.test(data) || XMLStringFormat.test(data);
  },
  async parse(asset, data, loader3) {
    const fontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);
    const { src } = data;
    const { page: pages } = fontData;
    const textureUrls = [];
    for (let i3 = 0;i3 < pages.length; ++i3) {
      const pageFile = pages[i3].file;
      let imagePath = exports_lib.path.join(exports_lib.path.dirname(src), pageFile);
      imagePath = copySearchParams(imagePath, src);
      textureUrls.push(imagePath);
    }
    const loadedTextures = await loader3.load(textureUrls);
    const textures2 = textureUrls.map((url3) => loadedTextures[url3]);
    return BitmapFont.install(fontData, textures2, true);
  },
  async load(url3, _options) {
    const response = await settings.ADAPTER.fetch(url3);
    return response.text();
  },
  unload(bitmapFont) {
    bitmapFont.destroy();
  }
};
extensions.add(loadBitmapFont);
// node_modules/colord/plugins/names.mjsistener.mjsgl
var _HTMLTextStyle = class extends TextStyle {
  constructor() {
    super(...arguments);
    this._fonts = [];
    this._overrides = [];
    this._stylesheet = "";
    this.fontsDirty = false;
  }
  static from(originalStyle) {
    return new _HTMLTextStyle(Object.keys(_HTMLTextStyle.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {}));
  }
  cleanFonts() {
    if (this._fonts.length > 0) {
      this._fonts.forEach((font) => {
        URL.revokeObjectURL(font.src);
        font.refs--;
        if (font.refs === 0) {
          if (font.fontFace) {
            document.fonts.delete(font.fontFace);
          }
          delete _HTMLTextStyle.availableFonts[font.originalUrl];
        }
      });
      this.fontFamily = "Arial";
      this._fonts.length = 0;
      this.styleID++;
      this.fontsDirty = true;
    }
  }
  loadFont(url3, options = {}) {
    const { availableFonts } = _HTMLTextStyle;
    if (availableFonts[url3]) {
      const font = availableFonts[url3];
      this._fonts.push(font);
      font.refs++;
      this.styleID++;
      this.fontsDirty = true;
      return Promise.resolve();
    }
    return settings.ADAPTER.fetch(url3).then((response) => response.blob()).then(async (blob) => new Promise((resolve, reject) => {
      const src = URL.createObjectURL(blob);
      const reader = new FileReader;
      reader.onload = () => resolve([src, reader.result]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    })).then(async ([src, dataSrc]) => {
      const font = Object.assign({
        family: exports_lib.path.basename(url3, exports_lib.path.extname(url3)),
        weight: "normal",
        style: "normal",
        src,
        dataSrc,
        refs: 1,
        originalUrl: url3,
        fontFace: null
      }, options);
      availableFonts[url3] = font;
      this._fonts.push(font);
      this.styleID++;
      const fontFace = new FontFace(font.family, `url(${font.src})`, {
        weight: font.weight,
        style: font.style
      });
      font.fontFace = fontFace;
      await fontFace.load();
      document.fonts.add(fontFace);
      await document.fonts.ready;
      this.styleID++;
      this.fontsDirty = true;
    });
  }
  addOverride(...value) {
    const toAdd = value.filter((v4) => !this._overrides.includes(v4));
    if (toAdd.length > 0) {
      this._overrides.push(...toAdd);
      this.styleID++;
    }
  }
  removeOverride(...value) {
    const toRemove = value.filter((v4) => this._overrides.includes(v4));
    if (toRemove.length > 0) {
      this._overrides = this._overrides.filter((v4) => !toRemove.includes(v4));
      this.styleID++;
    }
  }
  toCSS(scale3) {
    return [
      `transform: scale(${scale3})`,
      `transform-origin: top left`,
      "display: inline-block",
      `color: ${this.normalizeColor(this.fill)}`,
      `font-size: ${this.fontSize}px`,
      `font-family: ${this.fontFamily}`,
      `font-weight: ${this.fontWeight}`,
      `font-style: ${this.fontStyle}`,
      `font-variant: ${this.fontVariant}`,
      `letter-spacing: ${this.letterSpacing}px`,
      `text-align: ${this.align}`,
      `padding: ${this.padding}px`,
      `white-space: ${this.whiteSpace}`,
      ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],
      ...this.wordWrap ? [
        `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${this.wordWrapWidth}px`
      ] : [],
      ...this.strokeThickness ? [
        `-webkit-text-stroke-width: ${this.strokeThickness}px`,
        `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        `text-stroke-width: ${this.strokeThickness}px`,
        `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        "paint-order: stroke"
      ] : [],
      ...this.dropShadow ? [this.dropShadowToCSS()] : [],
      ...this._overrides
    ].join(";");
  }
  toGlobalCSS() {
    return this._fonts.reduce((result, font) => `${result}
            @font-face {
                font-family: "${font.family}";
                src: url('${font.dataSrc}');
                font-weight: ${font.weight};
                font-style: ${font.style}; 
            }`, this._stylesheet);
  }
  get stylesheet() {
    return this._stylesheet;
  }
  set stylesheet(value) {
    if (this._stylesheet !== value) {
      this._stylesheet = value;
      this.styleID++;
    }
  }
  normalizeColor(color8) {
    if (Array.isArray(color8)) {
      color8 = exports_lib.rgb2hex(color8);
    }
    if (typeof color8 === "number") {
      return exports_lib.hex2string(color8);
    }
    return color8;
  }
  dropShadowToCSS() {
    let color8 = this.normalizeColor(this.dropShadowColor);
    const alpha2 = this.dropShadowAlpha;
    const x3 = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance);
    const y3 = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
    if (color8.startsWith("#") && alpha2 < 1) {
      color8 += (alpha2 * 255 | 0).toString(16).padStart(2, "0");
    }
    const position = `${x3}px ${y3}px`;
    if (this.dropShadowBlur > 0) {
      return `text-shadow: ${position} ${this.dropShadowBlur}px ${color8}`;
    }
    return `text-shadow: ${position} ${color8}`;
  }
  reset() {
    Object.assign(this, _HTMLTextStyle.defaultOptions);
  }
  onBeforeDraw() {
    const { fontsDirty: prevFontsDirty } = this;
    this.fontsDirty = false;
    if (this.isSafari && this._fonts.length > 0 && prevFontsDirty) {
      return new Promise((resolve) => setTimeout(resolve, 100));
    }
    return Promise.resolve();
  }
  get isSafari() {
    const { userAgent } = settings.ADAPTER.getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  set fillGradientStops(_value) {
    console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");
  }
  get fillGradientStops() {
    return super.fillGradientStops;
  }
  set fillGradientType(_value) {
    console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");
  }
  get fillGradientType() {
    return super.fillGradientType;
  }
  set miterLimit(_value) {
    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
  }
  get miterLimit() {
    return super.miterLimit;
  }
  set trim(_value) {
    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
  }
  get trim() {
    return super.trim;
  }
  set textBaseline(_value) {
    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
  }
  get textBaseline() {
    return super.textBaseline;
  }
  set leading(_value) {
    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
  }
  get leading() {
    return super.leading;
  }
  set lineJoin(_value) {
    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
  }
  get lineJoin() {
    return super.lineJoin;
  }
};
var HTMLTextStyle = _HTMLTextStyle;
HTMLTextStyle.availableFonts = {};
HTMLTextStyle.defaultOptions = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  whiteSpace: "normal",
  wordWrap: false,
  wordWrapWidth: 100
};

// node_modules/colord/plugins/names.mjsistener.
var _HTMLText = class extends Sprite {
  constructor(text6 = "", style = {}) {
    super(Texture.EMPTY);
    this._text = null;
    this._style = null;
    this._autoResolution = true;
    this._loading = false;
    this.localStyleID = -1;
    this.dirty = false;
    this.ownsStyle = false;
    const image = new Image;
    const texture3 = Texture.from(image, {
      scaleMode: settings.SCALE_MODE,
      resourceOptions: {
        autoLoad: false
      }
    });
    texture3.orig = new Rectangle;
    texture3.trim = new Rectangle;
    this.texture = texture3;
    const nssvg = "http://www.w3.org/2000/svg";
    const nsxhtml = "http://www.w3.org/1999/xhtml";
    const svgRoot = document.createElementNS(nssvg, "svg");
    const foreignObject = document.createElementNS(nssvg, "foreignObject");
    const domElement = document.createElementNS(nsxhtml, "div");
    const styleElement = document.createElementNS(nsxhtml, "style");
    foreignObject.setAttribute("width", "10000");
    foreignObject.setAttribute("height", "10000");
    foreignObject.style.overflow = "hidden";
    svgRoot.appendChild(foreignObject);
    this.maxWidth = _HTMLText.defaultMaxWidth;
    this.maxHeight = _HTMLText.defaultMaxHeight;
    this._domElement = domElement;
    this._styleElement = styleElement;
    this._svgRoot = svgRoot;
    this._foreignObject = foreignObject;
    this._foreignObject.appendChild(styleElement);
    this._foreignObject.appendChild(domElement);
    this._image = image;
    this._loadImage = new Image;
    this._autoResolution = _HTMLText.defaultAutoResolution;
    this._resolution = _HTMLText.defaultResolution ?? settings.RESOLUTION;
    this.text = text6;
    this.style = style;
  }
  measureText(overrides) {
    const { text: text6, style, resolution } = Object.assign({
      text: this._text,
      style: this._style,
      resolution: this._resolution
    }, overrides);
    Object.assign(this._domElement, {
      innerHTML: text6,
      style: style.toCSS(resolution)
    });
    this._styleElement.textContent = style.toGlobalCSS();
    document.body.appendChild(this._svgRoot);
    const contentBounds = this._domElement.getBoundingClientRect();
    this._svgRoot.remove();
    const contentWidth = Math.min(this.maxWidth, Math.ceil(contentBounds.width));
    const contentHeight = Math.min(this.maxHeight, Math.ceil(contentBounds.height));
    this._svgRoot.setAttribute("width", contentWidth.toString());
    this._svgRoot.setAttribute("height", contentHeight.toString());
    if (text6 !== this._text) {
      this._domElement.innerHTML = this._text;
    }
    if (style !== this._style) {
      Object.assign(this._domElement, { style: this._style?.toCSS(resolution) });
      this._styleElement.textContent = this._style?.toGlobalCSS();
    }
    return {
      width: contentWidth + style.padding * 2,
      height: contentHeight + style.padding * 2
    };
  }
  async updateText(respectDirty = true) {
    const { style, _image: image, _loadImage: loadImage } = this;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    const { width, height } = this.measureText();
    image.width = loadImage.width = Math.ceil(Math.max(1, width));
    image.height = loadImage.height = Math.ceil(Math.max(1, height));
    if (!this._loading) {
      this._loading = true;
      await new Promise((resolve) => {
        loadImage.onload = async () => {
          await style.onBeforeDraw();
          this._loading = false;
          image.src = loadImage.src;
          loadImage.onload = null;
          loadImage.src = "";
          this.updateTexture();
          resolve();
        };
        const svgURL = new XMLSerializer().serializeToString(this._svgRoot);
        loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;
      });
    }
  }
  get source() {
    return this._image;
  }
  updateTexture() {
    const { style, texture: texture3, _image: image, resolution } = this;
    const { padding } = style;
    const { baseTexture } = texture3;
    texture3.trim.width = texture3._frame.width = image.width / resolution;
    texture3.trim.height = texture3._frame.height = image.height / resolution;
    texture3.trim.x = -padding;
    texture3.trim.y = -padding;
    texture3.orig.width = texture3._frame.width - padding * 2;
    texture3.orig.height = texture3._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(image.width, image.height, resolution);
    this.dirty = false;
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer);
  }
  _renderCanvas(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._renderCanvas(renderer);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds(rect);
  }
  _calculateBounds() {
    this.updateText(true);
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _onStyleChange() {
    this.dirty = true;
  }
  destroy(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, _HTMLText.defaultDestroyOptions, options);
    super.destroy(options);
    const forceClear = null;
    if (this.ownsStyle) {
      this._style?.cleanFonts();
    }
    this._style = forceClear;
    this._svgRoot?.remove();
    this._svgRoot = forceClear;
    this._domElement?.remove();
    this._domElement = forceClear;
    this._foreignObject?.remove();
    this._foreignObject = forceClear;
    this._styleElement?.remove();
    this._styleElement = forceClear;
    this._loadImage.src = "";
    this._loadImage.onload = null;
    this._loadImage = forceClear;
    this._image.src = "";
    this._image = forceClear;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._image.width / this.resolution;
  }
  set width(value) {
    this.updateText(true);
    const s3 = exports_lib.sign(this.scale.x) || 1;
    this.scale.x = s3 * value / this._image.width / this.resolution;
    this._width = value;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._image.height / this.resolution;
  }
  set height(value) {
    this.updateText(true);
    const s3 = exports_lib.sign(this.scale.y) || 1;
    this.scale.y = s3 * value / this._image.height / this.resolution;
    this._height = value;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    if (this._style === style) {
      return;
    }
    style = style || {};
    if (style instanceof HTMLTextStyle) {
      this.ownsStyle = false;
      this._style = style;
    } else if (style instanceof TextStyle) {
      console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle");
      this.ownsStyle = true;
      this._style = HTMLTextStyle.from(style);
    } else {
      this.ownsStyle = true;
      this._style = new HTMLTextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text6) {
    text6 = String(text6 === "" || text6 === null || text6 === undefined ? " " : text6);
    text6 = this.sanitiseText(text6);
    if (this._text === text6) {
      return;
    }
    this._text = text6;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
  sanitiseText(text6) {
    return text6.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");
  }
};
var HTMLText = _HTMLText;
HTMLText.defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
HTMLText.defaultMaxWidth = 2024;
HTMLText.defaultMaxHeight = 2024;
HTMLText.defaultAutoResolution = true;
// node_modules/colord/plugins/names.mjsistener.mjs
var W3 = function(c3, r4) {
  if (c3) {
    if (typeof c3 == "function")
      return c3;
    if (typeof c3 == "string")
      return b3[c3];
  } else
    return b3[r4];
};
var S4 = Object.defineProperty;
var M4 = (c3, r4, t4) => (r4 in c3) ? S4(c3, r4, { enumerable: true, configurable: true, writable: true, value: t4 }) : c3[r4] = t4;
var o3 = (c3, r4, t4) => (M4(c3, typeof r4 != "symbol" ? r4 + "" : r4, t4), t4);

class f3 {
  constructor(r4) {
    o3(this, "parent");
    o3(this, "paused");
    this.parent = r4, this.paused = false;
  }
  destroy() {
  }
  down(r4) {
    return false;
  }
  move(r4) {
    return false;
  }
  up(r4) {
    return false;
  }
  wheel(r4) {
    return false;
  }
  update(r4) {
  }
  resize() {
  }
  reset() {
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.paused = false;
  }
}
var C3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var H4 = { exports: {} };
(function(c3, r4) {
  (function() {
    var t4, i3;
    i3 = function(e3) {
      return c3.exports = e3;
    }, t4 = {
      linear: function(e3, n4, s3, h3) {
        return s3 * e3 / h3 + n4;
      },
      easeInQuad: function(e3, n4, s3, h3) {
        return s3 * (e3 /= h3) * e3 + n4;
      },
      easeOutQuad: function(e3, n4, s3, h3) {
        return -s3 * (e3 /= h3) * (e3 - 2) + n4;
      },
      easeInOutQuad: function(e3, n4, s3, h3) {
        return (e3 /= h3 / 2) < 1 ? s3 / 2 * e3 * e3 + n4 : -s3 / 2 * (--e3 * (e3 - 2) - 1) + n4;
      },
      easeInCubic: function(e3, n4, s3, h3) {
        return s3 * (e3 /= h3) * e3 * e3 + n4;
      },
      easeOutCubic: function(e3, n4, s3, h3) {
        return s3 * ((e3 = e3 / h3 - 1) * e3 * e3 + 1) + n4;
      },
      easeInOutCubic: function(e3, n4, s3, h3) {
        return (e3 /= h3 / 2) < 1 ? s3 / 2 * e3 * e3 * e3 + n4 : s3 / 2 * ((e3 -= 2) * e3 * e3 + 2) + n4;
      },
      easeInQuart: function(e3, n4, s3, h3) {
        return s3 * (e3 /= h3) * e3 * e3 * e3 + n4;
      },
      easeOutQuart: function(e3, n4, s3, h3) {
        return -s3 * ((e3 = e3 / h3 - 1) * e3 * e3 * e3 - 1) + n4;
      },
      easeInOutQuart: function(e3, n4, s3, h3) {
        return (e3 /= h3 / 2) < 1 ? s3 / 2 * e3 * e3 * e3 * e3 + n4 : -s3 / 2 * ((e3 -= 2) * e3 * e3 * e3 - 2) + n4;
      },
      easeInQuint: function(e3, n4, s3, h3) {
        return s3 * (e3 /= h3) * e3 * e3 * e3 * e3 + n4;
      },
      easeOutQuint: function(e3, n4, s3, h3) {
        return s3 * ((e3 = e3 / h3 - 1) * e3 * e3 * e3 * e3 + 1) + n4;
      },
      easeInOutQuint: function(e3, n4, s3, h3) {
        return (e3 /= h3 / 2) < 1 ? s3 / 2 * e3 * e3 * e3 * e3 * e3 + n4 : s3 / 2 * ((e3 -= 2) * e3 * e3 * e3 * e3 + 2) + n4;
      },
      easeInSine: function(e3, n4, s3, h3) {
        return -s3 * Math.cos(e3 / h3 * (Math.PI / 2)) + s3 + n4;
      },
      easeOutSine: function(e3, n4, s3, h3) {
        return s3 * Math.sin(e3 / h3 * (Math.PI / 2)) + n4;
      },
      easeInOutSine: function(e3, n4, s3, h3) {
        return -s3 / 2 * (Math.cos(Math.PI * e3 / h3) - 1) + n4;
      },
      easeInExpo: function(e3, n4, s3, h3) {
        return e3 === 0 ? n4 : s3 * Math.pow(2, 10 * (e3 / h3 - 1)) + n4;
      },
      easeOutExpo: function(e3, n4, s3, h3) {
        return e3 === h3 ? n4 + s3 : s3 * (-Math.pow(2, -10 * e3 / h3) + 1) + n4;
      },
      easeInOutExpo: function(e3, n4, s3, h3) {
        return (e3 /= h3 / 2) < 1 ? s3 / 2 * Math.pow(2, 10 * (e3 - 1)) + n4 : s3 / 2 * (-Math.pow(2, -10 * --e3) + 2) + n4;
      },
      easeInCirc: function(e3, n4, s3, h3) {
        return -s3 * (Math.sqrt(1 - (e3 /= h3) * e3) - 1) + n4;
      },
      easeOutCirc: function(e3, n4, s3, h3) {
        return s3 * Math.sqrt(1 - (e3 = e3 / h3 - 1) * e3) + n4;
      },
      easeInOutCirc: function(e3, n4, s3, h3) {
        return (e3 /= h3 / 2) < 1 ? -s3 / 2 * (Math.sqrt(1 - e3 * e3) - 1) + n4 : s3 / 2 * (Math.sqrt(1 - (e3 -= 2) * e3) + 1) + n4;
      },
      easeInElastic: function(e3, n4, s3, h3) {
        var a3, p3, l4;
        return l4 = 1.70158, p3 = 0, a3 = s3, e3 === 0 || (e3 /= h3), p3 || (p3 = h3 * 0.3), a3 < Math.abs(s3) ? (a3 = s3, l4 = p3 / 4) : l4 = p3 / (2 * Math.PI) * Math.asin(s3 / a3), -(a3 * Math.pow(2, 10 * (e3 -= 1)) * Math.sin((e3 * h3 - l4) * (2 * Math.PI) / p3)) + n4;
      },
      easeOutElastic: function(e3, n4, s3, h3) {
        var a3, p3, l4;
        return l4 = 1.70158, p3 = 0, a3 = s3, e3 === 0 || (e3 /= h3), p3 || (p3 = h3 * 0.3), a3 < Math.abs(s3) ? (a3 = s3, l4 = p3 / 4) : l4 = p3 / (2 * Math.PI) * Math.asin(s3 / a3), a3 * Math.pow(2, -10 * e3) * Math.sin((e3 * h3 - l4) * (2 * Math.PI) / p3) + s3 + n4;
      },
      easeInOutElastic: function(e3, n4, s3, h3) {
        var a3, p3, l4;
        return l4 = 1.70158, p3 = 0, a3 = s3, e3 === 0 || (e3 /= h3 / 2), p3 || (p3 = h3 * (0.3 * 1.5)), a3 < Math.abs(s3) ? (a3 = s3, l4 = p3 / 4) : l4 = p3 / (2 * Math.PI) * Math.asin(s3 / a3), e3 < 1 ? -0.5 * (a3 * Math.pow(2, 10 * (e3 -= 1)) * Math.sin((e3 * h3 - l4) * (2 * Math.PI) / p3)) + n4 : a3 * Math.pow(2, -10 * (e3 -= 1)) * Math.sin((e3 * h3 - l4) * (2 * Math.PI) / p3) * 0.5 + s3 + n4;
      },
      easeInBack: function(e3, n4, s3, h3, a3) {
        return a3 === undefined && (a3 = 1.70158), s3 * (e3 /= h3) * e3 * ((a3 + 1) * e3 - a3) + n4;
      },
      easeOutBack: function(e3, n4, s3, h3, a3) {
        return a3 === undefined && (a3 = 1.70158), s3 * ((e3 = e3 / h3 - 1) * e3 * ((a3 + 1) * e3 + a3) + 1) + n4;
      },
      easeInOutBack: function(e3, n4, s3, h3, a3) {
        return a3 === undefined && (a3 = 1.70158), (e3 /= h3 / 2) < 1 ? s3 / 2 * (e3 * e3 * (((a3 *= 1.525) + 1) * e3 - a3)) + n4 : s3 / 2 * ((e3 -= 2) * e3 * (((a3 *= 1.525) + 1) * e3 + a3) + 2) + n4;
      },
      easeInBounce: function(e3, n4, s3, h3) {
        var a3;
        return a3 = t4.easeOutBounce(h3 - e3, 0, s3, h3), s3 - a3 + n4;
      },
      easeOutBounce: function(e3, n4, s3, h3) {
        return (e3 /= h3) < 1 / 2.75 ? s3 * (7.5625 * e3 * e3) + n4 : e3 < 2 / 2.75 ? s3 * (7.5625 * (e3 -= 1.5 / 2.75) * e3 + 0.75) + n4 : e3 < 2.5 / 2.75 ? s3 * (7.5625 * (e3 -= 2.25 / 2.75) * e3 + 0.9375) + n4 : s3 * (7.5625 * (e3 -= 2.625 / 2.75) * e3 + 0.984375) + n4;
      },
      easeInOutBounce: function(e3, n4, s3, h3) {
        var a3;
        return e3 < h3 / 2 ? (a3 = t4.easeInBounce(e3 * 2, 0, s3, h3), a3 * 0.5 + n4) : (a3 = t4.easeOutBounce(e3 * 2 - h3, 0, s3, h3), a3 * 0.5 + s3 * 0.5 + n4);
      }
    }, i3(t4);
  }).call(C3);
})(H4);
var b3 = H4.exports;
var I3 = {
  removeOnInterrupt: false,
  ease: "linear",
  time: 1000
};

class k4 extends f3 {
  constructor(t4, i3 = {}) {
    super(t4);
    o3(this, "options");
    o3(this, "startX");
    o3(this, "startY");
    o3(this, "deltaX");
    o3(this, "deltaY");
    o3(this, "keepCenter");
    o3(this, "startWidth", null);
    o3(this, "startHeight", null);
    o3(this, "deltaWidth", null);
    o3(this, "deltaHeight", null);
    o3(this, "width", null);
    o3(this, "height", null);
    o3(this, "time", 0);
    this.options = Object.assign({}, I3, i3), this.options.ease = W3(this.options.ease), this.setupPosition(), this.setupZoom(), this.time = 0;
  }
  setupPosition() {
    typeof this.options.position < "u" ? (this.startX = this.parent.center.x, this.startY = this.parent.center.y, this.deltaX = this.options.position.x - this.parent.center.x, this.deltaY = this.options.position.y - this.parent.center.y, this.keepCenter = false) : this.keepCenter = true;
  }
  setupZoom() {
    this.width = null, this.height = null, typeof this.options.scale < "u" ? this.width = this.parent.screenWidth / this.options.scale : typeof this.options.scaleX < "u" || typeof this.options.scaleY < "u" ? (typeof this.options.scaleX < "u" && (this.width = this.parent.screenWidth / this.options.scaleX), typeof this.options.scaleY < "u" && (this.height = this.parent.screenHeight / this.options.scaleY)) : (typeof this.options.width < "u" && (this.width = this.options.width), typeof this.options.height < "u" && (this.height = this.options.height)), this.width !== null && (this.startWidth = this.parent.screenWidthInWorldPixels, this.deltaWidth = this.width - this.startWidth), this.height !== null && (this.startHeight = this.parent.screenHeightInWorldPixels, this.deltaHeight = this.height - this.startHeight);
  }
  down() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("animate"), false;
  }
  complete() {
    this.parent.plugins.remove("animate"), this.width !== null && this.parent.fitWidth(this.width, this.keepCenter, this.height === null), this.height !== null && this.parent.fitHeight(this.height, this.keepCenter, this.width === null), !this.keepCenter && this.options.position && this.parent.moveCenter(this.options.position), this.parent.emit("animate-end", this.parent), this.options.callbackOnComplete && this.options.callbackOnComplete(this.parent);
  }
  update(t4) {
    if (this.paused)
      return;
    this.time += t4;
    const i3 = new Point3(this.parent.scale.x, this.parent.scale.y);
    if (this.time >= this.options.time) {
      const e3 = this.parent.width, n4 = this.parent.height;
      this.complete(), (e3 !== this.parent.width || n4 !== this.parent.height) && this.parent.emit("zoomed", { viewport: this.parent, original: i3, type: "animate" });
    } else {
      const e3 = this.options.ease(this.time, 0, 1, this.options.time);
      if (this.width !== null) {
        const n4 = this.startWidth, s3 = this.deltaWidth;
        this.parent.fitWidth(n4 + s3 * e3, this.keepCenter, this.height === null);
      }
      if (this.height !== null) {
        const n4 = this.startHeight, s3 = this.deltaHeight;
        this.parent.fitHeight(n4 + s3 * e3, this.keepCenter, this.width === null);
      }
      if (this.width === null ? this.parent.scale.x = this.parent.scale.y : this.height === null && (this.parent.scale.y = this.parent.scale.x), !this.keepCenter) {
        const n4 = this.startX, s3 = this.startY, h3 = this.deltaX, a3 = this.deltaY, p3 = new Point3(this.parent.x, this.parent.y);
        this.parent.moveCenter(n4 + h3 * e3, s3 + a3 * e3), this.parent.emit("moved", { viewport: this.parent, original: p3, type: "animate" });
      }
      (this.width || this.height) && this.parent.emit("zoomed", { viewport: this.parent, original: i3, type: "animate" });
    }
  }
}
var Y2 = {
  sides: "all",
  friction: 0.5,
  time: 150,
  ease: "easeInOutSine",
  underflow: "center",
  bounceBox: null
};

class X2 extends f3 {
  constructor(t4, i3 = {}) {
    super(t4);
    o3(this, "options");
    o3(this, "left");
    o3(this, "top");
    o3(this, "right");
    o3(this, "bottom");
    o3(this, "underflowX");
    o3(this, "underflowY");
    o3(this, "ease");
    o3(this, "toX");
    o3(this, "toY");
    this.options = Object.assign({}, Y2, i3), this.ease = W3(this.options.ease, "easeInOutSine"), this.options.sides ? this.options.sides === "all" ? this.top = this.bottom = this.left = this.right = true : this.options.sides === "horizontal" ? (this.right = this.left = true, this.top = this.bottom = false) : this.options.sides === "vertical" ? (this.left = this.right = false, this.top = this.bottom = true) : (this.top = this.options.sides.indexOf("top") !== -1, this.bottom = this.options.sides.indexOf("bottom") !== -1, this.left = this.options.sides.indexOf("left") !== -1, this.right = this.options.sides.indexOf("right") !== -1) : this.left = this.top = this.right = this.bottom = false;
    const e3 = this.options.underflow.toLowerCase();
    e3 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (this.underflowX = e3.indexOf("left") !== -1 ? -1 : e3.indexOf("right") !== -1 ? 1 : 0, this.underflowY = e3.indexOf("top") !== -1 ? -1 : e3.indexOf("bottom") !== -1 ? 1 : 0), this.reset();
  }
  isActive() {
    return this.toX !== null || this.toY !== null;
  }
  down() {
    return this.toX = this.toY = null, false;
  }
  up() {
    return this.bounce(), false;
  }
  update(t4) {
    if (!this.paused) {
      if (this.bounce(), this.toX) {
        const i3 = this.toX;
        i3.time += t4, this.parent.emit("moved", { viewport: this.parent, type: "bounce-x" }), i3.time >= this.options.time ? (this.parent.x = i3.end, this.toX = null, this.parent.emit("bounce-x-end", this.parent)) : this.parent.x = this.ease(i3.time, i3.start, i3.delta, this.options.time);
      }
      if (this.toY) {
        const i3 = this.toY;
        i3.time += t4, this.parent.emit("moved", { viewport: this.parent, type: "bounce-y" }), i3.time >= this.options.time ? (this.parent.y = i3.end, this.toY = null, this.parent.emit("bounce-y-end", this.parent)) : this.parent.y = this.ease(i3.time, i3.start, i3.delta, this.options.time);
      }
    }
  }
  calcUnderflowX() {
    let t4;
    switch (this.underflowX) {
      case -1:
        t4 = 0;
        break;
      case 1:
        t4 = this.parent.screenWidth - this.parent.screenWorldWidth;
        break;
      default:
        t4 = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
    }
    return t4;
  }
  calcUnderflowY() {
    let t4;
    switch (this.underflowY) {
      case -1:
        t4 = 0;
        break;
      case 1:
        t4 = this.parent.screenHeight - this.parent.screenWorldHeight;
        break;
      default:
        t4 = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
    }
    return t4;
  }
  oob() {
    const t4 = this.options.bounceBox;
    if (t4) {
      const i3 = typeof t4.x > "u" ? 0 : t4.x, e3 = typeof t4.y > "u" ? 0 : t4.y, n4 = typeof t4.width > "u" ? this.parent.worldWidth : t4.width, s3 = typeof t4.height > "u" ? this.parent.worldHeight : t4.height;
      return {
        left: this.parent.left < i3,
        right: this.parent.right > n4,
        top: this.parent.top < e3,
        bottom: this.parent.bottom > s3,
        topLeft: new Point3(i3 * this.parent.scale.x, e3 * this.parent.scale.y),
        bottomRight: new Point3(n4 * this.parent.scale.x - this.parent.screenWidth, s3 * this.parent.scale.y - this.parent.screenHeight)
      };
    }
    return {
      left: this.parent.left < 0,
      right: this.parent.right > this.parent.worldWidth,
      top: this.parent.top < 0,
      bottom: this.parent.bottom > this.parent.worldHeight,
      topLeft: new Point3(0, 0),
      bottomRight: new Point3(this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth, this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight)
    };
  }
  bounce() {
    var s3, h3;
    if (this.paused)
      return;
    let t4, i3 = this.parent.plugins.get("decelerate", true);
    i3 && (i3.x || i3.y) && (i3.x && i3.percentChangeX === ((s3 = i3.options) == null ? undefined : s3.friction) || i3.y && i3.percentChangeY === ((h3 = i3.options) == null ? undefined : h3.friction)) && (t4 = this.oob(), (t4.left && this.left || t4.right && this.right) && (i3.percentChangeX = this.options.friction), (t4.top && this.top || t4.bottom && this.bottom) && (i3.percentChangeY = this.options.friction));
    const e3 = this.parent.plugins.get("drag", true) || {}, n4 = this.parent.plugins.get("pinch", true) || {};
    if (i3 = i3 || {}, !(e3 != null && e3.active) && !(n4 != null && n4.active) && (!this.toX || !this.toY) && (!i3.x || !i3.y)) {
      t4 = t4 || this.oob();
      const { topLeft: a3, bottomRight: p3 } = t4;
      if (!this.toX && !i3.x) {
        let l4 = null;
        t4.left && this.left ? l4 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -a3.x : t4.right && this.right && (l4 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -p3.x), l4 !== null && this.parent.x !== l4 && (this.toX = { time: 0, start: this.parent.x, delta: l4 - this.parent.x, end: l4 }, this.parent.emit("bounce-x-start", this.parent));
      }
      if (!this.toY && !i3.y) {
        let l4 = null;
        t4.top && this.top ? l4 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -a3.y : t4.bottom && this.bottom && (l4 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -p3.y), l4 !== null && this.parent.y !== l4 && (this.toY = { time: 0, start: this.parent.y, delta: l4 - this.parent.y, end: l4 }, this.parent.emit("bounce-y-start", this.parent));
      }
    }
  }
  reset() {
    this.toX = this.toY = null, this.bounce();
  }
}
var z2 = {
  left: false,
  right: false,
  top: false,
  bottom: false,
  direction: null,
  underflow: "center"
};

class A2 extends f3 {
  constructor(t4, i3 = {}) {
    super(t4);
    o3(this, "options");
    o3(this, "last");
    o3(this, "noUnderflow");
    o3(this, "underflowX");
    o3(this, "underflowY");
    this.options = Object.assign({}, z2, i3), this.options.direction && (this.options.left = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.right = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.top = this.options.direction === "y" || this.options.direction === "all" ? true : null, this.options.bottom = this.options.direction === "y" || this.options.direction === "all" ? true : null), this.parseUnderflow(), this.last = { x: null, y: null, scaleX: null, scaleY: null }, this.update();
  }
  parseUnderflow() {
    const t4 = this.options.underflow.toLowerCase();
    t4 === "none" ? this.noUnderflow = true : t4 === "center" ? (this.underflowX = this.underflowY = 0, this.noUnderflow = false) : (this.underflowX = t4.indexOf("left") !== -1 ? -1 : t4.indexOf("right") !== -1 ? 1 : 0, this.underflowY = t4.indexOf("top") !== -1 ? -1 : t4.indexOf("bottom") !== -1 ? 1 : 0, this.noUnderflow = false);
  }
  move() {
    return this.update(), false;
  }
  update() {
    if (this.paused || this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY)
      return;
    const t4 = new Point3(this.parent.x, this.parent.y), i3 = this.parent.plugins.decelerate || {};
    if (this.options.left !== null || this.options.right !== null) {
      let e3 = false;
      if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x !== 0 && (this.parent.x = 0, e3 = true);
            break;
          case 1:
            this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth && (this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth, e3 = true);
            break;
          default:
            this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2 && (this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2, e3 = true);
        }
      else
        this.options.left !== null && this.parent.left < (this.options.left === true ? 0 : this.options.left) && (this.parent.x = -(this.options.left === true ? 0 : this.options.left) * this.parent.scale.x, i3.x = 0, e3 = true), this.options.right !== null && this.parent.right > (this.options.right === true ? this.parent.worldWidth : this.options.right) && (this.parent.x = -(this.options.right === true ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth, i3.x = 0, e3 = true);
      e3 && this.parent.emit("moved", { viewport: this.parent, original: t4, type: "clamp-x" });
    }
    if (this.options.top !== null || this.options.bottom !== null) {
      let e3 = false;
      if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y !== 0 && (this.parent.y = 0, e3 = true);
            break;
          case 1:
            this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight && (this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight, e3 = true);
            break;
          default:
            this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2 && (this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2, e3 = true);
        }
      else
        this.options.top !== null && this.parent.top < (this.options.top === true ? 0 : this.options.top) && (this.parent.y = -(this.options.top === true ? 0 : this.options.top) * this.parent.scale.y, i3.y = 0, e3 = true), this.options.bottom !== null && this.parent.bottom > (this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) && (this.parent.y = -(this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight, i3.y = 0, e3 = true);
      e3 && this.parent.emit("moved", { viewport: this.parent, original: t4, type: "clamp-y" });
    }
    this.last.x = this.parent.x, this.last.y = this.parent.y, this.last.scaleX = this.parent.scale.x, this.last.scaleY = this.parent.scale.y;
  }
  reset() {
    this.update();
  }
}
var _2 = {
  minWidth: null,
  minHeight: null,
  maxWidth: null,
  maxHeight: null,
  minScale: null,
  maxScale: null
};

class T2 extends f3 {
  constructor(t4, i3 = {}) {
    super(t4);
    o3(this, "options");
    this.options = Object.assign({}, _2, i3), this.clamp();
  }
  resize() {
    this.clamp();
  }
  clamp() {
    if (!this.paused) {
      if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
        let t4 = this.parent.worldScreenWidth, i3 = this.parent.worldScreenHeight;
        if (this.options.minWidth !== null && t4 < this.options.minWidth) {
          const e3 = this.parent.scale.x;
          this.parent.fitWidth(this.options.minWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / e3, t4 = this.parent.worldScreenWidth, i3 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxWidth !== null && t4 > this.options.maxWidth) {
          const e3 = this.parent.scale.x;
          this.parent.fitWidth(this.options.maxWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / e3, t4 = this.parent.worldScreenWidth, i3 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.minHeight !== null && i3 < this.options.minHeight) {
          const e3 = this.parent.scale.y;
          this.parent.fitHeight(this.options.minHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / e3, t4 = this.parent.worldScreenWidth, i3 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxHeight !== null && i3 > this.options.maxHeight) {
          const e3 = this.parent.scale.y;
          this.parent.fitHeight(this.options.maxHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / e3, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
      } else if (this.options.minScale || this.options.maxScale) {
        const t4 = { x: null, y: null }, i3 = { x: null, y: null };
        if (typeof this.options.minScale == "number")
          t4.x = this.options.minScale, t4.y = this.options.minScale;
        else if (this.options.minScale !== null) {
          const s3 = this.options.minScale;
          t4.x = typeof s3.x > "u" ? null : s3.x, t4.y = typeof s3.y > "u" ? null : s3.y;
        }
        if (typeof this.options.maxScale == "number")
          i3.x = this.options.maxScale, i3.y = this.options.maxScale;
        else if (this.options.maxScale !== null) {
          const s3 = this.options.maxScale;
          i3.x = typeof s3.x > "u" ? null : s3.x, i3.y = typeof s3.y > "u" ? null : s3.y;
        }
        let e3 = this.parent.scale.x, n4 = this.parent.scale.y;
        t4.x !== null && e3 < t4.x && (e3 = t4.x), i3.x !== null && e3 > i3.x && (e3 = i3.x), t4.y !== null && n4 < t4.y && (n4 = t4.y), i3.y !== null && n4 > i3.y && (n4 = i3.y), (e3 !== this.parent.scale.x || n4 !== this.parent.scale.y) && (this.parent.scale.set(e3, n4), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" }));
      }
    }
  }
  reset() {
    this.clamp();
  }
}
var D4 = {
  friction: 0.98,
  bounce: 0.8,
  minSpeed: 0.01
};
var g4 = 16;

class E3 extends f3 {
  constructor(t4, i3 = {}) {
    super(t4);
    o3(this, "options");
    o3(this, "x");
    o3(this, "y");
    o3(this, "percentChangeX");
    o3(this, "percentChangeY");
    o3(this, "saved");
    o3(this, "timeSinceRelease");
    this.options = Object.assign({}, D4, i3), this.saved = [], this.timeSinceRelease = 0, this.reset(), this.parent.on("moved", (e3) => this.handleMoved(e3));
  }
  down() {
    return this.saved = [], this.x = this.y = null, false;
  }
  isActive() {
    return !!(this.x || this.y);
  }
  move() {
    if (this.paused)
      return false;
    const t4 = this.parent.input.count();
    return (t4 === 1 || t4 > 1 && !this.parent.plugins.get("pinch", true)) && (this.saved.push({ x: this.parent.x, y: this.parent.y, time: performance.now() }), this.saved.length > 60 && this.saved.splice(0, 30)), false;
  }
  handleMoved(t4) {
    if (this.saved.length) {
      const i3 = this.saved[this.saved.length - 1];
      t4.type === "clamp-x" && t4.original ? i3.x === t4.original.x && (i3.x = this.parent.x) : t4.type === "clamp-y" && t4.original && i3.y === t4.original.y && (i3.y = this.parent.y);
    }
  }
  up() {
    if (this.parent.input.count() === 0 && this.saved.length) {
      const t4 = performance.now();
      for (const i3 of this.saved)
        if (i3.time >= t4 - 100) {
          const e3 = t4 - i3.time;
          this.x = (this.parent.x - i3.x) / e3, this.y = (this.parent.y - i3.y) / e3, this.percentChangeX = this.percentChangeY = this.options.friction, this.timeSinceRelease = 0;
          break;
        }
    }
    return false;
  }
  activate(t4) {
    t4 = t4 || {}, typeof t4.x < "u" && (this.x = t4.x, this.percentChangeX = this.options.friction), typeof t4.y < "u" && (this.y = t4.y, this.percentChangeY = this.options.friction);
  }
  update(t4) {
    if (this.paused)
      return;
    const i3 = this.x || this.y, e3 = this.timeSinceRelease, n4 = this.timeSinceRelease + t4;
    if (this.x) {
      const s3 = this.percentChangeX, h3 = Math.log(s3);
      this.parent.x += this.x * g4 / h3 * (Math.pow(s3, n4 / g4) - Math.pow(s3, e3 / g4)), this.x *= Math.pow(this.percentChangeX, t4 / g4);
    }
    if (this.y) {
      const s3 = this.percentChangeY, h3 = Math.log(s3);
      this.parent.y += this.y * g4 / h3 * (Math.pow(s3, n4 / g4) - Math.pow(s3, e3 / g4)), this.y *= Math.pow(this.percentChangeY, t4 / g4);
    }
    this.timeSinceRelease += t4, this.x && this.y ? Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed && (this.x = 0, this.y = 0) : (Math.abs(this.x || 0) < this.options.minSpeed && (this.x = 0), Math.abs(this.y || 0) < this.options.minSpeed && (this.y = 0)), i3 && this.parent.emit("moved", { viewport: this.parent, type: "decelerate" });
  }
  reset() {
    this.x = this.y = null;
  }
}
var L3 = {
  direction: "all",
  pressDrag: true,
  wheel: true,
  wheelScroll: 1,
  reverse: false,
  clampWheel: false,
  underflow: "center",
  factor: 1,
  mouseButtons: "all",
  keyToPress: null,
  ignoreKeyToPressOnTouch: false,
  lineHeight: 20,
  wheelSwapAxes: false
};

class U2 extends f3 {
  constructor(t4, i3 = {}) {
    super(t4);
    o3(this, "options");
    o3(this, "moved");
    o3(this, "reverse");
    o3(this, "xDirection");
    o3(this, "yDirection");
    o3(this, "keyIsPressed");
    o3(this, "mouse");
    o3(this, "underflowX");
    o3(this, "underflowY");
    o3(this, "last");
    o3(this, "current");
    o3(this, "windowEventHandlers", []);
    this.options = Object.assign({}, L3, i3), this.moved = false, this.reverse = this.options.reverse ? 1 : -1, this.xDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "x", this.yDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "y", this.keyIsPressed = false, this.parseUnderflow(), this.mouseButtons(this.options.mouseButtons), this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  handleKeyPresses(t4) {
    const i3 = (n4) => {
      t4.includes(n4.code) && (this.keyIsPressed = true);
    }, e3 = (n4) => {
      t4.includes(n4.code) && (this.keyIsPressed = false);
    };
    this.addWindowEventHandler("keyup", e3), this.addWindowEventHandler("keydown", i3);
  }
  addWindowEventHandler(t4, i3) {
    window.addEventListener(t4, i3), this.windowEventHandlers.push({ event: t4, handler: i3 });
  }
  destroy() {
    this.windowEventHandlers.forEach(({ event: t4, handler: i3 }) => {
      window.removeEventListener(t4, i3);
    });
  }
  mouseButtons(t4) {
    !t4 || t4 === "all" ? this.mouse = [true, true, true] : this.mouse = [
      t4.indexOf("left") !== -1,
      t4.indexOf("middle") !== -1,
      t4.indexOf("right") !== -1
    ];
  }
  parseUnderflow() {
    const t4 = this.options.underflow.toLowerCase();
    t4 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (t4.includes("left") ? this.underflowX = -1 : t4.includes("right") ? this.underflowX = 1 : this.underflowX = 0, t4.includes("top") ? this.underflowY = -1 : t4.includes("bottom") ? this.underflowY = 1 : this.underflowY = 0);
  }
  checkButtons(t4) {
    const i3 = t4.pointerType === "mouse", e3 = this.parent.input.count();
    return !!((e3 === 1 || e3 > 1 && !this.parent.plugins.get("pinch", true)) && (!i3 || this.mouse[t4.button]));
  }
  checkKeyPress(t4) {
    return !this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && t4.data.pointerType === "touch";
  }
  down(t4) {
    return this.paused || !this.options.pressDrag ? false : this.checkButtons(t4) && this.checkKeyPress(t4) ? (this.last = { x: t4.global.x, y: t4.global.y }, this.current = t4.pointerId, true) : (this.last = null, false);
  }
  get active() {
    return this.moved;
  }
  move(t4) {
    if (this.paused || !this.options.pressDrag)
      return false;
    if (this.last && this.current === t4.data.pointerId) {
      const i3 = t4.global.x, e3 = t4.global.y, n4 = this.parent.input.count();
      if (n4 === 1 || n4 > 1 && !this.parent.plugins.get("pinch", true)) {
        const s3 = i3 - this.last.x, h3 = e3 - this.last.y;
        if (this.moved || this.xDirection && this.parent.input.checkThreshold(s3) || this.yDirection && this.parent.input.checkThreshold(h3)) {
          const a3 = { x: i3, y: e3 };
          return this.xDirection && (this.parent.x += (a3.x - this.last.x) * this.options.factor), this.yDirection && (this.parent.y += (a3.y - this.last.y) * this.options.factor), this.last = a3, this.moved || this.parent.emit("drag-start", {
            event: t4,
            screen: new Point3(this.last.x, this.last.y),
            world: this.parent.toWorld(new Point3(this.last.x, this.last.y)),
            viewport: this.parent
          }), this.moved = true, this.parent.emit("moved", { viewport: this.parent, type: "drag" }), true;
        }
      } else
        this.moved = false;
    }
    return false;
  }
  up(t4) {
    if (this.paused)
      return false;
    const i3 = this.parent.input.touches;
    if (i3.length === 1) {
      const e3 = i3[0];
      return e3.last && (this.last = { x: e3.last.x, y: e3.last.y }, this.current = e3.id), this.moved = false, true;
    } else if (this.last && this.moved) {
      const e3 = new Point3(this.last.x, this.last.y);
      return this.parent.emit("drag-end", {
        event: t4,
        screen: e3,
        world: this.parent.toWorld(e3),
        viewport: this.parent
      }), this.last = null, this.moved = false, true;
    }
    return false;
  }
  wheel(t4) {
    if (this.paused)
      return false;
    if (this.options.wheel) {
      const i3 = this.parent.plugins.get("wheel", true);
      if (!i3 || !i3.options.wheelZoom && !t4.ctrlKey) {
        const e3 = t4.deltaMode ? this.options.lineHeight : 1, n4 = [t4.deltaX, t4.deltaY], [s3, h3] = this.options.wheelSwapAxes ? n4.reverse() : n4;
        return this.xDirection && (this.parent.x += s3 * e3 * this.options.wheelScroll * this.reverse), this.yDirection && (this.parent.y += h3 * e3 * this.options.wheelScroll * this.reverse), this.options.clampWheel && this.clamp(), this.parent.emit("wheel-scroll", this.parent), this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.options.passiveWheel || t4.preventDefault(), this.parent.options.stopPropagation && t4.stopPropagation(), true;
      }
    }
    return false;
  }
  resume() {
    this.last = null, this.paused = false;
  }
  clamp() {
    const t4 = this.parent.plugins.get("decelerate", true) || {};
    if (this.options.clampWheel !== "y")
      if (this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x = 0;
            break;
          case 1:
            this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
            break;
          default:
            this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
        }
      else
        this.parent.left < 0 ? (this.parent.x = 0, t4.x = 0) : this.parent.right > this.parent.worldWidth && (this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth, t4.x = 0);
    if (this.options.clampWheel !== "x")
      if (this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y = 0;
            break;
          case 1:
            this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
            break;
          default:
            this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
        }
      else
        this.parent.top < 0 && (this.parent.y = 0, t4.y = 0), this.parent.bottom > this.parent.worldHeight && (this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight, t4.y = 0);
  }
}
var V3 = {
  speed: 0,
  acceleration: null,
  radius: null
};

class F3 extends f3 {
  constructor(t4, i3, e3 = {}) {
    super(t4);
    o3(this, "options");
    o3(this, "target");
    o3(this, "velocity");
    this.target = i3, this.options = Object.assign({}, V3, e3), this.velocity = { x: 0, y: 0 };
  }
  update(t4) {
    if (this.paused)
      return;
    const i3 = this.parent.center;
    let e3 = this.target.x, n4 = this.target.y;
    if (this.options.radius)
      if (Math.sqrt(Math.pow(this.target.y - i3.y, 2) + Math.pow(this.target.x - i3.x, 2)) > this.options.radius) {
        const p3 = Math.atan2(this.target.y - i3.y, this.target.x - i3.x);
        e3 = this.target.x - Math.cos(p3) * this.options.radius, n4 = this.target.y - Math.sin(p3) * this.options.radius;
      } else
        return;
    const s3 = e3 - i3.x, h3 = n4 - i3.y;
    if (s3 || h3)
      if (this.options.speed)
        if (this.options.acceleration) {
          const a3 = Math.atan2(n4 - i3.y, e3 - i3.x), p3 = Math.sqrt(Math.pow(s3, 2) + Math.pow(h3, 2));
          if (p3) {
            const l4 = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
            p3 > l4 ? this.velocity = {
              x: Math.min(this.velocity.x + (this.options.acceleration * t4, this.options.speed)),
              y: Math.min(this.velocity.y + (this.options.acceleration * t4, this.options.speed))
            } : this.velocity = {
              x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
              y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
            };
            const d3 = Math.cos(a3) * this.velocity.x, m4 = Math.sin(a3) * this.velocity.y, y3 = Math.abs(d3) > Math.abs(s3) ? e3 : i3.x + d3, x3 = Math.abs(m4) > Math.abs(h3) ? n4 : i3.y + m4;
            this.parent.moveCenter(y3, x3), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
          }
        } else {
          const a3 = Math.atan2(n4 - i3.y, e3 - i3.x), p3 = Math.cos(a3) * this.options.speed, l4 = Math.sin(a3) * this.options.speed, d3 = Math.abs(p3) > Math.abs(s3) ? e3 : i3.x + p3, m4 = Math.abs(l4) > Math.abs(h3) ? n4 : i3.y + l4;
          this.parent.moveCenter(d3, m4), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
        }
      else
        this.parent.moveCenter(e3, n4), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
  }
}
var B4 = {
  radius: null,
  distance: null,
  top: null,
  bottom: null,
  left: null,
  right: null,
  speed: 8,
  reverse: false,
  noDecelerate: false,
  linear: false,
  allowButtons: false
};

class N4 extends f3 {
  constructor(t4, i3 = {}) {
    super(t4);
    o3(this, "options");
    o3(this, "reverse");
    o3(this, "radiusSquared");
    o3(this, "left");
    o3(this, "top");
    o3(this, "right");
    o3(this, "bottom");
    o3(this, "horizontal");
    o3(this, "vertical");
    this.options = Object.assign({}, B4, i3), this.reverse = this.options.reverse ? 1 : -1, this.radiusSquared = typeof this.options.radius == "number" ? Math.pow(this.options.radius, 2) : null, this.resize();
  }
  resize() {
    const t4 = this.options.distance;
    t4 !== null ? (this.left = t4, this.top = t4, this.right = this.parent.screenWidth - t4, this.bottom = this.parent.screenHeight - t4) : this.options.radius || (this.left = this.options.left, this.top = this.options.top, this.right = this.options.right === null ? null : this.parent.screenWidth - this.options.right, this.bottom = this.options.bottom === null ? null : this.parent.screenHeight - this.options.bottom);
  }
  down() {
    return this.paused || this.options.allowButtons || (this.horizontal = this.vertical = null), false;
  }
  move(t4) {
    if (this.paused || t4.pointerType !== "mouse" && t4.pointerId !== 1 || !this.options.allowButtons && t4.buttons !== 0)
      return false;
    const i3 = t4.global.x, e3 = t4.global.y;
    if (this.radiusSquared) {
      const n4 = this.parent.toScreen(this.parent.center);
      if (Math.pow(n4.x - i3, 2) + Math.pow(n4.y - e3, 2) >= this.radiusSquared) {
        const h3 = Math.atan2(n4.y - e3, n4.x - i3);
        this.options.linear ? (this.horizontal = Math.round(Math.cos(h3)) * this.options.speed * this.reverse * (60 / 1000), this.vertical = Math.round(Math.sin(h3)) * this.options.speed * this.reverse * (60 / 1000)) : (this.horizontal = Math.cos(h3) * this.options.speed * this.reverse * (60 / 1000), this.vertical = Math.sin(h3) * this.options.speed * this.reverse * (60 / 1000));
      } else
        this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = 0;
    } else
      this.left !== null && i3 < this.left ? this.horizontal = Number(this.reverse) * this.options.speed * (60 / 1000) : this.right !== null && i3 > this.right ? this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1000) : (this.decelerateHorizontal(), this.horizontal = 0), this.top !== null && e3 < this.top ? this.vertical = Number(this.reverse) * this.options.speed * (60 / 1000) : this.bottom !== null && e3 > this.bottom ? this.vertical = -1 * this.reverse * this.options.speed * (60 / 1000) : (this.decelerateVertical(), this.vertical = 0);
    return false;
  }
  decelerateHorizontal() {
    const t4 = this.parent.plugins.get("decelerate", true);
    this.horizontal && t4 && !this.options.noDecelerate && t4.activate({ x: this.horizontal * this.options.speed * this.reverse / (1000 / 60) });
  }
  decelerateVertical() {
    const t4 = this.parent.plugins.get("decelerate", true);
    this.vertical && t4 && !this.options.noDecelerate && t4.activate({ y: this.vertical * this.options.speed * this.reverse / (1000 / 60) });
  }
  up() {
    return this.paused || (this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = null), false;
  }
  update() {
    if (!this.paused && (this.horizontal || this.vertical)) {
      const t4 = this.parent.center;
      this.horizontal && (t4.x += this.horizontal * this.options.speed), this.vertical && (t4.y += this.vertical * this.options.speed), this.parent.moveCenter(t4), this.parent.emit("moved", { viewport: this.parent, type: "mouse-edges" });
    }
  }
}
var Z3 = {
  noDrag: false,
  percent: 1,
  center: null,
  factor: 1,
  axis: "all"
};

class R3 extends f3 {
  constructor(t4, i3 = {}) {
    super(t4);
    o3(this, "options");
    o3(this, "active", false);
    o3(this, "pinching", false);
    o3(this, "moved", false);
    o3(this, "lastCenter");
    this.options = Object.assign({}, Z3, i3);
  }
  down() {
    return this.parent.input.count() >= 2 ? (this.active = true, true) : false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  move(t4) {
    if (this.paused || !this.active)
      return false;
    const i3 = t4.global.x, e3 = t4.global.y, n4 = this.parent.input.touches;
    if (n4.length >= 2) {
      const s3 = n4[0], h3 = n4[1], a3 = s3.last && h3.last ? Math.sqrt(Math.pow(h3.last.x - s3.last.x, 2) + Math.pow(h3.last.y - s3.last.y, 2)) : null;
      if (s3.id === t4.pointerId ? s3.last = { x: i3, y: e3, data: t4 } : h3.id === t4.pointerId && (h3.last = { x: i3, y: e3, data: t4 }), a3) {
        let p3;
        const l4 = new Point3(s3.last.x + (h3.last.x - s3.last.x) / 2, s3.last.y + (h3.last.y - s3.last.y) / 2);
        this.options.center || (p3 = this.parent.toLocal(l4));
        let d3 = Math.sqrt(Math.pow(h3.last.x - s3.last.x, 2) + Math.pow(h3.last.y - s3.last.y, 2));
        d3 = d3 === 0 ? d3 = 0.0000000001 : d3;
        const m4 = (1 - a3 / d3) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
        this.isAxisX() && (this.parent.scale.x += m4), this.isAxisY() && (this.parent.scale.y += m4), this.parent.emit("zoomed", { viewport: this.parent, type: "pinch", center: l4 });
        const y3 = this.parent.plugins.get("clamp-zoom", true);
        if (y3 && y3.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const x3 = this.parent.toGlobal(p3);
          this.parent.x += (l4.x - x3.x) * this.options.factor, this.parent.y += (l4.y - x3.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" });
        }
        !this.options.noDrag && this.lastCenter && (this.parent.x += (l4.x - this.lastCenter.x) * this.options.factor, this.parent.y += (l4.y - this.lastCenter.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" })), this.lastCenter = l4, this.moved = true;
      } else
        this.pinching || (this.parent.emit("pinch-start", this.parent), this.pinching = true);
      return true;
    }
    return false;
  }
  up() {
    return this.pinching && this.parent.input.touches.length <= 1 ? (this.active = false, this.lastCenter = null, this.pinching = false, this.moved = false, this.parent.emit("pinch-end", this.parent), true) : false;
  }
}
var j3 = {
  topLeft: false,
  friction: 0.8,
  time: 1000,
  ease: "easeInOutSine",
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false
};

class q2 extends f3 {
  constructor(t4, i3, e3, n4 = {}) {
    super(t4);
    o3(this, "options");
    o3(this, "ease");
    o3(this, "x");
    o3(this, "y");
    o3(this, "percent");
    o3(this, "snapping");
    o3(this, "deltaX");
    o3(this, "deltaY");
    o3(this, "startX");
    o3(this, "startY");
    this.options = Object.assign({}, j3, n4), this.ease = W3(n4.ease, "easeInOutSine"), this.x = i3, this.y = e3, this.options.forceStart && this.snapStart();
  }
  snapStart() {
    this.percent = 0, this.snapping = { time: 0 };
    const t4 = this.options.topLeft ? this.parent.corner : this.parent.center;
    this.deltaX = this.x - t4.x, this.deltaY = this.y - t4.y, this.startX = t4.x, this.startY = t4.y, this.parent.emit("snap-start", this.parent);
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap") : this.options.interrupt && (this.snapping = null), false;
  }
  up() {
    if (this.parent.input.count() === 0) {
      const t4 = this.parent.plugins.get("decelerate", true);
      t4 && (t4.x || t4.y) && (t4.percentChangeX = t4.percentChangeY = this.options.friction);
    }
    return false;
  }
  update(t4) {
    if (!this.paused && !(this.options.interrupt && this.parent.input.count() !== 0))
      if (this.snapping) {
        const i3 = this.snapping;
        i3.time += t4;
        let e3, n4, s3;
        const h3 = this.startX, a3 = this.startY, p3 = this.deltaX, l4 = this.deltaY;
        if (i3.time > this.options.time)
          e3 = true, n4 = h3 + p3, s3 = a3 + l4;
        else {
          const d3 = this.ease(i3.time, 0, 1, this.options.time);
          n4 = h3 + p3 * d3, s3 = a3 + l4 * d3;
        }
        this.options.topLeft ? this.parent.moveCorner(n4, s3) : this.parent.moveCenter(n4, s3), this.parent.emit("moved", { viewport: this.parent, type: "snap" }), e3 && (this.options.removeOnComplete && this.parent.plugins.remove("snap"), this.parent.emit("snap-end", this.parent), this.snapping = null);
      } else {
        const i3 = this.options.topLeft ? this.parent.corner : this.parent.center;
        (i3.x !== this.x || i3.y !== this.y) && this.snapStart();
      }
  }
}
var K3 = {
  width: 0,
  height: 0,
  time: 1000,
  ease: "easeInOutSine",
  center: null,
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false,
  noMove: false
};

class G3 extends f3 {
  constructor(t4, i3 = {}) {
    super(t4);
    o3(this, "options");
    o3(this, "ease");
    o3(this, "xScale");
    o3(this, "yScale");
    o3(this, "xIndependent");
    o3(this, "yIndependent");
    o3(this, "snapping");
    this.options = Object.assign({}, K3, i3), this.ease = W3(this.options.ease), this.xIndependent = false, this.yIndependent = false, this.xScale = 0, this.yScale = 0, this.options.width > 0 && (this.xScale = t4.screenWidth / this.options.width, this.xIndependent = true), this.options.height > 0 && (this.yScale = t4.screenHeight / this.options.height, this.yIndependent = true), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale, this.options.time === 0 ? (t4.container.scale.x = this.xScale, t4.container.scale.y = this.yScale, this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom")) : i3.forceStart && this.createSnapping();
  }
  createSnapping() {
    const t4 = this.parent.worldScreenWidth, i3 = this.parent.worldScreenHeight, e3 = this.parent.screenWidth / this.xScale, n4 = this.parent.screenHeight / this.yScale;
    this.snapping = {
      time: 0,
      startX: t4,
      startY: i3,
      deltaX: e3 - t4,
      deltaY: n4 - i3
    }, this.parent.emit("snap-zoom-start", this.parent);
  }
  resize() {
    this.snapping = null, this.options.width > 0 && (this.xScale = this.parent.screenWidth / this.options.width), this.options.height > 0 && (this.yScale = this.parent.screenHeight / this.options.height), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale;
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap-zoom"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap-zoom") : this.options.interrupt && (this.snapping = null), false;
  }
  update(t4) {
    if (this.paused || this.options.interrupt && this.parent.input.count() !== 0)
      return;
    let i3;
    if (!this.options.center && !this.options.noMove && (i3 = this.parent.center), !this.snapping)
      (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) && this.createSnapping();
    else if (this.snapping) {
      const e3 = this.snapping;
      if (e3.time += t4, e3.time >= this.options.time)
        this.parent.scale.set(this.xScale, this.yScale), this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom"), this.parent.emit("snap-zoom-end", this.parent), this.snapping = null;
      else {
        const s3 = this.snapping, h3 = this.ease(s3.time, s3.startX, s3.deltaX, this.options.time), a3 = this.ease(s3.time, s3.startY, s3.deltaY, this.options.time);
        this.parent.scale.x = this.parent.screenWidth / h3, this.parent.scale.y = this.parent.screenHeight / a3;
      }
      const n4 = this.parent.plugins.get("clamp-zoom", true);
      n4 && n4.clamp(), this.options.noMove || (this.options.center ? this.parent.moveCenter(this.options.center) : this.parent.moveCenter(i3));
    }
  }
  resume() {
    this.snapping = null, super.resume();
  }
}
var Q3 = {
  percent: 0.1,
  smooth: false,
  interrupt: true,
  reverse: false,
  center: null,
  lineHeight: 20,
  axis: "all",
  keyToPress: null,
  trackpadPinch: false,
  wheelZoom: true
};

class J3 extends f3 {
  constructor(t4, i3 = {}) {
    super(t4);
    o3(this, "options");
    o3(this, "smoothing");
    o3(this, "smoothingCenter");
    o3(this, "smoothingCount");
    o3(this, "keyIsPressed");
    this.options = Object.assign({}, Q3, i3), this.keyIsPressed = false, this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  handleKeyPresses(t4) {
    window.addEventListener("keydown", (i3) => {
      t4.includes(i3.code) && (this.keyIsPressed = true);
    }), window.addEventListener("keyup", (i3) => {
      t4.includes(i3.code) && (this.keyIsPressed = false);
    });
  }
  checkKeyPress() {
    return !this.options.keyToPress || this.keyIsPressed;
  }
  down() {
    return this.options.interrupt && (this.smoothing = null), false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  update() {
    if (this.smoothing) {
      const t4 = this.smoothingCenter, i3 = this.smoothing;
      let e3;
      this.options.center || (e3 = this.parent.toLocal(t4)), this.isAxisX() && (this.parent.scale.x += i3.x), this.isAxisY() && (this.parent.scale.y += i3.y), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
      const n4 = this.parent.plugins.get("clamp-zoom", true);
      if (n4 && n4.clamp(), this.options.center)
        this.parent.moveCenter(this.options.center);
      else {
        const s3 = this.parent.toGlobal(e3);
        this.parent.x += t4.x - s3.x, this.parent.y += t4.y - s3.y;
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.smoothingCount++, this.smoothingCount >= this.options.smooth && (this.smoothing = null);
    }
  }
  pinch(t4) {
    if (this.paused)
      return;
    const i3 = this.parent.input.getPointerPosition(t4), e3 = -t4.deltaY * (t4.deltaMode ? this.options.lineHeight : 1) / 200, n4 = Math.pow(2, (1 + this.options.percent) * e3);
    let s3;
    this.options.center || (s3 = this.parent.toLocal(i3)), this.isAxisX() && (this.parent.scale.x *= n4), this.isAxisY() && (this.parent.scale.y *= n4), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
    const h3 = this.parent.plugins.get("clamp-zoom", true);
    if (h3 && h3.clamp(), this.options.center)
      this.parent.moveCenter(this.options.center);
    else {
      const a3 = this.parent.toGlobal(s3);
      this.parent.x += i3.x - a3.x, this.parent.y += i3.y - a3.y;
    }
    this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit("wheel-start", { event: t4, viewport: this.parent });
  }
  wheel(t4) {
    if (this.paused || !this.checkKeyPress())
      return false;
    if (t4.ctrlKey && this.options.trackpadPinch)
      this.pinch(t4);
    else if (this.options.wheelZoom) {
      const i3 = this.parent.input.getPointerPosition(t4), n4 = (this.options.reverse ? -1 : 1) * -t4.deltaY * (t4.deltaMode ? this.options.lineHeight : 1) / 500, s3 = Math.pow(2, (1 + this.options.percent) * n4);
      if (this.options.smooth) {
        const h3 = {
          x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
          y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
        };
        this.smoothing = {
          x: ((this.parent.scale.x + h3.x) * s3 - this.parent.scale.x) / this.options.smooth,
          y: ((this.parent.scale.y + h3.y) * s3 - this.parent.scale.y) / this.options.smooth
        }, this.smoothingCount = 0, this.smoothingCenter = i3;
      } else {
        let h3;
        this.options.center || (h3 = this.parent.toLocal(i3)), this.isAxisX() && (this.parent.scale.x *= s3), this.isAxisY() && (this.parent.scale.y *= s3), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
        const a3 = this.parent.plugins.get("clamp-zoom", true);
        if (a3 && a3.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const p3 = this.parent.toGlobal(h3);
          this.parent.x += i3.x - p3.x, this.parent.y += i3.y - p3.y;
        }
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit("wheel-start", { event: t4, viewport: this.parent });
    }
    return !this.parent.options.passiveWheel;
  }
}

class $3 {
  constructor(r4) {
    o3(this, "viewport");
    o3(this, "clickedAvailable");
    o3(this, "isMouseDown");
    o3(this, "last");
    o3(this, "wheelFunction");
    o3(this, "touches");
    this.viewport = r4, this.touches = [], this.addListeners();
  }
  addListeners() {
    this.viewport.eventMode = "static", this.viewport.forceHitArea || (this.viewport.hitArea = new Rectangle(0, 0, this.viewport.worldWidth, this.viewport.worldHeight)), this.viewport.on("pointerdown", this.down, this), this.viewport.options.allowPreserveDragOutside ? this.viewport.on("globalpointermove", this.move, this) : this.viewport.on("pointermove", this.move, this), this.viewport.on("pointerup", this.up, this), this.viewport.on("pointerupoutside", this.up, this), this.viewport.on("pointercancel", this.up, this), this.viewport.options.allowPreserveDragOutside || this.viewport.on("pointerleave", this.up, this), this.wheelFunction = (r4) => this.handleWheel(r4), this.viewport.options.events.domElement.addEventListener("wheel", this.wheelFunction, { passive: this.viewport.options.passiveWheel }), this.isMouseDown = false;
  }
  destroy() {
    this.viewport.options.events.domElement.removeEventListener("wheel", this.wheelFunction);
  }
  down(r4) {
    if (this.viewport.pause || !this.viewport.worldVisible)
      return;
    if (r4.pointerType === "mouse" ? this.isMouseDown = true : this.get(r4.pointerId) || this.touches.push({ id: r4.pointerId, last: null }), this.count() === 1) {
      this.last = r4.global.clone();
      const i3 = this.viewport.plugins.get("decelerate", true), e3 = this.viewport.plugins.get("bounce", true);
      (!i3 || !i3.isActive()) && (!e3 || !e3.isActive()) ? this.clickedAvailable = true : this.clickedAvailable = false;
    } else
      this.clickedAvailable = false;
    this.viewport.plugins.down(r4) && this.viewport.options.stopPropagation && r4.stopPropagation();
  }
  clear() {
    this.isMouseDown = false, this.touches = [], this.last = null;
  }
  checkThreshold(r4) {
    return Math.abs(r4) >= this.viewport.threshold;
  }
  move(r4) {
    if (this.viewport.pause || !this.viewport.worldVisible)
      return;
    const t4 = this.viewport.plugins.move(r4);
    if (this.clickedAvailable && this.last) {
      const i3 = r4.global.x - this.last.x, e3 = r4.global.y - this.last.y;
      (this.checkThreshold(i3) || this.checkThreshold(e3)) && (this.clickedAvailable = false);
    }
    t4 && this.viewport.options.stopPropagation && r4.stopPropagation();
  }
  up(r4) {
    if (this.viewport.pause || !this.viewport.worldVisible)
      return;
    r4.pointerType === "mouse" && (this.isMouseDown = false), r4.pointerType !== "mouse" && this.remove(r4.pointerId);
    const t4 = this.viewport.plugins.up(r4);
    this.clickedAvailable && this.count() === 0 && this.last && (this.viewport.emit("clicked", {
      event: r4,
      screen: this.last,
      world: this.viewport.toWorld(this.last),
      viewport: this.viewport
    }), this.clickedAvailable = false), t4 && this.viewport.options.stopPropagation && r4.stopPropagation();
  }
  getPointerPosition(r4) {
    const t4 = new Point3;
    return this.viewport.options.events.mapPositionToPoint(t4, r4.clientX, r4.clientY), t4;
  }
  handleWheel(r4) {
    if (this.viewport.pause || !this.viewport.worldVisible)
      return;
    const t4 = this.viewport.toLocal(this.getPointerPosition(r4));
    this.viewport.left <= t4.x && t4.x <= this.viewport.right && this.viewport.top <= t4.y && t4.y <= this.viewport.bottom && this.viewport.plugins.wheel(r4) && !this.viewport.options.passiveWheel && r4.preventDefault();
  }
  pause() {
    this.touches = [], this.isMouseDown = false;
  }
  get(r4) {
    for (const t4 of this.touches)
      if (t4.id === r4)
        return t4;
    return null;
  }
  remove(r4) {
    for (let t4 = 0;t4 < this.touches.length; t4++)
      if (this.touches[t4].id === r4) {
        this.touches.splice(t4, 1);
        return;
      }
  }
  count() {
    return (this.isMouseDown ? 1 : 0) + this.touches.length;
  }
}
var w3 = [
  "drag",
  "pinch",
  "wheel",
  "follow",
  "mouse-edges",
  "decelerate",
  "animate",
  "bounce",
  "snap-zoom",
  "clamp-zoom",
  "snap",
  "clamp"
];

class tt2 {
  constructor(r4) {
    o3(this, "plugins");
    o3(this, "list");
    o3(this, "viewport");
    this.viewport = r4, this.list = [], this.plugins = {};
  }
  add(r4, t4, i3 = w3.length) {
    const e3 = this.plugins[r4];
    e3 && e3.destroy(), this.plugins[r4] = t4;
    const n4 = w3.indexOf(r4);
    n4 !== -1 && w3.splice(n4, 1), w3.splice(i3, 0, r4), this.sort();
  }
  get(r4, t4) {
    var i3;
    return t4 && (i3 = this.plugins[r4]) != null && i3.paused ? null : this.plugins[r4];
  }
  update(r4) {
    for (const t4 of this.list)
      t4.update(r4);
  }
  resize() {
    for (const r4 of this.list)
      r4.resize();
  }
  reset() {
    for (const r4 of this.list)
      r4.reset();
  }
  removeAll() {
    this.list.forEach((r4) => {
      r4.destroy();
    }), this.plugins = {}, this.sort();
  }
  remove(r4) {
    var t4;
    this.plugins[r4] && ((t4 = this.plugins[r4]) == null || t4.destroy(), delete this.plugins[r4], this.viewport.emit("plugin-remove", r4), this.sort());
  }
  pause(r4) {
    var t4;
    (t4 = this.plugins[r4]) == null || t4.pause();
  }
  resume(r4) {
    var t4;
    (t4 = this.plugins[r4]) == null || t4.resume();
  }
  sort() {
    this.list = [];
    for (const r4 of w3)
      this.plugins[r4] && this.list.push(this.plugins[r4]);
  }
  down(r4) {
    let t4 = false;
    for (const i3 of this.list)
      i3.down(r4) && (t4 = true);
    return t4;
  }
  move(r4) {
    let t4 = false;
    for (const i3 of this.viewport.plugins.list)
      i3.move(r4) && (t4 = true);
    return t4;
  }
  up(r4) {
    let t4 = false;
    for (const i3 of this.list)
      i3.up(r4) && (t4 = true);
    return t4;
  }
  wheel(r4) {
    let t4 = false;
    for (const i3 of this.list)
      i3.wheel(r4) && (t4 = true);
    return t4;
  }
}
var et2 = {
  screenWidth: window.innerWidth,
  screenHeight: window.innerHeight,
  worldWidth: null,
  worldHeight: null,
  threshold: 5,
  passiveWheel: true,
  stopPropagation: false,
  forceHitArea: null,
  noTicker: false,
  disableOnContextMenu: false,
  ticker: Ticker.shared,
  allowPreserveDragOutside: false
};

class ht2 extends Container {
  constructor(t4) {
    super();
    o3(this, "moving");
    o3(this, "screenWidth");
    o3(this, "screenHeight");
    o3(this, "threshold");
    o3(this, "input");
    o3(this, "plugins");
    o3(this, "zooming");
    o3(this, "lastViewport");
    o3(this, "options");
    o3(this, "_dirty");
    o3(this, "_forceHitArea");
    o3(this, "_hitAreaDefault");
    o3(this, "_pause");
    o3(this, "tickerFunction");
    o3(this, "_worldWidth");
    o3(this, "_worldHeight");
    o3(this, "_disableOnContextMenu", (t5) => t5.preventDefault());
    this.options = {
      ...et2,
      ...t4
    }, this.screenWidth = this.options.screenWidth, this.screenHeight = this.options.screenHeight, this._worldWidth = this.options.worldWidth, this._worldHeight = this.options.worldHeight, this.forceHitArea = this.options.forceHitArea, this.threshold = this.options.threshold, this.options.disableOnContextMenu && this.options.events.domElement.addEventListener("contextmenu", this._disableOnContextMenu), this.options.noTicker || (this.tickerFunction = () => this.update(this.options.ticker.elapsedMS), this.options.ticker.add(this.tickerFunction)), this.input = new $3(this), this.plugins = new tt2(this);
  }
  destroy(t4) {
    !this.options.noTicker && this.tickerFunction && this.options.ticker.remove(this.tickerFunction), this.options.disableOnContextMenu && this.options.events.domElement.removeEventListener("contextmenu", this._disableOnContextMenu), this.input.destroy(), super.destroy(t4);
  }
  update(t4) {
    this.pause || (this.plugins.update(t4), this.lastViewport && (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y ? this.moving = true : this.moving && (this.emit("moved-end", this), this.moving = false), this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y ? this.zooming = true : this.zooming && (this.emit("zoomed-end", this), this.zooming = false)), this.forceHitArea || (this._hitAreaDefault = new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight), this.hitArea = this._hitAreaDefault), this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y, this.lastViewport = {
      x: this.x,
      y: this.y,
      scaleX: this.scale.x,
      scaleY: this.scale.y
    }, this.emit("frame-end", this));
  }
  resize(t4 = window.innerWidth, i3 = window.innerHeight, e3, n4) {
    this.screenWidth = t4, this.screenHeight = i3, typeof e3 < "u" && (this._worldWidth = e3), typeof n4 < "u" && (this._worldHeight = n4), this.plugins.resize(), this.dirty = true;
  }
  get worldWidth() {
    return this._worldWidth ? this._worldWidth : this.width / this.scale.x;
  }
  set worldWidth(t4) {
    this._worldWidth = t4, this.plugins.resize();
  }
  get worldHeight() {
    return this._worldHeight ? this._worldHeight : this.height / this.scale.y;
  }
  set worldHeight(t4) {
    this._worldHeight = t4, this.plugins.resize();
  }
  getVisibleBounds() {
    return new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
  }
  toWorld(t4, i3) {
    return arguments.length === 2 ? this.toLocal(new Point3(t4, i3)) : this.toLocal(t4);
  }
  toScreen(t4, i3) {
    return arguments.length === 2 ? this.toGlobal(new Point3(t4, i3)) : this.toGlobal(t4);
  }
  get worldScreenWidth() {
    return this.screenWidth / this.scale.x;
  }
  get worldScreenHeight() {
    return this.screenHeight / this.scale.y;
  }
  get screenWorldWidth() {
    return this.worldWidth * this.scale.x;
  }
  get screenWorldHeight() {
    return this.worldHeight * this.scale.y;
  }
  get center() {
    return new Point3(this.worldScreenWidth / 2 - this.x / this.scale.x, this.worldScreenHeight / 2 - this.y / this.scale.y);
  }
  set center(t4) {
    this.moveCenter(t4);
  }
  moveCenter(...t4) {
    let i3, e3;
    typeof t4[0] == "number" ? (i3 = t4[0], e3 = t4[1]) : (i3 = t4[0].x, e3 = t4[0].y);
    const n4 = (this.worldScreenWidth / 2 - i3) * this.scale.x, s3 = (this.worldScreenHeight / 2 - e3) * this.scale.y;
    return (this.x !== n4 || this.y !== s3) && (this.position.set(n4, s3), this.plugins.reset(), this.dirty = true), this;
  }
  get corner() {
    return new Point3(-this.x / this.scale.x, -this.y / this.scale.y);
  }
  set corner(t4) {
    this.moveCorner(t4);
  }
  moveCorner(...t4) {
    let i3, e3;
    return t4.length === 1 ? (i3 = -t4[0].x * this.scale.x, e3 = -t4[0].y * this.scale.y) : (i3 = -t4[0] * this.scale.x, e3 = -t4[1] * this.scale.y), (i3 !== this.x || e3 !== this.y) && (this.position.set(i3, e3), this.plugins.reset(), this.dirty = true), this;
  }
  get screenWidthInWorldPixels() {
    return this.screenWidth / this.scale.x;
  }
  get screenHeightInWorldPixels() {
    return this.screenHeight / this.scale.y;
  }
  findFitWidth(t4) {
    return this.screenWidth / t4;
  }
  findFitHeight(t4) {
    return this.screenHeight / t4;
  }
  findFit(t4, i3) {
    const e3 = this.screenWidth / t4, n4 = this.screenHeight / i3;
    return Math.min(e3, n4);
  }
  findCover(t4, i3) {
    const e3 = this.screenWidth / t4, n4 = this.screenHeight / i3;
    return Math.max(e3, n4);
  }
  fitWidth(t4 = this.worldWidth, i3, e3 = true, n4) {
    let s3;
    i3 && (s3 = this.center), this.scale.x = this.screenWidth / t4, e3 && (this.scale.y = this.scale.x);
    const h3 = this.plugins.get("clamp-zoom", true);
    return !n4 && h3 && h3.clamp(), i3 && s3 && this.moveCenter(s3), this;
  }
  fitHeight(t4 = this.worldHeight, i3, e3 = true, n4) {
    let s3;
    i3 && (s3 = this.center), this.scale.y = this.screenHeight / t4, e3 && (this.scale.x = this.scale.y);
    const h3 = this.plugins.get("clamp-zoom", true);
    return !n4 && h3 && h3.clamp(), i3 && s3 && this.moveCenter(s3), this;
  }
  fitWorld(t4) {
    let i3;
    t4 && (i3 = this.center), this.scale.x = this.screenWidth / this.worldWidth, this.scale.y = this.screenHeight / this.worldHeight, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const e3 = this.plugins.get("clamp-zoom", true);
    return e3 && e3.clamp(), t4 && i3 && this.moveCenter(i3), this;
  }
  fit(t4, i3 = this.worldWidth, e3 = this.worldHeight) {
    let n4;
    t4 && (n4 = this.center), this.scale.x = this.screenWidth / i3, this.scale.y = this.screenHeight / e3, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const s3 = this.plugins.get("clamp-zoom", true);
    return s3 && s3.clamp(), t4 && n4 && this.moveCenter(n4), this;
  }
  setZoom(t4, i3) {
    let e3;
    i3 && (e3 = this.center), this.scale.set(t4);
    const n4 = this.plugins.get("clamp-zoom", true);
    return n4 && n4.clamp(), i3 && e3 && this.moveCenter(e3), this;
  }
  zoomPercent(t4, i3) {
    return this.setZoom(this.scale.x + this.scale.x * t4, i3);
  }
  zoom(t4, i3) {
    return this.fitWidth(t4 + this.worldScreenWidth, i3), this;
  }
  get scaled() {
    return this.scale.x;
  }
  set scaled(t4) {
    this.setZoom(t4, true);
  }
  snapZoom(t4) {
    return this.plugins.add("snap-zoom", new G3(this, t4)), this;
  }
  OOB() {
    return {
      left: this.left < 0,
      right: this.right > this.worldWidth,
      top: this.top < 0,
      bottom: this.bottom > this.worldHeight,
      cornerPoint: new Point3(this.worldWidth * this.scale.x - this.screenWidth, this.worldHeight * this.scale.y - this.screenHeight)
    };
  }
  get right() {
    return -this.x / this.scale.x + this.worldScreenWidth;
  }
  set right(t4) {
    this.x = -t4 * this.scale.x + this.screenWidth, this.plugins.reset();
  }
  get left() {
    return -this.x / this.scale.x;
  }
  set left(t4) {
    this.x = -t4 * this.scale.x, this.plugins.reset();
  }
  get top() {
    return -this.y / this.scale.y;
  }
  set top(t4) {
    this.y = -t4 * this.scale.y, this.plugins.reset();
  }
  get bottom() {
    return -this.y / this.scale.y + this.worldScreenHeight;
  }
  set bottom(t4) {
    this.y = -t4 * this.scale.y + this.screenHeight, this.plugins.reset();
  }
  get dirty() {
    return !!this._dirty;
  }
  set dirty(t4) {
    this._dirty = t4;
  }
  get forceHitArea() {
    return this._forceHitArea;
  }
  set forceHitArea(t4) {
    t4 ? (this._forceHitArea = t4, this.hitArea = t4) : (this._forceHitArea = null, this.hitArea = new Rectangle(0, 0, this.worldWidth, this.worldHeight));
  }
  drag(t4) {
    return this.plugins.add("drag", new U2(this, t4)), this;
  }
  clamp(t4) {
    return this.plugins.add("clamp", new A2(this, t4)), this;
  }
  decelerate(t4) {
    return this.plugins.add("decelerate", new E3(this, t4)), this;
  }
  bounce(t4) {
    return this.plugins.add("bounce", new X2(this, t4)), this;
  }
  pinch(t4) {
    return this.plugins.add("pinch", new R3(this, t4)), this;
  }
  snap(t4, i3, e3) {
    return this.plugins.add("snap", new q2(this, t4, i3, e3)), this;
  }
  follow(t4, i3) {
    return this.plugins.add("follow", new F3(this, t4, i3)), this;
  }
  wheel(t4) {
    return this.plugins.add("wheel", new J3(this, t4)), this;
  }
  animate(t4) {
    return this.plugins.add("animate", new k4(this, t4)), this;
  }
  clampZoom(t4) {
    return this.plugins.add("clamp-zoom", new T2(this, t4)), this;
  }
  mouseEdges(t4) {
    return this.plugins.add("mouse-edges", new N4(this, t4)), this;
  }
  get pause() {
    return !!this._pause;
  }
  set pause(t4) {
    this._pause = t4, this.lastViewport = null, this.moving = false, this.zooming = false, t4 && this.input.pause();
  }
  ensureVisible(t4, i3, e3, n4, s3) {
    s3 && (e3 > this.worldScreenWidth || n4 > this.worldScreenHeight) && (this.fit(true, e3, n4), this.emit("zoomed", { viewport: this, type: "ensureVisible" }));
    let h3 = false;
    t4 < this.left ? (this.left = t4, h3 = true) : t4 + e3 > this.right && (this.right = t4 + e3, h3 = true), i3 < this.top ? (this.top = i3, h3 = true) : i3 + n4 > this.bottom && (this.bottom = i3 + n4, h3 = true), h3 && this.emit("moved", { viewport: this, type: "ensureVisible" });
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
var matrixEquals = function(th, matrix, eps = 0.001) {
  return this === matrix || Math.abs(th.a - matrix.a) < eps && Math.abs(th.b - matrix.b) < eps && Math.abs(th.c - matrix.c) < eps && Math.abs(th.d - matrix.d) < eps && Math.abs(th.tx - matrix.tx) < eps && Math.abs(th.ty - matrix.ty) < eps;
};

class BatchStyleArray {
  constructor() {
    this.textureIds = [];
    this.matrices = [];
    this.lines = [];
    this.count = 0;
  }
  clear() {
    for (let i3 = 0;i3 < this.count; i3++) {
      this.textureIds[i3] = null;
      this.matrices[i3] = null;
    }
    this.count = 0;
  }
  add(textureId, matrix, lineWidth, lineAlignment, lineScaleMode, settings33) {
    const { textureIds, matrices, lines, count } = this;
    textureId = textureId * 4 + lineScaleMode;
    for (let i3 = 0;i3 < count; i3++) {
      if (lines[i3 * 2] === lineWidth && lines[i3 * 2 + 1] === lineAlignment && textureIds[i3] === textureId && matrixEquals(matrices[i3], matrix)) {
        return i3;
      }
    }
    if (count >= settings33.maxStyles) {
      return -1;
    }
    textureIds[count] = textureId;
    matrices[count] = matrix;
    lines[count * 2] = lineWidth;
    lines[count * 2 + 1] = lineAlignment;
    this.count++;
    return count;
  }
}

class BatchDrawCall3 {
  constructor() {
    this.texArray = new BatchTextureArray;
    this.styleArray = new BatchStyleArray;
    this.shader = null;
    this.blend = BLEND_MODES.NORMAL;
    this.start = 0;
    this.size = 0;
    this.TICK = 0;
    this.settings = null;
    this.data = null;
  }
  clear() {
    this.texArray.clear();
    this.styleArray.clear();
    this.settings = null;
    this.data = null;
    this.shader = null;
  }
  begin(settings33, shader) {
    this.TICK = ++BaseTexture._globalBatch;
    this.settings = settings33;
    this.shader = shader;
    this.start = 0;
    this.size = 0;
    this.data = null;
    if (shader && shader.settings) {
      this.settings = shader.settings;
    }
  }
  check(shader) {
    if (this.size === 0) {
      this.shader = shader;
      return true;
    }
    return this.shader === shader;
  }
  add(texture3, matrix, lineWidth, lineAlignment, lineScaleMode) {
    const { texArray, TICK, styleArray, settings: settings33 } = this;
    const { baseTexture } = texture3;
    if (baseTexture._batchEnabled !== TICK && texArray.count === settings33.maxTextures) {
      return -1;
    }
    const loc = baseTexture._batchEnabled !== TICK ? texArray.count : baseTexture._batchLocation;
    const res = styleArray.add(loc, matrix || Matrix.IDENTITY, lineWidth, lineAlignment, lineScaleMode, settings33);
    if (res >= 0) {
      if (baseTexture._batchEnabled !== TICK) {
        baseTexture._batchEnabled = TICK;
        baseTexture._batchLocation = texArray.count;
        texArray.elements[texArray.count++] = baseTexture;
      }
    }
    return res;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
class BatchPart4 {
  constructor() {
    this.reset();
  }
  begin(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
    this.jointEnd = 0;
  }
  end(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  }
  reset() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
    this.styleId = -1;
    this.rgba = 0;
    this.jointEnd = 0;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
class FillStyle4 {
  constructor() {
    this.reset();
  }
  toJSON() {
    return this.copyTo({});
  }
  clone() {
    return this.copyTo(new FillStyle4);
  }
  copyTo(obj) {
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.shader = this.shader;
    obj.visible = this.visible;
    obj.smooth = this.smooth;
    obj.matrixTex = null;
    return obj;
  }
  packLineScale() {
    return 0;
  }
  reset() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.shader = null;
    this.visible = false;
    this.smooth = false;
    this.matrixTex = null;
  }
  destroy() {
    this.texture = null;
    this.matrix = null;
    this.matrixTex = null;
  }
  getTextureMatrix() {
    const tex = this.texture;
    if (!this.matrix) {
      return null;
    }
    if (tex.frame.width === tex.baseTexture.width && tex.frame.height === tex.baseTexture.height) {
      return this.matrix;
    }
    if (!this.matrixTex) {
      this.matrixTex = this.matrix.clone();
    } else {
      this.matrixTex.copyFrom(this.matrix);
    }
    this.matrixTex.translate(Number(tex.frame.x), Number(tex.frame.y));
    return this.matrixTex;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
var LINE_SCALE_MODE = ((LINE_SCALE_MODE2) => {
  LINE_SCALE_MODE2["NONE"] = "none";
  LINE_SCALE_MODE2["NORMAL"] = "normal";
  LINE_SCALE_MODE2["HORIZONTAL"] = "horizontal";
  LINE_SCALE_MODE2["VERTICAL"] = "vertical";
  return LINE_SCALE_MODE2;
})(LINE_SCALE_MODE || {});

class LineStyle3 extends FillStyle4 {
  clone() {
    return this.copyTo(new LineStyle3);
  }
  copyTo(obj) {
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.shader = this.shader;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    obj.scaleMode = this.scaleMode;
    return obj;
  }
  packLineScale() {
    switch (this.scaleMode) {
      case "normal":
        return 1;
      case "horizontal":
        return 2;
      case "vertical":
        return 3;
      default:
        return 0;
    }
  }
  reset() {
    super.reset();
    this.smooth = true;
    this.color = 0;
    this.width = 0;
    this.alignment = 0.5;
    this.cap = LINE_CAP.BUTT;
    this.join = LINE_JOIN.MITER;
    this.miterLimit = 10;
    this.scaleMode = "normal";
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
class BuildData {
  constructor() {
    this.verts = [];
    this.joints = [];
    this.vertexSize = 0;
    this.indexSize = 0;
    this.closePointEps = 0.0001;
  }
  clear() {
    this.verts.length = 0;
    this.joints.length = 0;
    this.vertexSize = 0;
    this.indexSize = 0;
  }
  destroy() {
    this.verts.length = 0;
    this.joints.length = 0;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.m
var JOINT_TYPE = ((JOINT_TYPE2) => {
  JOINT_TYPE2[JOINT_TYPE2["NONE"] = 0] = "NONE";
  JOINT_TYPE2[JOINT_TYPE2["FILL"] = 1] = "FILL";
  JOINT_TYPE2[JOINT_TYPE2["JOINT_BEVEL"] = 4] = "JOINT_BEVEL";
  JOINT_TYPE2[JOINT_TYPE2["JOINT_MITER"] = 8] = "JOINT_MITER";
  JOINT_TYPE2[JOINT_TYPE2["JOINT_ROUND"] = 12] = "JOINT_ROUND";
  JOINT_TYPE2[JOINT_TYPE2["JOINT_CAP_BUTT"] = 16] = "JOINT_CAP_BUTT";
  JOINT_TYPE2[JOINT_TYPE2["JOINT_CAP_SQUARE"] = 18] = "JOINT_CAP_SQUARE";
  JOINT_TYPE2[JOINT_TYPE2["JOINT_CAP_ROUND"] = 20] = "JOINT_CAP_ROUND";
  JOINT_TYPE2[JOINT_TYPE2["FILL_EXPAND"] = 24] = "FILL_EXPAND";
  JOINT_TYPE2[JOINT_TYPE2["CAP_BUTT"] = 32] = "CAP_BUTT";
  JOINT_TYPE2[JOINT_TYPE2["CAP_SQUARE"] = 64] = "CAP_SQUARE";
  JOINT_TYPE2[JOINT_TYPE2["CAP_ROUND"] = 96] = "CAP_ROUND";
  JOINT_TYPE2[JOINT_TYPE2["CAP_BUTT2"] = 128] = "CAP_BUTT2";
  return JOINT_TYPE2;
})(JOINT_TYPE || {});
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
var _SegmentPacker = class {
  constructor() {
    this.strideFloats = 12;
    this.bufferPos = 0;
    this.indexPos = 0;
  }
  updateBufferSize(jointStart, jointLen, triangles, target) {
    const { joints } = target;
    let foundTriangle = false;
    let vertexSize = 0;
    let indexSize = 0;
    for (let i3 = jointStart;i3 < jointStart + jointLen; i3++) {
      const prevCap = joints[i3] & ~31;
      const joint = joints[i3] & 31;
      if (joint === JOINT_TYPE.FILL) {
        foundTriangle = true;
        vertexSize++;
        continue;
      }
      if (joint >= JOINT_TYPE.FILL_EXPAND) {
        vertexSize += 3;
        indexSize += 3;
        continue;
      }
      const vs = _SegmentPacker.vertsByJoint[joint] + _SegmentPacker.vertsByJoint[prevCap];
      if (vs >= 4) {
        vertexSize += vs;
        indexSize += 6 + 3 * Math.max(vs - 6, 0);
      }
    }
    if (foundTriangle) {
      indexSize += triangles;
    }
    target.vertexSize += vertexSize;
    target.indexSize += indexSize;
  }
  beginPack(buildData, bufFloat, bufUint, indices2, bufferPos = 0, indexPos = 0) {
    this.buildData = buildData;
    this.bufFloat = bufFloat;
    this.bufUint = bufUint;
    this.indices = indices2;
    this.bufferPos = bufferPos;
    this.indexPos = indexPos;
  }
  endPack() {
    this.buildData = null;
    this.bufFloat = null;
    this.bufUint = null;
    this.indices = null;
  }
  packInterleavedGeometry(jointStart, jointLen, triangles, lineStyle, color8) {
    const { bufFloat, bufUint, indices: indices2, buildData, strideFloats } = this;
    const { joints, verts: verts2 } = buildData;
    let bufPos = this.bufferPos;
    let indPos = this.indexPos;
    let index2 = this.bufferPos / this.strideFloats;
    let x1;
    let y1;
    let x22;
    let y22;
    let prevX;
    let prevY;
    let nextX;
    let nextY;
    let hasTriangle = false;
    let travel = 0;
    for (let j4 = jointStart;j4 < jointStart + jointLen; j4++) {
      const fullJoint = joints[j4];
      const prevCap = joints[j4] & ~31;
      const joint = joints[j4] & 31;
      if (joint === JOINT_TYPE.FILL) {
        hasTriangle = true;
        x1 = verts2[j4 * 2];
        y1 = verts2[j4 * 2 + 1];
        bufFloat[bufPos] = x1;
        bufFloat[bufPos + 1] = y1;
        bufFloat[bufPos + 2] = x1;
        bufFloat[bufPos + 3] = y1;
        bufFloat[bufPos + 4] = x1;
        bufFloat[bufPos + 5] = y1;
        bufFloat[bufPos + 6] = x1;
        bufFloat[bufPos + 7] = y1;
        bufFloat[bufPos + 8] = travel;
        bufFloat[bufPos + 9] = 16 * joint;
        bufFloat[bufPos + 10] = lineStyle;
        bufUint[bufPos + 11] = color8;
        bufPos += strideFloats;
        continue;
      }
      if (joint >= JOINT_TYPE.FILL_EXPAND) {
        prevX = verts2[j4 * 2];
        prevY = verts2[j4 * 2 + 1];
        x1 = verts2[j4 * 2 + 2];
        y1 = verts2[j4 * 2 + 3];
        x22 = verts2[j4 * 2 + 4];
        y22 = verts2[j4 * 2 + 5];
        const bis = j4 + 3;
        for (let i3 = 0;i3 < 3; i3++) {
          bufFloat[bufPos] = prevX;
          bufFloat[bufPos + 1] = prevY;
          bufFloat[bufPos + 2] = x1;
          bufFloat[bufPos + 3] = y1;
          bufFloat[bufPos + 4] = x22;
          bufFloat[bufPos + 5] = y22;
          bufFloat[bufPos + 6] = verts2[(bis + i3) * 2];
          bufFloat[bufPos + 7] = verts2[(bis + i3) * 2 + 1];
          bufFloat[bufPos + 8] = travel;
          bufFloat[bufPos + 9] = 16 * fullJoint + i3;
          bufFloat[bufPos + 10] = lineStyle;
          bufUint[bufPos + 11] = color8;
          bufPos += strideFloats;
        }
        indices2[indPos] = index2;
        indices2[indPos + 1] = index2 + 1;
        indices2[indPos + 2] = index2 + 2;
        indPos += 3;
        index2 += 3;
        continue;
      }
      const vs = _SegmentPacker.vertsByJoint[joint] + _SegmentPacker.vertsByJoint[prevCap];
      if (vs === 0) {
        continue;
      }
      x1 = verts2[j4 * 2];
      y1 = verts2[j4 * 2 + 1];
      x22 = verts2[j4 * 2 + 2];
      y22 = verts2[j4 * 2 + 3];
      prevX = verts2[j4 * 2 - 2];
      prevY = verts2[j4 * 2 - 1];
      const dist = Math.sqrt((x22 - x1) * (x22 - x1) + (y22 - y1) * (y22 - y1));
      if (_SegmentPacker.vertsByJoint[joint] === 0) {
        travel -= dist;
      }
      if ((joint & ~2) !== JOINT_TYPE.JOINT_CAP_BUTT) {
        nextX = verts2[j4 * 2 + 4];
        nextY = verts2[j4 * 2 + 5];
      } else {
        nextX = x1;
        nextY = y1;
      }
      for (let i3 = 0;i3 < vs; i3++) {
        bufFloat[bufPos] = prevX;
        bufFloat[bufPos + 1] = prevY;
        bufFloat[bufPos + 2] = x1;
        bufFloat[bufPos + 3] = y1;
        bufFloat[bufPos + 4] = x22;
        bufFloat[bufPos + 5] = y22;
        bufFloat[bufPos + 6] = nextX;
        bufFloat[bufPos + 7] = nextY;
        bufFloat[bufPos + 8] = travel;
        bufFloat[bufPos + 9] = 16 * fullJoint + i3;
        bufFloat[bufPos + 10] = lineStyle;
        bufUint[bufPos + 11] = color8;
        bufPos += strideFloats;
      }
      travel += dist;
      indices2[indPos] = index2;
      indices2[indPos + 1] = index2 + 1;
      indices2[indPos + 2] = index2 + 2;
      indices2[indPos + 3] = index2;
      indices2[indPos + 4] = index2 + 2;
      indices2[indPos + 5] = index2 + 3;
      indPos += 6;
      for (let j22 = 5;j22 + 1 < vs; j22++) {
        indices2[indPos] = index2 + 4;
        indices2[indPos + 1] = index2 + j22;
        indices2[indPos + 2] = index2 + j22 + 1;
        indPos += 3;
      }
      index2 += vs;
    }
    if (hasTriangle) {
      for (let i3 = 0;i3 < triangles.length; i3++) {
        indices2[indPos + i3] = triangles[i3] + index2;
      }
      indPos += triangles.length;
    }
    this.bufferPos = bufPos;
    this.indexPos = indPos;
  }
};
var SegmentPacker = _SegmentPacker;
SegmentPacker.vertsByJoint = [];
var verts = SegmentPacker.vertsByJoint;
for (let i3 = 0;i3 < 256; i3++) {
  verts.push(0);
}
verts[JOINT_TYPE.FILL] = 1;
for (let i3 = 0;i3 < 8; i3++) {
  verts[JOINT_TYPE.FILL_EXPAND + i3] = 3;
}
verts[JOINT_TYPE.JOINT_BEVEL] = 4 + 5;
verts[JOINT_TYPE.JOINT_BEVEL + 1] = 4 + 5;
verts[JOINT_TYPE.JOINT_BEVEL + 2] = 4 + 5;
verts[JOINT_TYPE.JOINT_BEVEL + 3] = 4 + 5;
verts[JOINT_TYPE.JOINT_ROUND] = 4 + 5;
verts[JOINT_TYPE.JOINT_ROUND + 1] = 4 + 5;
verts[JOINT_TYPE.JOINT_ROUND + 2] = 4 + 5;
verts[JOINT_TYPE.JOINT_ROUND + 3] = 4 + 5;
verts[JOINT_TYPE.JOINT_MITER] = 4 + 5;
verts[JOINT_TYPE.JOINT_MITER + 1] = 4 + 5;
verts[JOINT_TYPE.JOINT_MITER + 2] = 4;
verts[JOINT_TYPE.JOINT_MITER + 3] = 4;
verts[JOINT_TYPE.JOINT_CAP_BUTT] = 4;
verts[JOINT_TYPE.JOINT_CAP_BUTT + 1] = 4;
verts[JOINT_TYPE.JOINT_CAP_SQUARE] = 4;
verts[JOINT_TYPE.JOINT_CAP_SQUARE + 1] = 4;
verts[JOINT_TYPE.JOINT_CAP_ROUND] = 4 + 5;
verts[JOINT_TYPE.JOINT_CAP_ROUND + 1] = 4 + 5;
verts[JOINT_TYPE.CAP_ROUND] = 4;
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextu
class SmoothGraphicsData {
  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
    this.points = [];
    this.holes = [];
    this.triangles = [];
    this.closeStroke = false;
    this.clearBuild();
  }
  clearPath() {
    this.points.length = 0;
    this.closeStroke = true;
  }
  clearBuild() {
    this.triangles.length = 0;
    this.fillStart = 0;
    this.fillLen = 0;
    this.strokeStart = 0;
    this.strokeLen = 0;
    this.fillAA = false;
  }
  clone() {
    return new SmoothGraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  }
  capType() {
    let cap;
    switch (this.lineStyle.cap) {
      case LINE_CAP.SQUARE:
        cap = JOINT_TYPE.CAP_SQUARE;
        break;
      case LINE_CAP.ROUND:
        cap = JOINT_TYPE.CAP_ROUND;
        break;
      default:
        cap = JOINT_TYPE.CAP_BUTT;
        break;
    }
    return cap;
  }
  goodJointType() {
    let joint;
    switch (this.lineStyle.join) {
      case LINE_JOIN.BEVEL:
        joint = JOINT_TYPE.JOINT_BEVEL;
        break;
      case LINE_JOIN.ROUND:
        joint = JOINT_TYPE.JOINT_ROUND;
        break;
      default:
        joint = JOINT_TYPE.JOINT_MITER + 3;
        break;
    }
    return joint;
  }
  jointType() {
    let joint;
    switch (this.lineStyle.join) {
      case LINE_JOIN.BEVEL:
        joint = JOINT_TYPE.JOINT_BEVEL;
        break;
      case LINE_JOIN.ROUND:
        joint = JOINT_TYPE.JOINT_ROUND;
        break;
      default:
        joint = JOINT_TYPE.JOINT_MITER;
        break;
    }
    return joint;
  }
  destroy() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
    this.triangles = null;
  }
}
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTe
class CircleBuilder {
  path(graphicsData, _target) {
    const points2 = graphicsData.points;
    let x3;
    let y3;
    let dx;
    let dy;
    let rx;
    let ry;
    if (graphicsData.type === SHAPES.CIRC) {
      const circle = graphicsData.shape;
      x3 = circle.x;
      y3 = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (graphicsData.type === SHAPES.ELIP) {
      const ellipse = graphicsData.shape;
      x3 = ellipse.x;
      y3 = ellipse.y;
      rx = ellipse.width;
      ry = ellipse.height;
      dx = dy = 0;
    } else {
      const roundedRect = graphicsData.shape;
      const halfWidth = roundedRect.width / 2;
      const halfHeight = roundedRect.height / 2;
      x3 = roundedRect.x + halfWidth;
      y3 = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points2.length = 0;
      return;
    }
    const n4 = Math.ceil(2.3 * Math.sqrt(rx + ry));
    const m4 = n4 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    points2.length = m4;
    if (m4 === 0) {
      return;
    }
    if (n4 === 0) {
      points2.length = 8;
      points2[0] = points2[6] = x3 + dx;
      points2[1] = points2[3] = y3 + dy;
      points2[2] = points2[4] = x3 - dx;
      points2[5] = points2[7] = y3 - dy;
      return;
    }
    let j1 = 0;
    let j22 = n4 * 4 + (dx ? 2 : 0) + 2;
    let j32 = j22;
    let j4 = m4;
    {
      const x0 = dx + rx;
      const y0 = dy;
      const x1 = x3 + x0;
      const x22 = x3 - x0;
      const y1 = y3 + y0;
      points2[j1++] = x1;
      points2[j1++] = y1;
      points2[--j22] = y1;
      points2[--j22] = x22;
      if (dy) {
        const y22 = y3 - y0;
        points2[j32++] = x22;
        points2[j32++] = y22;
        points2[--j4] = y22;
        points2[--j4] = x1;
      }
    }
    for (let i3 = 1;i3 < n4; i3++) {
      const a3 = Math.PI / 2 * (i3 / n4);
      const x0 = dx + Math.cos(a3) * rx;
      const y0 = dy + Math.sin(a3) * ry;
      const x1 = x3 + x0;
      const x22 = x3 - x0;
      const y1 = y3 + y0;
      const y22 = y3 - y0;
      points2[j1++] = x1;
      points2[j1++] = y1;
      points2[--j22] = y1;
      points2[--j22] = x22;
      points2[j32++] = x22;
      points2[j32++] = y22;
      points2[--j4] = y22;
      points2[--j4] = x1;
    }
    {
      const x0 = dx;
      const y0 = dy + ry;
      const x1 = x3 + x0;
      const x22 = x3 - x0;
      const y1 = y3 + y0;
      const y22 = y3 - y0;
      points2[j1++] = x1;
      points2[j1++] = y1;
      points2[--j4] = y22;
      points2[--j4] = x1;
      if (dx) {
        points2[j1++] = x22;
        points2[j1++] = y1;
        points2[--j4] = y22;
        points2[--j4] = x22;
      }
    }
  }
  fill(graphicsData, target) {
    const { verts: verts2, joints } = target;
    const { points: points2, triangles } = graphicsData;
    if (points2.length === 0) {
      return;
    }
    let x3;
    let y3;
    if (graphicsData.type !== SHAPES.RREC) {
      const circle = graphicsData.shape;
      x3 = circle.x;
      y3 = circle.y;
    } else {
      const roundedRect = graphicsData.shape;
      x3 = roundedRect.x + roundedRect.width / 2;
      y3 = roundedRect.y + roundedRect.height / 2;
    }
    const matrix = graphicsData.matrix;
    const cx = matrix ? matrix.a * x3 + matrix.c * y3 + matrix.tx : x3;
    const cy = matrix ? matrix.b * x3 + matrix.d * y3 + matrix.ty : y3;
    let vertPos = 1;
    const center = 0;
    if (!graphicsData.fillAA) {
      verts2.push(cx, cy);
      joints.push(JOINT_TYPE.FILL);
      verts2.push(points2[0], points2[1]);
      joints.push(JOINT_TYPE.FILL);
      for (let i3 = 2;i3 < points2.length; i3 += 2) {
        verts2.push(points2[i3], points2[i3 + 1]);
        joints.push(JOINT_TYPE.FILL);
        triangles.push(vertPos++, center, vertPos);
      }
      triangles.push(center + 1, center, vertPos);
      return;
    }
    const len = points2.length;
    let x1 = points2[len - 2];
    let y1 = points2[len - 1];
    let nx1 = y1 - points2[len - 3];
    let ny1 = points2[len - 4] - x1;
    const n1 = Math.sqrt(nx1 * nx1 + ny1 * ny1);
    nx1 /= n1;
    ny1 /= n1;
    let bx1;
    let by1;
    for (let i3 = 0;i3 < len; i3 += 2) {
      const x22 = points2[i3];
      const y22 = points2[i3 + 1];
      let nx2 = y22 - y1;
      let ny2 = x1 - x22;
      const n22 = Math.sqrt(nx2 * nx2 + ny2 * ny2);
      nx2 /= n22;
      ny2 /= n22;
      let bx2 = nx1 + nx2;
      let by2 = ny1 + ny2;
      const b22 = nx2 * bx2 + ny2 * by2;
      bx2 /= b22;
      by2 /= b22;
      if (i3 > 0) {
        verts2.push(bx2);
        verts2.push(by2);
      } else {
        bx1 = bx2;
        by1 = by2;
      }
      verts2.push(cx);
      verts2.push(cy);
      verts2.push(x1);
      verts2.push(y1);
      verts2.push(x22);
      verts2.push(y22);
      verts2.push(0);
      verts2.push(0);
      verts2.push(bx2);
      verts2.push(by2);
      joints.push(JOINT_TYPE.FILL_EXPAND + 2);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      x1 = x22;
      y1 = y22;
      nx1 = nx2;
      ny1 = ny2;
    }
    verts2.push(bx1);
    verts2.push(by1);
  }
  line(graphicsData, target) {
    const { verts: verts2, joints } = target;
    const { points: points2 } = graphicsData;
    const joint = points2.length === 8 ? graphicsData.goodJointType() : JOINT_TYPE.JOINT_MITER + 3;
    const len = points2.length;
    if (len === 0) {
      return;
    }
    verts2.push(points2[len - 2], points2[len - 1]);
    joints.push(JOINT_TYPE.NONE);
    for (let i3 = 0;i3 < len; i3 += 2) {
      verts2.push(points2[i3], points2[i3 + 1]);
      joints.push(joint);
    }
    verts2.push(points2[0], points2[1]);
    joints.push(JOINT_TYPE.NONE);
    verts2.push(points2[2], points2[3]);
    joints.push(JOINT_TYPE.NONE);
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjs
var fixOrientation2 = function(points2, hole = false) {
  const m4 = points2.length;
  if (m4 < 6) {
    return;
  }
  let area = 0;
  for (let i3 = 0, x1 = points2[m4 - 2], y1 = points2[m4 - 1];i3 < m4; i3 += 2) {
    const x22 = points2[i3];
    const y22 = points2[i3 + 1];
    area += (x22 - x1) * (y22 + y1);
    x1 = x22;
    y1 = y22;
  }
  if (!hole && area > 0 || hole && area <= 0) {
    const n4 = m4 / 2;
    for (let i3 = n4 + n4 % 2;i3 < m4; i3 += 2) {
      const i1 = m4 - i3 - 2;
      const i22 = m4 - i3 - 1;
      const i32 = i3;
      const i4 = i3 + 1;
      [points2[i1], points2[i32]] = [points2[i32], points2[i1]];
      [points2[i22], points2[i4]] = [points2[i4], points2[i22]];
    }
  }
};
var tempArr = [];

class PolyBuilder {
  path(graphicsData, buildData) {
    const shape = graphicsData.shape;
    const points2 = graphicsData.points = shape.points.slice();
    const eps = buildData.closePointEps;
    const eps2 = eps * eps;
    if (points2.length === 0) {
      return;
    }
    const firstPoint = new Point3(points2[0], points2[1]);
    const lastPoint = new Point3(points2[points2.length - 2], points2[points2.length - 1]);
    const closedShape = graphicsData.closeStroke = shape.closeStroke;
    let len = points2.length;
    let newLen = 2;
    for (let i3 = 2;i3 < len; i3 += 2) {
      const x1 = points2[i3 - 2];
      const y1 = points2[i3 - 1];
      const x22 = points2[i3];
      const y22 = points2[i3 + 1];
      let flag = true;
      if (Math.abs(x1 - x22) < eps && Math.abs(y1 - y22) < eps) {
        flag = false;
      }
      if (flag) {
        points2[newLen] = points2[i3];
        points2[newLen + 1] = points2[i3 + 1];
        newLen += 2;
      }
    }
    points2.length = len = newLen;
    newLen = 2;
    for (let i3 = 2;i3 + 2 < len; i3 += 2) {
      let x1 = points2[i3 - 2];
      let y1 = points2[i3 - 1];
      const x22 = points2[i3];
      const y22 = points2[i3 + 1];
      let x3 = points2[i3 + 2];
      let y3 = points2[i3 + 3];
      x1 -= x22;
      y1 -= y22;
      x3 -= x22;
      y3 -= y22;
      let flag = true;
      if (Math.abs(x3 * y1 - y3 * x1) < eps2) {
        if (x1 * x3 + y1 * y3 < -eps2) {
          flag = false;
        }
      }
      if (flag) {
        points2[newLen] = points2[i3];
        points2[newLen + 1] = points2[i3 + 1];
        newLen += 2;
      }
    }
    points2[newLen] = points2[len - 2];
    points2[newLen + 1] = points2[len - 1];
    newLen += 2;
    points2.length = len = newLen;
    if (len <= 2) {
      return;
    }
    if (closedShape) {
      const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
      if (closedPath) {
        points2.pop();
        points2.pop();
      }
    }
  }
  line(graphicsData, buildData) {
    const { closeStroke, points: points2 } = graphicsData;
    const len = points2.length;
    if (len <= 2) {
      return;
    }
    const { verts: verts2, joints } = buildData;
    const joint = graphicsData.jointType();
    const cap = graphicsData.capType();
    let prevCap = 0;
    let prevX;
    let prevY;
    if (closeStroke) {
      prevX = points2[len - 2];
      prevY = points2[len - 1];
      joints.push(JOINT_TYPE.NONE);
    } else {
      prevX = points2[2];
      prevY = points2[3];
      if (cap === JOINT_TYPE.CAP_ROUND) {
        verts2.push(points2[0], points2[1]);
        joints.push(JOINT_TYPE.NONE);
        joints.push(JOINT_TYPE.CAP_ROUND);
        prevCap = 0;
      } else {
        prevCap = cap;
        joints.push(JOINT_TYPE.NONE);
      }
    }
    verts2.push(prevX, prevY);
    for (let i3 = 0;i3 < len; i3 += 2) {
      const x1 = points2[i3];
      const y1 = points2[i3 + 1];
      let endJoint = joint;
      if (i3 + 2 >= len) {
        if (!closeStroke) {
          endJoint = JOINT_TYPE.NONE;
        }
      } else if (i3 + 4 >= len) {
        if (!closeStroke) {
          if (cap === JOINT_TYPE.CAP_ROUND) {
            endJoint = JOINT_TYPE.JOINT_CAP_ROUND;
          }
          if (cap === JOINT_TYPE.CAP_BUTT) {
            endJoint = JOINT_TYPE.JOINT_CAP_BUTT;
          }
          if (cap === JOINT_TYPE.CAP_SQUARE) {
            endJoint = JOINT_TYPE.JOINT_CAP_SQUARE;
          }
        }
      }
      endJoint += prevCap;
      prevCap = 0;
      verts2.push(x1, y1);
      joints.push(endJoint);
      prevX = x1;
      prevY = y1;
    }
    if (closeStroke) {
      verts2.push(points2[0], points2[1]);
      joints.push(JOINT_TYPE.NONE);
      verts2.push(points2[2], points2[3]);
      joints.push(JOINT_TYPE.NONE);
    } else {
      verts2.push(points2[len - 4], points2[len - 3]);
      joints.push(JOINT_TYPE.NONE);
    }
  }
  fill(graphicsData, buildData) {
    let points2 = graphicsData.points;
    const holes = graphicsData.holes;
    const eps = buildData.closePointEps;
    const { verts: verts2, joints } = buildData;
    if (points2.length < 6) {
      return;
    }
    const holeArray = [];
    let len = points2.length;
    fixOrientation2(points2, false);
    for (let i3 = 0;i3 < holes.length; i3++) {
      const hole = holes[i3];
      fixOrientation2(hole.points, true);
      holeArray.push(points2.length / 2);
      points2 = points2.concat(hole.points);
    }
    const pn = tempArr;
    if (pn.length < points2.length) {
      pn.length = points2.length;
    }
    let start = 0;
    for (let i3 = 0;i3 <= holeArray.length; i3++) {
      let finish = len / 2;
      if (i3 > 0) {
        if (i3 < holeArray.length) {
          finish = holeArray[i3];
        } else {
          finish = points2.length >> 1;
        }
      }
      pn[start * 2] = finish - 1;
      pn[(finish - 1) * 2 + 1] = start;
      for (let j4 = start;j4 + 1 < finish; j4++) {
        pn[j4 * 2 + 1] = j4 + 1;
        pn[j4 * 2 + 2] = j4;
      }
      start = finish;
    }
    graphicsData.triangles = exports_lib.earcut(points2, holeArray, 2);
    if (!graphicsData.triangles) {
      return;
    }
    if (!graphicsData.fillAA) {
      for (let i3 = 0;i3 < points2.length; i3 += 2) {
        verts2.push(points2[i3], points2[i3 + 1]);
        joints.push(JOINT_TYPE.FILL);
      }
      return;
    }
    const { triangles } = graphicsData;
    len = points2.length;
    for (let i3 = 0;i3 < triangles.length; i3 += 3) {
      let flag = 0;
      for (let j4 = 0;j4 < 3; j4++) {
        const ind1 = triangles[i3 + j4];
        const ind2 = triangles[i3 + (j4 + 1) % 3];
        if (pn[ind1 * 2] === ind2 || pn[ind1 * 2 + 1] === ind2) {
          flag |= 1 << j4;
        }
      }
      joints.push(JOINT_TYPE.FILL_EXPAND + flag);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
    }
    for (let ind = 0;ind < len / 2; ind++) {
      const prev = pn[ind * 2];
      const next = pn[ind * 2 + 1];
      let nx1 = points2[next * 2 + 1] - points2[ind * 2 + 1];
      let ny1 = -(points2[next * 2] - points2[ind * 2]);
      let nx2 = points2[ind * 2 + 1] - points2[prev * 2 + 1];
      let ny2 = -(points2[ind * 2] - points2[prev * 2]);
      const D1 = Math.sqrt(nx1 * nx1 + ny1 * ny1);
      nx1 /= D1;
      ny1 /= D1;
      const D22 = Math.sqrt(nx2 * nx2 + ny2 * ny2);
      nx2 /= D22;
      ny2 /= D22;
      let bx = nx1 + nx2;
      let by = ny1 + ny2;
      const D5 = bx * nx1 + by * ny1;
      if (Math.abs(D5) < eps) {
        bx = nx1;
        by = ny1;
      } else {
        bx /= D5;
        by /= D5;
      }
      pn[ind * 2] = bx;
      pn[ind * 2 + 1] = by;
    }
    for (let i3 = 0;i3 < triangles.length; i3 += 3) {
      const prev = triangles[i3];
      const ind = triangles[i3 + 1];
      const next = triangles[i3 + 2];
      const nx1 = points2[next * 2 + 1] - points2[ind * 2 + 1];
      const ny1 = -(points2[next * 2] - points2[ind * 2]);
      const nx2 = points2[ind * 2 + 1] - points2[prev * 2 + 1];
      const ny2 = -(points2[ind * 2] - points2[prev * 2]);
      let j1 = 1;
      if (nx1 * ny2 - nx2 * ny1 > 0) {
        j1 = 2;
      }
      for (let j4 = 0;j4 < 3; j4++) {
        const ind2 = triangles[i3 + j4 * j1 % 3];
        verts2.push(points2[ind2 * 2], points2[ind2 * 2 + 1]);
      }
      for (let j4 = 0;j4 < 3; j4++) {
        const ind2 = triangles[i3 + j4 * j1 % 3];
        verts2.push(pn[ind2 * 2], pn[ind2 * 2 + 1]);
      }
    }
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextu
class RectangleBuilder {
  constructor() {
    this._polyBuilder = new PolyBuilder;
  }
  path(graphicsData, _target) {
    const rectData = graphicsData.shape;
    const x3 = rectData.x;
    const y3 = rectData.y;
    const width = rectData.width;
    const height = rectData.height;
    const points2 = graphicsData.points;
    points2.length = 0;
    points2.push(x3, y3, x3 + width, y3, x3 + width, y3 + height, x3, y3 + height);
  }
  line(graphicsData, target) {
    const { verts: verts2, joints } = target;
    const { points: points2 } = graphicsData;
    const joint = graphicsData.goodJointType();
    const len = points2.length;
    verts2.push(points2[len - 2], points2[len - 1]);
    joints.push(JOINT_TYPE.NONE);
    for (let i3 = 0;i3 < len; i3 += 2) {
      verts2.push(points2[i3], points2[i3 + 1]);
      joints.push(joint);
    }
    verts2.push(points2[0], points2[1]);
    joints.push(JOINT_TYPE.NONE);
    verts2.push(points2[2], points2[3]);
    joints.push(JOINT_TYPE.NONE);
  }
  fill(graphicsData, target) {
    const { verts: verts2, joints } = target;
    const { points: points2, triangles } = graphicsData;
    triangles.length = 0;
    if (!graphicsData.fillAA) {
      verts2.push(points2[0], points2[1], points2[2], points2[3], points2[4], points2[5], points2[6], points2[7]);
      joints.push(JOINT_TYPE.FILL, JOINT_TYPE.FILL, JOINT_TYPE.FILL, JOINT_TYPE.FILL);
      triangles.push(0, 1, 2, 0, 2, 3);
      return;
    }
    this._polyBuilder.fill(graphicsData, target);
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextureExten
class RoundedRectangleBuilder {
  constructor() {
    this._circleBuilder = new CircleBuilder;
  }
  path(graphicsData, target) {
    this._circleBuilder.path(graphicsData, target);
  }
  line(graphicsData, target) {
    this._circleBuilder.line(graphicsData, target);
  }
  fill(graphicsData, target) {
    this._circleBuilder.fill(graphicsData, target);
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
var FILL_COMMANDS2 = {
  [SHAPES.POLY]: new PolyBuilder,
  [SHAPES.CIRC]: new CircleBuilder,
  [SHAPES.ELIP]: new CircleBuilder,
  [SHAPES.RECT]: new RectangleBuilder,
  [SHAPES.RREC]: new RoundedRectangleBuilder
};
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsText
var BATCH_POOL2 = [];
var DRAW_CALL_POOL2 = [];
var tmpPoint3 = new Point3;
var tmpBounds = new Bounds;

class SmoothGraphicsGeometry extends Geometry {
  constructor() {
    super();
    this.indicesUint16 = null;
    this.initAttributes(false);
    this.buildData = new BuildData;
    this.graphicsData = [];
    this.dirty = 0;
    this.batchDirty = -1;
    this.cacheDirty = -1;
    this.clearDirty = 0;
    this.drawCalls = [];
    this.batches = [];
    this.shapeBuildIndex = 0;
    this.shapeBatchIndex = 0;
    this._bounds = new Bounds;
    this.boundsDirty = -1;
    this.boundsPadding = 0;
    this.batchable = false;
    this.indicesUint16 = null;
    this.packer = null;
    this.packSize = 0;
    this.pack32index = null;
  }
  get points() {
    return this.buildData.verts;
  }
  get closePointEps() {
    return this.buildData.closePointEps;
  }
  initAttributes(_static) {
    this._buffer = new Buffer(null, _static, false);
    this._bufferFloats = new Float32Array;
    this._bufferUint = new Uint32Array;
    this._indexBuffer = new Buffer(null, _static, true);
    this.addAttribute("aPrev", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aPoint1", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aPoint2", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aNext", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTravel", this._buffer, 1, false, TYPES.FLOAT).addAttribute("aVertexJoint", this._buffer, 1, false, TYPES.FLOAT).addAttribute("aStyleId", this._buffer, 1, false, TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addIndex(this._indexBuffer);
    this.strideFloats = 12;
  }
  checkInstancing(instanced, allow32Indices) {
    if (this.packer) {
      return;
    }
    this.packer = new SegmentPacker;
    this.pack32index = allow32Indices;
  }
  get bounds() {
    if (this.boundsDirty !== this.dirty) {
      this.boundsDirty = this.dirty;
      this.calculateBounds();
    }
    return this._bounds;
  }
  invalidate() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeBuildIndex = 0;
    this.shapeBatchIndex = 0;
    this.packSize = 0;
    this.buildData.clear();
    for (let i3 = 0;i3 < this.drawCalls.length; i3++) {
      this.drawCalls[i3].clear();
      DRAW_CALL_POOL2.push(this.drawCalls[i3]);
    }
    this.drawCalls.length = 0;
    for (let i3 = 0;i3 < this.batches.length; i3++) {
      const batchPart = this.batches[i3];
      batchPart.reset();
      BATCH_POOL2.push(batchPart);
    }
    this.batches.length = 0;
  }
  clear() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  }
  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
    const data = new SmoothGraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  }
  drawHole(shape, matrix = null) {
    if (!this.graphicsData.length) {
      return null;
    }
    const data = new SmoothGraphicsData(shape, null, null, matrix);
    const lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  }
  destroy() {
    super.destroy();
    for (let i3 = 0;i3 < this.graphicsData.length; ++i3) {
      this.graphicsData[i3].destroy();
    }
    this.buildData.destroy();
    this.buildData = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  }
  containsPoint(point) {
    const graphicsData = this.graphicsData;
    for (let i3 = 0;i3 < graphicsData.length; ++i3) {
      const data = graphicsData[i3];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint3);
        } else {
          tmpPoint3.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint3.x, tmpPoint3.y)) {
          let hitHole = false;
          if (data.holes) {
            for (let i22 = 0;i22 < data.holes.length; i22++) {
              const hole = data.holes[i22];
              if (hole.shape.contains(tmpPoint3.x, tmpPoint3.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  }
  updatePoints() {
  }
  updateBufferSize() {
    this._buffer.update(new Float32Array);
  }
  updateBuild() {
    const { graphicsData, buildData } = this;
    const len = graphicsData.length;
    for (let i3 = this.shapeBuildIndex;i3 < len; i3++) {
      const data = graphicsData[i3];
      data.strokeStart = 0;
      data.strokeLen = 0;
      data.fillStart = 0;
      data.fillLen = 0;
      const { fillStyle, lineStyle, holes } = data;
      if (!fillStyle.visible && !lineStyle.visible) {
        continue;
      }
      const command = FILL_COMMANDS2[data.type];
      data.clearPath();
      command.path(data, buildData);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      data.clearBuild();
      if (data.points.length <= 2) {
        continue;
      }
      if (fillStyle.visible || lineStyle.visible) {
        this.processHoles(holes);
      }
      if (fillStyle.visible) {
        data.fillAA = data.fillStyle.smooth && data.fillStyle.texture === Texture.WHITE && holes.length === 0 && !(data.closeStroke && data.lineStyle.visible && !data.lineStyle.shader && data.lineStyle.alpha >= 0.99 && data.lineStyle.width * Math.min(data.lineStyle.alignment, 1 - data.lineStyle.alignment) >= 0.495);
        data.fillStart = buildData.joints.length;
        if (holes.length) {
          FILL_COMMANDS2[SHAPES.POLY].fill(data, buildData);
        } else {
          command.fill(data, buildData);
        }
        data.fillLen = buildData.joints.length - data.fillStart;
      }
      if (lineStyle.visible) {
        data.strokeStart = buildData.joints.length;
        command.line(data, buildData);
        for (let i22 = 0;i22 < holes.length; i22++) {
          const hole = holes[i22];
          FILL_COMMANDS2[hole.type].line(hole, buildData);
        }
        data.strokeLen = buildData.joints.length - data.strokeStart;
      }
    }
    this.shapeBuildIndex = len;
  }
  updateBatches(shaderSettings) {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    this.updateBuild();
    if (!this.validateBatching()) {
      return;
    }
    const { buildData, graphicsData } = this;
    const len = graphicsData.length;
    this.cacheDirty = this.dirty;
    let batchPart = null;
    let currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (let i3 = this.shapeBatchIndex;i3 < len; i3++) {
      const data = graphicsData[i3];
      const fillStyle = data.fillStyle;
      const lineStyle = data.lineStyle;
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      if (!fillStyle.visible && !lineStyle.visible) {
        continue;
      }
      for (let j4 = 0;j4 < 2; j4++) {
        const style = j4 === 0 ? fillStyle : lineStyle;
        if (!style.visible)
          continue;
        const nextTexture = style.texture.baseTexture;
        const attribOld = buildData.vertexSize;
        const indexOld = buildData.indexSize;
        nextTexture.wrapMode = WRAP_MODES.REPEAT;
        if (j4 === 0) {
          this.packer.updateBufferSize(data.fillStart, data.fillLen, data.triangles.length, buildData);
        } else {
          this.packer.updateBufferSize(data.strokeStart, data.strokeLen, data.triangles.length, buildData);
        }
        const attribSize = buildData.vertexSize;
        if (attribSize === attribOld)
          continue;
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(indexOld, attribOld);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = BATCH_POOL2.pop() || new BatchPart4;
          batchPart.begin(style, indexOld, attribOld);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        if (j4 === 0) {
          batchPart.jointEnd = data.fillStart + data.fillLen;
        } else {
          batchPart.jointEnd = data.strokeStart + data.strokeLen;
        }
      }
    }
    this.shapeBatchIndex = len;
    if (batchPart) {
      batchPart.end(buildData.indexSize, buildData.vertexSize);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls(shaderSettings);
      this.updatePack();
    }
  }
  updatePack() {
    const { vertexSize, indexSize } = this.buildData;
    if (this.packSize === vertexSize) {
      return;
    }
    const { strideFloats, packer, buildData, batches } = this;
    const buffer = this._buffer;
    const index2 = this._indexBuffer;
    const floatsSize = vertexSize * strideFloats;
    if (buffer.data.length !== floatsSize) {
      const arrBuf = new ArrayBuffer(floatsSize * 4);
      this._bufferFloats = new Float32Array(arrBuf);
      this._bufferUint = new Uint32Array(arrBuf);
      buffer.data = this._bufferFloats;
    }
    if (index2.data.length !== indexSize) {
      if (vertexSize > 65535 && this.pack32index) {
        index2.data = new Uint32Array(indexSize);
      } else {
        index2.data = new Uint16Array(indexSize);
      }
    }
    packer.beginPack(buildData, this._bufferFloats, this._bufferUint, index2.data);
    let j4 = 0;
    for (let i3 = 0;i3 < this.graphicsData.length; i3++) {
      const data = this.graphicsData[i3];
      if (data.fillLen) {
        while (batches[j4].jointEnd <= data.fillStart) {
          j4++;
        }
        packer.packInterleavedGeometry(data.fillStart, data.fillLen, data.triangles, batches[j4].styleId, batches[j4].rgba);
      }
      if (data.strokeLen) {
        while (batches[j4].jointEnd <= data.strokeStart) {
          j4++;
        }
        packer.packInterleavedGeometry(data.strokeStart, data.strokeLen, data.triangles, batches[j4].styleId, batches[j4].rgba);
      }
    }
    buffer.update();
    index2.update();
    this.packSize = vertexSize;
  }
  _compareStyles(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (styleA.shader !== styleB.shader) {
      return false;
    }
    if (styleA.width !== styleB.width) {
      return false;
    }
    if (styleA.scaleMode !== styleB.scaleMode) {
      return false;
    }
    if (styleA.alignment !== styleB.alignment) {
      return false;
    }
    const mat1 = styleA.matrix || Matrix.IDENTITY;
    const mat2 = styleB.matrix || Matrix.IDENTITY;
    return matrixEquals(mat1, mat2);
  }
  validateBatching() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (let i3 = 0, l4 = this.graphicsData.length;i3 < l4; i3++) {
      const data = this.graphicsData[i3];
      const fill = data.fillStyle;
      const line = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid)
        return false;
      if (line && !line.texture.baseTexture.valid)
        return false;
    }
    return true;
  }
  packBatches() {
    this.batchDirty++;
    const batches = this.batches;
    for (let i3 = 0, l4 = batches.length;i3 < l4; i3++) {
      const batch = batches[i3];
      for (let j4 = 0;j4 < batch.size; j4++) {
        const index2 = batch.start + j4;
        this.indicesUint16[index2] = this.indicesUint16[index2] - batch.attribStart;
      }
    }
  }
  isBatchable() {
    return false;
  }
  buildDrawCalls(shaderSettings) {
    for (let i3 = 0;i3 < this.drawCalls.length; i3++) {
      this.drawCalls[i3].clear();
      DRAW_CALL_POOL2.push(this.drawCalls[i3]);
    }
    this.drawCalls.length = 0;
    let currentGroup = DRAW_CALL_POOL2.pop() || new BatchDrawCall3;
    currentGroup.begin(shaderSettings, null);
    let index2 = 0;
    this.drawCalls.push(currentGroup);
    for (let i3 = 0;i3 < this.batches.length; i3++) {
      const batchData = this.batches[i3];
      const style = batchData.style;
      if (batchData.attribSize === 0) {
        continue;
      }
      let styleId = -1;
      const mat = style.getTextureMatrix();
      if (currentGroup.check(style.shader)) {
        styleId = currentGroup.add(style.texture, mat, style.width, style.alignment || 0, style.packLineScale());
      }
      if (styleId < 0) {
        currentGroup = DRAW_CALL_POOL2.pop() || new BatchDrawCall3;
        this.drawCalls.push(currentGroup);
        currentGroup.begin(shaderSettings, style.shader);
        currentGroup.start = index2;
        styleId = currentGroup.add(style.texture, mat, style.width, style.alignment || 0, style.packLineScale());
      }
      currentGroup.size += batchData.size;
      index2 += batchData.size;
      const { color: color8, alpha: alpha2 } = style;
      const bgr = Color.shared.setValue(color8).toLittleEndianNumber();
      batchData.rgba = Color.shared.setValue(bgr).toPremultiplied(alpha2);
      batchData.styleId = styleId;
    }
  }
  processHoles(holes) {
    for (let i3 = 0;i3 < holes.length; i3++) {
      const hole = holes[i3];
      const command = FILL_COMMANDS2[hole.type];
      hole.clearPath();
      command.path(hole, this.buildData);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  }
  calculateBounds() {
    const bounds = this._bounds;
    const sequenceBounds = tmpBounds;
    let curMatrix = Matrix.IDENTITY;
    this._bounds.clear();
    sequenceBounds.clear();
    for (let i3 = 0;i3 < this.graphicsData.length; i3++) {
      const data = this.graphicsData[i3];
      const shape = data.shape;
      const type = data.type;
      const lineStyle = data.lineStyle;
      const nextMatrix = data.matrix || Matrix.IDENTITY;
      let lineWidth = 0;
      if (lineStyle && lineStyle.visible) {
        lineWidth = lineStyle.width;
        if (type !== SHAPES.POLY || data.fillStyle.visible) {
          lineWidth *= Math.max(0, lineStyle.alignment);
        } else {
          lineWidth *= Math.max(lineStyle.alignment, 1 - lineStyle.alignment);
        }
      }
      if (curMatrix !== nextMatrix) {
        if (!sequenceBounds.isEmpty()) {
          bounds.addBoundsMatrix(sequenceBounds, curMatrix);
          sequenceBounds.clear();
        }
        curMatrix = nextMatrix;
      }
      if (type === SHAPES.RECT || type === SHAPES.RREC) {
        const rect = shape;
        sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);
      } else if (type === SHAPES.CIRC) {
        const circle = shape;
        sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);
      } else if (type === SHAPES.ELIP) {
        const ellipse = shape;
        sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);
      } else {
        const poly = shape;
        bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);
      }
    }
    if (!sequenceBounds.isEmpty()) {
      bounds.addBoundsMatrix(sequenceBounds, curMatrix);
    }
    bounds.pad(this.boundsPadding, this.boundsPadding);
  }
  transformPoints(points2, matrix) {
    for (let i3 = 0;i3 < points2.length / 2; i3++) {
      const x3 = points2[i3 * 2];
      const y3 = points2[i3 * 2 + 1];
      points2[i3 * 2] = matrix.a * x3 + matrix.c * y3 + matrix.tx;
      points2[i3 * 2 + 1] = matrix.b * x3 + matrix.d * y3 + matrix.ty;
    }
  }
}
SmoothGraphicsGeometry.BATCHABLE_SIZE = 100;
// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs
var smoothVert = `#version 100
precision highp float;
const float FILL = 1.0;
const float BEVEL = 4.0;
const float MITER = 8.0;
const float ROUND = 12.0;
const float JOINT_CAP_BUTT = 16.0;
const float JOINT_CAP_SQUARE = 18.0;
const float JOINT_CAP_ROUND = 20.0;

const float FILL_EXPAND = 24.0;

const float CAP_BUTT = 1.0;
const float CAP_SQUARE = 2.0;
const float CAP_ROUND = 3.0;
const float CAP_BUTT2 = 4.0;

const float MITER_LIMIT = 10.0;

// === geom ===
attribute vec2 aPrev;
attribute vec2 aPoint1;
attribute vec2 aPoint2;
attribute vec2 aNext;
attribute float aVertexJoint;
attribute float aTravel;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec4 vLine1;
varying vec4 vLine2;
varying vec4 vArc;
varying float vType;

uniform float resolution;
uniform float expand;

// === style ===
attribute float aStyleId;
attribute vec4 aColor;

varying float vTextureId;
varying vec4 vColor;
varying vec2 vTextureCoord;
varying vec2 vTravel;

uniform vec2 styleLine[%MAX_STYLES%];
uniform vec3 styleMatrix[2 * %MAX_STYLES%];
uniform float styleTextureId[%MAX_STYLES%];
uniform vec2 samplerSize[%MAX_TEXTURES%];

vec2 doBisect(vec2 norm, float len, vec2 norm2, float len2,
    float dy, float inner) {
    vec2 bisect = (norm + norm2) / 2.0;
    bisect /= dot(norm, bisect);
    vec2 shift = dy * bisect;
    if (inner > 0.5) {
        if (len < len2) {
            if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {
                return dy * norm;
            }
        } else {
            if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {
                return dy * norm;
            }
        }
    }
    return dy * bisect;
}

void main(void){
    vec2 pointA = (translationMatrix * vec3(aPoint1, 1.0)).xy;
    vec2 pointB = (translationMatrix * vec3(aPoint2, 1.0)).xy;

    vec2 xBasis = pointB - pointA;
    float len = length(xBasis);
    vec2 forward = xBasis / len;
    vec2 norm = vec2(forward.y, -forward.x);

    float type = floor(aVertexJoint / 16.0);
    float vertexNum = aVertexJoint - type * 16.0;
    float dx = 0.0, dy = 1.0;

    float capType = floor(type / 32.0);
    type -= capType * 32.0;

    int styleId = int(aStyleId + 0.5);
    float lineWidth = styleLine[styleId].x;
    vTextureId = floor(styleTextureId[styleId] / 4.0);
    float scaleMode = styleTextureId[styleId] - vTextureId * 4.0;
    float avgScale = 1.0;
    if (scaleMode > 2.5) {
        avgScale = length(translationMatrix * vec3(1.0, 0.0, 0.0));
    } else if (scaleMode > 1.5) {
        avgScale = length(translationMatrix * vec3(0.0, 1.0, 0.0));
    } else if (scaleMode > 0.5) {
        vec2 avgDiag = (translationMatrix * vec3(1.0, 1.0, 0.0)).xy;
        avgScale = sqrt(dot(avgDiag, avgDiag) * 0.5);
    }
    lineWidth *= 0.5 * avgScale;
    float lineAlignment = 2.0 * styleLine[styleId].y - 1.0;
    vTextureCoord = vec2(0.0);

    vec2 pos;

    if (capType == CAP_ROUND) {
        vertexNum += 4.0;
        type = JOINT_CAP_ROUND;
        capType = 0.0;
        lineAlignment = -lineAlignment;
    }

    vLine1 = vec4(0.0, 10.0, 1.0, 0.0);
    vLine2 = vec4(0.0, 10.0, 1.0, 0.0);
    vArc = vec4(0.0);
    if (type == FILL) {
        pos = pointA;
        vType = 0.0;
        vLine2 = vec4(-2.0, -2.0, -2.0, 0.0);
        vec2 vTexturePixel;
        vTexturePixel.x = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2]);
        vTexturePixel.y = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2 + 1]);
        vTextureCoord = vTexturePixel / samplerSize[int(vTextureId)];
    } else if (type >= FILL_EXPAND && type < FILL_EXPAND + 7.5) {
        // expand vertices
        float flags = type - FILL_EXPAND;
        float flag3 = floor(flags / 4.0);
        float flag2 = floor((flags - flag3 * 4.0) / 2.0);
        float flag1 = flags - flag3 * 4.0 - flag2 * 2.0;

        vec2 prev = (translationMatrix * vec3(aPrev, 1.0)).xy;

        if (vertexNum < 0.5) {
            pos = prev;
        } else if (vertexNum < 1.5) {
            pos = pointA;
        } else {
            pos = pointB;
        }
        float len2 = length(aNext);
        vec2 bisect = (translationMatrix * vec3(aNext, 0.0)).xy;
        if (len2 > 0.01) {
            bisect = normalize(bisect) * len2;
        }

        vec2 n1 = normalize(vec2(pointA.y - prev.y, -(pointA.x - prev.x)));
        vec2 n2 = normalize(vec2(pointB.y - pointA.y, -(pointB.x - pointA.x)));
        vec2 n3 = normalize(vec2(prev.y - pointB.y, -(prev.x - pointB.x)));

        if (n1.x * n2.y - n1.y * n2.x < 0.0) {
            n1 = -n1;
            n2 = -n2;
            n3 = -n3;
        }
        pos += bisect * expand;

        vLine1 = vec4(16.0, 16.0, 16.0, -1.0);
        if (flag1 > 0.5) {
            vLine1.x = -dot(pos - prev, n1);
        }
        if (flag2 > 0.5) {
            vLine1.y = -dot(pos - pointA, n2);
        }
        if (flag3 > 0.5) {
            vLine1.z = -dot(pos - pointB, n3);
        }
        vLine1.xyz *= resolution;
        vType = 2.0;
    } else if (type >= BEVEL) {
        float dy = lineWidth + expand;
        float shift = lineWidth * lineAlignment;
        float inner = 0.0;
        if (vertexNum >= 1.5) {
            dy = -dy;
            inner = 1.0;
        }

        vec2 base, next, xBasis2, bisect;
        float flag = 0.0;
        float side2 = 1.0;
        if (vertexNum < 0.5 || vertexNum > 2.5 && vertexNum < 3.5) {
            next = (translationMatrix * vec3(aPrev, 1.0)).xy;
            base = pointA;
            flag = type - floor(type / 2.0) * 2.0;
            side2 = -1.0;
        } else {
            next = (translationMatrix * vec3(aNext, 1.0)).xy;
            base = pointB;
            if (type >= MITER && type < MITER + 3.5) {
                flag = step(MITER + 1.5, type);
                // check miter limit here?
            }
        }
        xBasis2 = next - base;
        float len2 = length(xBasis2);
        vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;
        float D = norm.x * norm2.y - norm.y * norm2.x;
        if (D < 0.0) {
            inner = 1.0 - inner;
        }

        norm2 *= side2;

        float collinear = step(0.0, dot(norm, norm2));

        vType = 0.0;
        float dy2 = -1000.0;

        if (abs(D) < 0.01 && collinear < 0.5) {
            if (type >= ROUND && type < ROUND + 1.5) {
                type = JOINT_CAP_ROUND;
            }
            //TODO: BUTT here too
        }

        vLine1 = vec4(0.0, lineWidth, max(abs(norm.x), abs(norm.y)), min(abs(norm.x), abs(norm.y)));
        vLine2 = vec4(0.0, lineWidth, max(abs(norm2.x), abs(norm2.y)), min(abs(norm2.x), abs(norm2.y)));

        if (vertexNum < 3.5) {
            if (abs(D) < 0.01 && collinear < 0.5) {
                pos = (shift + dy) * norm;
            } else {
                if (flag < 0.5 && inner < 0.5) {
                    pos = (shift + dy) * norm;
                } else {
                    pos = doBisect(norm, len, norm2, len2, shift + dy, inner);
                }
            }
            vLine2.y = -1000.0;
            if (capType >= CAP_BUTT && capType < CAP_ROUND) {
                float extra = step(CAP_SQUARE, capType) * lineWidth;
                vec2 back = -forward;
                if (vertexNum < 0.5 || vertexNum > 2.5) {
                    pos += back * (expand + extra);
                    dy2 = expand;
                } else {
                    dy2 = dot(pos + base - pointA, back) - extra;
                }
            }
            if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {
                float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;
                if (vertexNum < 0.5 || vertexNum > 2.5) {
                    vLine2.y = dot(pos + base - pointB, forward) - extra;
                } else {
                    pos += forward * (expand + extra);
                    vLine2.y = expand;
                    if (capType >= CAP_BUTT) {
                        dy2 -= expand + extra;
                    }
                }
            }
        } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {
            base += shift * norm;
            if (inner > 0.5) {
                dy = -dy;
                inner = 0.0;
            }
            vec2 d2 = abs(dy) * forward;
            if (vertexNum < 4.5) {
                dy = -dy;
                pos = dy * norm;
            } else if (vertexNum < 5.5) {
                pos = dy * norm;
            } else if (vertexNum < 6.5) {
                pos = dy * norm + d2;
                vArc.x = abs(dy);
            } else {
                dy = -dy;
                pos = dy * norm + d2;
                vArc.x = abs(dy);
            }
            vLine2 = vec4(0.0, lineWidth * 2.0 + 10.0, 1.0  , 0.0); // forget about line2 with type=3
            vArc.y = dy;
            vArc.z = 0.0;
            vArc.w = lineWidth;
            vType = 3.0;
        } else if (abs(D) < 0.01 && collinear < 0.5) {
            pos = dy * norm;
        } else {
            if (inner > 0.5) {
                dy = -dy;
                inner = 0.0;
            }
            float side = sign(dy);
            vec2 norm3 = normalize(norm + norm2);

            if (type >= MITER && type < MITER + 3.5) {
                vec2 farVertex = doBisect(norm, len, norm2, len2, shift + dy, 0.0);
                if (length(farVertex) > abs(shift + dy) * MITER_LIMIT) {
                    type = BEVEL;
                }
            }

            if (vertexNum < 4.5) {
                pos = doBisect(norm, len, norm2, len2, shift - dy, 1.0);
            } else if (vertexNum < 5.5) {
                pos = (shift + dy) * norm;
            } else if (vertexNum > 7.5) {
                pos = (shift + dy) * norm2;
            } else {
                if (type >= ROUND && type < ROUND + 1.5) {
                    pos = doBisect(norm, len, norm2, len2, shift + dy, 0.0);
                    float d2 = abs(shift + dy);
                    if (length(pos) > abs(shift + dy) * 1.5) {
                        if (vertexNum < 6.5) {
                            pos.x = (shift + dy) * norm.x - d2 * norm.y;
                            pos.y = (shift + dy) * norm.y + d2 * norm.x;
                        } else {
                            pos.x = (shift + dy) * norm2.x + d2 * norm2.y;
                            pos.y = (shift + dy) * norm2.y - d2 * norm2.x;
                        }
                    }
                } else if (type >= MITER && type < MITER + 3.5) {
                    pos = doBisect(norm, len, norm2, len2, shift + dy, 0.0); //farVertex
                } else if (type >= BEVEL && type < BEVEL + 1.5) {
                    float d2 = side / resolution;
                    if (vertexNum < 6.5) {
                        pos = (shift + dy) * norm + d2 * norm3;
                    } else {
                        pos = (shift + dy) * norm2 + d2 * norm3;
                    }
                }
            }

            if (type >= ROUND && type < ROUND + 1.5) {
                vArc.x = side * dot(pos, norm3);
                vArc.y = pos.x * norm3.y - pos.y * norm3.x;
                vArc.z = dot(norm, norm3) * (lineWidth + side * shift);
                vArc.w = lineWidth + side * shift;
                vType = 3.0;
            } else if (type >= MITER && type < MITER + 3.5) {
                vType = 1.0;
            } else if (type >= BEVEL && type < BEVEL + 1.5) {
                vType = 4.0;
                vArc.z = dot(norm, norm3) * (lineWidth + side * shift) - side * dot(pos, norm3);
            }

            dy = side * (dot(pos, norm) - shift);
            dy2 = side * (dot(pos, norm2) - shift);
        }

        pos += base;
        vLine1.xy = vec2(dy, vLine1.y) * resolution;
        vLine2.xy = vec2(dy2, vLine2.y) * resolution;
        vArc = vArc * resolution;
        vTravel = vec2(aTravel * avgScale + dot(pos - pointA, vec2(-norm.y, norm.x)), avgScale);
    }

    gl_Position = vec4((projectionMatrix * vec3(pos, 1.0)).xy, 0.0, 1.0);

    vColor = aColor * tint;
}`;
var precision = `#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif
`;
var smoothFrag = `%PRECISION%
varying vec4 vColor;
varying vec4 vLine1;
varying vec4 vLine2;
varying vec4 vArc;
varying float vType;
varying float vTextureId;
varying vec2 vTextureCoord;
varying vec2 vTravel;
uniform sampler2D uSamplers[%MAX_TEXTURES%];

%PIXEL_LINE%

void main(void){
    %PIXEL_COVERAGE%

    vec4 texColor;
    float textureId = floor(vTextureId+0.5);
    %FOR_LOOP%

    gl_FragColor = vColor * texColor * alpha;
}
`;
var pixelLineFunc = [`
float pixelLine(float x, float A, float B) {
    return clamp(x + 0.5, 0.0, 1.0);
}
`, `
float pixelLine(float x, float A, float B) {
    float y = abs(x), s = sign(x);
    if (y * 2.0 < A - B) {
        return 0.5 + s * y / A;
    }
    y -= (A - B) * 0.5;
    y = max(1.0 - y / B, 0.0);
    return (1.0 + s * (1.0 - y * y)) * 0.5;
    //return clamp(x + 0.5, 0.0, 1.0);
}
`];
var pixelCoverage = `float alpha = 1.0;
if (vType < 0.5) {
    float left = pixelLine(-vLine1.y - vLine1.x, vLine1.z, vLine1.w);
    float right = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);
    float near = vLine2.x - 0.5;
    float far = min(vLine2.x + 0.5, 0.0);
    float top = vLine2.y - 0.5;
    float bottom = min(vLine2.y + 0.5, 0.0);
    alpha = (right - left) * max(bottom - top, 0.0) * max(far - near, 0.0);
} else if (vType < 1.5) {
    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);
    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);
    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);
    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);
    alpha = a2 * b2 - a1 * b1;
} else if (vType < 2.5) {
    alpha *= max(min(vLine1.x + 0.5, 1.0), 0.0);
    alpha *= max(min(vLine1.y + 0.5, 1.0), 0.0);
    alpha *= max(min(vLine1.z + 0.5, 1.0), 0.0);
} else if (vType < 3.5) {
    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);
    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);
    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);
    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);
    float alpha_miter = a2 * b2 - a1 * b1;
    float alpha_plane = clamp(vArc.z - vArc.x + 0.5, 0.0, 1.0);
    float d = length(vArc.xy);
    float circle_hor = max(min(vArc.w, d + 0.5) - max(-vArc.w, d - 0.5), 0.0);
    float circle_vert = min(vArc.w * 2.0, 1.0);
    float alpha_circle = circle_hor * circle_vert;
    alpha = min(alpha_miter, max(alpha_circle, alpha_plane));
} else {
    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);
    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);
    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);
    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);
    alpha = a2 * b2 - a1 * b1;
    alpha *= clamp(vArc.z + 0.5, 0.0, 1.0);
}
`;

class SmoothGraphicsShader extends Shader {
  constructor(settings33, vert = smoothVert, frag = smoothFrag, uniforms = {}) {
    vert = SmoothGraphicsShader.generateVertexSrc(settings33, vert);
    frag = SmoothGraphicsShader.generateFragmentSrc(settings33, frag);
    const { maxStyles, maxTextures } = settings33;
    const sampleValues = new Int32Array(maxTextures);
    for (let i3 = 0;i3 < maxTextures; i3++) {
      sampleValues[i3] = i3;
    }
    super(Program.from(vert, frag), Object.assign(uniforms, {
      styleMatrix: new Float32Array(6 * maxStyles),
      styleTextureId: new Float32Array(maxStyles),
      styleLine: new Float32Array(2 * maxStyles),
      samplerSize: new Float32Array(2 * maxTextures),
      uSamplers: sampleValues,
      tint: new Float32Array([1, 1, 1, 1]),
      resolution: 1,
      expand: 1
    }));
    this.settings = settings33;
  }
  static generateVertexSrc(settings33, vertexSrc = smoothVert) {
    const { maxStyles, maxTextures } = settings33;
    vertexSrc = vertexSrc.replace(/%MAX_TEXTURES%/gi, `${maxTextures}`).replace(/%MAX_STYLES%/gi, `${maxStyles}`);
    return vertexSrc;
  }
  static generateFragmentSrc(settings33, fragmentSrc = smoothFrag) {
    const { maxTextures, pixelLine } = settings33;
    fragmentSrc = fragmentSrc.replace(/%PRECISION%/gi, precision).replace(/%PIXEL_LINE%/gi, pixelLineFunc[pixelLine]).replace(/%PIXEL_COVERAGE%/gi, pixelCoverage).replace(/%MAX_TEXTURES%/gi, `${maxTextures}`).replace(/%FOR_LOOP%/gi, this.generateSampleSrc(maxTextures));
    return fragmentSrc;
  }
  static generateSampleSrc(maxTextures) {
    let src = "";
    src += "\n";
    src += "\n";
    for (let i3 = 0;i3 < maxTextures; i3++) {
      if (i3 > 0) {
        src += "\nelse ";
      }
      if (i3 < maxTextures - 1) {
        src += `if(textureId < ${i3}.5)`;
      }
      src += "\n{";
      src += `
	texColor = texture2D(uSamplers[${i3}], vTextureCoord);`;
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle
var settings33 = {
  LINE_SCALE_MODE: LINE_SCALE_MODE.NORMAL,
  SHADER_MAX_STYLES: 24,
  SHADER_MAX_TEXTURES: 4,
  PIXEL_LINE: 0
};

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
var UnsmoothGraphics = Graphics;
var { BezierUtils: BezierUtils4, QuadraticUtils: QuadraticUtils4, ArcUtils: ArcUtils4 } = graphicsUtils;
var DEFAULT_SHADERS2 = {};
var _SmoothGraphics = class extends Container {
  constructor(geometry = null) {
    super();
    this._geometry = geometry || new SmoothGraphicsGeometry;
    this._geometry.refCount++;
    this.shader = null;
    this.shaderSettings = {
      maxStyles: settings33.SHADER_MAX_STYLES,
      maxTextures: settings33.SHADER_MAX_TEXTURES,
      pixelLine: settings33.PIXEL_LINE
    };
    this.state = State.for2d();
    this._fillStyle = new FillStyle4;
    this._lineStyle = new LineStyle3;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    this.batches = [];
    this.batchTint = -1;
    this.batchDirty = -1;
    this.vertexData = null;
    this.pluginName = "smooth";
    this._transformID = -1;
    this._tintColor = new Color(16777215);
    this.blendMode = BLEND_MODES.NORMAL;
  }
  get geometry() {
    return this._geometry;
  }
  clone() {
    this.finishPoly();
    return new _SmoothGraphics(this._geometry);
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
  }
  get fill() {
    return this._fillStyle;
  }
  get line() {
    return this._lineStyle;
  }
  lineStyle(options = null, color8 = 0, alpha2 = 1, alignment = 0.5, scaleMode = settings33.LINE_SCALE_MODE) {
    if (typeof options === "number") {
      if (typeof scaleMode === "boolean") {
        scaleMode = scaleMode ? LINE_SCALE_MODE.NONE : LINE_SCALE_MODE.NORMAL;
      }
      options = { width: options, color: color8, alpha: alpha2, alignment, scaleMode };
    } else {
      const native = options.native;
      if (native !== undefined) {
        options.scaleMode = native ? LINE_SCALE_MODE.NONE : LINE_SCALE_MODE.NORMAL;
      }
    }
    return this.lineTextureStyle(options);
  }
  lineTextureStyle(options) {
    options = Object.assign({
      width: 0,
      texture: Texture.WHITE,
      color: options && options.texture ? 16777215 : 0,
      alpha: 1,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10,
      shader: null,
      scaleMode: settings33.LINE_SCALE_MODE
    }, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.width > 0 && options.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options);
    }
    return this;
  }
  startPoly() {
    if (this.currentPath) {
      const points2 = this.currentPath.points;
      const len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new Polygon;
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points2[len - 2], points2[len - 1]);
      }
    } else {
      this.currentPath = new Polygon;
      this.currentPath.closeStroke = false;
    }
  }
  finishPoly() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  }
  moveTo(x3, y3) {
    this.startPoly();
    this.currentPath.points[0] = x3;
    this.currentPath.points[1] = y3;
    return this;
  }
  lineTo(x3, y3) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    const points2 = this.currentPath.points;
    const fromX = points2[points2.length - 2];
    const fromY = points2[points2.length - 1];
    if (fromX !== x3 || fromY !== y3) {
      points2.push(x3, y3);
    }
    return this;
  }
  _initCurve(x3 = 0, y3 = 0) {
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x3, y3];
      }
    } else {
      this.moveTo(x3, y3);
    }
  }
  quadraticCurveTo(cpX, cpY, toX, toY) {
    this._initCurve();
    const points2 = this.currentPath.points;
    if (points2.length === 0) {
      this.moveTo(0, 0);
    }
    QuadraticUtils4.curveTo(cpX, cpY, toX, toY, points2);
    return this;
  }
  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    BezierUtils4.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  }
  arcTo(x1, y1, x22, y22, radius) {
    this._initCurve(x1, y1);
    const points2 = this.currentPath.points;
    const result = ArcUtils4.curveTo(x1, y1, x22, y22, radius, points2);
    if (result) {
      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
    }
    return this;
  }
  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += PI_2;
    }
    const sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    const startX = cx + Math.cos(startAngle) * radius;
    const startY = cy + Math.sin(startAngle) * radius;
    const eps = this._geometry.closePointEps;
    let points2 = this.currentPath ? this.currentPath.points : null;
    if (points2) {
      const xDiff = Math.abs(points2[points2.length - 2] - startX);
      const yDiff = Math.abs(points2[points2.length - 1] - startY);
      if (xDiff < eps && yDiff < eps)
        ;
      else {
        points2.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points2 = this.currentPath.points;
    }
    ArcUtils4.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points2);
    return this;
  }
  beginFill(color8 = 0, alpha2 = 1, smooth = false) {
    return this.beginTextureFill({ texture: Texture.WHITE, color: color8, alpha: alpha2, smooth });
  }
  normalizeColor(options) {
    const temp = Color.shared.setValue(options.color ?? 0);
    options.color = temp.toNumber();
    options.alpha ?? (options.alpha = temp.alpha);
  }
  beginTextureFill(options) {
    options = Object.assign({
      texture: Texture.WHITE,
      color: 16777215,
      alpha: 1,
      matrix: null,
      smooth: false
    }, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options);
    }
    return this;
  }
  endFill() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  }
  drawRect(x3, y3, width, height) {
    return this.drawShape(new Rectangle(x3, y3, width, height));
  }
  drawRoundedRect(x3, y3, width, height, radius) {
    return this.drawShape(new RoundedRectangle(x3, y3, width, height, radius));
  }
  drawCircle(x3, y3, radius) {
    return this.drawShape(new Circle2(x3, y3, radius));
  }
  drawEllipse(x3, y3, width, height) {
    return this.drawShape(new Ellipse(x3, y3, width, height));
  }
  drawPolygon(...path2) {
    let points2;
    let closeStroke = true;
    const poly = path2[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points2 = poly.points;
    } else if (Array.isArray(path2[0])) {
      points2 = path2[0];
    } else {
      points2 = path2;
    }
    const shape = new Polygon(points2);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  }
  drawShape(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  }
  clear() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  }
  isFastRect() {
    const data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  }
  _renderCanvas(renderer) {
    UnsmoothGraphics.prototype._renderCanvas.call(this, renderer);
  }
  _render(renderer) {
    this.finishPoly();
    const geometry = this._geometry;
    const hasuint32 = renderer.context.supports.uint32Indices;
    geometry.checkInstancing(renderer.geometry.hasInstance, hasuint32);
    geometry.updateBatches(this.shaderSettings);
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer);
    } else {
      renderer.batch.flush();
      this._renderDirect(renderer);
    }
  }
  _populateBatches() {
    const geometry = this._geometry;
    const blendMode = this.blendMode;
    const len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (let i3 = 0;i3 < len; i3++) {
      const gI2 = geometry.batches[i3];
      const color8 = gI2.style.color;
      const vertexData = new Float32Array(this.vertexData.buffer, gI2.attribStart * 4 * 2, gI2.attribSize * 2);
      const batch = {
        vertexData,
        blendMode,
        _batchRGB: exports_lib.hex2rgb(color8),
        _tintRGB: color8,
        _texture: gI2.style.texture,
        alpha: gI2.style.alpha,
        worldAlpha: 1
      };
      this.batches[i3] = batch;
    }
  }
  _renderBatched(renderer) {
    if (!this.batches.length) {
      return;
    }
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (let i3 = 0, l4 = this.batches.length;i3 < l4; i3++) {
      const batch = this.batches[i3];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer.plugins[this.pluginName].render(batch);
    }
  }
  _renderDirect(renderer) {
    const directShader = this._resolveDirectShader(renderer);
    let shader = directShader;
    const geometry = this._geometry;
    const worldAlpha = this.worldAlpha;
    const uniforms = shader.uniforms;
    const drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint);
    uniforms.resolution = renderer.renderTexture.current ? renderer.renderTexture.current.resolution : renderer.resolution;
    const projTrans = renderer.projection.transform;
    if (projTrans) {
      const scale3 = Math.sqrt(projTrans.a * projTrans.a + projTrans.b * projTrans.b);
      uniforms.resolution *= scale3;
    }
    const multisample = renderer.renderTexture.current ? renderer.renderTexture.current.multisample : renderer.multisample;
    uniforms.expand = (multisample !== MSAA_QUALITY.NONE ? 2 : 1) / uniforms.resolution;
    renderer.shader.bind(shader);
    renderer.geometry.bind(geometry, shader);
    renderer.state.set(this.state);
    shader = null;
    for (let i3 = 0, l4 = drawCalls.length;i3 < l4; i3++) {
      const drawCall = geometry.drawCalls[i3];
      const shaderChange = shader !== drawCall.shader;
      if (shaderChange) {
        shader = drawCall.shader;
        if (shader) {
          shader.uniforms.translationMatrix = this.transform.worldTransform;
          if (shader.uniforms.tint) {
            shader.uniforms.tint[0] = uniforms.tint[0];
            shader.uniforms.tint[1] = uniforms.tint[1];
            shader.uniforms.tint[2] = uniforms.tint[2];
            shader.uniforms.tint[3] = uniforms.tint[3];
          }
        }
      }
      const { texArray, styleArray, size, start } = drawCall;
      const groupTextureCount = texArray.count;
      const shaderHere = shader || directShader;
      const texs = shaderHere.uniforms.styleTextureId;
      const mats = shaderHere.uniforms.styleMatrix;
      const lines = shaderHere.uniforms.styleLine;
      for (let i22 = 0;i22 < styleArray.count; i22++) {
        texs[i22] = styleArray.textureIds[i22];
        lines[i22 * 2] = styleArray.lines[i22 * 2];
        lines[i22 * 2 + 1] = styleArray.lines[i22 * 2 + 1];
        const m4 = styleArray.matrices[i22];
        mats[i22 * 6] = m4.a;
        mats[i22 * 6 + 1] = m4.c;
        mats[i22 * 6 + 2] = m4.tx;
        mats[i22 * 6 + 3] = m4.b;
        mats[i22 * 6 + 4] = m4.d;
        mats[i22 * 6 + 5] = m4.ty;
      }
      const sizes = shaderHere.uniforms.samplerSize;
      for (let i22 = 0;i22 < groupTextureCount; i22++) {
        sizes[i22 * 2] = texArray.elements[i22].width;
        sizes[i22 * 2 + 1] = texArray.elements[i22].height;
      }
      renderer.shader.bind(shaderHere);
      if (shaderChange) {
        renderer.geometry.bind(geometry);
      }
      for (let j4 = 0;j4 < groupTextureCount; j4++) {
        renderer.texture.bind(texArray.elements[j4], j4);
      }
      renderer.geometry.draw(DRAW_MODES.TRIANGLES, size, start);
    }
  }
  _resolveDirectShader(_renderer) {
    let shader = this.shader;
    const pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS2[pluginName]) {
        DEFAULT_SHADERS2[pluginName] = new SmoothGraphicsShader(this.shaderSettings);
      }
      shader = DEFAULT_SHADERS2[pluginName];
    }
    return shader;
  }
  _calculateBounds() {
    this.finishPoly();
    const geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    const { minX, minY, maxX, maxY } = geometry.bounds;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, _SmoothGraphics._TEMP_POINT);
    return this._geometry.containsPoint(_SmoothGraphics._TEMP_POINT);
  }
  calculateTints() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this._tintColor.toNumber();
      for (let i3 = 0;i3 < this.batches.length; i3++) {
        const batch = this.batches[i3];
        batch._tintRGB = Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
      }
    }
  }
  calculateVertices() {
    const wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    const wt = this.transform.worldTransform;
    const a3 = wt.a;
    const b4 = wt.b;
    const c3 = wt.c;
    const d3 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const data = this._geometry.points;
    const vertexData = this.vertexData;
    let count = 0;
    for (let i3 = 0;i3 < data.length; i3 += 2) {
      const x3 = data[i3];
      const y3 = data[i3 + 1];
      vertexData[count++] = a3 * x3 + c3 * y3 + tx;
      vertexData[count++] = d3 * y3 + b4 * x3 + ty;
    }
  }
  closePath() {
    const currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
    }
    return this;
  }
  setMatrix(matrix) {
    this._matrix = matrix;
    return this;
  }
  beginHole() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  }
  endHole() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  }
  destroy(options) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    super.destroy(options);
  }
};
var SmoothGraphics = _SmoothGraphics;
SmoothGraphics.curves = curves;
SmoothGraphics._TEMP_POINT = new Point3;
// node_modules/colord/plugi
function getParabola(p1, p22, p3) {
  const [x1, y1] = p1;
  const [x22, y22] = p22;
  const [x3, y3] = p3;
  const A3 = ((y22 - y1) * (x3 - x22) - (y3 - y22) * (x22 - x1)) / ((x22 * x22 - x1 * x1) * (x3 - x22) - (x3 * x3 - x22 * x22) * (x22 - x1));
  const B5 = (y22 - y1 - A3 * (x22 * x22 - x1 * x1)) / (x22 - x1);
  const C4 = y1 - A3 * x1 * x1 - B5 * x1;
  return (x4) => A3 * x4 * x4 + B5 * x4 + C4;
}

// node_modules/colord/plugins/names.mj
curves.adaptive = false;

class SimuloViewerPIXI {
  coll2gfx;
  renderer;
  scene;
  viewport;
  canvas;
  prevGFXPositions = {};
  panInputs = {
    up: false,
    left: false,
    down: false,
    right: false
  };
  listeners = {};
  on(event, callback) {
    if (!this.listeners[event])
      this.listeners[event] = [];
    this.listeners[event].push(callback);
  }
  off(event, callback) {
    if (!this.listeners[event])
      return;
    this.listeners[event].splice(this.listeners[event].indexOf(callback), 1);
  }
  previousMousePos = { x: 0, y: 0 };
  updateMouse(eventName, position, e3) {
    if (position) {
      this.previousMousePos = { x: position.x, y: position.y };
      if (this.listeners[eventName]) {
        let point = this.viewport.toWorld(position.x, position.y);
        this.listeners[eventName].forEach((callback) => callback({
          event: e3 ?? null,
          point: { x: point.x, y: -point.y }
        }));
      }
    } else {
      if (this.listeners[eventName]) {
        let point = this.viewport.toWorld(this.previousMousePos.x, this.previousMousePos.y);
        this.listeners[eventName].forEach((callback) => callback({
          event: e3 ?? null,
          point: { x: point.x, y: -point.y }
        }));
      }
    }
  }
  audioChannels = {};
  playSound(src, volume) {
    if (!this.audioChannels[src]) {
      this.audioChannels[src] = [];
      for (let i3 = 0;i3 < 8; i3++) {
        let audio2 = new Audio(src);
        this.audioChannels[src].push(audio2);
      }
    }
    let audio = this.audioChannels[src].find((audio2) => audio2.paused);
    if (audio) {
      audio.currentTime = 0;
      audio.volume = volume;
      audio.play();
    } else {
      this.audioChannels[src][0].currentTime = 0;
      this.audioChannels[src][0].volume = volume;
      this.audioChannels[src][0].play();
    }
  }
  mouseDown = false;
  constructor() {
    this.audioChannels = {};
    const pixelRatio = window.devicePixelRatio ? Math.min(window.devicePixelRatio, 1.5) : 1;
    this.coll2gfx = new Map;
    this.renderer = new Renderer({
      backgroundAlpha: 0,
      antialias: true,
      resolution: pixelRatio,
      width: window.innerWidth,
      height: window.innerHeight
    });
    this.scene = new Container;
    this.canvas = document.body.appendChild(this.renderer.view);
    this.viewport = new ht2({
      screenWidth: window.innerWidth,
      screenHeight: window.innerHeight,
      events: this.renderer.events
    });
    this.scene.addChild(this.viewport);
    this.viewport.drag({
      mouseButtons: "middle-right"
    }).pinch().wheel().decelerate();
    this.viewport.on("pointermove", (e3) => {
      this.updateMouse("pointermove", { x: e3.globalX, y: e3.globalY }, e3);
    });
    this.viewport.on("pointerdown", (e3) => {
      this.mouseDown = true;
      this.updateMouse("pointerdown", { x: e3.globalX, y: e3.globalY }, e3);
    });
    this.viewport.on("pointerup", (e3) => {
      this.mouseDown = false;
      this.updateMouse("pointerup", { x: e3.globalX, y: e3.globalY }, e3);
    });
    this.canvas.addEventListener("keydown", (e3) => {
      if (e3.key === "h") {
        this.panInputs.left = true;
      }
      if (e3.key === "j") {
        this.panInputs.down = true;
      }
      if (e3.key === "k") {
        this.panInputs.up = true;
      }
      if (e3.key === "l") {
        this.panInputs.right = true;
      }
    });
    this.canvas.addEventListener("keyup", (e3) => {
      if (e3.key === "h") {
        this.panInputs.left = false;
      }
      if (e3.key === "j") {
        this.panInputs.down = false;
      }
      if (e3.key === "k") {
        this.panInputs.up = false;
      }
      if (e3.key === "l") {
        this.panInputs.right = false;
      }
    });
    setInterval(() => {
      let x3 = 0;
      let y3 = 0;
      let speed = 2 / this.viewport.scale.y;
      if (this.panInputs.left) {
        x3 = -1;
      }
      if (this.panInputs.down) {
        y3 = 1;
      }
      if (this.panInputs.up) {
        y3 = -1;
      }
      if (this.panInputs.right) {
        x3 = 1;
      }
      if (x3 !== 0 || y3 !== 0) {
        x3 *= speed;
        y3 *= speed;
        this.viewport.moveCenter(this.viewport.center.x + x3, this.viewport.center.y + y3);
      }
      this.updateMouse("pointermove");
    }, 10);
    let me = this;
    function onWindowResize() {
      me.renderer.resize(window.innerWidth, window.innerHeight);
      me.viewport.resize(window.innerWidth, window.innerHeight);
    }
    function onContextMenu(event) {
      event.preventDefault();
    }
    document.oncontextmenu = onContextMenu;
    document.body.oncontextmenu = onContextMenu;
    window.addEventListener("resize", onWindowResize, false);
    this.lookAt({
      target: { x: -10, y: -30 },
      zoom: 7
    });
  }
  tempGFXs = [];
  shapeContents = {};
  update(worldUpdate) {
    worldUpdate.delta.removedContents.forEach((id) => {
      let gfx = this.coll2gfx.get(id);
      if (gfx) {
        this.viewport.removeChild(gfx.gfx);
        gfx.gfx.destroy();
        this.coll2gfx.delete(id);
      }
    });
    for (let key in worldUpdate.delta.shapeContent) {
      let content = worldUpdate.delta.shapeContent[key];
      this.addShape(content);
    }
    let parabolas = this.updatePositions(worldUpdate.delta.shapeTransforms);
    this.tempGFXs.forEach((gfx) => {
      this.viewport.removeChild(gfx);
    });
    this.tempGFXs = [];
    worldUpdate.springs.forEach((spring) => {
      let gfx = new Graphics;
      gfx.lineStyle(3 / this.viewport.scale.y, "#ffffff").moveTo(spring.pointA.x, -spring.pointA.y).lineTo(spring.pointB.x, -spring.pointB.y);
      this.tempGFXs.push(gfx);
      this.viewport.addChild(gfx);
    });
    for (let parabola of parabolas) {
      let gfx = new Graphics;
      gfx.lineStyle(2 / this.viewport.scale.y, "#ffffff", 0.2);
      for (let x3 = parabola.x - 1000;x3 < parabola.x + 1000; x3 += 0.5) {
        if (x3 === parabola.x - 1000) {
          gfx.moveTo(x3, -parabola.parabola(x3));
          continue;
        }
        const y3 = parabola.parabola(x3);
        gfx.lineTo(x3, -y3);
      }
      this.tempGFXs.push(gfx);
      this.viewport.addChild(gfx);
    }
    worldUpdate.overlays.shapes.forEach((shape) => {
      let content = shape.content;
      let transform = shape.transform;
      let gfx = this.renderShape(content);
      gfx.position.x = transform.x;
      gfx.position.y = -transform.y;
      gfx.rotation = -transform.angle;
      this.tempGFXs.push(gfx);
      this.viewport.addChild(gfx);
    });
    worldUpdate.overlays.texts.forEach((text7) => {
    });
    worldUpdate.sounds.forEach((sound) => {
    });
    let selectedShapes = [];
    Object.keys(worldUpdate.selectedObjects).forEach((key) => {
      let selectedObjects = worldUpdate.selectedObjects[key];
      selectedObjects.forEach((content) => {
        let realGfx = this.coll2gfx.get(content.id);
        if (realGfx && !realGfx.selected) {
          let posX = realGfx.gfx.position.x;
          let posY = realGfx.gfx.position.y;
          let rotation = realGfx.gfx.rotation;
          this.viewport.removeChild(realGfx.gfx);
          realGfx.gfx.destroy();
          this.coll2gfx.delete(content.id);
          let gfx = this.renderShape({
            ...content,
            border: 16777215,
            borderWidth: 3
          });
          this.shapeContents[content.id] = content;
          gfx.position.x = posX;
          gfx.position.y = posY;
          gfx.rotation = rotation;
          this.coll2gfx.set(content.id, { selected: true, gfx });
          this.viewport.addChild(gfx);
        }
        selectedShapes.push(content.id);
      });
    });
    this.coll2gfx.forEach((gfx, key) => {
      if (!selectedShapes.includes(key) && gfx.selected) {
        let posX = gfx.gfx.position.x;
        let posY = gfx.gfx.position.y;
        let rotation = gfx.gfx.rotation;
        this.viewport.removeChild(gfx.gfx);
        gfx.gfx.destroy();
        let newGfx = this.renderShape(this.shapeContents[key]);
        newGfx.position.x = posX;
        newGfx.position.y = posY;
        newGfx.rotation = rotation;
        this.coll2gfx.set(key, { selected: false, gfx: newGfx });
        this.viewport.addChild(newGfx);
      }
    });
  }
  render() {
    this.renderer.render(this.scene);
  }
  lookAt(pos) {
    this.viewport.setZoom(pos.zoom);
    this.viewport.moveCenter(pos.target.x, pos.target.y);
  }
  updatePositions(transformData) {
    let parabolas = [];
    Object.keys(transformData).forEach((id) => {
      let gfx = this.coll2gfx.get(id);
      let data = transformData[id];
      let position = { x: data.x, y: data.y };
      let angle = data.angle;
      if (!!gfx) {
        gfx.gfx.position.x = position.x;
        gfx.gfx.position.y = -position.y;
        gfx.gfx.rotation = -angle;
        if (gfx.gfx instanceof SmoothGraphics) {
          if (!this.prevGFXPositions[id]) {
            this.prevGFXPositions[id] = [];
          }
          let prevPos = this.prevGFXPositions[id];
          if (prevPos.length > 2) {
            this.prevGFXPositions[id] = [prevPos[prevPos.length - 2], prevPos[prevPos.length - 1]];
          }
          this.prevGFXPositions[id].push({ x: position.x, y: position.y });
          prevPos = this.prevGFXPositions[id];
          if (prevPos.length === 3 && !this.mouseDown) {
            let dist = Math.abs(prevPos[0].x - prevPos[2].x);
            if (dist >= 0.1) {
              let parabola = getParabola([prevPos[0].x, prevPos[0].y], [prevPos[1].x, prevPos[1].y], [prevPos[2].x, prevPos[2].y]);
              parabolas.push({
                parabola,
                x: position.x
              });
            }
          }
        }
      }
    });
    return parabolas;
  }
  reset() {
    this.coll2gfx.forEach((gfx) => {
      this.viewport.removeChild(gfx.gfx);
      gfx.gfx.destroy();
    });
    this.coll2gfx = new Map;
    this.prevGFXPositions = {};
  }
  renderShape(content) {
    let gfx;
    if (content.border !== null) {
      gfx = new SmoothGraphics;
      gfx.lineStyle(content.borderWidth ?? 1, content.border, 1, 0, LINE_SCALE_MODE.NONE);
    } else {
      gfx = new Graphics;
    }
    gfx.alpha = content.alpha;
    switch (content.type) {
      case "cuboid":
        let rectangle = content;
        gfx.beginFill(rectangle.color);
        gfx.moveTo(-rectangle.width / 2, rectangle.height / 2);
        gfx.lineTo(rectangle.width / 2, rectangle.height / 2);
        gfx.lineTo(rectangle.width / 2, -rectangle.height / 2);
        gfx.lineTo(-rectangle.width / 2, -rectangle.height / 2);
        gfx.lineTo(-rectangle.width / 2, rectangle.height / 2);
        gfx.endFill();
        break;
      case "ball":
        let circle = content;
        gfx.beginFill(circle.color);
        let segments = 50;
        let size = 2 * Math.PI / segments;
        gfx.moveTo(0, circle.radius);
        for (let i3 = 0;i3 < segments; i3++) {
          gfx.lineTo(Math.sin(size * i3) * circle.radius, Math.cos(size * i3) * circle.radius);
        }
        gfx.lineTo(0, circle.radius);
        gfx.endFill();
        if (circle.cakeSlice) {
          if (gfx instanceof SmoothGraphics) {
            gfx.lineStyle(0);
          } else {
            gfx.lineStyle(0);
          }
          gfx.beginFill(0, 0.5);
          gfx.moveTo(0, 0);
          gfx.arc(0, 0, circle.radius, -Math.PI / 16, Math.PI / 16);
          gfx.lineTo(0, 0);
          gfx.endFill();
        }
        break;
      case "polygon":
        let polygon = content;
        gfx.beginFill(polygon.color);
        gfx.moveTo(polygon.points[0][0], -polygon.points[0][1]);
        for (let i3 = 1;i3 < polygon.points.length; i3++) {
          gfx.lineTo(polygon.points[i3][0], -polygon.points[i3][1]);
        }
        gfx.lineTo(polygon.points[0][0], -polygon.points[0][1]);
        gfx.endFill();
        break;
      case "plane":
        gfx.beginFill(content.color);
        gfx.moveTo(-1e5, 0);
        gfx.lineTo(1e5, 0);
        gfx.lineTo(1e5, 1e5);
        gfx.lineTo(-1e5, 1e5);
        gfx.lineTo(-1e5, 0);
        gfx.endFill();
        break;
      default:
        console.error("Unknown shape type: " + content.type);
        break;
    }
    return gfx;
  }
  addShape(content) {
    if (this.coll2gfx.has(content.id)) {
      let gfx2 = this.coll2gfx.get(content.id);
      if (gfx2) {
        this.viewport.removeChild(gfx2.gfx);
      }
    }
    let gfx = this.renderShape(content);
    this.coll2gfx.set(content.id, { selected: false, gfx });
    this.viewport.addChild(gfx);
  }
}

// node_modules/colord/plugins/names.mjsist
var generateUUID = function() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d22 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d22 & 63 | 128] + _lut[d22 >> 8 & 255] + "-" + _lut[d22 >> 16 & 255] + _lut[d22 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
};
var clamp = function(value, min, max) {
  return Math.max(min, Math.min(max, value));
};
var euclideanModulo = function(n4, m4) {
  return (n4 % m4 + m4) % m4;
};
var mapLinear = function(x3, a1, a22, b1, b22) {
  return b1 + (x3 - a1) * (b22 - b1) / (a22 - a1);
};
var inverseLerp = function(x3, y3, value) {
  if (x3 !== y3) {
    return (value - x3) / (y3 - x3);
  } else {
    return 0;
  }
};
var lerp2 = function(x3, y3, t4) {
  return (1 - t4) * x3 + t4 * y3;
};
var damp = function(x3, y3, lambda, dt) {
  return lerp2(x3, y3, 1 - Math.exp(-lambda * dt));
};
var pingpong = function(x3, length2 = 1) {
  return length2 - Math.abs(euclideanModulo(x3, length2 * 2) - length2);
};
var smoothstep = function(x3, min, max) {
  if (x3 <= min)
    return 0;
  if (x3 >= max)
    return 1;
  x3 = (x3 - min) / (max - min);
  return x3 * x3 * (3 - 2 * x3);
};
var smootherstep = function(x3, min, max) {
  if (x3 <= min)
    return 0;
  if (x3 >= max)
    return 1;
  x3 = (x3 - min) / (max - min);
  return x3 * x3 * x3 * (x3 * (x3 * 6 - 15) + 10);
};
var randInt = function(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
};
var randFloat = function(low, high) {
  return low + Math.random() * (high - low);
};
var randFloatSpread = function(range) {
  return range * (0.5 - Math.random());
};
var seededRandom = function(s3) {
  if (s3 !== undefined)
    _seed = s3;
  let t4 = _seed += 1831565813;
  t4 = Math.imul(t4 ^ t4 >>> 15, t4 | 1);
  t4 ^= t4 + Math.imul(t4 ^ t4 >>> 7, t4 | 61);
  return ((t4 ^ t4 >>> 14) >>> 0) / 4294967296;
};
var degToRad = function(degrees) {
  return degrees * DEG2RAD;
};
var radToDeg = function(radians) {
  return radians * RAD2DEG;
};
var isPowerOfTwo = function(value) {
  return (value & value - 1) === 0 && value !== 0;
};
var ceilPowerOfTwo = function(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
};
var floorPowerOfTwo = function(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
};
var setQuaternionFromProperEuler = function(q3, a3, b4, c3, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c22 = cos(b4 / 2);
  const s22 = sin(b4 / 2);
  const c13 = cos((a3 + c3) / 2);
  const s13 = sin((a3 + c3) / 2);
  const c1_3 = cos((a3 - c3) / 2);
  const s1_3 = sin((a3 - c3) / 2);
  const c3_1 = cos((c3 - a3) / 2);
  const s3_1 = sin((c3 - a3) / 2);
  switch (order) {
    case "XYX":
      q3.set(c22 * s13, s22 * c1_3, s22 * s1_3, c22 * c13);
      break;
    case "YZY":
      q3.set(s22 * s1_3, c22 * s13, s22 * c1_3, c22 * c13);
      break;
    case "ZXZ":
      q3.set(s22 * c1_3, s22 * s1_3, c22 * s13, c22 * c13);
      break;
    case "XZX":
      q3.set(c22 * s13, s22 * s3_1, s22 * c3_1, c22 * c13);
      break;
    case "YXY":
      q3.set(s22 * c3_1, c22 * s13, s22 * s3_1, c22 * c13);
      break;
    case "ZYZ":
      q3.set(s22 * s3_1, s22 * c3_1, c22 * s13, c22 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
};
var denormalize = function(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
};
var normalize2 = function(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
};
var arrayNeedsUint32 = function(array) {
  for (let i3 = array.length - 1;i3 >= 0; --i3) {
    if (array[i3] >= 65535)
      return true;
  }
  return false;
};
var createElementNS = function(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
};
var createCanvasElement = function() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
};
var warnOnce = function(message) {
  if (message in _cache)
    return;
  _cache[message] = true;
  console.warn(message);
};
var SRGBToLinear = function(c3) {
  return c3 < 0.04045 ? c3 * 0.0773993808 : Math.pow(c3 * 0.9478672986 + 0.0521327014, 2.4);
};
var LinearToSRGB = function(c3) {
  return c3 < 0.0031308 ? c3 * 12.92 : 1.055 * Math.pow(c3, 0.41666) - 0.055;
};
var DisplayP3ToLinearSRGB = function(color8) {
  return color8.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB);
};
var LinearSRGBToDisplayP3 = function(color8) {
  return color8.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB();
};
var serializeImage = function(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
};
var satForAxes = function(axes, v02, v1, v22, extents) {
  for (let i3 = 0, j4 = axes.length - 3;i3 <= j4; i3 += 3) {
    _testAxis.fromArray(axes, i3);
    const r4 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v02.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p22 = v22.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p22), Math.min(p0, p1, p22)) > r4) {
      return false;
    }
  }
  return true;
};
var hue2rgb = function(p3, q3, t4) {
  if (t4 < 0)
    t4 += 1;
  if (t4 > 1)
    t4 -= 1;
  if (t4 < 1 / 6)
    return p3 + (q3 - p3) * 6 * t4;
  if (t4 < 1 / 2)
    return q3;
  if (t4 < 2 / 3)
    return p3 + (q3 - p3) * 6 * (2 / 3 - t4);
  return p3;
};
var checkIntersection = function(object, material, raycaster, ray, pA2, pB, pC, point) {
  let intersect2;
  if (material.side === BackSide) {
    intersect2 = ray.intersectTriangle(pC, pB, pA2, true, point);
  } else {
    intersect2 = ray.intersectTriangle(pA2, pB, pC, material.side === FrontSide, point);
  }
  if (intersect2 === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance3 = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance3 < raycaster.near || distance3 > raycaster.far)
    return null;
  return {
    distance: distance3,
    point: _intersectionPointWorld.clone(),
    object
  };
};
var checkGeometryIntersection = function(object, material, raycaster, ray, uv, uv1, normal, a3, b4, c3) {
  object.getVertexPosition(a3, _vA$1);
  object.getVertexPosition(b4, _vB$1);
  object.getVertexPosition(c3, _vC$1);
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a3);
      _uvB$1.fromBufferAttribute(uv, b4);
      _uvC$1.fromBufferAttribute(uv, c3);
      intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2);
    }
    if (uv1) {
      _uvA$1.fromBufferAttribute(uv1, a3);
      _uvB$1.fromBufferAttribute(uv1, b4);
      _uvC$1.fromBufferAttribute(uv1, c3);
      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2);
      intersection.uv2 = intersection.uv1;
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a3);
      _normalB.fromBufferAttribute(normal, b4);
      _normalC.fromBufferAttribute(normal, c3);
      intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3);
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a: a3,
      b: b4,
      c: c3,
      normal: new Vector3,
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
};
var cloneUniforms = function(src) {
  const dst = {};
  for (const u6 in src) {
    dst[u6] = {};
    for (const p3 in src[u6]) {
      const property = src[u6][p3];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        if (property.isRenderTargetTexture) {
          console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
          dst[u6][p3] = null;
        } else {
          dst[u6][p3] = property.clone();
        }
      } else if (Array.isArray(property)) {
        dst[u6][p3] = property.slice();
      } else {
        dst[u6][p3] = property;
      }
    }
  }
  return dst;
};
var mergeUniforms = function(uniforms) {
  const merged = {};
  for (let u6 = 0;u6 < uniforms.length; u6++) {
    const tmp16 = cloneUniforms(uniforms[u6]);
    for (const p3 in tmp16) {
      merged[p3] = tmp16[p3];
    }
  }
  return merged;
};
var cloneUniformsGroups = function(src) {
  const dst = [];
  for (let u6 = 0;u6 < src.length; u6++) {
    dst.push(src[u6].clone());
  }
  return dst;
};
var getUnlitUniformColorSpace = function(renderer) {
  if (renderer.getRenderTarget() === null) {
    return renderer.outputColorSpace;
  }
  return LinearSRGBColorSpace;
};
var WebGLAnimation = function() {
  let context2 = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context2.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context2.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context2.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context2 = value;
    }
  };
};
var WebGLAttributes = function(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap;
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = gl.HALF_FLOAT;
        } else {
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
    attribute.onUploadCallback();
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === undefined) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
};
var WebGLBackground = function(renderer, cubemaps, cubeuvmaps, state, objects, alpha2, premultipliedAlpha) {
  const clearColor = new Color2(0);
  let clearAlpha = alpha2 === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      const usePMREM = scene.backgroundBlurriness > 0;
      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
    } else if (environmentBlendMode === "alpha-blend") {
      state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === undefined) {
        boxMesh = new Mesh2(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
          vertexShader: ShaderLib.backgroundCube.vertexShader,
          fragmentShader: ShaderLib.backgroundCube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      boxMesh.material.toneMapped = background.colorSpace === SRGBColorSpace ? false : true;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      boxMesh.layers.enableAll();
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === undefined) {
        planeMesh = new Mesh2(new PlaneGeometry3(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      planeMesh.material.toneMapped = background.colorSpace === SRGBColorSpace ? false : true;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      planeMesh.layers.enableAll();
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color8, alpha3) {
    color8.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha3, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color8, alpha3 = 1) {
      clearColor.set(color8);
      clearAlpha = alpha3;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha3) {
      clearAlpha = alpha3;
      setClear(clearColor, clearAlpha);
    },
    render
  };
};
var WebGLBindingStates = function(gl, extensions31, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const extension = capabilities.isWebGL2 ? null : extensions31.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index2) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(object, geometry, program, index2);
      if (updateBuffers)
        saveCache(object, geometry, program, index2);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (index2 !== null) {
      attributes.update(index2, gl.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index2 !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index2).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === undefined) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === undefined) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === undefined) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i3 = 0;i3 < maxVertexAttributes; i3++) {
      newAttributes[i3] = 0;
      enabledAttributes[i3] = 0;
      attributeDivisors[i3] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(object, geometry, program, index2) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name];
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === undefined) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === undefined)
          return true;
        if (cachedAttribute.attribute !== geometryAttribute)
          return true;
        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data)
          return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index2)
      return true;
    return false;
  }
  function saveCache(object, geometry, program, index2) {
    const cache2 = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name];
        if (attribute === undefined) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            attribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            attribute = object.instanceColor;
        }
        const data = {};
        data.attribute = attribute;
        if (attribute && attribute.data) {
          data.data = attribute.data;
        }
        cache2[name] = data;
        attributesNum++;
      }
    }
    currentState.attributes = cache2;
    currentState.attributesNum = attributesNum;
    currentState.index = index2;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i3 = 0, il = newAttributes.length;i3 < il; i3++) {
      newAttributes[i3] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions31.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i3 = 0, il = enabledAttributes.length;i3 < il; i3++) {
      if (enabledAttributes[i3] !== newAttributes[i3]) {
        gl.disableVertexAttribArray(i3);
        enabledAttributes[i3] = 0;
      }
    }
  }
  function vertexAttribPointer(index2, size, type, normalized, stride, offset, integer) {
    if (integer === true) {
      gl.vertexAttribIPointer(index2, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index2, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions31.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === undefined) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== undefined) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === undefined)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          const integer = capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType);
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i3 = 0;i3 < programAttribute.locationSize; i3++) {
                enableAttributeAndDivisor(programAttribute.location + i3, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i3 = 0;i3 < programAttribute.locationSize; i3++) {
                enableAttribute(programAttribute.location + i3);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i3 = 0;i3 < programAttribute.locationSize; i3++) {
              vertexAttribPointer(programAttribute.location + i3, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i3) * bytesPerElement, integer);
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i3 = 0;i3 < programAttribute.locationSize; i3++) {
                enableAttributeAndDivisor(programAttribute.location + i3, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i3 = 0;i3 < programAttribute.locationSize; i3++) {
                enableAttribute(programAttribute.location + i3);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i3 = 0;i3 < programAttribute.locationSize; i3++) {
              vertexAttribPointer(programAttribute.location + i3, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i3 * bytesPerElement, integer);
            }
          }
        } else if (materialDefaultAttributeValues !== undefined) {
          const value = materialDefaultAttributeValues[name];
          if (value !== undefined) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === undefined)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === undefined)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
};
var WebGLBufferRenderer = function(gl, extensions31, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions31.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
};
var WebGLCapabilities = function(gl, extensions31, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== undefined)
      return maxAnisotropy;
    if (extensions31.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions31.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision3) {
    if (precision3 === "highp") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision3 = "mediump";
    }
    if (precision3 === "mediump") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl.constructor.name === "WebGL2RenderingContext";
  let precision2 = parameters.precision !== undefined ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision2);
  if (maxPrecision !== precision2) {
    console.warn("THREE.WebGLRenderer:", precision2, "not supported, using", maxPrecision, "instead.");
    precision2 = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions31.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions31.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision: precision2,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
};
var WebGLClipping = function(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane2, viewNormalMatrix = new Matrix32, uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
  };
  this.setGlobalState = function(planes, camera) {
    globalState = projectPlanes(planes, camera, 0);
  };
  this.setState = function(material, camera, useCache) {
    const { clippingPlanes: planes, clipIntersection, clipShadows } = material;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i3 = 0;i3 !== lGlobal; ++i3) {
        dstArray[i3] = globalState[i3];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i3 = 0, i4 = dstOffset;i3 !== nPlanes; ++i3, i4 += 4) {
          plane.copy(planes[i3]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
};
var WebGLCubeMaps = function(renderer) {
  let cubemaps = new WeakMap;
  function mapTextureMapping(texture3, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture3.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture3.mapping = CubeRefractionMapping;
    }
    return texture3;
  }
  function get(texture3) {
    if (texture3 && texture3.isTexture && texture3.isRenderTargetTexture === false) {
      const mapping = texture3.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture3)) {
          const cubemap = cubemaps.get(texture3).texture;
          return mapTextureMapping(cubemap, texture3.mapping);
        } else {
          const image = texture3.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture3);
            cubemaps.set(texture3, renderTarget);
            texture3.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture3.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture3;
  }
  function onTextureDispose(event) {
    const texture3 = event.target;
    texture3.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture3);
    if (cubemap !== undefined) {
      cubemaps.delete(texture3);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = new WeakMap;
  }
  return {
    get,
    dispose
  };
};
var _createPlanes = function(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i3 = 0;i3 < totalLods; i3++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i3 > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i3 - lodMax + LOD_MIN - 1];
    } else if (i3 === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min = -texelSize;
    const max = 1 + texelSize;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0;face < cubeFaces; face++) {
      const x3 = face % 3 * 2 / 3 - 1;
      const y3 = face > 2 ? 0 : -1;
      const coordinates = [
        x3,
        y3,
        0,
        x3 + 2 / 3,
        y3,
        0,
        x3 + 2 / 3,
        y3 + 1,
        0,
        x3,
        y3,
        0,
        x3 + 2 / 3,
        y3 + 1,
        0,
        x3,
        y3 + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry;
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
};
var _createRenderTarget = function(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
};
var _setViewport = function(target, x3, y3, width, height) {
  target.viewport.set(x3, y3, width, height);
  target.scissor.set(x3, y3, width, height);
};
var _getBlurShader = function(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      n: MAX_SAMPLES,
      CUBEUV_TEXEL_WIDTH: 1 / width,
      CUBEUV_TEXEL_HEIGHT: 1 / height,
      CUBEUV_MAX_MIP: `${lodMax}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: weights },
      latitudinal: { value: false },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
};
var _getEquirectMaterial = function() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
};
var _getCubemapMaterial = function() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
};
var _getCommonVertexShader = function() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
};
var WebGLCubeUVMaps = function(renderer) {
  let cubeUVmaps = new WeakMap;
  let pmremGenerator = null;
  function get(texture3) {
    if (texture3 && texture3.isTexture) {
      const mapping = texture3.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (texture3.isRenderTargetTexture && texture3.needsPMREMUpdate === true) {
          texture3.needsPMREMUpdate = false;
          let renderTarget = cubeUVmaps.get(texture3);
          if (pmremGenerator === null)
            pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture3, renderTarget) : pmremGenerator.fromCubemap(texture3, renderTarget);
          cubeUVmaps.set(texture3, renderTarget);
          return renderTarget.texture;
        } else {
          if (cubeUVmaps.has(texture3)) {
            return cubeUVmaps.get(texture3).texture;
          } else {
            const image = texture3.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null)
                pmremGenerator = new PMREMGenerator(renderer);
              const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture3) : pmremGenerator.fromCubemap(texture3);
              cubeUVmaps.set(texture3, renderTarget);
              texture3.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture3;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length2 = 6;
    for (let i3 = 0;i3 < length2; i3++) {
      if (image[i3] !== undefined)
        count++;
    }
    return count === length2;
  }
  function onTextureDispose(event) {
    const texture3 = event.target;
    texture3.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture3);
    if (cubemapUV !== undefined) {
      cubeUVmaps.delete(texture3);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = new WeakMap;
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose
  };
};
var WebGLExtensions = function(gl) {
  const extensions31 = {};
  function getExtension(name) {
    if (extensions31[name] !== undefined) {
      return extensions31[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions31[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
};
var WebGLGeometries = function(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = new WeakMap;
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    for (const name in geometry.morphAttributes) {
      const array = geometry.morphAttributes[name];
      for (let i3 = 0, l4 = array.length;i3 < l4; i3++) {
        attributes.remove(array[i3]);
      }
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i3 = 0, l4 = array.length;i3 < l4; i3++) {
        attributes.update(array[i3], gl.ARRAY_BUFFER);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices2 = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i3 = 0, l4 = array.length;i3 < l4; i3 += 3) {
        const a3 = array[i3 + 0];
        const b4 = array[i3 + 1];
        const c3 = array[i3 + 2];
        indices2.push(a3, b4, b4, c3, c3, a3);
      }
    } else if (geometryPosition !== undefined) {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i3 = 0, l4 = array.length / 3 - 1;i3 < l4; i3 += 3) {
        const a3 = i3 + 0;
        const b4 = i3 + 1;
        const c3 = i3 + 2;
        indices2.push(a3, b4, b4, c3, c3, a3);
      }
    } else {
      return;
    }
    const attribute = new ((arrayNeedsUint32(indices2)) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices2, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
};
var WebGLIndexedBufferRenderer = function(gl, extensions31, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions31.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
};
var WebGLInfo = function(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case gl.TRIANGLES:
        render.triangles += instanceCount * (count / 3);
        break;
      case gl.LINES:
        render.lines += instanceCount * (count / 2);
        break;
      case gl.LINE_STRIP:
        render.lines += instanceCount * (count - 1);
        break;
      case gl.LINE_LOOP:
        render.lines += instanceCount * count;
        break;
      case gl.POINTS:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
};
var numericalSort = function(a3, b4) {
  return a3[0] - b4[0];
};
var absNumericalSort = function(a3, b4) {
  return Math.abs(b4[1]) - Math.abs(a3[1]);
};
var WebGLMorphtargets = function(gl, capabilities, textures2) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = new WeakMap;
  const morph = new Vector4;
  const workInfluences = [];
  for (let i3 = 0;i3 < 8; i3++) {
    workInfluences[i3] = [i3, 0];
  }
  function update(object, geometry, program) {
    const objectInfluences = object.morphTargetInfluences;
    if (capabilities.isWebGL2 === true) {
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
      let entry = morphTextures.get(geometry);
      if (entry === undefined || entry.count !== morphTargetsCount) {
        let disposeTexture = function() {
          texture3.dispose();
          morphTextures.delete(geometry);
          geometry.removeEventListener("dispose", disposeTexture);
        };
        if (entry !== undefined)
          entry.texture.dispose();
        const hasMorphPosition = geometry.morphAttributes.position !== undefined;
        const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
        const hasMorphColors = geometry.morphAttributes.color !== undefined;
        const morphTargets = geometry.morphAttributes.position || [];
        const morphNormals = geometry.morphAttributes.normal || [];
        const morphColors = geometry.morphAttributes.color || [];
        let vertexDataCount = 0;
        if (hasMorphPosition === true)
          vertexDataCount = 1;
        if (hasMorphNormals === true)
          vertexDataCount = 2;
        if (hasMorphColors === true)
          vertexDataCount = 3;
        let width = geometry.attributes.position.count * vertexDataCount;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
        const texture3 = new DataArrayTexture(buffer, width, height, morphTargetsCount);
        texture3.type = FloatType;
        texture3.needsUpdate = true;
        const vertexDataStride = vertexDataCount * 4;
        for (let i3 = 0;i3 < morphTargetsCount; i3++) {
          const morphTarget = morphTargets[i3];
          const morphNormal = morphNormals[i3];
          const morphColor = morphColors[i3];
          const offset = width * height * 4 * i3;
          for (let j4 = 0;j4 < morphTarget.count; j4++) {
            const stride = j4 * vertexDataStride;
            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j4);
              buffer[offset + stride + 0] = morph.x;
              buffer[offset + stride + 1] = morph.y;
              buffer[offset + stride + 2] = morph.z;
              buffer[offset + stride + 3] = 0;
            }
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j4);
              buffer[offset + stride + 4] = morph.x;
              buffer[offset + stride + 5] = morph.y;
              buffer[offset + stride + 6] = morph.z;
              buffer[offset + stride + 7] = 0;
            }
            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j4);
              buffer[offset + stride + 8] = morph.x;
              buffer[offset + stride + 9] = morph.y;
              buffer[offset + stride + 10] = morph.z;
              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
            }
          }
        }
        entry = {
          count: morphTargetsCount,
          texture: texture3,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry, entry);
        geometry.addEventListener("dispose", disposeTexture);
      }
      let morphInfluencesSum = 0;
      for (let i3 = 0;i3 < objectInfluences.length; i3++) {
        morphInfluencesSum += objectInfluences[i3];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
      program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures2);
      program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
    } else {
      const length2 = objectInfluences === undefined ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === undefined || influences.length !== length2) {
        influences = [];
        for (let i3 = 0;i3 < length2; i3++) {
          influences[i3] = [i3, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i3 = 0;i3 < length2; i3++) {
        const influence = influences[i3];
        influence[0] = i3;
        influence[1] = objectInfluences[i3];
      }
      influences.sort(absNumericalSort);
      for (let i3 = 0;i3 < 8; i3++) {
        if (i3 < length2 && influences[i3][1]) {
          workInfluences[i3][0] = influences[i3][0];
          workInfluences[i3][1] = influences[i3][1];
        } else {
          workInfluences[i3][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i3][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry.morphAttributes.position;
      const morphNormals = geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i3 = 0;i3 < 8; i3++) {
        const influence = workInfluences[i3];
        const index2 = influence[0];
        const value = influence[1];
        if (index2 !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i3) !== morphTargets[index2]) {
            geometry.setAttribute("morphTarget" + i3, morphTargets[index2]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i3) !== morphNormals[index2]) {
            geometry.setAttribute("morphNormal" + i3, morphNormals[index2]);
          }
          morphInfluences[i3] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i3) === true) {
            geometry.deleteAttribute("morphTarget" + i3);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i3) === true) {
            geometry.deleteAttribute("morphNormal" + i3);
          }
          morphInfluences[i3] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update
  };
};
var WebGLObjects = function(gl, geometries, attributes, info) {
  let updateMap = new WeakMap;
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      if (updateMap.get(object) !== frame) {
        attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
        }
        updateMap.set(object, frame);
      }
    }
    if (object.isSkinnedMesh) {
      const skeleton = object.skeleton;
      if (updateMap.get(skeleton) !== frame) {
        skeleton.update();
        updateMap.set(skeleton, frame);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = new WeakMap;
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
};
var flatten = function(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n4 = nBlocks * blockSize;
  let r4 = arrayCacheF32[n4];
  if (r4 === undefined) {
    r4 = new Float32Array(n4);
    arrayCacheF32[n4] = r4;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r4, 0);
    for (let i3 = 1, offset = 0;i3 !== nBlocks; ++i3) {
      offset += blockSize;
      array[i3].toArray(r4, offset);
    }
  }
  return r4;
};
var arraysEqual = function(a3, b4) {
  if (a3.length !== b4.length)
    return false;
  for (let i3 = 0, l4 = a3.length;i3 < l4; i3++) {
    if (a3[i3] !== b4[i3])
      return false;
  }
  return true;
};
var copyArray = function(a3, b4) {
  for (let i3 = 0, l4 = b4.length;i3 < l4; i3++) {
    a3[i3] = b4[i3];
  }
};
var allocTexUnits = function(textures2, n4) {
  let r4 = arrayCacheI32[n4];
  if (r4 === undefined) {
    r4 = new Int32Array(n4);
    arrayCacheI32[n4] = r4;
  }
  for (let i3 = 0;i3 !== n4; ++i3) {
    r4[i3] = textures2.allocateTextureUnit();
  }
  return r4;
};
var setValueV1f = function(gl, v4) {
  const cache2 = this.cache;
  if (cache2[0] === v4)
    return;
  gl.uniform1f(this.addr, v4);
  cache2[0] = v4;
};
var setValueV2f = function(gl, v4) {
  const cache2 = this.cache;
  if (v4.x !== undefined) {
    if (cache2[0] !== v4.x || cache2[1] !== v4.y) {
      gl.uniform2f(this.addr, v4.x, v4.y);
      cache2[0] = v4.x;
      cache2[1] = v4.y;
    }
  } else {
    if (arraysEqual(cache2, v4))
      return;
    gl.uniform2fv(this.addr, v4);
    copyArray(cache2, v4);
  }
};
var setValueV3f = function(gl, v4) {
  const cache2 = this.cache;
  if (v4.x !== undefined) {
    if (cache2[0] !== v4.x || cache2[1] !== v4.y || cache2[2] !== v4.z) {
      gl.uniform3f(this.addr, v4.x, v4.y, v4.z);
      cache2[0] = v4.x;
      cache2[1] = v4.y;
      cache2[2] = v4.z;
    }
  } else if (v4.r !== undefined) {
    if (cache2[0] !== v4.r || cache2[1] !== v4.g || cache2[2] !== v4.b) {
      gl.uniform3f(this.addr, v4.r, v4.g, v4.b);
      cache2[0] = v4.r;
      cache2[1] = v4.g;
      cache2[2] = v4.b;
    }
  } else {
    if (arraysEqual(cache2, v4))
      return;
    gl.uniform3fv(this.addr, v4);
    copyArray(cache2, v4);
  }
};
var setValueV4f = function(gl, v4) {
  const cache2 = this.cache;
  if (v4.x !== undefined) {
    if (cache2[0] !== v4.x || cache2[1] !== v4.y || cache2[2] !== v4.z || cache2[3] !== v4.w) {
      gl.uniform4f(this.addr, v4.x, v4.y, v4.z, v4.w);
      cache2[0] = v4.x;
      cache2[1] = v4.y;
      cache2[2] = v4.z;
      cache2[3] = v4.w;
    }
  } else {
    if (arraysEqual(cache2, v4))
      return;
    gl.uniform4fv(this.addr, v4);
    copyArray(cache2, v4);
  }
};
var setValueM2 = function(gl, v4) {
  const cache2 = this.cache;
  const elements = v4.elements;
  if (elements === undefined) {
    if (arraysEqual(cache2, v4))
      return;
    gl.uniformMatrix2fv(this.addr, false, v4);
    copyArray(cache2, v4);
  } else {
    if (arraysEqual(cache2, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache2, elements);
  }
};
var setValueM3 = function(gl, v4) {
  const cache2 = this.cache;
  const elements = v4.elements;
  if (elements === undefined) {
    if (arraysEqual(cache2, v4))
      return;
    gl.uniformMatrix3fv(this.addr, false, v4);
    copyArray(cache2, v4);
  } else {
    if (arraysEqual(cache2, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache2, elements);
  }
};
var setValueM4 = function(gl, v4) {
  const cache2 = this.cache;
  const elements = v4.elements;
  if (elements === undefined) {
    if (arraysEqual(cache2, v4))
      return;
    gl.uniformMatrix4fv(this.addr, false, v4);
    copyArray(cache2, v4);
  } else {
    if (arraysEqual(cache2, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache2, elements);
  }
};
var setValueV1i = function(gl, v4) {
  const cache2 = this.cache;
  if (cache2[0] === v4)
    return;
  gl.uniform1i(this.addr, v4);
  cache2[0] = v4;
};
var setValueV2i = function(gl, v4) {
  const cache2 = this.cache;
  if (v4.x !== undefined) {
    if (cache2[0] !== v4.x || cache2[1] !== v4.y) {
      gl.uniform2i(this.addr, v4.x, v4.y);
      cache2[0] = v4.x;
      cache2[1] = v4.y;
    }
  } else {
    if (arraysEqual(cache2, v4))
      return;
    gl.uniform2iv(this.addr, v4);
    copyArray(cache2, v4);
  }
};
var setValueV3i = function(gl, v4) {
  const cache2 = this.cache;
  if (v4.x !== undefined) {
    if (cache2[0] !== v4.x || cache2[1] !== v4.y || cache2[2] !== v4.z) {
      gl.uniform3i(this.addr, v4.x, v4.y, v4.z);
      cache2[0] = v4.x;
      cache2[1] = v4.y;
      cache2[2] = v4.z;
    }
  } else {
    if (arraysEqual(cache2, v4))
      return;
    gl.uniform3iv(this.addr, v4);
    copyArray(cache2, v4);
  }
};
var setValueV4i = function(gl, v4) {
  const cache2 = this.cache;
  if (v4.x !== undefined) {
    if (cache2[0] !== v4.x || cache2[1] !== v4.y || cache2[2] !== v4.z || cache2[3] !== v4.w) {
      gl.uniform4i(this.addr, v4.x, v4.y, v4.z, v4.w);
      cache2[0] = v4.x;
      cache2[1] = v4.y;
      cache2[2] = v4.z;
      cache2[3] = v4.w;
    }
  } else {
    if (arraysEqual(cache2, v4))
      return;
    gl.uniform4iv(this.addr, v4);
    copyArray(cache2, v4);
  }
};
var setValueV1ui = function(gl, v4) {
  const cache2 = this.cache;
  if (cache2[0] === v4)
    return;
  gl.uniform1ui(this.addr, v4);
  cache2[0] = v4;
};
var setValueV2ui = function(gl, v4) {
  const cache2 = this.cache;
  if (v4.x !== undefined) {
    if (cache2[0] !== v4.x || cache2[1] !== v4.y) {
      gl.uniform2ui(this.addr, v4.x, v4.y);
      cache2[0] = v4.x;
      cache2[1] = v4.y;
    }
  } else {
    if (arraysEqual(cache2, v4))
      return;
    gl.uniform2uiv(this.addr, v4);
    copyArray(cache2, v4);
  }
};
var setValueV3ui = function(gl, v4) {
  const cache2 = this.cache;
  if (v4.x !== undefined) {
    if (cache2[0] !== v4.x || cache2[1] !== v4.y || cache2[2] !== v4.z) {
      gl.uniform3ui(this.addr, v4.x, v4.y, v4.z);
      cache2[0] = v4.x;
      cache2[1] = v4.y;
      cache2[2] = v4.z;
    }
  } else {
    if (arraysEqual(cache2, v4))
      return;
    gl.uniform3uiv(this.addr, v4);
    copyArray(cache2, v4);
  }
};
var setValueV4ui = function(gl, v4) {
  const cache2 = this.cache;
  if (v4.x !== undefined) {
    if (cache2[0] !== v4.x || cache2[1] !== v4.y || cache2[2] !== v4.z || cache2[3] !== v4.w) {
      gl.uniform4ui(this.addr, v4.x, v4.y, v4.z, v4.w);
      cache2[0] = v4.x;
      cache2[1] = v4.y;
      cache2[2] = v4.z;
      cache2[3] = v4.w;
    }
  } else {
    if (arraysEqual(cache2, v4))
      return;
    gl.uniform4uiv(this.addr, v4);
    copyArray(cache2, v4);
  }
};
var setValueT1 = function(gl, v4, textures2) {
  const cache2 = this.cache;
  const unit = textures2.allocateTextureUnit();
  if (cache2[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache2[0] = unit;
  }
  textures2.setTexture2D(v4 || emptyTexture, unit);
};
var setValueT3D1 = function(gl, v4, textures2) {
  const cache2 = this.cache;
  const unit = textures2.allocateTextureUnit();
  if (cache2[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache2[0] = unit;
  }
  textures2.setTexture3D(v4 || empty3dTexture, unit);
};
var setValueT6 = function(gl, v4, textures2) {
  const cache2 = this.cache;
  const unit = textures2.allocateTextureUnit();
  if (cache2[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache2[0] = unit;
  }
  textures2.setTextureCube(v4 || emptyCubeTexture, unit);
};
var setValueT2DArray1 = function(gl, v4, textures2) {
  const cache2 = this.cache;
  const unit = textures2.allocateTextureUnit();
  if (cache2[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache2[0] = unit;
  }
  textures2.setTexture2DArray(v4 || emptyArrayTexture, unit);
};
var getSingularSetter = function(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
};
var setValueV1fArray = function(gl, v4) {
  gl.uniform1fv(this.addr, v4);
};
var setValueV2fArray = function(gl, v4) {
  const data = flatten(v4, this.size, 2);
  gl.uniform2fv(this.addr, data);
};
var setValueV3fArray = function(gl, v4) {
  const data = flatten(v4, this.size, 3);
  gl.uniform3fv(this.addr, data);
};
var setValueV4fArray = function(gl, v4) {
  const data = flatten(v4, this.size, 4);
  gl.uniform4fv(this.addr, data);
};
var setValueM2Array = function(gl, v4) {
  const data = flatten(v4, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
};
var setValueM3Array = function(gl, v4) {
  const data = flatten(v4, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
};
var setValueM4Array = function(gl, v4) {
  const data = flatten(v4, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
};
var setValueV1iArray = function(gl, v4) {
  gl.uniform1iv(this.addr, v4);
};
var setValueV2iArray = function(gl, v4) {
  gl.uniform2iv(this.addr, v4);
};
var setValueV3iArray = function(gl, v4) {
  gl.uniform3iv(this.addr, v4);
};
var setValueV4iArray = function(gl, v4) {
  gl.uniform4iv(this.addr, v4);
};
var setValueV1uiArray = function(gl, v4) {
  gl.uniform1uiv(this.addr, v4);
};
var setValueV2uiArray = function(gl, v4) {
  gl.uniform2uiv(this.addr, v4);
};
var setValueV3uiArray = function(gl, v4) {
  gl.uniform3uiv(this.addr, v4);
};
var setValueV4uiArray = function(gl, v4) {
  gl.uniform4uiv(this.addr, v4);
};
var setValueT1Array = function(gl, v4, textures2) {
  const cache2 = this.cache;
  const n4 = v4.length;
  const units = allocTexUnits(textures2, n4);
  if (!arraysEqual(cache2, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache2, units);
  }
  for (let i3 = 0;i3 !== n4; ++i3) {
    textures2.setTexture2D(v4[i3] || emptyTexture, units[i3]);
  }
};
var setValueT3DArray = function(gl, v4, textures2) {
  const cache2 = this.cache;
  const n4 = v4.length;
  const units = allocTexUnits(textures2, n4);
  if (!arraysEqual(cache2, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache2, units);
  }
  for (let i3 = 0;i3 !== n4; ++i3) {
    textures2.setTexture3D(v4[i3] || empty3dTexture, units[i3]);
  }
};
var setValueT6Array = function(gl, v4, textures2) {
  const cache2 = this.cache;
  const n4 = v4.length;
  const units = allocTexUnits(textures2, n4);
  if (!arraysEqual(cache2, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache2, units);
  }
  for (let i3 = 0;i3 !== n4; ++i3) {
    textures2.setTextureCube(v4[i3] || emptyCubeTexture, units[i3]);
  }
};
var setValueT2DArrayArray = function(gl, v4, textures2) {
  const cache2 = this.cache;
  const n4 = v4.length;
  const units = allocTexUnits(textures2, n4);
  if (!arraysEqual(cache2, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache2, units);
  }
  for (let i3 = 0;i3 !== n4; ++i3) {
    textures2.setTexture2DArray(v4[i3] || emptyArrayTexture, units[i3]);
  }
};
var getPureArraySetter = function(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
};
var addUniform = function(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
};
var parseUniform = function(activeInfo, addr, container) {
  const path2 = activeInfo.name, pathLength = path2.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path2), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === undefined || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map4 = container.map;
      let next = map4[id];
      if (next === undefined) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
};
var WebGLShader = function(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
};
var handleSource = function(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to = Math.min(errorLine + 6, lines.length);
  for (let i3 = from;i3 < to; i3++) {
    const line = i3 + 1;
    lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i3]}`);
  }
  return lines2.join("\n");
};
var getEncodingComponents = function(colorSpace) {
  switch (colorSpace) {
    case LinearSRGBColorSpace:
      return ["Linear", "( value )"];
    case SRGBColorSpace:
      return ["sRGB", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported color space:", colorSpace);
      return ["Linear", "( value )"];
  }
};
var getShaderErrors = function(gl, shader, type) {
  const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "")
    return "";
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1]);
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
  } else {
    return errors;
  }
};
var getTexelEncodingFunction = function(functionName, colorSpace) {
  const components = getEncodingComponents(colorSpace);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
};
var getToneMappingFunction = function(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
};
var generateExtensions = function(parameters) {
  const chunks = [
    parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.normalMapTangentSpace || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
};
var generateDefines = function(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
};
var fetchAttributeLocations = function(gl, program) {
  const attributes = {};
  const n4 = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i3 = 0;i3 < n4; i3++) {
    const info = gl.getActiveAttrib(program, i3);
    const name = info.name;
    let locationSize = 1;
    if (info.type === gl.FLOAT_MAT2)
      locationSize = 2;
    if (info.type === gl.FLOAT_MAT3)
      locationSize = 3;
    if (info.type === gl.FLOAT_MAT4)
      locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
};
var filterEmptyLine = function(string) {
  return string !== "";
};
var replaceLightNums = function(string, parameters) {
  const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
};
var replaceClippingPlaneNums = function(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
};
var resolveIncludes = function(string) {
  return string.replace(includePattern, includeReplacer);
};
var includeReplacer = function(match, include) {
  let string = ShaderChunk[include];
  if (string === undefined) {
    const newInclude = shaderChunkMap.get(include);
    if (newInclude !== undefined) {
      string = ShaderChunk[newInclude];
      console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
    } else {
      throw new Error("Can not resolve #include <" + include + ">");
    }
  }
  return resolveIncludes(string);
};
var unrollLoops = function(string) {
  return string.replace(unrollLoopPattern, loopReplacer);
};
var loopReplacer = function(match, start, end, snippet) {
  let string = "";
  for (let i3 = parseInt(start);i3 < parseInt(end); i3++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i3 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i3);
  }
  return string;
};
var generatePrecision = function(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
};
var generateShadowMapTypeDefine = function(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
};
var generateEnvMapTypeDefine = function(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
};
var generateEnvMapModeDefine = function(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
};
var generateEnvMapBlendingDefine = function(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
};
var generateCubeUVSize = function(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null)
    return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
};
var WebGLProgram = function(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
      parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
      parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
      parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
      parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
      parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
      parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
      parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
      parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
      parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
      parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
      parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
      parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
      parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
      parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
      parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
      parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
      parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
      parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
      parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
      parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
      parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
      parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["colorspace_pars_fragment"],
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
      parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== undefined) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
      runnable = false;
      if (typeof renderer.debug.onShaderError === "function") {
        renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
      } else {
        const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
        const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
      }
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === undefined) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === undefined) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = undefined;
  };
  this.type = parameters.shaderType;
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
};
var WebGLPrograms = function(renderer, cubemaps, cubeuvmaps, extensions31, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers;
  const _customShaders = new WebGLShaderCache;
  const programs = [];
  const IS_WEBGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
  let precision2 = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getChannel(value) {
    if (value === 0)
      return "uv";
    return `uv${value}`;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    if (material.precision !== null) {
      precision2 = capabilities.getMaxPrecision(material.precision);
      if (precision2 !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision2, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== undefined)
      morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== undefined)
      morphTextureStride = 2;
    if (geometry.morphAttributes.color !== undefined)
      morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const IS_INSTANCEDMESH = object.isInstancedMesh === true;
    const HAS_MAP = !!material.map;
    const HAS_MATCAP = !!material.matcap;
    const HAS_ENVMAP = !!envMap;
    const HAS_AOMAP = !!material.aoMap;
    const HAS_LIGHTMAP = !!material.lightMap;
    const HAS_BUMPMAP = !!material.bumpMap;
    const HAS_NORMALMAP = !!material.normalMap;
    const HAS_DISPLACEMENTMAP = !!material.displacementMap;
    const HAS_EMISSIVEMAP = !!material.emissiveMap;
    const HAS_METALNESSMAP = !!material.metalnessMap;
    const HAS_ROUGHNESSMAP = !!material.roughnessMap;
    const HAS_ANISOTROPY = material.anisotropy > 0;
    const HAS_CLEARCOAT = material.clearcoat > 0;
    const HAS_IRIDESCENCE = material.iridescence > 0;
    const HAS_SHEEN = material.sheen > 0;
    const HAS_TRANSMISSION = material.transmission > 0;
    const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
    const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
    const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
    const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
    const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
    const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
    const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
    const HAS_SPECULARMAP = !!material.specularMap;
    const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
    const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
    const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
    const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
    const HAS_GRADIENTMAP = !!material.gradientMap;
    const HAS_ALPHAMAP = !!material.alphaMap;
    const HAS_ALPHATEST = material.alphaTest > 0;
    const HAS_ALPHAHASH = !!material.alphaHash;
    const HAS_EXTENSIONS = !!material.extensions;
    const HAS_ATTRIBUTE_UV1 = !!geometry.attributes.uv1;
    const HAS_ATTRIBUTE_UV2 = !!geometry.attributes.uv2;
    const HAS_ATTRIBUTE_UV3 = !!geometry.attributes.uv3;
    let toneMapping = NoToneMapping;
    if (material.toneMapped) {
      if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
        toneMapping = renderer.toneMapping;
      }
    }
    const parameters = {
      isWebGL2: IS_WEBGL2,
      shaderID,
      shaderType: material.type,
      shaderName: material.name,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision: precision2,
      instancing: IS_INSTANCEDMESH,
      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
      supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
      outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
      map: HAS_MAP,
      matcap: HAS_MATCAP,
      envMap: HAS_ENVMAP,
      envMapMode: HAS_ENVMAP && envMap.mapping,
      envMapCubeUVHeight,
      aoMap: HAS_AOMAP,
      lightMap: HAS_LIGHTMAP,
      bumpMap: HAS_BUMPMAP,
      normalMap: HAS_NORMALMAP,
      displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
      emissiveMap: HAS_EMISSIVEMAP,
      normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
      metalnessMap: HAS_METALNESSMAP,
      roughnessMap: HAS_ROUGHNESSMAP,
      anisotropy: HAS_ANISOTROPY,
      anisotropyMap: HAS_ANISOTROPYMAP,
      clearcoat: HAS_CLEARCOAT,
      clearcoatMap: HAS_CLEARCOATMAP,
      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
      iridescence: HAS_IRIDESCENCE,
      iridescenceMap: HAS_IRIDESCENCEMAP,
      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
      sheen: HAS_SHEEN,
      sheenColorMap: HAS_SHEEN_COLORMAP,
      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
      specularMap: HAS_SPECULARMAP,
      specularColorMap: HAS_SPECULAR_COLORMAP,
      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
      transmission: HAS_TRANSMISSION,
      transmissionMap: HAS_TRANSMISSIONMAP,
      thicknessMap: HAS_THICKNESSMAP,
      gradientMap: HAS_GRADIENTMAP,
      opaque: material.transparent === false && material.blending === NormalBlending,
      alphaMap: HAS_ALPHAMAP,
      alphaTest: HAS_ALPHATEST,
      alphaHash: HAS_ALPHAHASH,
      combine: material.combine,
      mapUv: HAS_MAP && getChannel(material.map.channel),
      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
      displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
      emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
      metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
      roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
      anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
      clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
      clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
      iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
      iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
      sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
      sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
      specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
      specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
      specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
      transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
      thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
      vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      vertexUv1s: HAS_ATTRIBUTE_UV1,
      vertexUv2s: HAS_ATTRIBUTE_UV2,
      vertexUv3s: HAS_ATTRIBUTE_UV3,
      pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: fog && fog.isFogExp2,
      flatShading: material.flatShading === true,
      sizeAttenuation: material.sizeAttenuation === true,
      logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== undefined,
      morphNormals: geometry.morphAttributes.normal !== undefined,
      morphColors: geometry.morphAttributes.color !== undefined,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numSpotLightMaps: lights.spotLightMap.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping,
      useLegacyLights: renderer._useLegacyLights,
      decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && material.map.colorSpace === SRGBColorSpace,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: material.depthPacking >= 0,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: HAS_EXTENSIONS && material.extensions.derivatives === true,
      extensionFragDepth: HAS_EXTENSIONS && material.extensions.fragDepth === true,
      extensionDrawBuffers: HAS_EXTENSIONS && material.extensions.drawBuffers === true,
      extensionShaderTextureLOD: HAS_EXTENSIONS && material.extensions.shaderTextureLOD === true,
      rendererExtensionFragDepth: IS_WEBGL2 || extensions31.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: IS_WEBGL2 || extensions31.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: IS_WEBGL2 || extensions31.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== undefined) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputColorSpace);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputColorSpace);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.mapUv);
    array.push(parameters.alphaMapUv);
    array.push(parameters.lightMapUv);
    array.push(parameters.aoMapUv);
    array.push(parameters.bumpMapUv);
    array.push(parameters.normalMapUv);
    array.push(parameters.displacementMapUv);
    array.push(parameters.emissiveMapUv);
    array.push(parameters.metalnessMapUv);
    array.push(parameters.roughnessMapUv);
    array.push(parameters.anisotropyMapUv);
    array.push(parameters.clearcoatMapUv);
    array.push(parameters.clearcoatNormalMapUv);
    array.push(parameters.clearcoatRoughnessMapUv);
    array.push(parameters.iridescenceMapUv);
    array.push(parameters.iridescenceThicknessMapUv);
    array.push(parameters.sheenColorMapUv);
    array.push(parameters.sheenRoughnessMapUv);
    array.push(parameters.specularMapUv);
    array.push(parameters.specularColorMapUv);
    array.push(parameters.specularIntensityMapUv);
    array.push(parameters.transmissionMapUv);
    array.push(parameters.thicknessMapUv);
    array.push(parameters.combine);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numSpotLightMaps);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.numSpotLightShadowsWithMaps);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.isWebGL2)
      _programLayers.enable(0);
    if (parameters.supportsVertexTextures)
      _programLayers.enable(1);
    if (parameters.instancing)
      _programLayers.enable(2);
    if (parameters.instancingColor)
      _programLayers.enable(3);
    if (parameters.matcap)
      _programLayers.enable(4);
    if (parameters.envMap)
      _programLayers.enable(5);
    if (parameters.normalMapObjectSpace)
      _programLayers.enable(6);
    if (parameters.normalMapTangentSpace)
      _programLayers.enable(7);
    if (parameters.clearcoat)
      _programLayers.enable(8);
    if (parameters.iridescence)
      _programLayers.enable(9);
    if (parameters.alphaTest)
      _programLayers.enable(10);
    if (parameters.vertexColors)
      _programLayers.enable(11);
    if (parameters.vertexAlphas)
      _programLayers.enable(12);
    if (parameters.vertexUv1s)
      _programLayers.enable(13);
    if (parameters.vertexUv2s)
      _programLayers.enable(14);
    if (parameters.vertexUv3s)
      _programLayers.enable(15);
    if (parameters.vertexTangents)
      _programLayers.enable(16);
    if (parameters.anisotropy)
      _programLayers.enable(17);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.fog)
      _programLayers.enable(0);
    if (parameters.useFog)
      _programLayers.enable(1);
    if (parameters.flatShading)
      _programLayers.enable(2);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(3);
    if (parameters.skinning)
      _programLayers.enable(4);
    if (parameters.morphTargets)
      _programLayers.enable(5);
    if (parameters.morphNormals)
      _programLayers.enable(6);
    if (parameters.morphColors)
      _programLayers.enable(7);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(8);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(9);
    if (parameters.useLegacyLights)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.useDepthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.transmission)
      _programLayers.enable(15);
    if (parameters.sheen)
      _programLayers.enable(16);
    if (parameters.opaque)
      _programLayers.enable(17);
    if (parameters.pointsUvs)
      _programLayers.enable(18);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(19);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p3 = 0, pl = programs.length;p3 < pl; p3++) {
      const preexistingProgram = programs[p3];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === undefined) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i3 = programs.indexOf(program);
      programs[i3] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    programs,
    dispose
  };
};
var WebGLProperties = function() {
  let properties = new WeakMap;
  function get(object) {
    let map4 = properties.get(object);
    if (map4 === undefined) {
      map4 = {};
      properties.set(object, map4);
    }
    return map4;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = new WeakMap;
  }
  return {
    get,
    remove,
    update,
    dispose
  };
};
var painterSortStable = function(a3, b4) {
  if (a3.groupOrder !== b4.groupOrder) {
    return a3.groupOrder - b4.groupOrder;
  } else if (a3.renderOrder !== b4.renderOrder) {
    return a3.renderOrder - b4.renderOrder;
  } else if (a3.material.id !== b4.material.id) {
    return a3.material.id - b4.material.id;
  } else if (a3.z !== b4.z) {
    return a3.z - b4.z;
  } else {
    return a3.id - b4.id;
  }
};
var reversePainterSortStable = function(a3, b4) {
  if (a3.groupOrder !== b4.groupOrder) {
    return a3.groupOrder - b4.groupOrder;
  } else if (a3.renderOrder !== b4.renderOrder) {
    return a3.renderOrder - b4.renderOrder;
  } else if (a3.z !== b4.z) {
    return b4.z - a3.z;
  } else {
    return a3.id - b4.id;
  }
};
var WebGLRenderList = function() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init2() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z3, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === undefined) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z: z3,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z3;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z3, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z3, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z3, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z3, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i3 = renderItemsIndex, il = renderItems.length;i3 < il; i3++) {
      const renderItem = renderItems[i3];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init: init2,
    push,
    unshift,
    finish,
    sort
  };
};
var WebGLRenderLists = function() {
  let lists = new WeakMap;
  function get(scene, renderCallDepth) {
    const listArray = lists.get(scene);
    let list;
    if (listArray === undefined) {
      list = new WebGLRenderList;
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= listArray.length) {
        list = new WebGLRenderList;
        listArray.push(list);
      } else {
        list = listArray[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = new WeakMap;
  }
  return {
    get,
    dispose
  };
};
var UniformsCache = function() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3,
            color: new Color2
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3,
            direction: new Vector3,
            color: new Color2,
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3,
            color: new Color2,
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3,
            skyColor: new Color2,
            groundColor: new Color2
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color2,
            position: new Vector3,
            halfWidth: new Vector3,
            halfHeight: new Vector3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
};
var ShadowUniformsCache = function() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2,
            shadowCameraNear: 1,
            shadowCameraFar: 1000
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
};
var shadowCastingAndTexturingLightsFirst = function(lightA, lightB) {
  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
};
var WebGLLights = function(extensions31, capabilities) {
  const cache2 = new UniformsCache;
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0
  };
  for (let i3 = 0;i3 < 9; i3++)
    state.probe.push(new Vector3);
  const vector3 = new Vector3;
  const matrix4 = new Matrix4;
  const matrix42 = new Matrix4;
  function setup(lights, useLegacyLights) {
    let r4 = 0, g5 = 0, b4 = 0;
    for (let i3 = 0;i3 < 9; i3++)
      state.probe[i3].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    let numSpotMaps = 0;
    let numSpotShadowsWithMaps = 0;
    lights.sort(shadowCastingAndTexturingLightsFirst);
    const scaleFactor = useLegacyLights === true ? Math.PI : 1;
    for (let i3 = 0, l4 = lights.length;i3 < l4; i3++) {
      const light = lights[i3];
      const color8 = light.color;
      const intensity = light.intensity;
      const distance3 = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r4 += color8.r * intensity * scaleFactor;
        g5 += color8.g * intensity * scaleFactor;
        b4 += color8.b * intensity * scaleFactor;
      } else if (light.isLightProbe) {
        for (let j4 = 0;j4 < 9; j4++) {
          state.probe[j4].addScaledVector(light.sh.coefficients[j4], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache2.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache2.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color8).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance3;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        state.spot[spotLength] = uniforms;
        const shadow = light.shadow;
        if (light.map) {
          state.spotLightMap[numSpotMaps] = light.map;
          numSpotMaps++;
          shadow.updateMatrices(light);
          if (light.castShadow)
            numSpotShadowsWithMaps++;
        }
        state.spotLightMatrix[spotLength] = shadow.matrix;
        if (light.castShadow) {
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          numSpotShadows++;
        }
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache2.get(light);
        uniforms.color.copy(color8).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache2.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache2.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions31.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions31.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r4;
    state.ambient[1] = g5;
    state.ambient[2] = b4;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
      state.spotLightMap.length = numSpotMaps;
      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      hash.numSpotMaps = numSpotMaps;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i3 = 0, l4 = lights.length;i3 < l4; i3++) {
      const light = lights[i3];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
};
var WebGLRenderState = function(extensions31, capabilities) {
  const lights = new WebGLLights(extensions31, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init2() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(useLegacyLights) {
    lights.setup(lightsArray, useLegacyLights);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init: init2,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
};
var WebGLRenderStates = function(extensions31, capabilities) {
  let renderStates = new WeakMap;
  function get(scene, renderCallDepth = 0) {
    const renderStateArray = renderStates.get(scene);
    let renderState;
    if (renderStateArray === undefined) {
      renderState = new WebGLRenderState(extensions31, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStateArray.length) {
        renderState = new WebGLRenderState(extensions31, capabilities);
        renderStateArray.push(renderState);
      } else {
        renderState = renderStateArray[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = new WeakMap;
  }
  return {
    get,
    dispose
  };
};
var WebGLShadowMap = function(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum;
  const _shadowMapSize = new Vector2, _viewportSize = new Vector2, _viewport = new Vector4, _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial, _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2 },
      radius: { value: 4 }
    },
    vertexShader: vertex6,
    fragmentShader: fragment9
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry;
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh2(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  let _previousType = this.type;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
    const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
    for (let i3 = 0, il = lights.length;i3 < il; i3++) {
      const light = lights[i3];
      const shadow = light.shadow;
      if (shadow === undefined) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null || toVSM === true || fromVSM === true) {
        const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
        if (shadow.map !== null) {
          shadow.map.dispose();
        }
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0;vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    _previousType = this.type;
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== undefined) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      if (_renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === undefined) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === undefined) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
        }
        result = cachedMaterial;
      }
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.map = material.map;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      const materialProperties = _renderer.properties.get(result);
      materialProperties.light = light;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k5 = 0, kl = groups.length;k5 < kl; k5++) {
            const group = groups[k5];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i3 = 0, l4 = children.length;i3 < l4; i3++) {
      renderObject(children[i3], camera, shadowCamera, light, type);
    }
  }
};
var WebGLState = function(gl, extensions31, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color8 = new Vector4;
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r4, g5, b4, a3, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r4 *= a3;
          g5 *= a3;
          b4 *= a3;
        }
        color8.set(r4, g5, b4, a3);
        if (currentColorClear.equals(color8) === false) {
          gl.clearColor(r4, g5, b4, a3);
          currentColorClear.copy(color8);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          switch (depthFunc) {
            case NeverDepth:
              gl.depthFunc(gl.NEVER);
              break;
            case AlwaysDepth:
              gl.depthFunc(gl.ALWAYS);
              break;
            case LessDepth:
              gl.depthFunc(gl.LESS);
              break;
            case LessEqualDepth:
              gl.depthFunc(gl.LEQUAL);
              break;
            case EqualDepth:
              gl.depthFunc(gl.EQUAL);
              break;
            case GreaterEqualDepth:
              gl.depthFunc(gl.GEQUAL);
              break;
            case GreaterDepth:
              gl.depthFunc(gl.GREATER);
              break;
            case NotEqualDepth:
              gl.depthFunc(gl.NOTEQUAL);
              break;
            default:
              gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl.STENCIL_TEST);
          } else {
            disable(gl.STENCIL_TEST);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer;
  const depthBuffer = new DepthBuffer;
  const stencilBuffer = new StencilBuffer;
  const uboBindings = new WeakMap;
  const uboProgramMap = new WeakMap;
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = new WeakMap;
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(gl.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
  const viewportParam = gl.getParameter(gl.VIEWPORT);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture4(type, target, count, dimensions) {
    const data = new Uint8Array(4);
    const texture3 = gl.createTexture();
    gl.bindTexture(type, texture3);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (let i3 = 0;i3 < count; i3++) {
      if (isWebGL2 && (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY)) {
        gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      } else {
        gl.texImage2D(target + i3, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      }
    }
    return texture3;
  }
  const emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture4(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture4(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  if (isWebGL2) {
    emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture4(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
    emptyTextures[gl.TEXTURE_3D] = createTexture4(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);
  }
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl.CULL_FACE);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === gl.DRAW_FRAMEBUFFER) {
          currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
        }
        if (target === gl.FRAMEBUFFER) {
          currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === undefined) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        const textures2 = renderTarget.texture;
        if (drawBuffers2.length !== textures2.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
          for (let i3 = 0, il = textures2.length;i3 < il; i3++) {
            drawBuffers2[i3] = gl.COLOR_ATTACHMENT0 + i3;
          }
          drawBuffers2.length = textures2.length;
          needsUpdate = true;
        }
      } else {
        if (drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
          drawBuffers2[0] = gl.COLOR_ATTACHMENT0;
          needsUpdate = true;
        }
      }
    } else {
      if (drawBuffers2[0] !== gl.BACK) {
        drawBuffers2[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      if (capabilities.isWebGL2) {
        gl.drawBuffers(drawBuffers2);
      } else {
        extensions31.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
      }
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: gl.FUNC_ADD,
    [SubtractEquation]: gl.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = gl.MIN;
    equationToGL[MaxEquation] = gl.MAX;
  } else {
    const extension = extensions31.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: gl.ZERO,
    [OneFactor]: gl.ONE,
    [SrcColorFactor]: gl.SRC_COLOR,
    [SrcAlphaFactor]: gl.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
    [DstColorFactor]: gl.DST_COLOR,
    [DstAlphaFactor]: gl.DST_ALPHA,
    [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = false;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === undefined)
      webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture, webglSlot) {
    if (webglSlot === undefined) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === undefined) {
      boundTexture = { type: undefined, texture: undefined };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== undefined && boundTexture.type !== undefined) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = undefined;
      boundTexture.texture = undefined;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexImage3D() {
    try {
      gl.compressedTexImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage3D() {
    try {
      gl.compressedTexSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    let mapping = uboProgramMap.get(program);
    if (mapping === undefined) {
      mapping = new WeakMap;
      uboProgramMap.set(program, mapping);
    }
    let blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === undefined) {
      blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    const mapping = uboProgramMap.get(program);
    const blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(program) !== blockIndex) {
      gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
      uboBindings.set(program, blockIndex);
    }
  }
  function reset() {
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(gl.LESS);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.clearStencil(0);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW);
    gl.polygonOffset(0, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = new WeakMap;
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    compressedTexImage3D,
    texImage2D,
    texImage3D,
    updateUBOMapping,
    uniformBlockBinding,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    compressedTexSubImage3D,
    scissor,
    viewport,
    reset
  };
};
var WebGLTextures = function(_gl, extensions31, state, properties, capabilities, utils27, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const multisampledRTTExt = extensions31.has("WEBGL_multisampled_render_to_texture") ? extensions31.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
  const _videoTextures = new WeakMap;
  let _canvas;
  const _sources = new WeakMap;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale3 = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale3 = maxSize / Math.max(image.width, image.height);
    }
    if (scale3 < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor(scale3 * image.width);
        const height = floor(scale3 * image.height);
        if (_canvas === undefined)
          _canvas = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
        canvas.width = width;
        canvas.height = height;
        const context2 = canvas.getContext("2d");
        context2.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture3) {
    if (isWebGL2)
      return false;
    return texture3.wrapS !== ClampToEdgeWrapping || texture3.wrapT !== ClampToEdgeWrapping || texture3.minFilter !== NearestFilter && texture3.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture3, supportsMips) {
    return texture3.generateMipmaps && supportsMips && texture3.minFilter !== NearestFilter && texture3.minFilter !== LinearFilter;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== undefined)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'" + internalFormatName + "\'");
    }
    let internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT)
        internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT)
        internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RED_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = _gl.R8UI;
      if (glType === _gl.UNSIGNED_SHORT)
        internalFormat = _gl.R16UI;
      if (glType === _gl.UNSIGNED_INT)
        internalFormat = _gl.R32UI;
      if (glType === _gl.BYTE)
        internalFormat = _gl.R8I;
      if (glType === _gl.SHORT)
        internalFormat = _gl.R16I;
      if (glType === _gl.INT)
        internalFormat = _gl.R32I;
    }
    if (glFormat === _gl.RG) {
      if (glType === _gl.FLOAT)
        internalFormat = _gl.RG32F;
      if (glType === _gl.HALF_FLOAT)
        internalFormat = _gl.RG16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = _gl.RG8;
    }
    if (glFormat === _gl.RGBA) {
      if (glType === _gl.FLOAT)
        internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT)
        internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = colorSpace === SRGBColorSpace && forceLinearTransfer === false ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4)
        internalFormat = _gl.RGBA4;
      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1)
        internalFormat = _gl.RGB5_A1;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions31.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getMipLevels(texture3, image, supportsMips) {
    if (textureNeedsGenerateMipmaps(texture3, supportsMips) === true || texture3.isFramebufferTexture && texture3.minFilter !== NearestFilter && texture3.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture3.mipmaps !== undefined && texture3.mipmaps.length > 0) {
      return texture3.mipmaps.length;
    } else if (texture3.isCompressedTexture && Array.isArray(texture3.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function filterFallback(f4) {
    if (f4 === NearestFilter || f4 === NearestMipmapNearestFilter || f4 === NearestMipmapLinearFilter) {
      return _gl.NEAREST;
    }
    return _gl.LINEAR;
  }
  function onTextureDispose(event) {
    const texture3 = event.target;
    texture3.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture3);
    if (texture3.isVideoTexture) {
      _videoTextures.delete(texture3);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture3) {
    const textureProperties = properties.get(texture3);
    if (textureProperties.__webglInit === undefined)
      return;
    const source = texture3.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture3);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture3);
  }
  function deleteTexture(texture3) {
    const textureProperties = properties.get(texture3);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture3.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const texture3 = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture3);
    if (textureProperties.__webglTexture !== undefined) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i3 = 0;i3 < 6; i3++) {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i3])) {
          for (let level = 0;level < renderTargetProperties.__webglFramebuffer[i3].length; level++)
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i3][level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i3]);
        }
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i3]);
      }
    } else {
      if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
        for (let level = 0;level < renderTargetProperties.__webglFramebuffer.length; level++)
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      }
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (let i3 = 0;i3 < renderTargetProperties.__webglColorRenderbuffer.length; i3++) {
          if (renderTargetProperties.__webglColorRenderbuffer[i3])
            _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i3]);
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i3 = 0, il = texture3.length;i3 < il; i3++) {
        const attachmentProperties = properties.get(texture3[i3]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture3[i3]);
      }
    }
    properties.remove(texture3);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture3) {
    const array = [];
    array.push(texture3.wrapS);
    array.push(texture3.wrapT);
    array.push(texture3.wrapR || 0);
    array.push(texture3.magFilter);
    array.push(texture3.minFilter);
    array.push(texture3.anisotropy);
    array.push(texture3.internalFormat);
    array.push(texture3.format);
    array.push(texture3.type);
    array.push(texture3.generateMipmaps);
    array.push(texture3.premultiplyAlpha);
    array.push(texture3.flipY);
    array.push(texture3.unpackAlignment);
    array.push(texture3.colorSpace);
    return array.join();
  }
  function setTexture2D(texture3, slot) {
    const textureProperties = properties.get(texture3);
    if (texture3.isVideoTexture)
      updateVideoTexture(texture3);
    if (texture3.isRenderTargetTexture === false && texture3.version > 0 && textureProperties.__version !== texture3.version) {
      const image = texture3.image;
      if (image === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture3, slot);
        return;
      }
    }
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture2DArray(texture3, slot) {
    const textureProperties = properties.get(texture3);
    if (texture3.version > 0 && textureProperties.__version !== texture3.version) {
      uploadTexture(textureProperties, texture3, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture3D(texture3, slot) {
    const textureProperties = properties.get(texture3);
    if (texture3.version > 0 && textureProperties.__version !== texture3.version) {
      uploadTexture(textureProperties, texture3, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTextureCube(texture3, slot) {
    const textureProperties = properties.get(texture3);
    if (texture3.version > 0 && textureProperties.__version !== texture3.version) {
      uploadCubeTexture(textureProperties, texture3, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  const wrappingToGL = {
    [RepeatWrapping]: _gl.REPEAT,
    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
  };
  const filterToGL = {
    [NearestFilter]: _gl.NEAREST,
    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
    [LinearFilter]: _gl.LINEAR,
    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
  };
  const compareToGL = {
    [NeverCompare]: _gl.NEVER,
    [AlwaysCompare]: _gl.ALWAYS,
    [LessCompare]: _gl.LESS,
    [LessEqualCompare]: _gl.LEQUAL,
    [EqualCompare]: _gl.EQUAL,
    [GreaterEqualCompare]: _gl.GEQUAL,
    [GreaterCompare]: _gl.GREATER,
    [NotEqualCompare]: _gl.NOTEQUAL
  };
  function setTextureParameters(textureType, texture3, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture3.wrapS]);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture3.wrapT]);
      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture3.wrapR]);
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture3.magFilter]);
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture3.minFilter]);
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
      }
      if (texture3.wrapS !== ClampToEdgeWrapping || texture3.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture3.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture3.minFilter));
      if (texture3.minFilter !== NearestFilter && texture3.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (texture3.compareFunction) {
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture3.compareFunction]);
    }
    if (extensions31.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions31.get("EXT_texture_filter_anisotropic");
      if (texture3.magFilter === NearestFilter)
        return;
      if (texture3.minFilter !== NearestMipmapLinearFilter && texture3.minFilter !== LinearMipmapLinearFilter)
        return;
      if (texture3.type === FloatType && extensions31.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture3.type === HalfFloatType && extensions31.has("OES_texture_half_float_linear") === false))
        return;
      if (texture3.anisotropy > 1 || properties.get(texture3).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture3.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture3).__currentAnisotropy = texture3.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture3) {
    let forceUpload = false;
    if (textureProperties.__webglInit === undefined) {
      textureProperties.__webglInit = true;
      texture3.addEventListener("dispose", onTextureDispose);
    }
    const source = texture3.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === undefined) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture3);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === undefined) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== undefined) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture3);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture3, slot) {
    let textureType = _gl.TEXTURE_2D;
    if (texture3.isDataArrayTexture || texture3.isCompressedArrayTexture)
      textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture3.isData3DTexture)
      textureType = _gl.TEXTURE_3D;
    const forceUpload = initTexture(textureProperties, texture3);
    const source = texture3.source;
    state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture3.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture3.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture3.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
      const needsPowerOfTwo = textureNeedsPowerOfTwo(texture3) && isPowerOfTwo$1(texture3.image) === false;
      let image = resizeImage(texture3.image, needsPowerOfTwo, false, maxTextureSize);
      image = verifyColorSpace(texture3, image);
      const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils27.convert(texture3.format, texture3.colorSpace);
      let glType = utils27.convert(texture3.type), glInternalFormat = getInternalFormat(texture3.internalFormat, glFormat, glType, texture3.colorSpace, texture3.isVideoTexture);
      setTextureParameters(textureType, texture3, supportsMips);
      let mipmap;
      const mipmaps = texture3.mipmaps;
      const useTexStorage = isWebGL2 && texture3.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === undefined || forceUpload === true;
      const levels = getMipLevels(texture3, image, supportsMips);
      if (texture3.isDepthTexture) {
        glInternalFormat = _gl.DEPTH_COMPONENT;
        if (isWebGL2) {
          if (texture3.type === FloatType) {
            glInternalFormat = _gl.DEPTH_COMPONENT32F;
          } else if (texture3.type === UnsignedIntType) {
            glInternalFormat = _gl.DEPTH_COMPONENT24;
          } else if (texture3.type === UnsignedInt248Type) {
            glInternalFormat = _gl.DEPTH24_STENCIL8;
          } else {
            glInternalFormat = _gl.DEPTH_COMPONENT16;
          }
        } else {
          if (texture3.type === FloatType) {
            console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
          }
        }
        if (texture3.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
          if (texture3.type !== UnsignedShortType && texture3.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture3.type = UnsignedIntType;
            glType = utils27.convert(texture3.type);
          }
        }
        if (texture3.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
          glInternalFormat = _gl.DEPTH_STENCIL;
          if (texture3.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture3.type = UnsignedInt248Type;
            glType = utils27.convert(texture3.type);
          }
        }
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        }
      } else if (texture3.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i3 = 0, il = mipmaps.length;i3 < il; i3++) {
            mipmap = mipmaps[i3];
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_2D, i3, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i3, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture3.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture3.isCompressedTexture) {
        if (texture3.isCompressedArrayTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
          }
          for (let i3 = 0, il = mipmaps.length;i3 < il; i3++) {
            mipmap = mipmaps[i3];
            if (texture3.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i3, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
                } else {
                  state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i3, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i3, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
              } else {
                state.texImage3D(_gl.TEXTURE_2D_ARRAY, i3, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i3 = 0, il = mipmaps.length;i3 < il; i3++) {
            mipmap = mipmaps[i3];
            if (texture3.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(_gl.TEXTURE_2D, i3, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_2D, i3, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_2D, i3, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i3, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else if (texture3.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture3.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture3.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
          } else {
            let { width, height } = image;
            for (let i3 = 0;i3 < levels; i3++) {
              state.texImage2D(_gl.TEXTURE_2D, i3, glInternalFormat, width, height, 0, glFormat, glType, null);
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i3 = 0, il = mipmaps.length;i3 < il; i3++) {
            mipmap = mipmaps[i3];
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_2D, i3, 0, 0, glFormat, glType, mipmap);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i3, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture3.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture3, supportsMips)) {
        generateMipmap(textureType);
      }
      sourceProperties.__version = source.version;
      if (texture3.onUpdate)
        texture3.onUpdate(texture3);
    }
    textureProperties.__version = texture3.version;
  }
  function uploadCubeTexture(textureProperties, texture3, slot) {
    if (texture3.image.length !== 6)
      return;
    const forceUpload = initTexture(textureProperties, texture3);
    const source = texture3.source;
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture3.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture3.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture3.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
      const isCompressed = texture3.isCompressedTexture || texture3.image[0].isCompressedTexture;
      const isDataTexture = texture3.image[0] && texture3.image[0].isDataTexture;
      const cubeImage = [];
      for (let i3 = 0;i3 < 6; i3++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i3] = resizeImage(texture3.image[i3], false, true, maxCubemapSize);
        } else {
          cubeImage[i3] = isDataTexture ? texture3.image[i3].image : texture3.image[i3];
        }
        cubeImage[i3] = verifyColorSpace(texture3, cubeImage[i3]);
      }
      const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils27.convert(texture3.format, texture3.colorSpace), glType = utils27.convert(texture3.type), glInternalFormat = getInternalFormat(texture3.internalFormat, glFormat, glType, texture3.colorSpace);
      const useTexStorage = isWebGL2 && texture3.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === undefined || forceUpload === true;
      let levels = getMipLevels(texture3, image, supportsMips);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture3, supportsMips);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
        }
        for (let i3 = 0;i3 < 6; i3++) {
          mipmaps = cubeImage[i3].mipmaps;
          for (let j4 = 0;j4 < mipmaps.length; j4++) {
            const mipmap = mipmaps[j4];
            if (texture3.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, j4, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, j4, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, j4, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, j4, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture3.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0)
            levels++;
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
        }
        for (let i3 = 0;i3 < 6; i3++) {
          if (isDataTexture) {
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, 0, 0, 0, cubeImage[i3].width, cubeImage[i3].height, glFormat, glType, cubeImage[i3].data);
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, 0, glInternalFormat, cubeImage[i3].width, cubeImage[i3].height, 0, glFormat, glType, cubeImage[i3].data);
            }
            for (let j4 = 0;j4 < mipmaps.length; j4++) {
              const mipmap = mipmaps[j4];
              const mipmapImage = mipmap.image[i3].image;
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, j4 + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, j4 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, 0, 0, 0, glFormat, glType, cubeImage[i3]);
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, 0, glInternalFormat, glFormat, glType, cubeImage[i3]);
            }
            for (let j4 = 0;j4 < mipmaps.length; j4++) {
              const mipmap = mipmaps[j4];
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, j4 + 1, 0, 0, glFormat, glType, mipmap.image[i3]);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, j4 + 1, glInternalFormat, glFormat, glType, mipmap.image[i3]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture3, supportsMips)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      sourceProperties.__version = source.version;
      if (texture3.onUpdate)
        texture3.onUpdate(texture3);
    }
    textureProperties.__version = texture3.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture3, attachment, textureTarget, level) {
    const glFormat = utils27.convert(texture3.format, texture3.colorSpace);
    const glType = utils27.convert(texture3.type);
    const glInternalFormat = getInternalFormat(texture3.internalFormat, glFormat, glType, texture3.colorSpace);
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      const width = Math.max(1, renderTarget.width >> level);
      const height = Math.max(1, renderTarget.height >> level);
      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
        state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture3).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture3).__webglTexture, level);
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = _gl.DEPTH_COMPONENT16;
      if (isMultisample || useMultisampledRTT(renderTarget)) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = _gl.DEPTH_COMPONENT32F;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = _gl.DEPTH_COMPONENT24;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else {
      const textures2 = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
      for (let i3 = 0;i3 < textures2.length; i3++) {
        const texture3 = textures2[i3];
        const glFormat = utils27.convert(texture3.format, texture3.colorSpace);
        const glType = utils27.convert(texture3.type);
        const glInternalFormat = getInternalFormat(texture3.internalFormat, glFormat, glType, texture3.colorSpace);
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i3 = 0;i3 < 6; i3++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i3]);
          renderTargetProperties.__webglDepthbuffer[i3] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i3], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== undefined) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
    }
    if (depthTexture !== undefined) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture3 = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture3);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      if (textureProperties.__webglTexture === undefined) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture3.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i3 = 0;i3 < 6; i3++) {
        if (isWebGL2 && texture3.mipmaps && texture3.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer[i3] = [];
          for (let level = 0;level < texture3.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[i3][level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer[i3] = _gl.createFramebuffer();
        }
      }
    } else {
      if (isWebGL2 && texture3.mipmaps && texture3.mipmaps.length > 0) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let level = 0;level < texture3.mipmaps.length; level++) {
          renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      }
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures2 = renderTarget.texture;
          for (let i3 = 0, il = textures2.length;i3 < il; i3++) {
            const attachmentProperties = properties.get(textures2[i3]);
            if (attachmentProperties.__webglTexture === undefined) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      }
      if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        const textures2 = isMultipleRenderTargets ? texture3 : [texture3];
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        for (let i3 = 0;i3 < textures2.length; i3++) {
          const texture4 = textures2[i3];
          renderTargetProperties.__webglColorRenderbuffer[i3] = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i3]);
          const glFormat = utils27.convert(texture4.format, texture4.colorSpace);
          const glType = utils27.convert(texture4.type);
          const glInternalFormat = getInternalFormat(texture4.internalFormat, glFormat, glType, texture4.colorSpace, renderTarget.isXRRenderTarget === true);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i3, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i3]);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture3, supportsMips);
      for (let i3 = 0;i3 < 6; i3++) {
        if (isWebGL2 && texture3.mipmaps && texture3.mipmaps.length > 0) {
          for (let level = 0;level < texture3.mipmaps.length; level++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i3][level], renderTarget, texture3, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, level);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i3], renderTarget, texture3, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, 0);
        }
      }
      if (textureNeedsGenerateMipmaps(texture3, supportsMips)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      const textures2 = renderTarget.texture;
      for (let i3 = 0, il = textures2.length;i3 < il; i3++) {
        const attachment = textures2[i3];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i3, _gl.TEXTURE_2D, 0);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(_gl.TEXTURE_2D);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = _gl.TEXTURE_2D;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        if (isWebGL2) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
        } else {
          console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture3, supportsMips);
      if (isWebGL2 && texture3.mipmaps && texture3.mipmaps.length > 0) {
        for (let level = 0;level < texture3.mipmaps.length; level++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture3, _gl.COLOR_ATTACHMENT0, glTextureType, level);
        }
      } else {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture3, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
      }
      if (textureNeedsGenerateMipmaps(texture3, supportsMips)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures2 = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i3 = 0, il = textures2.length;i3 < il; i3++) {
      const texture3 = textures2[i3];
      if (textureNeedsGenerateMipmaps(texture3, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        const webglTexture = properties.get(texture3).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
      const textures2 = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
      const width = renderTarget.width;
      const height = renderTarget.height;
      let mask = _gl.COLOR_BUFFER_BIT;
      const invalidationArray = [];
      const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
      const renderTargetProperties = properties.get(renderTarget);
      const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
      if (isMultipleRenderTargets) {
        for (let i3 = 0;i3 < textures2.length; i3++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i3, _gl.RENDERBUFFER, null);
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i3, _gl.TEXTURE_2D, null, 0);
        }
      }
      state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
      for (let i3 = 0;i3 < textures2.length; i3++) {
        invalidationArray.push(_gl.COLOR_ATTACHMENT0 + i3);
        if (renderTarget.depthBuffer) {
          invalidationArray.push(depthStyle);
        }
        const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== undefined ? renderTargetProperties.__ignoreDepthValues : false;
        if (ignoreDepthValues === false) {
          if (renderTarget.depthBuffer)
            mask |= _gl.DEPTH_BUFFER_BIT;
          if (renderTarget.stencilBuffer)
            mask |= _gl.STENCIL_BUFFER_BIT;
        }
        if (isMultipleRenderTargets) {
          _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i3]);
        }
        if (ignoreDepthValues === true) {
          _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);
          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
        }
        if (isMultipleRenderTargets) {
          const webglTexture = properties.get(textures2[i3]).__webglTexture;
          _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
        }
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
        if (supportsInvalidateFramebuffer) {
          _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);
        }
      }
      state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
      if (isMultipleRenderTargets) {
        for (let i3 = 0;i3 < textures2.length; i3++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i3, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i3]);
          const webglTexture = properties.get(textures2[i3]).__webglTexture;
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i3, _gl.TEXTURE_2D, webglTexture, 0);
        }
      }
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return isWebGL2 && renderTarget.samples > 0 && extensions31.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture3) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture3) !== frame) {
      _videoTextures.set(texture3, frame);
      texture3.update();
    }
  }
  function verifyColorSpace(texture3, image) {
    const colorSpace = texture3.colorSpace;
    const format = texture3.format;
    const type = texture3.type;
    if (texture3.isCompressedTexture === true || texture3.isVideoTexture === true || texture3.format === _SRGBAFormat)
      return image;
    if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
      if (colorSpace === SRGBColorSpace || colorSpace === DisplayP3ColorSpace) {
        if (isWebGL2 === false) {
          if (extensions31.has("EXT_sRGB") === true && format === RGBAFormat) {
            texture3.format = _SRGBAFormat;
            texture3.minFilter = LinearFilter;
            texture3.generateMipmaps = false;
          } else {
            image = ImageUtils.sRGBToLinear(image);
          }
        } else {
          if (format !== RGBAFormat || type !== UnsignedByteType) {
            console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
          }
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace);
      }
    }
    return image;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
};
var WebGLUtils = function(gl, extensions31, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p3, colorSpace = NoColorSpace) {
    let extension;
    const transferFunction = colorSpace === SRGBColorSpace || colorSpace === DisplayP3ColorSpace ? SRGBTransferFunction : LinearTransferFunction;
    if (p3 === UnsignedByteType)
      return gl.UNSIGNED_BYTE;
    if (p3 === UnsignedShort4444Type)
      return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p3 === UnsignedShort5551Type)
      return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p3 === ByteType)
      return gl.BYTE;
    if (p3 === ShortType)
      return gl.SHORT;
    if (p3 === UnsignedShortType)
      return gl.UNSIGNED_SHORT;
    if (p3 === IntType)
      return gl.INT;
    if (p3 === UnsignedIntType)
      return gl.UNSIGNED_INT;
    if (p3 === FloatType)
      return gl.FLOAT;
    if (p3 === HalfFloatType) {
      if (isWebGL2)
        return gl.HALF_FLOAT;
      extension = extensions31.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p3 === AlphaFormat)
      return gl.ALPHA;
    if (p3 === RGBAFormat)
      return gl.RGBA;
    if (p3 === LuminanceFormat)
      return gl.LUMINANCE;
    if (p3 === LuminanceAlphaFormat)
      return gl.LUMINANCE_ALPHA;
    if (p3 === DepthFormat)
      return gl.DEPTH_COMPONENT;
    if (p3 === DepthStencilFormat)
      return gl.DEPTH_STENCIL;
    if (p3 === _SRGBAFormat) {
      extension = extensions31.get("EXT_sRGB");
      if (extension !== null) {
        return extension.SRGB_ALPHA_EXT;
      } else {
        return null;
      }
    }
    if (p3 === RedFormat)
      return gl.RED;
    if (p3 === RedIntegerFormat)
      return gl.RED_INTEGER;
    if (p3 === RGFormat)
      return gl.RG;
    if (p3 === RGIntegerFormat)
      return gl.RG_INTEGER;
    if (p3 === RGBAIntegerFormat)
      return gl.RGBA_INTEGER;
    if (p3 === RGB_S3TC_DXT1_Format || p3 === RGBA_S3TC_DXT1_Format || p3 === RGBA_S3TC_DXT3_Format || p3 === RGBA_S3TC_DXT5_Format) {
      if (transferFunction === SRGBTransferFunction) {
        extension = extensions31.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p3 === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p3 === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p3 === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p3 === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions31.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p3 === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p3 === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p3 === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p3 === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p3 === RGB_PVRTC_4BPPV1_Format || p3 === RGB_PVRTC_2BPPV1_Format || p3 === RGBA_PVRTC_4BPPV1_Format || p3 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions31.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p3 === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p3 === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p3 === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p3 === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p3 === RGB_ETC1_Format) {
      extension = extensions31.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p3 === RGB_ETC2_Format || p3 === RGBA_ETC2_EAC_Format) {
      extension = extensions31.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p3 === RGB_ETC2_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p3 === RGBA_ETC2_EAC_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p3 === RGBA_ASTC_4x4_Format || p3 === RGBA_ASTC_5x4_Format || p3 === RGBA_ASTC_5x5_Format || p3 === RGBA_ASTC_6x5_Format || p3 === RGBA_ASTC_6x6_Format || p3 === RGBA_ASTC_8x5_Format || p3 === RGBA_ASTC_8x6_Format || p3 === RGBA_ASTC_8x8_Format || p3 === RGBA_ASTC_10x5_Format || p3 === RGBA_ASTC_10x6_Format || p3 === RGBA_ASTC_10x8_Format || p3 === RGBA_ASTC_10x10_Format || p3 === RGBA_ASTC_12x10_Format || p3 === RGBA_ASTC_12x12_Format) {
      extension = extensions31.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p3 === RGBA_ASTC_4x4_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p3 === RGBA_ASTC_5x4_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p3 === RGBA_ASTC_5x5_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p3 === RGBA_ASTC_6x5_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p3 === RGBA_ASTC_6x6_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p3 === RGBA_ASTC_8x5_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p3 === RGBA_ASTC_8x6_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p3 === RGBA_ASTC_8x8_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p3 === RGBA_ASTC_10x5_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p3 === RGBA_ASTC_10x6_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p3 === RGBA_ASTC_10x8_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p3 === RGBA_ASTC_10x10_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p3 === RGBA_ASTC_12x10_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p3 === RGBA_ASTC_12x12_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p3 === RGBA_BPTC_Format || p3 === RGB_BPTC_SIGNED_Format || p3 === RGB_BPTC_UNSIGNED_Format) {
      extension = extensions31.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p3 === RGBA_BPTC_Format)
          return transferFunction === SRGBTransferFunction ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (p3 === RGB_BPTC_SIGNED_Format)
          return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (p3 === RGB_BPTC_UNSIGNED_Format)
          return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else {
        return null;
      }
    }
    if (p3 === RED_RGTC1_Format || p3 === SIGNED_RED_RGTC1_Format || p3 === RED_GREEN_RGTC2_Format || p3 === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions31.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p3 === RGBA_BPTC_Format)
          return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p3 === SIGNED_RED_RGTC1_Format)
          return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p3 === RED_GREEN_RGTC2_Format)
          return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p3 === SIGNED_RED_GREEN_RGTC2_Format)
          return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p3 === UnsignedInt248Type) {
      if (isWebGL2)
        return gl.UNSIGNED_INT_24_8;
      extension = extensions31.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
    return gl[p3] !== undefined ? gl[p3] : null;
  }
  return { convert };
};
var WebGLMaterials = function(renderer, properties) {
  function refreshTransformUniform(map4, uniform) {
    if (map4.matrixAutoUpdate === true) {
      map4.updateMatrix();
    }
    uniform.value.copy(map4.matrix);
  }
  function refreshFogUniforms(uniforms, fog) {
    fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) {
        uniforms.bumpScale.value *= -1;
      }
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) {
        uniforms.normalScale.value.negate();
      }
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
      refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
      refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      const scaleFactor = renderer._useLegacyLights === true ? Math.PI : 1;
      uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
      refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
      refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.uvTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 0.0001);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.metalness.value = material.metalness;
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
      refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
    }
    uniforms.roughness.value = material.roughness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
      refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
        refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
        refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
        refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
        refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
        refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    if (material.anisotropy > 0) {
      uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
      if (material.anisotropyMap) {
        uniforms.anisotropyMap.value = material.anisotropyMap;
        refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
      }
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
      refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
    }
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
      refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    const light = properties.get(material).light;
    uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
    uniforms.nearDistance.value = light.shadow.camera.near;
    uniforms.farDistance.value = light.shadow.camera.far;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
};
var WebGLUniformsGroups = function(gl, info, capabilities, state) {
  let buffers = {};
  let updateList = {};
  let allocatedBindingPoints = [];
  const maxBindingPoints = capabilities.isWebGL2 ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function bind(uniformsGroup, program) {
    const webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update(uniformsGroup, program) {
    let buffer = buffers[uniformsGroup.id];
    if (buffer === undefined) {
      prepareUniformsGroup(uniformsGroup);
      buffer = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer;
      uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
    }
    const webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);
    const frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    const bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    const buffer = gl.createBuffer();
    const size = uniformsGroup.__size;
    const usage = uniformsGroup.usage;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
    return buffer;
  }
  function allocateBindingPointIndex() {
    for (let i3 = 0;i3 < maxBindingPoints; i3++) {
      if (allocatedBindingPoints.indexOf(i3) === -1) {
        allocatedBindingPoints.push(i3);
        return i3;
      }
    }
    console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    const buffer = buffers[uniformsGroup.id];
    const uniforms = uniformsGroup.uniforms;
    const cache2 = uniformsGroup.__cache;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    for (let i3 = 0, il = uniforms.length;i3 < il; i3++) {
      const uniform = uniforms[i3];
      if (hasUniformChanged(uniform, i3, cache2) === true) {
        const offset = uniform.__offset;
        const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
        let arrayOffset = 0;
        for (let i4 = 0;i4 < values.length; i4++) {
          const value = values[i4];
          const info2 = getUniformSize(value);
          if (typeof value === "number") {
            uniform.__data[0] = value;
            gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
          } else if (value.isMatrix3) {
            uniform.__data[0] = value.elements[0];
            uniform.__data[1] = value.elements[1];
            uniform.__data[2] = value.elements[2];
            uniform.__data[3] = value.elements[0];
            uniform.__data[4] = value.elements[3];
            uniform.__data[5] = value.elements[4];
            uniform.__data[6] = value.elements[5];
            uniform.__data[7] = value.elements[0];
            uniform.__data[8] = value.elements[6];
            uniform.__data[9] = value.elements[7];
            uniform.__data[10] = value.elements[8];
            uniform.__data[11] = value.elements[0];
          } else {
            value.toArray(uniform.__data, arrayOffset);
            arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
          }
        }
        gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
      }
    }
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
  }
  function hasUniformChanged(uniform, index2, cache2) {
    const value = uniform.value;
    if (cache2[index2] === undefined) {
      if (typeof value === "number") {
        cache2[index2] = value;
      } else {
        const values = Array.isArray(value) ? value : [value];
        const tempValues = [];
        for (let i3 = 0;i3 < values.length; i3++) {
          tempValues.push(values[i3].clone());
        }
        cache2[index2] = tempValues;
      }
      return true;
    } else {
      if (typeof value === "number") {
        if (cache2[index2] !== value) {
          cache2[index2] = value;
          return true;
        }
      } else {
        const cachedObjects = Array.isArray(cache2[index2]) ? cache2[index2] : [cache2[index2]];
        const values = Array.isArray(value) ? value : [value];
        for (let i3 = 0;i3 < cachedObjects.length; i3++) {
          const cachedObject = cachedObjects[i3];
          if (cachedObject.equals(values[i3]) === false) {
            cachedObject.copy(values[i3]);
            return true;
          }
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    const uniforms = uniformsGroup.uniforms;
    let offset = 0;
    const chunkSize = 16;
    let chunkOffset = 0;
    for (let i3 = 0, l4 = uniforms.length;i3 < l4; i3++) {
      const uniform = uniforms[i3];
      const infos = {
        boundary: 0,
        storage: 0
      };
      const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
      for (let j4 = 0, jl = values.length;j4 < jl; j4++) {
        const value = values[j4];
        const info2 = getUniformSize(value);
        infos.boundary += info2.boundary;
        infos.storage += info2.storage;
      }
      uniform.__data = new Float32Array(infos.storage / Float32Array.BYTES_PER_ELEMENT);
      uniform.__offset = offset;
      if (i3 > 0) {
        chunkOffset = offset % chunkSize;
        const remainingSizeInChunk = chunkSize - chunkOffset;
        if (chunkOffset !== 0 && remainingSizeInChunk - infos.boundary < 0) {
          offset += chunkSize - chunkOffset;
          uniform.__offset = offset;
        }
      }
      offset += infos.storage;
    }
    chunkOffset = offset % chunkSize;
    if (chunkOffset > 0)
      offset += chunkSize - chunkOffset;
    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(value) {
    const info2 = {
      boundary: 0,
      storage: 0
    };
    if (typeof value === "number") {
      info2.boundary = 4;
      info2.storage = 4;
    } else if (value.isVector2) {
      info2.boundary = 8;
      info2.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      info2.boundary = 16;
      info2.storage = 12;
    } else if (value.isVector4) {
      info2.boundary = 16;
      info2.storage = 16;
    } else if (value.isMatrix3) {
      info2.boundary = 48;
      info2.storage = 48;
    } else if (value.isMatrix4) {
      info2.boundary = 64;
      info2.storage = 64;
    } else if (value.isTexture) {
      console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
    } else {
      console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
    }
    return info2;
  }
  function onUniformsGroupsDispose(event) {
    const uniformsGroup = event.target;
    uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
    const index2 = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
    allocatedBindingPoints.splice(index2, 1);
    gl.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose() {
    for (const id in buffers) {
      gl.deleteBuffer(buffers[id]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind,
    update,
    dispose
  };
};
var arraySlice = function(array, from, to) {
  if (isTypedArray(array)) {
    return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
  }
  return array.slice(from, to);
};
var convertArray = function(array, type, forceClone) {
  if (!array || !forceClone && array.constructor === type)
    return array;
  if (typeof type.BYTES_PER_ELEMENT === "number") {
    return new type(array);
  }
  return Array.prototype.slice.call(array);
};
var isTypedArray = function(object) {
  return ArrayBuffer.isView(object) && !(object instanceof DataView);
};
var REVISION = "156";
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var RGB_BPTC_SIGNED_Format = 36494;
var RGB_BPTC_UNSIGNED_Format = 36495;
var RED_RGTC1_Format = 36283;
var SIGNED_RED_RGTC1_Format = 36284;
var RED_GREEN_RGTC2_Format = 36285;
var SIGNED_RED_GREEN_RGTC2_Format = 36286;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var NoColorSpace = "";
var SRGBColorSpace = "srgb";
var LinearSRGBColorSpace = "srgb-linear";
var DisplayP3ColorSpace = "display-p3";
var KeepStencilOp = 7680;
var AlwaysStencilFunc = 519;
var NeverCompare = 512;
var LessCompare = 513;
var EqualCompare = 514;
var LessEqualCompare = 515;
var GreaterCompare = 516;
var NotEqualCompare = 517;
var GreaterEqualCompare = 518;
var AlwaysCompare = 519;
var StaticDrawUsage = 35044;
var GLSL3 = "300 es";
var _SRGBAFormat = 1035;
var WebGLCoordinateSystem = 2000;
var WebGPUCoordinateSystem = 2001;

class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === undefined)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === undefined) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === undefined)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === undefined)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== undefined) {
      const index2 = listenerArray.indexOf(listener);
      if (index2 !== -1) {
        listenerArray.splice(index2, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === undefined)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== undefined) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i3 = 0, l4 = array.length;i3 < l4; i3++) {
        array[i3].call(this, event);
      }
      event.target = null;
    }
  }
}
var _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var _seed = 1234567;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
var MathUtils = {
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp: lerp2,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize: normalize2,
  denormalize
};

class Vector2 {
  constructor(x3 = 0, y3 = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x3;
    this.y = y3;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x3, y3) {
    this.x = x3;
    this.y = y3;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x3) {
    this.x = x3;
    return this;
  }
  setY(y3) {
    this.y = y3;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v4) {
    this.x = v4.x;
    this.y = v4.y;
    return this;
  }
  add(v4) {
    this.x += v4.x;
    this.y += v4.y;
    return this;
  }
  addScalar(s3) {
    this.x += s3;
    this.y += s3;
    return this;
  }
  addVectors(a3, b4) {
    this.x = a3.x + b4.x;
    this.y = a3.y + b4.y;
    return this;
  }
  addScaledVector(v4, s3) {
    this.x += v4.x * s3;
    this.y += v4.y * s3;
    return this;
  }
  sub(v4) {
    this.x -= v4.x;
    this.y -= v4.y;
    return this;
  }
  subScalar(s3) {
    this.x -= s3;
    this.y -= s3;
    return this;
  }
  subVectors(a3, b4) {
    this.x = a3.x - b4.x;
    this.y = a3.y - b4.y;
    return this;
  }
  multiply(v4) {
    this.x *= v4.x;
    this.y *= v4.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v4) {
    this.x /= v4.x;
    this.y /= v4.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m4) {
    const x3 = this.x, y3 = this.y;
    const e3 = m4.elements;
    this.x = e3[0] * x3 + e3[3] * y3 + e3[6];
    this.y = e3[1] * x3 + e3[4] * y3 + e3[7];
    return this;
  }
  min(v4) {
    this.x = Math.min(this.x, v4.x);
    this.y = Math.min(this.y, v4.y);
    return this;
  }
  max(v4) {
    this.x = Math.max(this.x, v4.x);
    this.y = Math.max(this.y, v4.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v4) {
    return this.x * v4.x + this.y * v4.y;
  }
  cross(v4) {
    return this.x * v4.y - this.y * v4.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  angleTo(v4) {
    const denominator = Math.sqrt(this.lengthSq() * v4.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v4) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v4) {
    return Math.sqrt(this.distanceToSquared(v4));
  }
  distanceToSquared(v4) {
    const dx = this.x - v4.x, dy = this.y - v4.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v4) {
    return Math.abs(this.x - v4.x) + Math.abs(this.y - v4.y);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v4, alpha2) {
    this.x += (v4.x - this.x) * alpha2;
    this.y += (v4.y - this.y) * alpha2;
    return this;
  }
  lerpVectors(v1, v22, alpha2) {
    this.x = v1.x + (v22.x - v1.x) * alpha2;
    this.y = v1.y + (v22.y - v1.y) * alpha2;
    return this;
  }
  equals(v4) {
    return v4.x === this.x && v4.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    return this;
  }
  rotateAround(center, angle) {
    const c3 = Math.cos(angle), s3 = Math.sin(angle);
    const x3 = this.x - center.x;
    const y3 = this.y - center.y;
    this.x = x3 * c3 - y3 * s3 + center.x;
    this.y = x3 * s3 + y3 * c3 + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}

class Matrix32 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix32.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== undefined) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m4) {
    const te = this.elements;
    const me = m4.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis2, yAxis2, zAxis) {
    xAxis2.setFromMatrix3Column(this, 0);
    yAxis2.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m4) {
    const me = m4.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }
  multiply(m4) {
    return this.multiplyMatrices(this, m4);
  }
  premultiply(m4) {
    return this.multiplyMatrices(m4, this);
  }
  multiplyMatrices(a3, b4) {
    const ae = a3.elements;
    const be = b4.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s3) {
    const te = this.elements;
    te[0] *= s3;
    te[3] *= s3;
    te[6] *= s3;
    te[1] *= s3;
    te[4] *= s3;
    te[7] *= s3;
    te[2] *= s3;
    te[5] *= s3;
    te[8] *= s3;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a3 = te[0], b4 = te[1], c3 = te[2], d3 = te[3], e3 = te[4], f4 = te[5], g5 = te[6], h3 = te[7], i3 = te[8];
    return a3 * e3 * i3 - a3 * f4 * h3 - b4 * d3 * i3 + b4 * f4 * g5 + c3 * d3 * h3 - c3 * e3 * g5;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp16;
    const m4 = this.elements;
    tmp16 = m4[1];
    m4[1] = m4[3];
    m4[3] = tmp16;
    tmp16 = m4[2];
    m4[2] = m4[6];
    m4[6] = tmp16;
    tmp16 = m4[5];
    m4[5] = m4[7];
    m4[7] = tmp16;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r4) {
    const m4 = this.elements;
    r4[0] = m4[0];
    r4[1] = m4[3];
    r4[2] = m4[6];
    r4[3] = m4[1];
    r4[4] = m4[4];
    r4[5] = m4[7];
    r4[6] = m4[2];
    r4[7] = m4[5];
    r4[8] = m4[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c3 = Math.cos(rotation);
    const s3 = Math.sin(rotation);
    this.set(sx * c3, sx * s3, -sx * (c3 * cx + s3 * cy) + cx + tx, -sy * s3, sy * c3, -sy * (-s3 * cx + c3 * cy) + cy + ty, 0, 0, 1);
    return this;
  }
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  makeTranslation(x3, y3) {
    if (x3.isVector2) {
      this.set(1, 0, x3.x, 0, 1, x3.y, 0, 0, 1);
    } else {
      this.set(1, 0, x3, 0, 1, y3, 0, 0, 1);
    }
    return this;
  }
  makeRotation(theta) {
    const c3 = Math.cos(theta);
    const s3 = Math.sin(theta);
    this.set(c3, -s3, 0, s3, c3, 0, 0, 0, 1);
    return this;
  }
  makeScale(x3, y3) {
    this.set(x3, 0, 0, 0, y3, 0, 0, 0, 1);
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i3 = 0;i3 < 9; i3++) {
      if (te[i3] !== me[i3])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i3 = 0;i3 < 9; i3++) {
      this.elements[i3] = array[i3 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
var _m3 = new Matrix32;
var _cache = {};
var LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix32().fromArray([
  0.8224621,
  0.0331941,
  0.0170827,
  0.177538,
  0.9668058,
  0.0723974,
  -0.0000001,
  0.0000001,
  0.9105199
]);
var LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix32().fromArray([
  1.2249401,
  -0.0420569,
  -0.0196376,
  -0.2249404,
  1.0420571,
  -0.0786361,
  0.0000001,
  0,
  1.0982735
]);
var TO_LINEAR = {
  [LinearSRGBColorSpace]: (color8) => color8,
  [SRGBColorSpace]: (color8) => color8.convertSRGBToLinear(),
  [DisplayP3ColorSpace]: DisplayP3ToLinearSRGB
};
var FROM_LINEAR = {
  [LinearSRGBColorSpace]: (color8) => color8,
  [SRGBColorSpace]: (color8) => color8.convertLinearToSRGB(),
  [DisplayP3ColorSpace]: LinearSRGBToDisplayP3
};
var ColorManagement = {
  enabled: true,
  get legacyMode() {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.");
    return !this.enabled;
  },
  set legacyMode(legacyMode) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.");
    this.enabled = !legacyMode;
  },
  get workingColorSpace() {
    return LinearSRGBColorSpace;
  },
  set workingColorSpace(colorSpace) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(color8, sourceColorSpace, targetColorSpace) {
    if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color8;
    }
    const sourceToLinear = TO_LINEAR[sourceColorSpace];
    const targetFromLinear = FROM_LINEAR[targetColorSpace];
    if (sourceToLinear === undefined || targetFromLinear === undefined) {
      throw new Error(`Unsupported color space conversion, "${sourceColorSpace}" to "${targetColorSpace}".`);
    }
    return targetFromLinear(sourceToLinear(color8));
  },
  fromWorkingColorSpace: function(color8, targetColorSpace) {
    return this.convert(color8, this.workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function(color8, sourceColorSpace) {
    return this.convert(color8, sourceColorSpace, this.workingColorSpace);
  }
};
var _canvas;

class ImageUtils {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === undefined)
        _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context2 = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context2.putImageData(image, 0, 0);
      } else {
        context2.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context2 = canvas.getContext("2d");
      context2.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context2.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i3 = 0;i3 < data.length; i3++) {
        data[i3] = SRGBToLinear(data[i3] / 255) * 255;
      }
      context2.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i3 = 0;i3 < data.length; i3++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i3] = Math.floor(SRGBToLinear(data[i3] / 255) * 255);
        } else {
          data[i3] = SRGBToLinear(data[i3]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
}
var sourceId = 0;

class Source {
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: sourceId++ });
    this.uuid = generateUUID();
    this.data = data;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  toJSON(meta2) {
    const isRootObject = meta2 === undefined || typeof meta2 === "string";
    if (!isRootObject && meta2.images[this.uuid] !== undefined) {
      return meta2.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url3;
      if (Array.isArray(data)) {
        url3 = [];
        for (let i3 = 0, l4 = data.length;i3 < l4; i3++) {
          if (data[i3].isDataTexture) {
            url3.push(serializeImage(data[i3].image));
          } else {
            url3.push(serializeImage(data[i3]));
          }
        }
      } else {
        url3 = serializeImage(data);
      }
      output.url = url3;
    }
    if (!isRootObject) {
      meta2.images[this.uuid] = output;
    }
    return output;
  }
}
var _textureId = 0;

class Texture3 extends EventDispatcher {
  constructor(image = Texture3.DEFAULT_IMAGE, mapping = Texture3.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture3.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix32;
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    if (typeof colorSpace === "string") {
      this.colorSpace = colorSpace;
    } else {
      warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
      this.colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta2) {
    const isRootObject = meta2 === undefined || typeof meta2 === "string";
    if (!isRootObject && meta2.textures[this.uuid] !== undefined) {
      return meta2.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta2).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (Object.keys(this.userData).length > 0)
      output.userData = this.userData;
    if (!isRootObject) {
      meta2.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
  get encoding() {
    warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
    return this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
  }
  set encoding(encoding) {
    warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
    this.colorSpace = encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
  }
}
Texture3.DEFAULT_IMAGE = null;
Texture3.DEFAULT_MAPPING = UVMapping;
Texture3.DEFAULT_ANISOTROPY = 1;

class Vector4 {
  constructor(x3 = 0, y3 = 0, z3 = 0, w4 = 1) {
    Vector4.prototype.isVector4 = true;
    this.x = x3;
    this.y = y3;
    this.z = z3;
    this.w = w4;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x3, y3, z3, w4) {
    this.x = x3;
    this.y = y3;
    this.z = z3;
    this.w = w4;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x3) {
    this.x = x3;
    return this;
  }
  setY(y3) {
    this.y = y3;
    return this;
  }
  setZ(z3) {
    this.z = z3;
    return this;
  }
  setW(w4) {
    this.w = w4;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v4) {
    this.x = v4.x;
    this.y = v4.y;
    this.z = v4.z;
    this.w = v4.w !== undefined ? v4.w : 1;
    return this;
  }
  add(v4) {
    this.x += v4.x;
    this.y += v4.y;
    this.z += v4.z;
    this.w += v4.w;
    return this;
  }
  addScalar(s3) {
    this.x += s3;
    this.y += s3;
    this.z += s3;
    this.w += s3;
    return this;
  }
  addVectors(a3, b4) {
    this.x = a3.x + b4.x;
    this.y = a3.y + b4.y;
    this.z = a3.z + b4.z;
    this.w = a3.w + b4.w;
    return this;
  }
  addScaledVector(v4, s3) {
    this.x += v4.x * s3;
    this.y += v4.y * s3;
    this.z += v4.z * s3;
    this.w += v4.w * s3;
    return this;
  }
  sub(v4) {
    this.x -= v4.x;
    this.y -= v4.y;
    this.z -= v4.z;
    this.w -= v4.w;
    return this;
  }
  subScalar(s3) {
    this.x -= s3;
    this.y -= s3;
    this.z -= s3;
    this.w -= s3;
    return this;
  }
  subVectors(a3, b4) {
    this.x = a3.x - b4.x;
    this.y = a3.y - b4.y;
    this.z = a3.z - b4.z;
    this.w = a3.w - b4.w;
    return this;
  }
  multiply(v4) {
    this.x *= v4.x;
    this.y *= v4.y;
    this.z *= v4.z;
    this.w *= v4.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m4) {
    const x3 = this.x, y3 = this.y, z3 = this.z, w4 = this.w;
    const e3 = m4.elements;
    this.x = e3[0] * x3 + e3[4] * y3 + e3[8] * z3 + e3[12] * w4;
    this.y = e3[1] * x3 + e3[5] * y3 + e3[9] * z3 + e3[13] * w4;
    this.z = e3[2] * x3 + e3[6] * y3 + e3[10] * z3 + e3[14] * w4;
    this.w = e3[3] * x3 + e3[7] * y3 + e3[11] * z3 + e3[15] * w4;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q3) {
    this.w = 2 * Math.acos(q3.w);
    const s3 = Math.sqrt(1 - q3.w * q3.w);
    if (s3 < 0.0001) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q3.x / s3;
      this.y = q3.y / s3;
      this.z = q3.z / s3;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m4) {
    let angle, x3, y3, z3;
    const epsilon2 = 0.01, epsilon22 = 0.1, te = m4.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon2 && Math.abs(m13 - m31) < epsilon2 && Math.abs(m23 - m32) < epsilon2) {
      if (Math.abs(m12 + m21) < epsilon22 && Math.abs(m13 + m31) < epsilon22 && Math.abs(m23 + m32) < epsilon22 && Math.abs(m11 + m22 + m33 - 3) < epsilon22) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon2) {
          x3 = 0;
          y3 = 0.707106781;
          z3 = 0.707106781;
        } else {
          x3 = Math.sqrt(xx);
          y3 = xy / x3;
          z3 = xz / x3;
        }
      } else if (yy > zz) {
        if (yy < epsilon2) {
          x3 = 0.707106781;
          y3 = 0;
          z3 = 0.707106781;
        } else {
          y3 = Math.sqrt(yy);
          x3 = xy / y3;
          z3 = yz / y3;
        }
      } else {
        if (zz < epsilon2) {
          x3 = 0.707106781;
          y3 = 0.707106781;
          z3 = 0;
        } else {
          z3 = Math.sqrt(zz);
          x3 = xz / z3;
          y3 = yz / z3;
        }
      }
      this.set(x3, y3, z3, angle);
      return this;
    }
    let s3 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s3) < 0.001)
      s3 = 1;
    this.x = (m32 - m23) / s3;
    this.y = (m13 - m31) / s3;
    this.z = (m21 - m12) / s3;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v4) {
    this.x = Math.min(this.x, v4.x);
    this.y = Math.min(this.y, v4.y);
    this.z = Math.min(this.z, v4.z);
    this.w = Math.min(this.w, v4.w);
    return this;
  }
  max(v4) {
    this.x = Math.max(this.x, v4.x);
    this.y = Math.max(this.y, v4.y);
    this.z = Math.max(this.z, v4.z);
    this.w = Math.max(this.w, v4.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v4) {
    return this.x * v4.x + this.y * v4.y + this.z * v4.z + this.w * v4.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v4, alpha2) {
    this.x += (v4.x - this.x) * alpha2;
    this.y += (v4.y - this.y) * alpha2;
    this.z += (v4.z - this.z) * alpha2;
    this.w += (v4.w - this.w) * alpha2;
    return this;
  }
  lerpVectors(v1, v22, alpha2) {
    this.x = v1.x + (v22.x - v1.x) * alpha2;
    this.y = v1.y + (v22.y - v1.y) * alpha2;
    this.z = v1.z + (v22.z - v1.z) * alpha2;
    this.w = v1.w + (v22.w - v1.w) * alpha2;
    return this;
  }
  equals(v4) {
    return v4.x === this.x && v4.y === this.y && v4.z === this.z && v4.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    this.z = attribute.getZ(index2);
    this.w = attribute.getW(index2);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}

class RenderTarget extends EventDispatcher {
  constructor(width = 1, height = 1, options = {}) {
    super();
    this.isRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    const image = { width, height, depth: 1 };
    if (options.encoding !== undefined) {
      warnOnce("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.");
      options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    this.texture = new Texture3(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    this.texture.isRenderTargetTexture = true;
    this.texture.flipY = false;
    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
    this.samples = options.samples !== undefined ? options.samples : 0;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.texture.isRenderTargetTexture = true;
    const image = Object.assign({}, source.texture.image);
    this.texture.source = new Source(image);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    if (source.depthTexture !== null)
      this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}

class WebGLRenderTarget extends RenderTarget {
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isWebGLRenderTarget = true;
  }
}

class DataArrayTexture extends Texture3 {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class Data3DTexture extends Texture3 {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class Quaternion {
  constructor(x3 = 0, y3 = 0, z3 = 0, w4 = 1) {
    this.isQuaternion = true;
    this._x = x3;
    this._y = y3;
    this._z = z3;
    this._w = w4;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t4) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t4 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t4 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s3 = 1 - t4;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s3 = Math.sin(s3 * len) / sin;
        t4 = Math.sin(t4 * len) / sin;
      }
      const tDir = t4 * dir;
      x0 = x0 * s3 + x1 * tDir;
      y0 = y0 * s3 + y1 * tDir;
      z0 = z0 * s3 + z1 * tDir;
      w0 = w0 * s3 + w1 * tDir;
      if (s3 === 1 - t4) {
        const f4 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f4;
        y0 *= f4;
        z0 *= f4;
        w0 *= f4;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x3, y3, z3, w4) {
    this._x = x3;
    this._y = y3;
    this._z = z3;
    this._w = w4;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    const { _x: x3, _y: y3, _z: z3, _order: order } = euler;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x3 / 2);
    const c22 = cos(y3 / 2);
    const c3 = cos(z3 / 2);
    const s1 = sin(x3 / 2);
    const s22 = sin(y3 / 2);
    const s3 = sin(z3 / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c22 * c3 + c1 * s22 * s3;
        this._y = c1 * s22 * c3 - s1 * c22 * s3;
        this._z = c1 * c22 * s3 + s1 * s22 * c3;
        this._w = c1 * c22 * c3 - s1 * s22 * s3;
        break;
      case "YXZ":
        this._x = s1 * c22 * c3 + c1 * s22 * s3;
        this._y = c1 * s22 * c3 - s1 * c22 * s3;
        this._z = c1 * c22 * s3 - s1 * s22 * c3;
        this._w = c1 * c22 * c3 + s1 * s22 * s3;
        break;
      case "ZXY":
        this._x = s1 * c22 * c3 - c1 * s22 * s3;
        this._y = c1 * s22 * c3 + s1 * c22 * s3;
        this._z = c1 * c22 * s3 + s1 * s22 * c3;
        this._w = c1 * c22 * c3 - s1 * s22 * s3;
        break;
      case "ZYX":
        this._x = s1 * c22 * c3 - c1 * s22 * s3;
        this._y = c1 * s22 * c3 + s1 * c22 * s3;
        this._z = c1 * c22 * s3 - s1 * s22 * c3;
        this._w = c1 * c22 * c3 + s1 * s22 * s3;
        break;
      case "YZX":
        this._x = s1 * c22 * c3 + c1 * s22 * s3;
        this._y = c1 * s22 * c3 + s1 * c22 * s3;
        this._z = c1 * c22 * s3 - s1 * s22 * c3;
        this._w = c1 * c22 * c3 - s1 * s22 * s3;
        break;
      case "XZY":
        this._x = s1 * c22 * c3 - c1 * s22 * s3;
        this._y = c1 * s22 * c3 - s1 * c22 * s3;
        this._z = c1 * c22 * s3 + s1 * s22 * c3;
        this._w = c1 * c22 * c3 + s1 * s22 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s3 = Math.sin(halfAngle);
    this._x = axis.x * s3;
    this._y = axis.y * s3;
    this._z = axis.z * s3;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m4) {
    const te = m4.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s3 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s3;
      this._x = (m32 - m23) * s3;
      this._y = (m13 - m31) * s3;
      this._z = (m21 - m12) * s3;
    } else if (m11 > m22 && m11 > m33) {
      const s3 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s3;
      this._x = 0.25 * s3;
      this._y = (m12 + m21) / s3;
      this._z = (m13 + m31) / s3;
    } else if (m22 > m33) {
      const s3 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s3;
      this._x = (m12 + m21) / s3;
      this._y = 0.25 * s3;
      this._z = (m23 + m32) / s3;
    } else {
      const s3 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s3;
      this._x = (m13 + m31) / s3;
      this._y = (m23 + m32) / s3;
      this._z = 0.25 * s3;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r4 = vFrom.dot(vTo) + 1;
    if (r4 < Number.EPSILON) {
      r4 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r4;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r4;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r4;
    }
    return this.normalize();
  }
  angleTo(q3) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q3), -1, 1)));
  }
  rotateTowards(q3, step) {
    const angle = this.angleTo(q3);
    if (angle === 0)
      return this;
    const t4 = Math.min(1, step / angle);
    this.slerp(q3, t4);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v4) {
    return this._x * v4._x + this._y * v4._y + this._z * v4._z + this._w * v4._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l4 = this.length();
    if (l4 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l4 = 1 / l4;
      this._x = this._x * l4;
      this._y = this._y * l4;
      this._z = this._z * l4;
      this._w = this._w * l4;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q3) {
    return this.multiplyQuaternions(this, q3);
  }
  premultiply(q3) {
    return this.multiplyQuaternions(q3, this);
  }
  multiplyQuaternions(a3, b4) {
    const { _x: qax, _y: qay, _z: qaz, _w: qaw } = a3;
    const { _x: qbx, _y: qby, _z: qbz, _w: qbw } = b4;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t4) {
    if (t4 === 0)
      return this;
    if (t4 === 1)
      return this.copy(qb);
    const x3 = this._x, y3 = this._y, z3 = this._z, w4 = this._w;
    let cosHalfTheta = w4 * qb._w + x3 * qb._x + y3 * qb._y + z3 * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w4;
      this._x = x3;
      this._y = y3;
      this._z = z3;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s3 = 1 - t4;
      this._w = s3 * w4 + t4 * this._w;
      this._x = s3 * x3 + t4 * this._x;
      this._y = s3 * y3 + t4 * this._y;
      this._z = s3 * z3 + t4 * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t4) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t4 * halfTheta) / sinHalfTheta;
    this._w = w4 * ratioA + this._w * ratioB;
    this._x = x3 * ratioA + this._x * ratioB;
    this._y = y3 * ratioA + this._y * ratioB;
    this._z = z3 * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t4) {
    return this.copy(qa).slerp(qb, t4);
  }
  random() {
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u22 = 2 * Math.PI * Math.random();
    const u32 = 2 * Math.PI * Math.random();
    return this.set(sqrt1u1 * Math.cos(u22), sqrtu1 * Math.sin(u32), sqrtu1 * Math.cos(u32), sqrt1u1 * Math.sin(u22));
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this._x = attribute.getX(index2);
    this._y = attribute.getY(index2);
    this._z = attribute.getZ(index2);
    this._w = attribute.getW(index2);
    return this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
}

class Vector3 {
  constructor(x3 = 0, y3 = 0, z3 = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x3;
    this.y = y3;
    this.z = z3;
  }
  set(x3, y3, z3) {
    if (z3 === undefined)
      z3 = this.z;
    this.x = x3;
    this.y = y3;
    this.z = z3;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x3) {
    this.x = x3;
    return this;
  }
  setY(y3) {
    this.y = y3;
    return this;
  }
  setZ(z3) {
    this.z = z3;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v4) {
    this.x = v4.x;
    this.y = v4.y;
    this.z = v4.z;
    return this;
  }
  add(v4) {
    this.x += v4.x;
    this.y += v4.y;
    this.z += v4.z;
    return this;
  }
  addScalar(s3) {
    this.x += s3;
    this.y += s3;
    this.z += s3;
    return this;
  }
  addVectors(a3, b4) {
    this.x = a3.x + b4.x;
    this.y = a3.y + b4.y;
    this.z = a3.z + b4.z;
    return this;
  }
  addScaledVector(v4, s3) {
    this.x += v4.x * s3;
    this.y += v4.y * s3;
    this.z += v4.z * s3;
    return this;
  }
  sub(v4) {
    this.x -= v4.x;
    this.y -= v4.y;
    this.z -= v4.z;
    return this;
  }
  subScalar(s3) {
    this.x -= s3;
    this.y -= s3;
    this.z -= s3;
    return this;
  }
  subVectors(a3, b4) {
    this.x = a3.x - b4.x;
    this.y = a3.y - b4.y;
    this.z = a3.z - b4.z;
    return this;
  }
  multiply(v4) {
    this.x *= v4.x;
    this.y *= v4.y;
    this.z *= v4.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a3, b4) {
    this.x = a3.x * b4.x;
    this.y = a3.y * b4.y;
    this.z = a3.z * b4.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m4) {
    const x3 = this.x, y3 = this.y, z3 = this.z;
    const e3 = m4.elements;
    this.x = e3[0] * x3 + e3[3] * y3 + e3[6] * z3;
    this.y = e3[1] * x3 + e3[4] * y3 + e3[7] * z3;
    this.z = e3[2] * x3 + e3[5] * y3 + e3[8] * z3;
    return this;
  }
  applyNormalMatrix(m4) {
    return this.applyMatrix3(m4).normalize();
  }
  applyMatrix4(m4) {
    const x3 = this.x, y3 = this.y, z3 = this.z;
    const e3 = m4.elements;
    const w4 = 1 / (e3[3] * x3 + e3[7] * y3 + e3[11] * z3 + e3[15]);
    this.x = (e3[0] * x3 + e3[4] * y3 + e3[8] * z3 + e3[12]) * w4;
    this.y = (e3[1] * x3 + e3[5] * y3 + e3[9] * z3 + e3[13]) * w4;
    this.z = (e3[2] * x3 + e3[6] * y3 + e3[10] * z3 + e3[14]) * w4;
    return this;
  }
  applyQuaternion(q3) {
    const x3 = this.x, y3 = this.y, z3 = this.z;
    const { x: qx, y: qy, z: qz, w: qw } = q3;
    const ix = qw * x3 + qy * z3 - qz * y3;
    const iy = qw * y3 + qz * x3 - qx * z3;
    const iz = qw * z3 + qx * y3 - qy * x3;
    const iw = -qx * x3 - qy * y3 - qz * z3;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m4) {
    const x3 = this.x, y3 = this.y, z3 = this.z;
    const e3 = m4.elements;
    this.x = e3[0] * x3 + e3[4] * y3 + e3[8] * z3;
    this.y = e3[1] * x3 + e3[5] * y3 + e3[9] * z3;
    this.z = e3[2] * x3 + e3[6] * y3 + e3[10] * z3;
    return this.normalize();
  }
  divide(v4) {
    this.x /= v4.x;
    this.y /= v4.y;
    this.z /= v4.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v4) {
    this.x = Math.min(this.x, v4.x);
    this.y = Math.min(this.y, v4.y);
    this.z = Math.min(this.z, v4.z);
    return this;
  }
  max(v4) {
    this.x = Math.max(this.x, v4.x);
    this.y = Math.max(this.y, v4.y);
    this.z = Math.max(this.z, v4.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v4) {
    return this.x * v4.x + this.y * v4.y + this.z * v4.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v4, alpha2) {
    this.x += (v4.x - this.x) * alpha2;
    this.y += (v4.y - this.y) * alpha2;
    this.z += (v4.z - this.z) * alpha2;
    return this;
  }
  lerpVectors(v1, v22, alpha2) {
    this.x = v1.x + (v22.x - v1.x) * alpha2;
    this.y = v1.y + (v22.y - v1.y) * alpha2;
    this.z = v1.z + (v22.z - v1.z) * alpha2;
    return this;
  }
  cross(v4) {
    return this.crossVectors(this, v4);
  }
  crossVectors(a3, b4) {
    const { x: ax, y: ay, z: az } = a3;
    const { x: bx, y: by, z: bz } = b4;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v4) {
    const denominator = v4.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v4.dot(this) / denominator;
    return this.copy(v4).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$b.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$b);
  }
  reflect(normal) {
    return this.sub(_vector$b.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v4) {
    const denominator = Math.sqrt(this.lengthSq() * v4.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v4) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v4) {
    return Math.sqrt(this.distanceToSquared(v4));
  }
  distanceToSquared(v4) {
    const dx = this.x - v4.x, dy = this.y - v4.y, dz = this.z - v4.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v4) {
    return Math.abs(this.x - v4.x) + Math.abs(this.y - v4.y) + Math.abs(this.z - v4.z);
  }
  setFromSpherical(s3) {
    return this.setFromSphericalCoords(s3.radius, s3.phi, s3.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c3) {
    return this.setFromCylindricalCoords(c3.radius, c3.theta, c3.y);
  }
  setFromCylindricalCoords(radius, theta, y3) {
    this.x = radius * Math.sin(theta);
    this.y = y3;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m4) {
    const e3 = m4.elements;
    this.x = e3[12];
    this.y = e3[13];
    this.z = e3[14];
    return this;
  }
  setFromMatrixScale(m4) {
    const sx = this.setFromMatrixColumn(m4, 0).length();
    const sy = this.setFromMatrixColumn(m4, 1).length();
    const sz = this.setFromMatrixColumn(m4, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m4, index2) {
    return this.fromArray(m4.elements, index2 * 4);
  }
  setFromMatrix3Column(m4, index2) {
    return this.fromArray(m4.elements, index2 * 3);
  }
  setFromEuler(e3) {
    this.x = e3._x;
    this.y = e3._y;
    this.z = e3._z;
    return this;
  }
  setFromColor(c3) {
    this.x = c3.r;
    this.y = c3.g;
    this.z = c3.b;
    return this;
  }
  equals(v4) {
    return v4.x === this.x && v4.y === this.y && v4.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    this.z = attribute.getZ(index2);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const u6 = (Math.random() - 0.5) * 2;
    const t4 = Math.random() * Math.PI * 2;
    const f4 = Math.sqrt(1 - u6 ** 2);
    this.x = f4 * Math.cos(t4);
    this.y = f4 * Math.sin(t4);
    this.z = u6;
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
var _vector$b = new Vector3;
var _quaternion$4 = new Quaternion;

class Box3 {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3((-Infinity), (-Infinity), (-Infinity))) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    this.makeEmpty();
    for (let i3 = 0, il = array.length;i3 < il; i3 += 3) {
      this.expandByPoint(_vector$a.fromArray(array, i3));
    }
    return this;
  }
  setFromBufferAttribute(attribute) {
    this.makeEmpty();
    for (let i3 = 0, il = attribute.count;i3 < il; i3++) {
      this.expandByPoint(_vector$a.fromBufferAttribute(attribute, i3));
    }
    return this;
  }
  setFromPoints(points2) {
    this.makeEmpty();
    for (let i3 = 0, il = points2.length;i3 < il; i3++) {
      this.expandByPoint(points2[i3]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$a.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = (-Infinity);
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    if (object.boundingBox !== undefined) {
      if (object.boundingBox === null) {
        object.computeBoundingBox();
      }
      _box$3.copy(object.boundingBox);
      _box$3.applyMatrix4(object.matrixWorld);
      this.union(_box$3);
    } else {
      const geometry = object.geometry;
      if (geometry !== undefined) {
        if (precise && geometry.attributes !== undefined && geometry.attributes.position !== undefined) {
          const position = geometry.attributes.position;
          for (let i3 = 0, l4 = position.count;i3 < l4; i3++) {
            _vector$a.fromBufferAttribute(position, i3).applyMatrix4(object.matrixWorld);
            this.expandByPoint(_vector$a);
          }
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$3.copy(geometry.boundingBox);
          _box$3.applyMatrix4(object.matrixWorld);
          this.union(_box$3);
        }
      }
    }
    const children = object.children;
    for (let i3 = 0, l4 = children.length;i3 < l4; i3++) {
      this.expandByObject(children[i3], precise);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$a);
    return _vector$a.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$4.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$2, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$a).distanceTo(point);
  }
  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$a).length() * 0.5;
    }
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
var _points = [
  new Vector3,
  new Vector3,
  new Vector3,
  new Vector3,
  new Vector3,
  new Vector3,
  new Vector3,
  new Vector3
];
var _vector$a = new Vector3;
var _box$3 = new Box3;
var _v0$2 = new Vector3;
var _v1$7 = new Vector3;
var _v2$4 = new Vector3;
var _f0 = new Vector3;
var _f1 = new Vector3;
var _f2 = new Vector3;
var _center = new Vector3;
var _extents = new Vector3;
var _triangleNormal = new Vector3;
var _testAxis = new Vector3;
var _box$2 = new Box3;
var _v1$6 = new Vector3;
var _v2$3 = new Vector3;

class Sphere {
  constructor(center = new Vector3, radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points2, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== undefined) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points2).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i3 = 0, il = points2.length;i3 < il; i3++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points2[i3]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point, this.center);
    const lengthSq = _v1$6.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length2 = Math.sqrt(lengthSq);
      const delta = (length2 - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length2);
      this.radius += delta;
    }
    return this;
  }
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
var _vector$9 = new Vector3;
var _segCenter = new Vector3;
var _segDir = new Vector3;
var _diff = new Vector3;
var _edge1 = new Vector3;
var _edge2 = new Vector3;
var _normal$1 = new Vector3;

class Ray2 {
  constructor(origin = new Vector3, direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t4, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t4);
  }
  lookAt(v4) {
    this.direction.copy(v4).sub(this.origin).normalize();
    return this;
  }
  recast(t4) {
    this.origin.copy(this.at(t4, _vector$9));
    return this;
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$9.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$9.copy(this.origin).addScaledVector(this.direction, directionDistance);
    return _vector$9.distanceToSquared(point);
  }
  distanceSqToSegment(v02, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v02).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v02).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v02.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c3 = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c3;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c3;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$9.subVectors(sphere.center, this.origin);
    const tca = _vector$9.dot(this.direction);
    const d22 = _vector$9.dot(_vector$9) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d22 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d22);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t4 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t4 >= 0 ? t4 : null;
  }
  intersectPlane(plane, target) {
    const t4 = this.distanceToPlane(plane);
    if (t4 === null) {
      return null;
    }
    return this.at(t4, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || isNaN(tmin))
      tmin = tymin;
    if (tymax < tmax || isNaN(tmax))
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$9) !== null;
  }
  intersectTriangle(a3, b4, c3, backfaceCulling, target) {
    _edge1.subVectors(b4, a3);
    _edge2.subVectors(c3, a3);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a3);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}

class Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== undefined) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m4) {
    const te = this.elements;
    const me = m4.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m4) {
    const te = this.elements, me = m4.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m4) {
    const me = m4.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis2, yAxis2, zAxis) {
    xAxis2.setFromMatrixColumn(this, 0);
    yAxis2.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis2, yAxis2, zAxis) {
    this.set(xAxis2.x, yAxis2.x, zAxis.x, 0, xAxis2.y, yAxis2.y, zAxis.y, 0, xAxis2.z, yAxis2.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m4) {
    const te = this.elements;
    const me = m4.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m4, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m4, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m4, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const { x: x3, y: y3, z: z3 } = euler;
    const a3 = Math.cos(x3), b4 = Math.sin(x3);
    const c3 = Math.cos(y3), d3 = Math.sin(y3);
    const e3 = Math.cos(z3), f4 = Math.sin(z3);
    if (euler.order === "XYZ") {
      const ae = a3 * e3, af = a3 * f4, be = b4 * e3, bf = b4 * f4;
      te[0] = c3 * e3;
      te[4] = -c3 * f4;
      te[8] = d3;
      te[1] = af + be * d3;
      te[5] = ae - bf * d3;
      te[9] = -b4 * c3;
      te[2] = bf - ae * d3;
      te[6] = be + af * d3;
      te[10] = a3 * c3;
    } else if (euler.order === "YXZ") {
      const ce2 = c3 * e3, cf = c3 * f4, de2 = d3 * e3, df = d3 * f4;
      te[0] = ce2 + df * b4;
      te[4] = de2 * b4 - cf;
      te[8] = a3 * d3;
      te[1] = a3 * f4;
      te[5] = a3 * e3;
      te[9] = -b4;
      te[2] = cf * b4 - de2;
      te[6] = df + ce2 * b4;
      te[10] = a3 * c3;
    } else if (euler.order === "ZXY") {
      const ce2 = c3 * e3, cf = c3 * f4, de2 = d3 * e3, df = d3 * f4;
      te[0] = ce2 - df * b4;
      te[4] = -a3 * f4;
      te[8] = de2 + cf * b4;
      te[1] = cf + de2 * b4;
      te[5] = a3 * e3;
      te[9] = df - ce2 * b4;
      te[2] = -a3 * d3;
      te[6] = b4;
      te[10] = a3 * c3;
    } else if (euler.order === "ZYX") {
      const ae = a3 * e3, af = a3 * f4, be = b4 * e3, bf = b4 * f4;
      te[0] = c3 * e3;
      te[4] = be * d3 - af;
      te[8] = ae * d3 + bf;
      te[1] = c3 * f4;
      te[5] = bf * d3 + ae;
      te[9] = af * d3 - be;
      te[2] = -d3;
      te[6] = b4 * c3;
      te[10] = a3 * c3;
    } else if (euler.order === "YZX") {
      const ac2 = a3 * c3, ad = a3 * d3, bc4 = b4 * c3, bd2 = b4 * d3;
      te[0] = c3 * e3;
      te[4] = bd2 - ac2 * f4;
      te[8] = bc4 * f4 + ad;
      te[1] = f4;
      te[5] = a3 * e3;
      te[9] = -b4 * e3;
      te[2] = -d3 * e3;
      te[6] = ad * f4 + bc4;
      te[10] = ac2 - bd2 * f4;
    } else if (euler.order === "XZY") {
      const ac2 = a3 * c3, ad = a3 * d3, bc4 = b4 * c3, bd2 = b4 * d3;
      te[0] = c3 * e3;
      te[4] = -f4;
      te[8] = d3 * e3;
      te[1] = ac2 * f4 + bd2;
      te[5] = a3 * e3;
      te[9] = ad * f4 - bc4;
      te[2] = bc4 * f4 - ad;
      te[6] = b4 * e3;
      te[10] = bd2 * f4 + ac2;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q3) {
    return this.compose(_zero, q3, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 0.0001;
      } else {
        _z.z += 0.0001;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m4) {
    return this.multiplyMatrices(this, m4);
  }
  premultiply(m4) {
    return this.multiplyMatrices(m4, this);
  }
  multiplyMatrices(a3, b4) {
    const ae = a3.elements;
    const be = b4.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s3) {
    const te = this.elements;
    te[0] *= s3;
    te[4] *= s3;
    te[8] *= s3;
    te[12] *= s3;
    te[1] *= s3;
    te[5] *= s3;
    te[9] *= s3;
    te[13] *= s3;
    te[2] *= s3;
    te[6] *= s3;
    te[10] *= s3;
    te[14] *= s3;
    te[3] *= s3;
    te[7] *= s3;
    te[11] *= s3;
    te[15] *= s3;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp16;
    tmp16 = te[1];
    te[1] = te[4];
    te[4] = tmp16;
    tmp16 = te[2];
    te[2] = te[8];
    te[8] = tmp16;
    tmp16 = te[6];
    te[6] = te[9];
    te[9] = tmp16;
    tmp16 = te[3];
    te[3] = te[12];
    te[12] = tmp16;
    tmp16 = te[7];
    te[7] = te[13];
    te[13] = tmp16;
    tmp16 = te[11];
    te[11] = te[14];
    te[14] = tmp16;
    return this;
  }
  setPosition(x3, y3, z3) {
    const te = this.elements;
    if (x3.isVector3) {
      te[12] = x3.x;
      te[13] = x3.y;
      te[14] = x3.z;
    } else {
      te[12] = x3;
      te[13] = y3;
      te[14] = z3;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v4) {
    const te = this.elements;
    const { x: x3, y: y3, z: z3 } = v4;
    te[0] *= x3;
    te[4] *= y3;
    te[8] *= z3;
    te[1] *= x3;
    te[5] *= y3;
    te[9] *= z3;
    te[2] *= x3;
    te[6] *= y3;
    te[10] *= z3;
    te[3] *= x3;
    te[7] *= y3;
    te[11] *= z3;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x3, y3, z3) {
    if (x3.isVector3) {
      this.set(1, 0, 0, x3.x, 0, 1, 0, x3.y, 0, 0, 1, x3.z, 0, 0, 0, 1);
    } else {
      this.set(1, 0, 0, x3, 0, 1, 0, y3, 0, 0, 1, z3, 0, 0, 0, 1);
    }
    return this;
  }
  makeRotationX(theta) {
    const c3 = Math.cos(theta), s3 = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c3, -s3, 0, 0, s3, c3, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c3 = Math.cos(theta), s3 = Math.sin(theta);
    this.set(c3, 0, s3, 0, 0, 1, 0, 0, -s3, 0, c3, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c3 = Math.cos(theta), s3 = Math.sin(theta);
    this.set(c3, -s3, 0, 0, s3, c3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c3 = Math.cos(angle);
    const s3 = Math.sin(angle);
    const t4 = 1 - c3;
    const { x: x3, y: y3, z: z3 } = axis;
    const tx = t4 * x3, ty = t4 * y3;
    this.set(tx * x3 + c3, tx * y3 - s3 * z3, tx * z3 + s3 * y3, 0, tx * y3 + s3 * z3, ty * y3 + c3, ty * z3 - s3 * x3, 0, tx * z3 - s3 * y3, ty * z3 + s3 * x3, t4 * z3 * z3 + c3, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x3, y3, z3) {
    this.set(x3, 0, 0, 0, 0, y3, 0, 0, 0, 0, z3, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale3) {
    const te = this.elements;
    const { _x: x3, _y: y3, _z: z3, _w: w4 } = quaternion;
    const x22 = x3 + x3, y22 = y3 + y3, z22 = z3 + z3;
    const xx = x3 * x22, xy = x3 * y22, xz = x3 * z22;
    const yy = y3 * y22, yz = y3 * z22, zz = z3 * z22;
    const wx = w4 * x22, wy = w4 * y22, wz = w4 * z22;
    const { x: sx, y: sy, z: sz } = scale3;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale3) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale3.x = sx;
    scale3.y = sy;
    scale3.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const x3 = 2 * near / (right - left);
    const y3 = 2 * near / (top - bottom);
    const a3 = (right + left) / (right - left);
    const b4 = (top + bottom) / (top - bottom);
    let c3, d3;
    if (coordinateSystem === WebGLCoordinateSystem) {
      c3 = -(far + near) / (far - near);
      d3 = -2 * far * near / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      c3 = -far / (far - near);
      d3 = -far * near / (far - near);
    } else {
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = x3;
    te[4] = 0;
    te[8] = a3;
    te[12] = 0;
    te[1] = 0;
    te[5] = y3;
    te[9] = b4;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c3;
    te[14] = d3;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const w4 = 1 / (right - left);
    const h3 = 1 / (top - bottom);
    const p3 = 1 / (far - near);
    const x3 = (right + left) * w4;
    const y3 = (top + bottom) * h3;
    let z3, zInv;
    if (coordinateSystem === WebGLCoordinateSystem) {
      z3 = (far + near) * p3;
      zInv = -2 * p3;
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      z3 = near * p3;
      zInv = -1 * p3;
    } else {
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = 2 * w4;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x3;
    te[1] = 0;
    te[5] = 2 * h3;
    te[9] = 0;
    te[13] = -y3;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z3;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i3 = 0;i3 < 16; i3++) {
      if (te[i3] !== me[i3])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i3 = 0;i3 < 16; i3++) {
      this.elements[i3] = array[i3 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
}
var _v1$5 = new Vector3;
var _m1$2 = new Matrix4;
var _zero = new Vector3(0, 0, 0);
var _one = new Vector3(1, 1, 1);
var _x = new Vector3;
var _y = new Vector3;
var _z = new Vector3;
var _matrix = new Matrix4;
var _quaternion$3 = new Quaternion;

class Euler {
  constructor(x3 = 0, y3 = 0, z3 = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x3;
    this._y = y3;
    this._z = z3;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x3, y3, z3, order = this._order) {
    this._x = x3;
    this._y = y3;
    this._z = z3;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m4, order = this._order, update = true) {
    const te = m4.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q3, order, update) {
    _matrix.makeRotationFromQuaternion(q3);
    return this.setFromRotationMatrix(_matrix, order, update);
  }
  setFromVector3(v4, order = this._order) {
    return this.set(v4.x, v4.y, v4.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";

class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
}
var _object3DId = 0;
var _v1$4 = new Vector3;
var _q1 = new Quaternion;
var _m1$1 = new Matrix4;
var _target = new Vector3;
var _position$3 = new Vector3;
var _scale$2 = new Vector3;
var _quaternion$2 = new Quaternion;
var _xAxis = new Vector3(1, 0, 0);
var _yAxis = new Vector3(0, 1, 0);
var _zAxis = new Vector3(0, 0, 1);
var _addedEvent = { type: "added" };
var _removedEvent = { type: "removed" };

class Object3D extends EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new Vector3;
    const rotation = new Euler;
    const quaternion = new Quaternion;
    const scale3 = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, undefined, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale3
      },
      modelViewMatrix: {
        value: new Matrix4
      },
      normalMatrix: {
        value: new Matrix32
      }
    });
    this.matrix = new Matrix4;
    this.matrixWorld = new Matrix4;
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.layers = new Layers;
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q3) {
    this.quaternion.premultiply(q3);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m4) {
    this.quaternion.setFromRotationMatrix(m4);
  }
  setRotationFromQuaternion(q3) {
    this.quaternion.copy(q3);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance3) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance3));
    return this;
  }
  translateX(distance3) {
    return this.translateOnAxis(_xAxis, distance3);
  }
  translateY(distance3) {
    return this.translateOnAxis(_yAxis, distance3);
  }
  translateZ(distance3) {
    return this.translateOnAxis(_zAxis, distance3);
  }
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x3, y3, z3) {
    if (x3.isVector3) {
      _target.copy(x3);
    } else {
      _target.set(x3, y3, z3);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i3 = 0;i3 < arguments.length; i3++) {
        this.add(arguments[i3]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can\'t be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i3 = 0;i3 < arguments.length; i3++) {
        this.remove(arguments[i3]);
      }
      return this;
    }
    const index2 = this.children.indexOf(object);
    if (index2 !== -1) {
      object.parent = null;
      this.children.splice(index2, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value)
      return this;
    for (let i3 = 0, l4 = this.children.length;i3 < l4; i3++) {
      const child = this.children[i3];
      const object = child.getObjectByProperty(name, value);
      if (object !== undefined) {
        return object;
      }
    }
    return;
  }
  getObjectsByProperty(name, value) {
    let result = [];
    if (this[name] === value)
      result.push(this);
    for (let i3 = 0, l4 = this.children.length;i3 < l4; i3++) {
      const childResult = this.children[i3].getObjectsByProperty(name, value);
      if (childResult.length > 0) {
        result = result.concat(childResult);
      }
    }
    return result;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e3 = this.matrixWorld.elements;
    return target.set(e3[8], e3[9], e3[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i3 = 0, l4 = children.length;i3 < l4; i3++) {
      children[i3].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i3 = 0, l4 = children.length;i3 < l4; i3++) {
      children[i3].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i3 = 0, l4 = children.length;i3 < l4; i3++) {
      const child = children[i3];
      if (child.matrixWorldAutoUpdate === true || force === true) {
        child.updateMatrixWorld(force);
      }
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i3 = 0, l4 = children.length;i3 < l4; i3++) {
        const child = children[i3];
        if (child.matrixWorldAutoUpdate === true) {
          child.updateWorldMatrix(false, true);
        }
      }
    }
  }
  toJSON(meta2) {
    const isRootObject = meta2 === undefined || typeof meta2 === "string";
    const output = {};
    if (isRootObject) {
      meta2 = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0)
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta2);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta2).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta2).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta2.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== undefined && parameters.shapes !== undefined) {
        const shapes2 = parameters.shapes;
        if (Array.isArray(shapes2)) {
          for (let i3 = 0, l4 = shapes2.length;i3 < l4; i3++) {
            const shape = shapes2[i3];
            serialize(meta2.shapes, shape);
          }
        } else {
          serialize(meta2.shapes, shapes2);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== undefined) {
        serialize(meta2.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i3 = 0, l4 = this.material.length;i3 < l4; i3++) {
          uuids.push(serialize(meta2.materials, this.material[i3]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta2.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i3 = 0;i3 < this.children.length; i3++) {
        object.children.push(this.children[i3].toJSON(meta2).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i3 = 0;i3 < this.animations.length; i3++) {
        const animation = this.animations[i3];
        object.animations.push(serialize(meta2.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta2.geometries);
      const materials = extractFromCache(meta2.materials);
      const textures2 = extractFromCache(meta2.textures);
      const images = extractFromCache(meta2.images);
      const shapes2 = extractFromCache(meta2.shapes);
      const skeletons = extractFromCache(meta2.skeletons);
      const animations = extractFromCache(meta2.animations);
      const nodes = extractFromCache(meta2.nodes);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures2.length > 0)
        output.textures = textures2;
      if (images.length > 0)
        output.images = images;
      if (shapes2.length > 0)
        output.shapes = shapes2;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
      if (nodes.length > 0)
        output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data = cache2[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i3 = 0;i3 < source.children.length; i3++) {
        const child = source.children[i3];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DEFAULT_UP = new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
var _v0$1 = new Vector3;
var _v1$3 = new Vector3;
var _v2$2 = new Vector3;
var _v3$1 = new Vector3;
var _vab = new Vector3;
var _vac = new Vector3;
var _vbc = new Vector3;
var _vap = new Vector3;
var _vbp = new Vector3;
var _vcp = new Vector3;
var warnedGetUV = false;

class Triangle {
  constructor(a3 = new Vector3, b4 = new Vector3, c3 = new Vector3) {
    this.a = a3;
    this.b = b4;
    this.c = c3;
  }
  static getNormal(a3, b4, c3, target) {
    target.subVectors(c3, b4);
    _v0$1.subVectors(a3, b4);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  static getBarycoord(point, a3, b4, c3, target) {
    _v0$1.subVectors(c3, a3);
    _v1$3.subVectors(b4, a3);
    _v2$2.subVectors(point, a3);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u6 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v4 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u6 - v4, v4, u6);
  }
  static containsPoint(point, a3, b4, c3) {
    this.getBarycoord(point, a3, b4, c3, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point, p1, p22, p3, uv1, uv2, uv3, target) {
    if (warnedGetUV === false) {
      console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().");
      warnedGetUV = true;
    }
    return this.getInterpolation(point, p1, p22, p3, uv1, uv2, uv3, target);
  }
  static getInterpolation(point, p1, p22, p3, v1, v22, v32, target) {
    this.getBarycoord(point, p1, p22, p3, _v3$1);
    target.setScalar(0);
    target.addScaledVector(v1, _v3$1.x);
    target.addScaledVector(v22, _v3$1.y);
    target.addScaledVector(v32, _v3$1.z);
    return target;
  }
  static isFrontFacing(a3, b4, c3, direction) {
    _v0$1.subVectors(c3, b4);
    _v1$3.subVectors(a3, b4);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a3, b4, c3) {
    this.a.copy(a3);
    this.b.copy(b4);
    this.c.copy(c3);
    return this;
  }
  setFromPointsAndIndices(points2, i0, i1, i22) {
    this.a.copy(points2[i0]);
    this.b.copy(points2[i1]);
    this.c.copy(points2[i22]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i22) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i22);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    if (warnedGetUV === false) {
      console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().");
      warnedGetUV = true;
    }
    return Triangle.getInterpolation(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  getInterpolation(point, v1, v22, v32, target) {
    return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v22, v32, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p3, target) {
    const a3 = this.a, b4 = this.b, c3 = this.c;
    let v4, w4;
    _vab.subVectors(b4, a3);
    _vac.subVectors(c3, a3);
    _vap.subVectors(p3, a3);
    const d1 = _vab.dot(_vap);
    const d22 = _vac.dot(_vap);
    if (d1 <= 0 && d22 <= 0) {
      return target.copy(a3);
    }
    _vbp.subVectors(p3, b4);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b4);
    }
    const vc = d1 * d4 - d3 * d22;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v4 = d1 / (d1 - d3);
      return target.copy(a3).addScaledVector(_vab, v4);
    }
    _vcp.subVectors(p3, c3);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c3);
    }
    const vb = d5 * d22 - d1 * d6;
    if (vb <= 0 && d22 >= 0 && d6 <= 0) {
      w4 = d22 / (d22 - d6);
      return target.copy(a3).addScaledVector(_vac, w4);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c3, b4);
      w4 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b4).addScaledVector(_vbc, w4);
    }
    const denom = 1 / (va + vb + vc);
    v4 = vb * denom;
    w4 = vc * denom;
    return target.copy(a3).addScaledVector(_vab, v4).addScaledVector(_vac, w4);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
var _materialId = 0;

class Material2 extends EventDispatcher {
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: _materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.alphaHash = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === undefined)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === undefined) {
        console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === undefined) {
        console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta2) {
    const isRootObject = meta2 === undefined || typeof meta2 === "string";
    if (isRootObject) {
      meta2 = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== undefined)
      data.roughness = this.roughness;
    if (this.metalness !== undefined)
      data.metalness = this.metalness;
    if (this.sheen !== undefined)
      data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor)
      data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== undefined)
      data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.specularIntensity !== undefined)
      data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor)
      data.specularColor = this.specularColor.getHex();
    if (this.shininess !== undefined)
      data.shininess = this.shininess;
    if (this.clearcoat !== undefined)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== undefined)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta2).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta2).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta2).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.iridescence !== undefined)
      data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== undefined)
      data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== undefined)
      data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta2).uuid;
    }
    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta2).uuid;
    }
    if (this.anisotropy !== undefined)
      data.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== undefined)
      data.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data.anisotropyMap = this.anisotropyMap.toJSON(meta2).uuid;
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta2).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta2).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta2).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta2).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta2).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta2).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta2).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta2).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta2).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta2).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta2).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta2).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta2).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture)
      data.specularColorMap = this.specularColorMap.toJSON(meta2).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta2).uuid;
      if (this.combine !== undefined)
        data.combine = this.combine;
    }
    if (this.envMapIntensity !== undefined)
      data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== undefined)
      data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== undefined)
      data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta2).uuid;
    }
    if (this.transmission !== undefined)
      data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta2).uuid;
    if (this.thickness !== undefined)
      data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta2).uuid;
    if (this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity)
      data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== undefined)
      data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== undefined)
      data.size = this.size;
    if (this.shadowSide !== null)
      data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== undefined)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation !== undefined && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== undefined && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== undefined)
      data.dashSize = this.dashSize;
    if (this.gapSize !== undefined)
      data.gapSize = this.gapSize;
    if (this.scale !== undefined)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.alphaHash === true)
      data.alphaHash = this.alphaHash;
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.forceSinglePass === true)
      data.forceSinglePass = this.forceSinglePass;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (this.fog === false)
      data.fog = false;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures2 = extractFromCache(meta2.textures);
      const images = extractFromCache(meta2.images);
      if (textures2.length > 0)
        data.textures = textures2;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n4 = srcPlanes.length;
      dstPlanes = new Array(n4);
      for (let i3 = 0;i3 !== n4; ++i3) {
        dstPlanes[i3] = srcPlanes[i3].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaHash = source.alphaHash;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
}
var _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };

class Color2 {
  constructor(r4, g5, b4) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r4, g5, b4);
  }
  set(r4, g5, b4) {
    if (g5 === undefined && b4 === undefined) {
      const value = r4;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r4, g5, b4);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r4, g5, b4, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r4;
    this.g = g5;
    this.b = b4;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h3, s3, l4, colorSpace = ColorManagement.workingColorSpace) {
    h3 = euclideanModulo(h3, 1);
    s3 = clamp(s3, 0, 1);
    l4 = clamp(l4, 0, 1);
    if (s3 === 0) {
      this.r = this.g = this.b = l4;
    } else {
      const p3 = l4 <= 0.5 ? l4 * (1 + s3) : l4 + s3 - l4 * s3;
      const q3 = 2 * l4 - p3;
      this.r = hue2rgb(q3, p3, h3 + 1 / 3);
      this.g = hue2rgb(q3, p3, h3);
      this.b = hue2rgb(q3, p3, h3 - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === undefined)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m4;
    if (m4 = /^(\w+)\(([^\)]*)\)/.exec(style)) {
      let color8;
      const name = m4[1];
      const components = m4[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color8 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color8[4]);
            return this.setRGB(Math.min(255, parseInt(color8[1], 10)) / 255, Math.min(255, parseInt(color8[2], 10)) / 255, Math.min(255, parseInt(color8[3], 10)) / 255, colorSpace);
          }
          if (color8 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color8[4]);
            return this.setRGB(Math.min(100, parseInt(color8[1], 10)) / 100, Math.min(100, parseInt(color8[2], 10)) / 100, Math.min(100, parseInt(color8[3], 10)) / 100, colorSpace);
          }
          break;
        case "hsl":
        case "hsla":
          if (color8 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color8[4]);
            return this.setHSL(parseFloat(color8[1]) / 360, parseFloat(color8[2]) / 100, parseFloat(color8[3]) / 100, colorSpace);
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style);
      }
    } else if (m4 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m4[1];
      const size = hex.length;
      if (size === 3) {
        return this.setRGB(parseInt(hex.charAt(0), 16) / 15, parseInt(hex.charAt(1), 16) / 15, parseInt(hex.charAt(2), 16) / 15, colorSpace);
      } else if (size === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== undefined) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color8) {
    this.r = color8.r;
    this.g = color8.g;
    this.b = color8.b;
    return this;
  }
  copySRGBToLinear(color8) {
    this.r = SRGBToLinear(color8.r);
    this.g = SRGBToLinear(color8.g);
    this.b = SRGBToLinear(color8.b);
    return this;
  }
  copyLinearToSRGB(color8) {
    this.r = LinearToSRGB(color8.r);
    this.g = LinearToSRGB(color8.g);
    this.b = LinearToSRGB(color8.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const { r: r4, g: g5, b: b4 } = _color;
    const max = Math.max(r4, g5, b4);
    const min = Math.min(r4, g5, b4);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r4:
          hue = (g5 - b4) / delta + (g5 < b4 ? 6 : 0);
          break;
        case g5:
          hue = (b4 - r4) / delta + 2;
          break;
        case b4:
          hue = (r4 - g5) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    target.r = _color.r;
    target.g = _color.g;
    target.b = _color.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const { r: r4, g: g5, b: b4 } = _color;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r4.toFixed(3)} ${g5.toFixed(3)} ${b4.toFixed(3)})`;
    }
    return `rgb(${Math.round(r4 * 255)},${Math.round(g5 * 255)},${Math.round(b4 * 255)})`;
  }
  offsetHSL(h3, s3, l4) {
    this.getHSL(_hslA);
    _hslA.h += h3;
    _hslA.s += s3;
    _hslA.l += l4;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color8) {
    this.r += color8.r;
    this.g += color8.g;
    this.b += color8.b;
    return this;
  }
  addColors(color1, color22) {
    this.r = color1.r + color22.r;
    this.g = color1.g + color22.g;
    this.b = color1.b + color22.b;
    return this;
  }
  addScalar(s3) {
    this.r += s3;
    this.g += s3;
    this.b += s3;
    return this;
  }
  sub(color8) {
    this.r = Math.max(0, this.r - color8.r);
    this.g = Math.max(0, this.g - color8.g);
    this.b = Math.max(0, this.b - color8.b);
    return this;
  }
  multiply(color8) {
    this.r *= color8.r;
    this.g *= color8.g;
    this.b *= color8.b;
    return this;
  }
  multiplyScalar(s3) {
    this.r *= s3;
    this.g *= s3;
    this.b *= s3;
    return this;
  }
  lerp(color8, alpha2) {
    this.r += (color8.r - this.r) * alpha2;
    this.g += (color8.g - this.g) * alpha2;
    this.b += (color8.b - this.b) * alpha2;
    return this;
  }
  lerpColors(color1, color22, alpha2) {
    this.r = color1.r + (color22.r - color1.r) * alpha2;
    this.g = color1.g + (color22.g - color1.g) * alpha2;
    this.b = color1.b + (color22.b - color1.b) * alpha2;
    return this;
  }
  lerpHSL(color8, alpha2) {
    this.getHSL(_hslA);
    color8.getHSL(_hslB);
    const h3 = lerp2(_hslA.h, _hslB.h, alpha2);
    const s3 = lerp2(_hslA.s, _hslB.s, alpha2);
    const l4 = lerp2(_hslA.l, _hslB.l, alpha2);
    this.setHSL(h3, s3, l4);
    return this;
  }
  setFromVector3(v4) {
    this.r = v4.x;
    this.g = v4.y;
    this.b = v4.z;
    return this;
  }
  applyMatrix3(m4) {
    const r4 = this.r, g5 = this.g, b4 = this.b;
    const e3 = m4.elements;
    this.r = e3[0] * r4 + e3[3] * g5 + e3[6] * b4;
    this.g = e3[1] * r4 + e3[4] * g5 + e3[7] * b4;
    this.b = e3[2] * r4 + e3[5] * g5 + e3[8] * b4;
    return this;
  }
  equals(c3) {
    return c3.r === this.r && c3.g === this.g && c3.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.r = attribute.getX(index2);
    this.g = attribute.getY(index2);
    this.b = attribute.getZ(index2);
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
}
var _color = new Color2;
Color2.NAMES = _colorKeywords;

class MeshBasicMaterial extends Material2 {
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.type = "MeshBasicMaterial";
    this.color = new Color2(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
var _vector$8 = new Vector3;
var _vector2$1 = new Vector2;

class BufferAttribute {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.gpuType = FloatType;
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i3 = 0, l4 = this.itemSize;i3 < l4; i3++) {
      this.array[index1 + i3] = attribute.array[index2 + i3];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  applyMatrix3(m4) {
    if (this.itemSize === 2) {
      for (let i3 = 0, l4 = this.count;i3 < l4; i3++) {
        _vector2$1.fromBufferAttribute(this, i3);
        _vector2$1.applyMatrix3(m4);
        this.setXY(i3, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i3 = 0, l4 = this.count;i3 < l4; i3++) {
        _vector$8.fromBufferAttribute(this, i3);
        _vector$8.applyMatrix3(m4);
        this.setXYZ(i3, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
    return this;
  }
  applyMatrix4(m4) {
    for (let i3 = 0, l4 = this.count;i3 < l4; i3++) {
      _vector$8.fromBufferAttribute(this, i3);
      _vector$8.applyMatrix4(m4);
      this.setXYZ(i3, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    return this;
  }
  applyNormalMatrix(m4) {
    for (let i3 = 0, l4 = this.count;i3 < l4; i3++) {
      _vector$8.fromBufferAttribute(this, i3);
      _vector$8.applyNormalMatrix(m4);
      this.setXYZ(i3, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    return this;
  }
  transformDirection(m4) {
    for (let i3 = 0, l4 = this.count;i3 < l4; i3++) {
      _vector$8.fromBufferAttribute(this, i3);
      _vector$8.transformDirection(m4);
      this.setXYZ(i3, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getComponent(index2, component) {
    let value = this.array[index2 * this.itemSize + component];
    if (this.normalized)
      value = denormalize(value, this.array);
    return value;
  }
  setComponent(index2, component, value) {
    if (this.normalized)
      value = normalize2(value, this.array);
    this.array[index2 * this.itemSize + component] = value;
    return this;
  }
  getX(index2) {
    let x3 = this.array[index2 * this.itemSize];
    if (this.normalized)
      x3 = denormalize(x3, this.array);
    return x3;
  }
  setX(index2, x3) {
    if (this.normalized)
      x3 = normalize2(x3, this.array);
    this.array[index2 * this.itemSize] = x3;
    return this;
  }
  getY(index2) {
    let y3 = this.array[index2 * this.itemSize + 1];
    if (this.normalized)
      y3 = denormalize(y3, this.array);
    return y3;
  }
  setY(index2, y3) {
    if (this.normalized)
      y3 = normalize2(y3, this.array);
    this.array[index2 * this.itemSize + 1] = y3;
    return this;
  }
  getZ(index2) {
    let z3 = this.array[index2 * this.itemSize + 2];
    if (this.normalized)
      z3 = denormalize(z3, this.array);
    return z3;
  }
  setZ(index2, z3) {
    if (this.normalized)
      z3 = normalize2(z3, this.array);
    this.array[index2 * this.itemSize + 2] = z3;
    return this;
  }
  getW(index2) {
    let w4 = this.array[index2 * this.itemSize + 3];
    if (this.normalized)
      w4 = denormalize(w4, this.array);
    return w4;
  }
  setW(index2, w4) {
    if (this.normalized)
      w4 = normalize2(w4, this.array);
    this.array[index2 * this.itemSize + 3] = w4;
    return this;
  }
  setXY(index2, x3, y3) {
    index2 *= this.itemSize;
    if (this.normalized) {
      x3 = normalize2(x3, this.array);
      y3 = normalize2(y3, this.array);
    }
    this.array[index2 + 0] = x3;
    this.array[index2 + 1] = y3;
    return this;
  }
  setXYZ(index2, x3, y3, z3) {
    index2 *= this.itemSize;
    if (this.normalized) {
      x3 = normalize2(x3, this.array);
      y3 = normalize2(y3, this.array);
      z3 = normalize2(z3, this.array);
    }
    this.array[index2 + 0] = x3;
    this.array[index2 + 1] = y3;
    this.array[index2 + 2] = z3;
    return this;
  }
  setXYZW(index2, x3, y3, z3, w4) {
    index2 *= this.itemSize;
    if (this.normalized) {
      x3 = normalize2(x3, this.array);
      y3 = normalize2(y3, this.array);
      z3 = normalize2(z3, this.array);
      w4 = normalize2(w4, this.array);
    }
    this.array[index2 + 0] = x3;
    this.array[index2 + 1] = y3;
    this.array[index2 + 2] = z3;
    this.array[index2 + 3] = w4;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "")
      data.name = this.name;
    if (this.usage !== StaticDrawUsage)
      data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange;
    return data;
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
}
class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
}
var _id$2 = 0;
var _m1 = new Matrix4;
var _obj = new Object3D;
var _offset = new Vector3;
var _box$1 = new Box3;
var _boxMorphTargets = new Box3;
var _vector$7 = new Vector3;

class BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$2++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index2) {
    if (Array.isArray(index2)) {
      this.index = new ((arrayNeedsUint32(index2)) ? Uint32BufferAttribute : Uint16BufferAttribute)(index2, 1);
    } else {
      this.index = index2;
    }
    return this;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== undefined;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== undefined) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== undefined) {
      const normalMatrix = new Matrix32().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== undefined) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q3) {
    _m1.makeRotationFromQuaternion(q3);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x3, y3, z3) {
    _m1.makeTranslation(x3, y3, z3);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x3, y3, z3) {
    _m1.makeScale(x3, y3, z3);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points2) {
    const position = [];
    for (let i3 = 0, l4 = points2.length;i3 < l4; i3++) {
      const point = points2[i3];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3;
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3((-Infinity), (-Infinity), (-Infinity)), new Vector3(Infinity, Infinity, Infinity));
      return;
    }
    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i3 = 0, il = morphAttributesPosition.length;i3 < il; i3++) {
          const morphAttribute = morphAttributesPosition[i3];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$7.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$7);
            _vector$7.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$7);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere;
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3, Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i3 = 0, il = morphAttributesPosition.length;i3 < il; i3++) {
          const morphAttribute = morphAttributesPosition[i3];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$7.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$7);
            _vector$7.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$7);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i3 = 0, il = position.count;i3 < il; i3++) {
        _vector$7.fromBufferAttribute(position, i3);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$7));
      }
      if (morphAttributesPosition) {
        for (let i3 = 0, il = morphAttributesPosition.length;i3 < il; i3++) {
          const morphAttribute = morphAttributesPosition[i3];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j4 = 0, jl = morphAttribute.count;j4 < jl; j4++) {
            _vector$7.fromBufferAttribute(morphAttribute, j4);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j4);
              _vector$7.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$7));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index2 = this.index;
    const attributes = this.attributes;
    if (index2 === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices2 = index2.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = this.getAttribute("tangent").array;
    const tan1 = [], tan2 = [];
    for (let i3 = 0;i3 < nVertices; i3++) {
      tan1[i3] = new Vector3;
      tan2[i3] = new Vector3;
    }
    const vA2 = new Vector3, vB = new Vector3, vC = new Vector3, uvA = new Vector2, uvB = new Vector2, uvC = new Vector2, sdir = new Vector3, tdir = new Vector3;
    function handleTriangle(a3, b4, c3) {
      vA2.fromArray(positions, a3 * 3);
      vB.fromArray(positions, b4 * 3);
      vC.fromArray(positions, c3 * 3);
      uvA.fromArray(uvs, a3 * 2);
      uvB.fromArray(uvs, b4 * 2);
      uvC.fromArray(uvs, c3 * 2);
      vB.sub(vA2);
      vC.sub(vA2);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r4 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r4))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r4);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r4);
      tan1[a3].add(sdir);
      tan1[b4].add(sdir);
      tan1[c3].add(sdir);
      tan2[a3].add(tdir);
      tan2[b4].add(tdir);
      tan2[c3].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices2.length
      }];
    }
    for (let i3 = 0, il = groups.length;i3 < il; ++i3) {
      const group = groups[i3];
      const start = group.start;
      const count = group.count;
      for (let j4 = start, jl = start + count;j4 < jl; j4 += 3) {
        handleTriangle(indices2[j4 + 0], indices2[j4 + 1], indices2[j4 + 2]);
      }
    }
    const tmp16 = new Vector3, tmp22 = new Vector3;
    const n4 = new Vector3, n22 = new Vector3;
    function handleVertex(v4) {
      n4.fromArray(normals, v4 * 3);
      n22.copy(n4);
      const t4 = tan1[v4];
      tmp16.copy(t4);
      tmp16.sub(n4.multiplyScalar(n4.dot(t4))).normalize();
      tmp22.crossVectors(n22, t4);
      const test = tmp22.dot(tan2[v4]);
      const w4 = test < 0 ? -1 : 1;
      tangents[v4 * 4] = tmp16.x;
      tangents[v4 * 4 + 1] = tmp16.y;
      tangents[v4 * 4 + 2] = tmp16.z;
      tangents[v4 * 4 + 3] = w4;
    }
    for (let i3 = 0, il = groups.length;i3 < il; ++i3) {
      const group = groups[i3];
      const start = group.start;
      const count = group.count;
      for (let j4 = start, jl = start + count;j4 < jl; j4 += 3) {
        handleVertex(indices2[j4 + 0]);
        handleVertex(indices2[j4 + 1]);
        handleVertex(indices2[j4 + 2]);
      }
    }
  }
  computeVertexNormals() {
    const index2 = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== undefined) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === undefined) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i3 = 0, il = normalAttribute.count;i3 < il; i3++) {
          normalAttribute.setXYZ(i3, 0, 0, 0);
        }
      }
      const pA2 = new Vector3, pB = new Vector3, pC = new Vector3;
      const nA2 = new Vector3, nB = new Vector3, nC = new Vector3;
      const cb = new Vector3, ab4 = new Vector3;
      if (index2) {
        for (let i3 = 0, il = index2.count;i3 < il; i3 += 3) {
          const vA2 = index2.getX(i3 + 0);
          const vB = index2.getX(i3 + 1);
          const vC = index2.getX(i3 + 2);
          pA2.fromBufferAttribute(positionAttribute, vA2);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab4.subVectors(pA2, pB);
          cb.cross(ab4);
          nA2.fromBufferAttribute(normalAttribute, vA2);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA2.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA2, nA2.x, nA2.y, nA2.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i3 = 0, il = positionAttribute.count;i3 < il; i3 += 3) {
          pA2.fromBufferAttribute(positionAttribute, i3 + 0);
          pB.fromBufferAttribute(positionAttribute, i3 + 1);
          pC.fromBufferAttribute(positionAttribute, i3 + 2);
          cb.subVectors(pC, pB);
          ab4.subVectors(pA2, pB);
          cb.cross(ab4);
          normalAttribute.setXYZ(i3 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i3 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i3 + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i3 = 0, il = normals.count;i3 < il; i3++) {
      _vector$7.fromBufferAttribute(normals, i3);
      _vector$7.normalize();
      normals.setXYZ(i3, _vector$7.x, _vector$7.y, _vector$7.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices3) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices3.length * itemSize);
      let index2 = 0, index22 = 0;
      for (let i3 = 0, l4 = indices3.length;i3 < l4; i3++) {
        if (attribute.isInterleavedBufferAttribute) {
          index2 = indices3[i3] * attribute.data.stride + attribute.offset;
        } else {
          index2 = indices3[i3] * itemSize;
        }
        for (let j4 = 0;j4 < itemSize; j4++) {
          array2[index22++] = array[index2++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry;
    const indices2 = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices2);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i3 = 0, il = morphAttribute.length;i3 < il; i3++) {
        const attribute = morphAttribute[i3];
        const newAttribute = convertBufferAttribute(attribute, indices2);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i3 = 0, l4 = groups.length;i3 < l4; i3++) {
      const group = groups[i3];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== undefined) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== undefined)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index2 = this.index;
    if (index2 !== null) {
      data.data.index = {
        type: index2.array.constructor.name,
        array: Array.prototype.slice.call(index2.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i3 = 0, il = attributeArray.length;i3 < il; i3++) {
        const attribute = attributeArray[i3];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index2 = source.index;
    if (index2 !== null) {
      this.setIndex(index2.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i3 = 0, l4 = morphAttribute.length;i3 < l4; i3++) {
        array.push(morphAttribute[i3].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i3 = 0, l4 = groups.length;i3 < l4; i3++) {
      const group = groups[i3];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
var _inverseMatrix$3 = new Matrix4;
var _ray$3 = new Ray2;
var _sphere$5 = new Sphere;
var _sphereHitAt = new Vector3;
var _vA$1 = new Vector3;
var _vB$1 = new Vector3;
var _vC$1 = new Vector3;
var _tempA = new Vector3;
var _morphA = new Vector3;
var _uvA$1 = new Vector2;
var _uvB$1 = new Vector2;
var _uvC$1 = new Vector2;
var _normalA = new Vector3;
var _normalB = new Vector3;
var _normalC = new Vector3;
var _intersectionPoint = new Vector3;
var _intersectionPointWorld = new Vector3;

class Mesh2 extends Object3D {
  constructor(geometry = new BufferGeometry, material = new MeshBasicMaterial) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== undefined) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== undefined) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== undefined) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m4 = 0, ml = morphAttribute.length;m4 < ml; m4++) {
          const name = morphAttribute[m4].name || String(m4);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m4;
        }
      }
    }
  }
  getVertexPosition(index2, target) {
    const geometry = this.geometry;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target.fromBufferAttribute(position, index2);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i3 = 0, il = morphPosition.length;i3 < il; i3++) {
        const influence = morphInfluences[i3];
        const morphAttribute = morphPosition[i3];
        if (influence === 0)
          continue;
        _tempA.fromBufferAttribute(morphAttribute, index2);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target), influence);
        }
      }
      target.add(_morphA);
    }
    return target;
  }
  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === undefined)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$5.copy(geometry.boundingSphere);
    _sphere$5.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$5.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$5, _sphereHitAt) === null)
        return;
      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2)
        return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    this._computeIntersections(raycaster, intersects, _ray$3);
  }
  _computeIntersections(raycaster, intersects, rayLocalSpace) {
    let intersection;
    const geometry = this.geometry;
    const material = this.material;
    const index2 = geometry.index;
    const position = geometry.attributes.position;
    const uv = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal = geometry.attributes.normal;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index2 !== null) {
      if (Array.isArray(material)) {
        for (let i3 = 0, il = groups.length;i3 < il; i3++) {
          const group = groups[i3];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(index2.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j4 = start, jl = end;j4 < jl; j4 += 3) {
            const a3 = index2.getX(j4);
            const b4 = index2.getX(j4 + 1);
            const c3 = index2.getX(j4 + 2);
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a3, b4, c3);
            if (intersection) {
              intersection.faceIndex = Math.floor(j4 / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index2.count, drawRange.start + drawRange.count);
        for (let i3 = start, il = end;i3 < il; i3 += 3) {
          const a3 = index2.getX(i3);
          const b4 = index2.getX(i3 + 1);
          const c3 = index2.getX(i3 + 2);
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a3, b4, c3);
          if (intersection) {
            intersection.faceIndex = Math.floor(i3 / 3);
            intersects.push(intersection);
          }
        }
      }
    } else if (position !== undefined) {
      if (Array.isArray(material)) {
        for (let i3 = 0, il = groups.length;i3 < il; i3++) {
          const group = groups[i3];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j4 = start, jl = end;j4 < jl; j4 += 3) {
            const a3 = j4;
            const b4 = j4 + 1;
            const c3 = j4 + 2;
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a3, b4, c3);
            if (intersection) {
              intersection.faceIndex = Math.floor(j4 / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i3 = start, il = end;i3 < il; i3 += 3) {
          const a3 = i3;
          const b4 = i3 + 1;
          const c3 = i3 + 2;
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a3, b4, c3);
          if (intersection) {
            intersection.faceIndex = Math.floor(i3 / 3);
            intersects.push(intersection);
          }
        }
      }
    }
  }
}

class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices2 = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices2);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u6, v4, w4, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3;
      for (let iy = 0;iy < gridY1; iy++) {
        const y3 = iy * segmentHeight - heightHalf;
        for (let ix = 0;ix < gridX1; ix++) {
          const x3 = ix * segmentWidth - widthHalf;
          vector[u6] = x3 * udir;
          vector[v4] = y3 * vdir;
          vector[w4] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u6] = 0;
          vector[v4] = 0;
          vector[w4] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0;iy < gridY; iy++) {
        for (let ix = 0;ix < gridX; ix++) {
          const a3 = numberOfVertices + ix + gridX1 * iy;
          const b4 = numberOfVertices + ix + gridX1 * (iy + 1);
          const c3 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d3 = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices2.push(a3, b4, d3);
          indices2.push(b4, c3, d3);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
}
var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

class ShaderMaterial extends Material2 {
  constructor(parameters) {
    super();
    this.isShaderMaterial = true;
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.uniformsGroups = [];
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.forceSinglePass = true;
    this.extensions = {
      derivatives: false,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    };
    this.index0AttributeName = undefined;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== undefined) {
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta2) {
    const data = super.toJSON(meta2);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta2).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    data.lights = this.lights;
    data.clipping = this.clipping;
    const extensions31 = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true)
        extensions31[key] = true;
    }
    if (Object.keys(extensions31).length > 0)
      data.extensions = extensions31;
    return data;
  }
}

class Camera extends Object3D {
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4;
    this.projectionMatrix = new Matrix4;
    this.projectionMatrixInverse = new Matrix4;
    this.coordinateSystem = WebGLCoordinateSystem;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e3 = this.matrixWorld.elements;
    return target.set(-e3[8], -e3[9], -e3[10]).normalize();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}

class PerspectiveCamera extends Camera {
  constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(fullWidth, fullHeight, x3, y3, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x3;
    this.view.offsetY = y3;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const { fullWidth, fullHeight } = view;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta2) {
    const data = super.toJSON(meta2);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
var fov = -90;
var aspect = 1;

class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    this.renderTarget = renderTarget;
    this.coordinateSystem = null;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    this.add(cameraNZ);
  }
  updateCoordinateSystem() {
    const coordinateSystem = this.coordinateSystem;
    const cameras = this.children.concat();
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
    for (const camera of cameras)
      this.remove(camera);
    if (coordinateSystem === WebGLCoordinateSystem) {
      cameraPX.up.set(0, 1, 0);
      cameraPX.lookAt(1, 0, 0);
      cameraNX.up.set(0, 1, 0);
      cameraNX.lookAt(-1, 0, 0);
      cameraPY.up.set(0, 0, -1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, 1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, 1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, 1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(-1, 0, 0);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(1, 0, 0);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else {
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
    }
    for (const camera of cameras) {
      this.add(camera);
      camera.updateMatrixWorld();
    }
  }
  update(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    if (this.coordinateSystem !== renderer.coordinateSystem) {
      this.coordinateSystem = renderer.coordinateSystem;
      this.updateCoordinateSystem();
    }
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentXrEnabled = renderer.xr.enabled;
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
}

class CubeTexture extends Texture3 {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isCubeTexture = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}

class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size = 1, options = {}) {
    super(size, size, options);
    this.isWebGLCubeRenderTarget = true;
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    if (options.encoding !== undefined) {
      warnOnce("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.");
      options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
  }
  fromEquirectangularTexture(renderer, texture3) {
    this.texture.type = texture3.type;
    this.texture.colorSpace = texture3.colorSpace;
    this.texture.generateMipmaps = texture3.generateMipmaps;
    this.texture.minFilter = texture3.minFilter;
    this.texture.magFilter = texture3.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture3;
    const mesh4 = new Mesh2(geometry, material);
    const currentMinFilter = texture3.minFilter;
    if (texture3.minFilter === LinearMipmapLinearFilter)
      texture3.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh4);
    texture3.minFilter = currentMinFilter;
    mesh4.geometry.dispose();
    mesh4.material.dispose();
    return this;
  }
  clear(renderer, color8, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i3 = 0;i3 < 6; i3++) {
      renderer.setRenderTarget(this, i3);
      renderer.clear(color8, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
var _vector1 = new Vector3;
var _vector2 = new Vector3;
var _normalMatrix = new Matrix32;

class Plane2 {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x3, y3, z3, w4) {
    this.normal.set(x3, y3, z3);
    this.constant = w4;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a3, b4, c3) {
    const normal = _vector1.subVectors(c3, b4).cross(_vector2.subVectors(a3, b4)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a3);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t4 = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t4 < 0 || t4 > 1) {
      return null;
    }
    return target.copy(line.start).addScaledVector(direction, t4);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
var _sphere$4 = new Sphere;
var _vector$6 = new Vector3;

class Frustum {
  constructor(p0 = new Plane2, p1 = new Plane2, p22 = new Plane2, p3 = new Plane2, p4 = new Plane2, p5 = new Plane2) {
    this.planes = [p0, p1, p22, p3, p4, p5];
  }
  set(p0, p1, p22, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p22);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i3 = 0;i3 < 6; i3++) {
      planes[i3].copy(frustum.planes[i3]);
    }
    return this;
  }
  setFromProjectionMatrix(m4, coordinateSystem = WebGLCoordinateSystem) {
    const planes = this.planes;
    const me = m4.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    if (coordinateSystem === WebGLCoordinateSystem) {
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      planes[5].setComponents(me2, me6, me10, me14).normalize();
    } else {
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
    }
    return this;
  }
  intersectsObject(object) {
    if (object.boundingSphere !== undefined) {
      if (object.boundingSphere === null)
        object.computeBoundingSphere();
      _sphere$4.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    } else {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$4.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere$4);
  }
  intersectsSprite(sprite7) {
    _sphere$4.center.set(0, 0, 0);
    _sphere$4.radius = 0.7071067811865476;
    _sphere$4.applyMatrix4(sprite7.matrixWorld);
    return this.intersectsSphere(_sphere$4);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i3 = 0;i3 < 6; i3++) {
      const distance3 = planes[i3].distanceToPoint(center);
      if (distance3 < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i3 = 0;i3 < 6; i3++) {
      const plane = planes[i3];
      _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$6) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i3 = 0;i3 < 6; i3++) {
      if (planes[i3].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}

class PlaneGeometry3 extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices2 = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0;iy < gridY1; iy++) {
      const y3 = iy * segment_height - height_half;
      for (let ix = 0;ix < gridX1; ix++) {
        const x3 = ix * segment_width - width_half;
        vertices.push(x3, -y3, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0;iy < gridY; iy++) {
      for (let ix = 0;ix < gridX; ix++) {
        const a3 = ix + gridX1 * iy;
        const b4 = ix + gridX1 * (iy + 1);
        const c3 = ix + 1 + gridX1 * (iy + 1);
        const d3 = ix + 1 + gridX1 * iy;
        indices2.push(a3, b4, d3);
        indices2.push(b4, c3, d3);
      }
    }
    this.setIndex(indices2);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new PlaneGeometry3(data.width, data.height, data.widthSegments, data.heightSegments);
  }
}
var alphahash_fragment = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";
var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var colorspace_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";
var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";
var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";
var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";
var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";
var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
var vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
var vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
var fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";
var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";
var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";
var ShaderChunk = {
  alphahash_fragment,
  alphahash_pars_fragment,
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  colorspace_fragment,
  colorspace_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_fragment,
  lights_lambert_pars_fragment,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  opaque_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  worldpos_vertex,
  background_vert: vertex$h,
  background_frag: fragment$h,
  backgroundCube_vert: vertex$g,
  backgroundCube_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
var UniformsLib = {
  common: {
    diffuse: { value: new Color2(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: new Matrix32 },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Matrix32 },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: new Matrix32 }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: new Matrix32 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: new Matrix32 }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: new Matrix32 },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: new Matrix32 },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: new Matrix32 },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: new Matrix32 }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: new Matrix32 }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: new Matrix32 }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 0.00025 },
    fogNear: { value: 1 },
    fogFar: { value: 2000 },
    fogColor: { value: new Color2(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color2(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Matrix32 },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix32 }
  },
  sprite: {
    diffuse: { value: new Color2(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: new Matrix32 },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Matrix32 },
    alphaTest: { value: 0 }
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color2(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color2(0) },
        specular: { value: new Color2(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color2(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color2(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix32 },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.backgroundCube_vert,
    fragmentShader: ShaderChunk.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3 },
        nearDistance: { value: 1 },
        farDistance: { value: 1000 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color2(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Matrix32 },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Matrix32 },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Matrix32 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Matrix32 },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Matrix32 },
      sheen: { value: 0 },
      sheenColor: { value: new Color2(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Matrix32 },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Matrix32 },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Matrix32 },
      transmissionSamplerSize: { value: new Vector2 },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Matrix32 },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color2(0) },
      specularColor: { value: new Color2(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Matrix32 },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Matrix32 },
      anisotropyVector: { value: new Vector2 },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Matrix32 }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
var _rgb = { r: 0, b: 0, g: 0 };

class OrthographicCamera extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x3, y3, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x3;
    this.view.offsetY = y3;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta2) {
    const data = super.toJSON(meta2);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
}
var LOD_MIN = 4;
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var MAX_SAMPLES = 20;
var _flatCamera = new OrthographicCamera;
var _clearColor = new Color2;
var _oldTarget = null;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  new Vector3(1, 1, 1),
  new Vector3(-1, 1, 1),
  new Vector3(1, 1, -1),
  new Vector3(-1, 1, -1),
  new Vector3(0, PHI, INV_PHI),
  new Vector3(0, PHI, -INV_PHI),
  new Vector3(INV_PHI, 0, PHI),
  new Vector3(-INV_PHI, 0, PHI),
  new Vector3(PHI, INV_PHI, 0),
  new Vector3(-PHI, INV_PHI, 0)
];

class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null)
      this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null)
      this._equirectMaterial.dispose();
  }
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null)
      this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null)
      this._pingPongRenderTarget.dispose();
    for (let i3 = 0;i3 < this._lodPlanes.length; i3++) {
      this._lodPlanes[i3].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture3, renderTarget) {
    if (texture3.mapping === CubeReflectionMapping || texture3.mapping === CubeRefractionMapping) {
      this._setSize(texture3.image.length === 0 ? 16 : texture3.image[0].width || texture3.image[0].image.width);
    } else {
      this._setSize(texture3.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture3, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      colorSpace: LinearSRGBColorSpace,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh2(this._lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh2(new BoxGeometry, backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i3 = 0;i3 < 6; i3++) {
      const col = i3 % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i3], 0);
        cubeCamera.lookAt(forwardSign[i3], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i3]);
        cubeCamera.lookAt(0, forwardSign[i3], 0);
      } else {
        cubeCamera.up.set(0, upSign[i3], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i3]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i3 > 2 ? size : 0, size, size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture3, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture3.mapping === CubeReflectionMapping || texture3.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value = texture3.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    const mesh4 = new Mesh2(this._lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture3;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh4, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i3 = 1;i3 < this._lodPlanes.length; i3++) {
      const sigma = Math.sqrt(this._sigmas[i3] * this._sigmas[i3] - this._sigmas[i3 - 1] * this._sigmas[i3 - 1]);
      const poleAxis = _axisDirections[(i3 - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i3 - 1, i3, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh2(this._lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum2 = 0;
    for (let i3 = 0;i3 < MAX_SAMPLES; ++i3) {
      const x4 = i3 / sigmaPixels;
      const weight = Math.exp(-x4 * x4 / 2);
      weights.push(weight);
      if (i3 === 0) {
        sum2 += weight;
      } else if (i3 < samples) {
        sum2 += 2 * weight;
      }
    }
    for (let i3 = 0;i3 < weights.length; i3++) {
      weights[i3] = weights[i3] / sum2;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x3 = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y3 = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x3, y3, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
}
var emptyTexture = new Texture3;
var emptyArrayTexture = new DataArrayTexture;
var empty3dTexture = new Data3DTexture;
var emptyCubeTexture = new CubeTexture;
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);

class SingleUniform {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
  }
}

class PureArrayUniform {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
}

class StructuredUniform {
  constructor(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  setValue(gl, value, textures2) {
    const seq = this.seq;
    for (let i3 = 0, n4 = seq.length;i3 !== n4; ++i3) {
      const u6 = seq[i3];
      u6.setValue(gl, value[u6.id], textures2);
    }
  }
}
var RePathPart = /(\w+)(\])?(\[|\.)?/g;

class WebGLUniforms {
  constructor(gl, program) {
    this.seq = [];
    this.map = {};
    const n4 = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i3 = 0;i3 < n4; ++i3) {
      const info = gl.getActiveUniform(program, i3), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  setValue(gl, name, value, textures2) {
    const u6 = this.map[name];
    if (u6 !== undefined)
      u6.setValue(gl, value, textures2);
  }
  setOptional(gl, object, name) {
    const v4 = object[name];
    if (v4 !== undefined)
      this.setValue(gl, name, v4);
  }
  static upload(gl, seq, values, textures2) {
    for (let i3 = 0, n4 = seq.length;i3 !== n4; ++i3) {
      const u6 = seq[i3], v4 = values[u6.id];
      if (v4.needsUpdate !== false) {
        u6.setValue(gl, v4.value, textures2);
      }
    }
  }
  static seqWithValue(seq, values) {
    const r4 = [];
    for (let i3 = 0, n4 = seq.length;i3 !== n4; ++i3) {
      const u6 = seq[i3];
      if (u6.id in values)
        r4.push(u6);
    }
    return r4;
  }
}
var programIdCount = 0;
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
var shaderChunkMap = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"]
]);
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
var _id$1 = 0;

class WebGLShaderCache {
  constructor() {
    this.shaderCache = new Map;
    this.materialCache = new Map;
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0)
        this.shaderCache.delete(shaderStage.code);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache2 = this.materialCache;
    let set2 = cache2.get(material);
    if (set2 === undefined) {
      set2 = new Set;
      cache2.set(material, set2);
    }
    return set2;
  }
  _getShaderStage(code) {
    const cache2 = this.shaderCache;
    let stage = cache2.get(code);
    if (stage === undefined) {
      stage = new WebGLShaderStage(code);
      cache2.set(code, stage);
    }
    return stage;
  }
}

class WebGLShaderStage {
  constructor(code) {
    this.id = _id$1++;
    this.code = code;
    this.usedTimes = 0;
  }
}
var nextVersion = 0;

class MeshDepthMaterial extends Material2 {
  constructor(parameters) {
    super();
    this.isMeshDepthMaterial = true;
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
}

class MeshDistanceMaterial extends Material2 {
  constructor(parameters) {
    super();
    this.isMeshDistanceMaterial = true;
    this.type = "MeshDistanceMaterial";
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
}
var vertex6 = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
var fragment9 = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var LinearTransferFunction = 0;
var SRGBTransferFunction = 1;

class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.isArrayCamera = true;
    this.cameras = array;
  }
}

class Group extends Object3D {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
}
var _moveEvent = { type: "move" };

class WebXRController {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group;
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group;
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3;
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3;
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group;
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3;
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3;
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  connect(inputSource) {
    if (inputSource && inputSource.hand) {
      const hand = this._hand;
      if (hand) {
        for (const inputjoint of inputSource.hand.values()) {
          this._getHandJoint(hand, inputjoint);
        }
      }
    }
    this.dispatchEvent({ type: "connected", data: inputSource });
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          const joint = this._getHandJoint(hand, inputjoint);
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.matrixWorldNeedsUpdate = true;
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance3 = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 0.005;
        if (hand.inputState.pinching && distance3 > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance3 <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            grip.matrixWorldNeedsUpdate = true;
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose;
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          targetRay.matrixWorldNeedsUpdate = true;
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
  _getHandJoint(hand, inputjoint) {
    if (hand.joints[inputjoint.jointName] === undefined) {
      const joint = new Group;
      joint.matrixAutoUpdate = false;
      joint.visible = false;
      hand.joints[inputjoint.jointName] = joint;
      hand.add(joint);
    }
    return hand.joints[inputjoint.jointName];
  }
}

class DepthTexture extends Texture3 {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== undefined ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === undefined && format === DepthFormat)
      type = UnsignedIntType;
    if (type === undefined && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isDepthTexture = true;
    this.image = { width, height };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta2) {
    const data = super.toJSON(meta2);
    if (this.compareFunction !== null)
      data.compareFunction = this.compareFunction;
    return data;
  }
}

class WebXRManager extends EventDispatcher {
  constructor(renderer, gl) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let foveation = 1;
    let customReferenceSpace = null;
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const attributes = gl.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const controllerInputSources = [];
    const cameraL = new PerspectiveCamera;
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4;
    const cameraR = new PerspectiveCamera;
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4;
    const cameras = [cameraL, cameraR];
    const cameraXR = new ArrayCamera;
    cameraXR.layers.enable(1);
    cameraXR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index2) {
      let controller = controllers[index2];
      if (controller === undefined) {
        controller = new WebXRController;
        controllers[index2] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index2) {
      let controller = controllers[index2];
      if (controller === undefined) {
        controller = new WebXRController;
        controllers[index2] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index2) {
      let controller = controllers[index2];
      if (controller === undefined) {
        controller = new WebXRController;
        controllers[index2] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controllerIndex = controllerInputSources.indexOf(event.inputSource);
      if (controllerIndex === -1) {
        return;
      }
      const controller = controllers[controllerIndex];
      if (controller !== undefined) {
        controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      session.removeEventListener("select", onSessionEvent);
      session.removeEventListener("selectstart", onSessionEvent);
      session.removeEventListener("selectend", onSessionEvent);
      session.removeEventListener("squeeze", onSessionEvent);
      session.removeEventListener("squeezestart", onSessionEvent);
      session.removeEventListener("squeezeend", onSessionEvent);
      session.removeEventListener("end", onSessionEnd);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
      for (let i3 = 0;i3 < controllers.length; i3++) {
        const inputSource = controllerInputSources[i3];
        if (inputSource === null)
          continue;
        controllerInputSources[i3] = null;
        controllers[i3].disconnect(inputSource);
      }
      _currentDepthNear = null;
      _currentDepthFar = null;
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return customReferenceSpace || referenceSpace;
    };
    this.setReferenceSpace = function(space) {
      customReferenceSpace = space;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        if (session.renderState.layers === undefined || renderer.capabilities.isWebGL2 === false) {
          const layerInit = {
            antialias: session.renderState.layers === undefined ? attributes.antialias : true,
            alpha: true,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
            format: RGBAFormat,
            type: UnsignedByteType,
            colorSpace: renderer.outputColorSpace,
            stencilBuffer: attributes.stencil
          });
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
          }
          const projectionlayerInit = {
            colorFormat: gl.RGBA8,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
            format: RGBAFormat,
            type: UnsignedByteType,
            depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),
            stencilBuffer: attributes.stencil,
            colorSpace: renderer.outputColorSpace,
            samples: attributes.antialias ? 4 : 0
          });
          const renderTargetProperties = renderer.properties.get(newRenderTarget);
          renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(foveation);
        customReferenceSpace = null;
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    this.getEnvironmentBlendMode = function() {
      if (session !== null) {
        return session.environmentBlendMode;
      }
    };
    function onInputSourcesChange(event) {
      for (let i3 = 0;i3 < event.removed.length; i3++) {
        const inputSource = event.removed[i3];
        const index2 = controllerInputSources.indexOf(inputSource);
        if (index2 >= 0) {
          controllerInputSources[index2] = null;
          controllers[index2].disconnect(inputSource);
        }
      }
      for (let i3 = 0;i3 < event.added.length; i3++) {
        const inputSource = event.added[i3];
        let controllerIndex = controllerInputSources.indexOf(inputSource);
        if (controllerIndex === -1) {
          for (let i4 = 0;i4 < controllers.length; i4++) {
            if (i4 >= controllerInputSources.length) {
              controllerInputSources.push(inputSource);
              controllerIndex = i4;
              break;
            } else if (controllerInputSources[i4] === null) {
              controllerInputSources[i4] = inputSource;
              controllerIndex = i4;
              break;
            }
          }
          if (controllerIndex === -1)
            break;
        }
        const controller = controllers[controllerIndex];
        if (controller) {
          controller.connect(inputSource);
        }
      }
    }
    const cameraLPos = new Vector3;
    const cameraRPos = new Vector3;
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
      camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null)
        return;
      cameraXR.near = cameraR.near = cameraL.near = camera.near;
      cameraXR.far = cameraR.far = cameraL.far = camera.far;
      if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
        session.updateRenderState({
          depthNear: cameraXR.near,
          depthFar: cameraXR.far
        });
        _currentDepthNear = cameraXR.near;
        _currentDepthFar = cameraXR.far;
      }
      const parent = camera.parent;
      const cameras2 = cameraXR.cameras;
      updateCamera(cameraXR, parent);
      for (let i3 = 0;i3 < cameras2.length; i3++) {
        updateCamera(cameras2[i3], parent);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraXR, cameraL, cameraR);
      } else {
        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
      updateUserCamera(camera, cameraXR, parent);
    };
    function updateUserCamera(camera, cameraXR2, parent) {
      if (parent === null) {
        camera.matrix.copy(cameraXR2.matrixWorld);
      } else {
        camera.matrix.copy(parent.matrixWorld);
        camera.matrix.invert();
        camera.matrix.multiply(cameraXR2.matrixWorld);
      }
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.updateMatrixWorld(true);
      camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
      camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
      if (camera.isPerspectiveCamera) {
        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
        camera.zoom = 1;
      }
    }
    this.getCamera = function() {
      return cameraXR;
    };
    this.getFoveation = function() {
      if (glProjLayer === null && glBaseLayer === null) {
        return;
      }
      return foveation;
    };
    this.setFoveation = function(value) {
      foveation = value;
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = value;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
        glBaseLayer.fixedFoveation = value;
      }
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraXRNeedsUpdate = false;
        if (views.length !== cameraXR.cameras.length) {
          cameraXR.cameras.length = 0;
          cameraXRNeedsUpdate = true;
        }
        for (let i3 = 0;i3 < views.length; i3++) {
          const view = views[i3];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i3 === 0) {
              renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          let camera = cameras[i3];
          if (camera === undefined) {
            camera = new PerspectiveCamera;
            camera.layers.enable(i3);
            camera.viewport = new Vector4;
            cameras[i3] = camera;
          }
          camera.matrix.fromArray(view.transform.matrix);
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i3 === 0) {
            cameraXR.matrix.copy(camera.matrix);
            cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
          }
          if (cameraXRNeedsUpdate === true) {
            cameraXR.cameras.push(camera);
          }
        }
      }
      for (let i3 = 0;i3 < controllers.length; i3++) {
        const inputSource = controllerInputSources[i3];
        const controller = controllers[i3];
        if (inputSource !== null && controller !== undefined) {
          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
        }
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time, frame);
      if (frame.detectedPlanes) {
        scope.dispatchEvent({ type: "planesdetected", data: frame });
      }
      xrFrame = null;
    }
    const animation = new WebGLAnimation;
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
}

class WebGLRenderer {
  constructor(parameters = {}) {
    const {
      canvas = createCanvasElement(),
      context: context2 = null,
      depth = true,
      stencil = true,
      alpha: alpha2 = false,
      antialias = false,
      premultipliedAlpha = true,
      preserveDrawingBuffer = false,
      powerPreference = "default",
      failIfMajorPerformanceCaveat = false
    } = parameters;
    this.isWebGLRenderer = true;
    let _alpha;
    if (context2 !== null) {
      _alpha = context2.getContextAttributes().alpha;
    } else {
      _alpha = alpha2;
    }
    const uintClearColor = new Uint32Array(4);
    const intClearColor = new Int32Array(4);
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = canvas;
    this.debug = {
      checkShaderErrors: true,
      onShaderError: null
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.outputColorSpace = SRGBColorSpace;
    this._useLegacyLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4;
    const _currentScissor = new Vector4;
    let _currentScissorTest = null;
    const _currentClearColor = new Color2(0);
    let _currentClearAlpha = 0;
    let _width = canvas.width;
    let _height = canvas.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum;
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    let _transmissionRenderTarget = null;
    const _projScreenMatrix = new Matrix4;
    const _vector22 = new Vector2;
    const _vector3 = new Vector3;
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = context2;
    function getContext(contextNames, contextAttributes) {
      for (let i3 = 0;i3 < contextNames.length; i3++) {
        const contextName = contextNames[i3];
        const context3 = canvas.getContext(contextName, contextAttributes);
        if (context3 !== null)
          return context3;
      }
      return null;
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth,
        stencil,
        antialias,
        premultipliedAlpha,
        preserveDrawingBuffer,
        powerPreference,
        failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in canvas)
        canvas.setAttribute("data-engine", `three.js r${REVISION}`);
      canvas.addEventListener("webglcontextlost", onContextLost, false);
      canvas.addEventListener("webglcontextrestored", onContextRestore, false);
      canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
      if (_gl === null) {
        const contextNames = ["webgl2", "webgl", "experimental-webgl"];
        if (_this.isWebGL1Renderer === true) {
          contextNames.shift();
        }
        _gl = getContext(contextNames, contextAttributes);
        if (_gl === null) {
          if (getContext(contextNames)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
      if (typeof WebGLRenderingContext !== "undefined" && _gl instanceof WebGLRenderingContext) {
        console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.");
      }
      if (_gl.getShaderPrecisionFormat === undefined) {
        _gl.getShaderPrecisionFormat = function() {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions31, capabilities, state, info;
    let properties, textures2, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils27, bindingStates, uniformsGroups;
    function initGLContext() {
      extensions31 = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions31, parameters);
      extensions31.init(capabilities);
      utils27 = new WebGLUtils(_gl, extensions31, capabilities);
      state = new WebGLState(_gl, extensions31, capabilities);
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties;
      textures2 = new WebGLTextures(_gl, extensions31, state, properties, capabilities, utils27, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl, capabilities);
      bindingStates = new WebGLBindingStates(_gl, extensions31, attributes, capabilities);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures2);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions31, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists;
      renderStates = new WebGLRenderStates(extensions31, capabilities);
      background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions31, info, capabilities);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions31, info, capabilities);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions31;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions31.get("WEBGL_lose_context");
      if (extension)
        extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions31.get("WEBGL_lose_context");
      if (extension)
        extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === undefined)
        return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle = true) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can\'t change size while VR device is presenting.");
        return;
      }
      _width = width;
      _height = height;
      canvas.width = Math.floor(width * _pixelRatio);
      canvas.height = Math.floor(height * _pixelRatio);
      if (updateStyle === true) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      canvas.width = Math.floor(width * pixelRatio);
      canvas.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x3, y3, width, height) {
      if (x3.isVector4) {
        _viewport.set(x3.x, x3.y, x3.z, x3.w);
      } else {
        _viewport.set(x3, y3, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x3, y3, width, height) {
      if (x3.isVector4) {
        _scissor.set(x3.x, x3.y, x3.z, x3.w);
      } else {
        _scissor.set(x3, y3, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color8 = true, depth2 = true, stencil2 = true) {
      let bits = 0;
      if (color8) {
        let isIntegerFormat = false;
        if (_currentRenderTarget !== null) {
          const targetFormat = _currentRenderTarget.texture.format;
          isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
        }
        if (isIntegerFormat) {
          const targetType = _currentRenderTarget.texture.type;
          const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
          const clearColor = background.getClearColor();
          const a3 = background.getClearAlpha();
          const r4 = clearColor.r;
          const g5 = clearColor.g;
          const b4 = clearColor.b;
          if (isUnsignedType) {
            uintClearColor[0] = r4;
            uintClearColor[1] = g5;
            uintClearColor[2] = b4;
            uintClearColor[3] = a3;
            _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
          } else {
            intClearColor[0] = r4;
            intClearColor[1] = g5;
            intClearColor[2] = b4;
            intClearColor[3] = a3;
            _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
          }
        } else {
          bits |= _gl.COLOR_BUFFER_BIT;
        }
      }
      if (depth2)
        bits |= _gl.DEPTH_BUFFER_BIT;
      if (stencil2)
        bits |= _gl.STENCIL_BUFFER_BIT;
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      canvas.removeEventListener("webglcontextlost", onContextLost, false);
      canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
      canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      uniformsGroups.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      if (_transmissionRenderTarget) {
        _transmissionRenderTarget.dispose();
        _transmissionRenderTarget = null;
      }
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== undefined) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null)
        scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index2 = geometry.index;
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index2 = geometries.getWireframeAttribute(geometry);
        if (index2 === undefined)
          return;
        rangeFactor = 2;
      }
      const drawRange = geometry.drawRange;
      const position = geometry.attributes.position;
      let drawStart = drawRange.start * rangeFactor;
      let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
      if (group !== null) {
        drawStart = Math.max(drawStart, group.start * rangeFactor);
        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
      }
      if (index2 !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, index2.count);
      } else if (position !== undefined && position !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, position.count);
      }
      const drawCount = drawEnd - drawStart;
      if (drawCount < 0 || drawCount === Infinity)
        return;
      bindingStates.setup(object, material, program, geometry, index2);
      let attribute;
      let renderer = bufferRenderer;
      if (index2 !== null) {
        attribute = attributes.get(index2);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(_gl.LINES);
        } else {
          renderer.setMode(_gl.TRIANGLES);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === undefined)
          lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(_gl.LINES);
        } else if (object.isLineLoop) {
          renderer.setMode(_gl.LINE_LOOP);
        } else {
          renderer.setMode(_gl.LINE_STRIP);
        }
      } else if (object.isPoints) {
        renderer.setMode(_gl.POINTS);
      } else if (object.isSprite) {
        renderer.setMode(_gl.TRIANGLES);
      }
      if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
        const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    this.compile = function(scene, camera) {
      function prepare2(material, scene2, object) {
        if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
          material.side = BackSide;
          material.needsUpdate = true;
          getProgram(material, scene2, object);
          material.side = FrontSide;
          material.needsUpdate = true;
          getProgram(material, scene2, object);
          material.side = DoubleSide;
        } else {
          getProgram(material, scene2, object);
        }
      }
      currentRenderState = renderStates.get(scene);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      scene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      currentRenderState.setupLights(_this._useLegacyLights);
      scene.traverse(function(object) {
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i3 = 0;i3 < material.length; i3++) {
              const material2 = material[i3];
              prepare2(material2, scene, object);
            }
          } else {
            prepare2(material, scene, object);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation;
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined")
      animation.setContext(self);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== undefined && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true)
        return;
      if (scene.matrixWorldAutoUpdate === true)
        scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
        camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true)
          xr.updateCamera(camera);
        camera = xr.getCamera();
      }
      if (scene.isScene === true)
        scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      this.info.render.frame++;
      if (_clippingEnabled === true)
        clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true)
        clipping.endShadows();
      if (this.info.autoReset === true)
        this.info.reset();
      background.render(currentRenderList, scene);
      currentRenderState.setupLights(_this._useLegacyLights);
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let i3 = 0, l4 = cameras.length;i3 < l4; i3++) {
          const camera2 = cameras[i3];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null) {
        textures2.updateMultisampleRenderTarget(_currentRenderTarget);
        textures2.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true)
        scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true)
            object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            const geometry = objects.update(object);
            const material = object.material;
            if (sortObjects) {
              if (object.boundingSphere !== undefined) {
                if (object.boundingSphere === null)
                  object.computeBoundingSphere();
                _vector3.copy(object.boundingSphere.center);
              } else {
                if (geometry.boundingSphere === null)
                  geometry.computeBoundingSphere();
                _vector3.copy(geometry.boundingSphere.center);
              }
              _vector3.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i3 = 0, l4 = groups.length;i3 < l4; i3++) {
                const group = groups[i3];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i3 = 0, l4 = children.length;i3 < l4; i3++) {
        projectObject(children[i3], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true)
        clipping.setGlobalState(_this.clippingPlanes, camera);
      if (transmissiveObjects.length > 0)
        renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
      if (viewport)
        state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0)
        renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0)
        renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0)
        renderObjects(transparentObjects, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
      const isWebGL2 = capabilities.isWebGL2;
      if (_transmissionRenderTarget === null) {
        _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: extensions31.has("EXT_color_buffer_half_float") ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: isWebGL2 ? 4 : 0
        });
      }
      _this.getDrawingBufferSize(_vector22);
      if (isWebGL2) {
        _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
      } else {
        _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
      }
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(_transmissionRenderTarget);
      _this.getClearColor(_currentClearColor);
      _currentClearAlpha = _this.getClearAlpha();
      if (_currentClearAlpha < 1)
        _this.setClearColor(16777215, 0.5);
      _this.clear();
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      renderObjects(opaqueObjects, scene, camera);
      textures2.updateMultisampleRenderTarget(_transmissionRenderTarget);
      textures2.updateRenderTargetMipmap(_transmissionRenderTarget);
      let renderTargetNeedsUpdate = false;
      for (let i3 = 0, l4 = transmissiveObjects.length;i3 < l4; i3++) {
        const renderItem = transmissiveObjects[i3];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = renderItem.material;
        const group = renderItem.group;
        if (material.side === DoubleSide && object.layers.test(camera.layers)) {
          const currentSide = material.side;
          material.side = BackSide;
          material.needsUpdate = true;
          renderObject(object, scene, camera, geometry, material, group);
          material.side = currentSide;
          material.needsUpdate = true;
          renderTargetNeedsUpdate = true;
        }
      }
      if (renderTargetNeedsUpdate === true) {
        textures2.updateMultisampleRenderTarget(_transmissionRenderTarget);
        textures2.updateRenderTargetMipmap(_transmissionRenderTarget);
      }
      _this.setRenderTarget(currentRenderTarget);
      _this.setClearColor(_currentClearColor, _currentClearAlpha);
      _this.toneMapping = currentToneMapping;
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i3 = 0, l4 = renderList.length;i3 < l4; i3++) {
        const renderItem = renderList[i3];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      if (programs === undefined) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = new Map;
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== undefined) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBuild(object, parameters2, _this);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
        uniforms.spotLightMap.value = lights.state.spotLightMap;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      const progUniforms = program.getUniforms();
      const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = uniformsList;
      return program;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputColorSpace = parameters2.outputColorSpace;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.instancingColor = parameters2.instancingColor;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      textures2.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      let toneMapping = NoToneMapping;
      if (material.toneMapped) {
        if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
          toneMapping = _this.toneMapping;
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputColorSpace !== colorSpace) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== undefined) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === null)
              skeleton.computeBoneTexture();
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures2);
            p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
          } else {
            console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.");
          }
        }
      }
      const morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || morphAttributes.color !== undefined && capabilities.isWebGL2 === true) {
        morphtargets.update(object, geometry, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (material.isMeshGouraudMaterial && material.envMap !== null) {
        m_uniforms.envMap.value = envMap;
        m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog === true) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures2);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures2);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      if (material.isShaderMaterial || material.isRawShaderMaterial) {
        const groups = material.uniformsGroups;
        for (let i3 = 0, l4 = groups.length;i3 < l4; i3++) {
          if (capabilities.isWebGL2) {
            const group = groups[i3];
            uniformsGroups.update(group, program);
            uniformsGroups.bind(group, program);
          } else {
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
          }
        }
      }
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      if (renderTargetProperties.__hasExternalTextures) {
        renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;
        if (!renderTargetProperties.__autoAllocateDepthBuffer) {
          if (extensions31.has("WEBGL_multisampled_render_to_texture") === true) {
            console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
            renderTargetProperties.__useRenderToTexture = false;
          }
        }
      }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === undefined) {
          textures2.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures2.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        }
        const texture3 = renderTarget.texture;
        if (texture3.isData3DTexture || texture3.isDataArrayTexture || texture3.isCompressedArrayTexture) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
            framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer[activeCubeFace];
          }
          isCube = true;
        } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures2.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          if (Array.isArray(__webglFramebuffer)) {
            framebuffer = __webglFramebuffer[activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer;
          }
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x3, y3, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        try {
          const texture3 = renderTarget.texture;
          const textureFormat = texture3.format;
          const textureType = texture3.type;
          if (textureFormat !== RGBAFormat && utils27.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions31.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions31.has("EXT_color_buffer_float"));
          if (textureType !== UnsignedByteType && utils27.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions31.has("OES_texture_float") || extensions31.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (x3 >= 0 && x3 <= renderTarget.width - width && (y3 >= 0 && y3 <= renderTarget.height - height)) {
            _gl.readPixels(x3, y3, width, height, utils27.convert(textureFormat), utils27.convert(textureType), buffer);
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
        }
      }
    };
    this.copyFramebufferToTexture = function(position, texture3, level = 0) {
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture3.image.width * levelScale);
      const height = Math.floor(texture3.image.height * levelScale);
      textures2.setTexture2D(texture3, 0);
      _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
      const width = srcTexture.image.width;
      const height = srcTexture.image.height;
      const glFormat = utils27.convert(dstTexture.format);
      const glType = utils27.convert(dstTexture.type);
      textures2.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        } else {
          _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
        }
      }
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(_gl.TEXTURE_2D);
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
      if (_this.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const width = sourceBox.max.x - sourceBox.min.x + 1;
      const height = sourceBox.max.y - sourceBox.min.y + 1;
      const depth2 = sourceBox.max.z - sourceBox.min.z + 1;
      const glFormat = utils27.convert(dstTexture.format);
      const glType = utils27.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures2.setTexture3D(dstTexture, 0);
        glTarget = _gl.TEXTURE_3D;
      } else if (dstTexture.isDataArrayTexture) {
        textures2.setTexture2DArray(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D_ARRAY;
      } else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
      if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, glType, image.data);
      } else {
        if (srcTexture.isCompressedArrayTexture) {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
          _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, image.data);
        } else {
          _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, glType, image);
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(glTarget);
      state.unbindTexture();
    };
    this.initTexture = function(texture3) {
      if (texture3.isCubeTexture) {
        textures2.setTextureCube(texture3, 0);
      } else if (texture3.isData3DTexture) {
        textures2.setTexture3D(texture3, 0);
      } else if (texture3.isDataArrayTexture || texture3.isCompressedArrayTexture) {
        textures2.setTexture2DArray(texture3, 0);
      } else {
        textures2.setTexture2D(texture3, 0);
      }
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  get physicallyCorrectLights() {
    console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.");
    return !this.useLegacyLights;
  }
  set physicallyCorrectLights(value) {
    console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.");
    this.useLegacyLights = !value;
  }
  get outputEncoding() {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.");
    return this.outputColorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
  }
  set outputEncoding(encoding) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.");
    this.outputColorSpace = encoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;
  }
  get useLegacyLights() {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.");
    return this._useLegacyLights;
  }
  set useLegacyLights(value) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.");
    this._useLegacyLights = value;
  }
}

class WebGL1Renderer extends WebGLRenderer {
}
WebGL1Renderer.prototype.isWebGL1Renderer = true;
class Scene extends Object3D {
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.backgroundBlurriness = 0;
    this.backgroundIntensity = 1;
    this.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    this.backgroundBlurriness = source.backgroundBlurriness;
    this.backgroundIntensity = source.backgroundIntensity;
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta2) {
    const data = super.toJSON(meta2);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    if (this.backgroundBlurriness > 0)
      data.object.backgroundBlurriness = this.backgroundBlurriness;
    if (this.backgroundIntensity !== 1)
      data.object.backgroundIntensity = this.backgroundIntensity;
    return data;
  }
}
class LineBasicMaterial extends Material2 {
  constructor(parameters) {
    super();
    this.isLineBasicMaterial = true;
    this.type = "LineBasicMaterial";
    this.color = new Color2(16777215);
    this.map = null;
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.fog = source.fog;
    return this;
  }
}
var _start$1 = new Vector3;
var _end$1 = new Vector3;
var _inverseMatrix$1 = new Matrix4;
var _ray$1 = new Ray2;
var _sphere$1 = new Sphere;

class Line2 extends Object3D {
  constructor(geometry = new BufferGeometry, material = new LineBasicMaterial) {
    super();
    this.isLine = true;
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [0];
      for (let i3 = 1, l4 = positionAttribute.count;i3 < l4; i3++) {
        _start$1.fromBufferAttribute(positionAttribute, i3 - 1);
        _end$1.fromBufferAttribute(positionAttribute, i3);
        lineDistances[i3] = lineDistances[i3 - 1];
        lineDistances[i3] += _start$1.distanceTo(_end$1);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3;
    const vEnd = new Vector3;
    const interSegment = new Vector3;
    const interRay = new Vector3;
    const step = this.isLineSegments ? 2 : 1;
    const index2 = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index2 !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index2.count, drawRange.start + drawRange.count);
      for (let i3 = start, l4 = end - 1;i3 < l4; i3 += step) {
        const a3 = index2.getX(i3);
        const b4 = index2.getX(i3 + 1);
        vStart.fromBufferAttribute(positionAttribute, a3);
        vEnd.fromBufferAttribute(positionAttribute, b4);
        const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
        if (distSq > localThresholdSq)
          continue;
        interRay.applyMatrix4(this.matrixWorld);
        const distance3 = raycaster.ray.origin.distanceTo(interRay);
        if (distance3 < raycaster.near || distance3 > raycaster.far)
          continue;
        intersects.push({
          distance: distance3,
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i3,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i3 = start, l4 = end - 1;i3 < l4; i3 += step) {
        vStart.fromBufferAttribute(positionAttribute, i3);
        vEnd.fromBufferAttribute(positionAttribute, i3 + 1);
        const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
        if (distSq > localThresholdSq)
          continue;
        interRay.applyMatrix4(this.matrixWorld);
        const distance3 = raycaster.ray.origin.distanceTo(interRay);
        if (distance3 < raycaster.near || distance3 > raycaster.far)
          continue;
        intersects.push({
          distance: distance3,
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i3,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== undefined) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m4 = 0, ml = morphAttribute.length;m4 < ml; m4++) {
          const name = morphAttribute[m4].name || String(m4);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m4;
        }
      }
    }
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices2 = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index2 = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0)
        generateCap(true);
      if (radiusBottom > 0)
        generateCap(false);
    }
    this.setIndex(indices2);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3;
      const vertex7 = new Vector3;
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y3 = 0;y3 <= heightSegments; y3++) {
        const indexRow = [];
        const v4 = y3 / heightSegments;
        const radius = v4 * (radiusBottom - radiusTop) + radiusTop;
        for (let x3 = 0;x3 <= radialSegments; x3++) {
          const u6 = x3 / radialSegments;
          const theta = u6 * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex7.x = radius * sinTheta;
          vertex7.y = -v4 * height + halfHeight;
          vertex7.z = radius * cosTheta;
          vertices.push(vertex7.x, vertex7.y, vertex7.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u6, 1 - v4);
          indexRow.push(index2++);
        }
        indexArray.push(indexRow);
      }
      for (let x3 = 0;x3 < radialSegments; x3++) {
        for (let y3 = 0;y3 < heightSegments; y3++) {
          const a3 = indexArray[y3][x3];
          const b4 = indexArray[y3 + 1][x3];
          const c3 = indexArray[y3 + 1][x3 + 1];
          const d3 = indexArray[y3][x3 + 1];
          indices2.push(a3, b4, d3);
          indices2.push(b4, c3, d3);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index2;
      const uv = new Vector2;
      const vertex7 = new Vector3;
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x3 = 1;x3 <= radialSegments; x3++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index2++;
      }
      const centerIndexEnd = index2;
      for (let x3 = 0;x3 <= radialSegments; x3++) {
        const u6 = x3 / radialSegments;
        const theta = u6 * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex7.x = radius * sinTheta;
        vertex7.y = halfHeight * sign2;
        vertex7.z = radius * cosTheta;
        vertices.push(vertex7.x, vertex7.y, vertex7.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index2++;
      }
      for (let x3 = 0;x3 < radialSegments; x3++) {
        const c3 = centerIndexStart + x3;
        const i3 = centerIndexEnd + x3;
        if (top === true) {
          indices2.push(i3, i3 + 1, c3);
        } else {
          indices2.push(i3 + 1, i3, c3);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index2 = 0;
    const grid = [];
    const vertex7 = new Vector3;
    const normal = new Vector3;
    const indices2 = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0;iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v4 = iy / heightSegments;
      let uOffset = 0;
      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0;ix <= widthSegments; ix++) {
        const u6 = ix / widthSegments;
        vertex7.x = -radius * Math.cos(phiStart + u6 * phiLength) * Math.sin(thetaStart + v4 * thetaLength);
        vertex7.y = radius * Math.cos(thetaStart + v4 * thetaLength);
        vertex7.z = radius * Math.sin(phiStart + u6 * phiLength) * Math.sin(thetaStart + v4 * thetaLength);
        vertices.push(vertex7.x, vertex7.y, vertex7.z);
        normal.copy(vertex7).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u6 + uOffset, 1 - v4);
        verticesRow.push(index2++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0;iy < heightSegments; iy++) {
      for (let ix = 0;ix < widthSegments; ix++) {
        const a3 = grid[iy][ix + 1];
        const b4 = grid[iy][ix];
        const c3 = grid[iy + 1][ix];
        const d3 = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices2.push(a3, b4, d3);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices2.push(b4, c3, d3);
      }
    }
    this.setIndex(indices2);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
}
class MeshPhongMaterial extends Material2 {
  constructor(parameters) {
    super();
    this.isMeshPhongMaterial = true;
    this.type = "MeshPhongMaterial";
    this.color = new Color2(16777215);
    this.specular = new Color2(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color2(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t4) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t4 < t1)) {
              for (let giveUpAt = i1 + 2;; ) {
                if (t1 === undefined) {
                  if (t4 < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.copySampleValue_(i1 - 1);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t4 < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t4 >= t0)) {
            const t1global = pp[1];
            if (t4 < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2;; ) {
              if (t0 === undefined) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t4 >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t4 < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === undefined) {
          this._cachedIndex = 0;
          return this.copySampleValue_(0);
        }
        if (t1 === undefined) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.copySampleValue_(i1 - 1);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t4, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index2) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index2 * stride;
    for (let i3 = 0;i3 !== stride; ++i3) {
      result[i3] = values[offset + i3];
    }
    return result;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}

class CubicInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === undefined) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === undefined) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t4, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p3 = (t4 - t0) / (t1 - t0), pp = p3 * p3, ppp = pp * p3;
    const sP = -wP * ppp + 2 * wP * pp - wP * p3;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p3 + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p3;
    const sN = wN * ppp - wN * pp;
    for (let i3 = 0;i3 !== stride; ++i3) {
      result[i3] = sP * values[oP + i3] + s0 * values[o0 + i3] + s1 * values[o1 + i3] + sN * values[oN + i3];
    }
    return result;
  }
}

class LinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t4, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t4 - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i3 = 0;i3 !== stride; ++i3) {
      result[i3] = values[offset0 + i3] * weight0 + values[offset1 + i3] * weight1;
    }
    return result;
  }
}

class DiscreteInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
}

class KeyframeTrack {
  constructor(name, times, values, interpolation) {
    if (name === undefined)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === undefined || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = convertArray(times, this.TimeBufferType);
    this.values = convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        name: track.name,
        times: convertArray(track.times, Array),
        values: convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === undefined) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === undefined) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i3 = 0, n4 = times.length;i3 !== n4; ++i3) {
        times[i3] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i3 = 0, n4 = times.length;i3 !== n4; ++i3) {
        times[i3] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = arraySlice(times, from, to);
      this.values = arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  }
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i3 = 0;i3 !== nKeys; i3++) {
      const currTime = times[i3];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i3, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i3, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== undefined) {
      if (isTypedArray(values)) {
        for (let i3 = 0, n4 = values.length;i3 !== n4; ++i3) {
          const value = values[i3];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i3, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  optimize() {
    const times = arraySlice(this.times), values = arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i3 = 1;i3 < lastIndex; ++i3) {
      let keep = false;
      const time = times[i3];
      const timeNext = times[i3 + 1];
      if (time !== timeNext && (i3 !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i3 * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j4 = 0;j4 !== stride; ++j4) {
            const value = values[offset + j4];
            if (value !== values[offsetP + j4] || value !== values[offsetN + j4]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i3 !== writeIndex) {
          times[writeIndex] = times[i3];
          const readOffset = i3 * stride, writeOffset = writeIndex * stride;
          for (let j4 = 0;j4 !== stride; ++j4) {
            values[writeOffset + j4] = values[readOffset + j4];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j4 = 0;j4 !== stride; ++j4) {
        values[writeOffset + j4] = values[readOffset + j4];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = arraySlice(times, 0, writeIndex);
      this.values = arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = arraySlice(this.times, 0);
    const values = arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

class BooleanKeyframeTrack extends KeyframeTrack {
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";

class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";

class QuaternionLinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t4, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha2 = (t4 - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride;offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha2);
    }
    return result;
  }
}

class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

class StringKeyframeTrack extends KeyframeTrack {
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = undefined;
    const handlers = [];
    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url3) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== undefined) {
          scope.onStart(url3, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url3) {
      itemsLoaded++;
      if (scope.onProgress !== undefined) {
        scope.onProgress(url3, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== undefined) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url3) {
      if (scope.onError !== undefined) {
        scope.onError(url3);
      }
    };
    this.resolveURL = function(url3) {
      if (urlModifier) {
        return urlModifier(url3);
      }
      return url3;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader3) {
      handlers.push(regex, loader3);
      return this;
    };
    this.removeHandler = function(regex) {
      const index2 = handlers.indexOf(regex);
      if (index2 !== -1) {
        handlers.splice(index2, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i3 = 0, l4 = handlers.length;i3 < l4; i3 += 2) {
        const regex = handlers[i3];
        const loader3 = handlers[i3 + 1];
        if (regex.global)
          regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader3;
        }
      }
      return null;
    };
  }
}
var DefaultLoadingManager = new LoadingManager;

class Loader3 {
  constructor(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url3, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url3, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path2) {
    this.path = path2;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
}
Loader3.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class Light extends Object3D {
  constructor(color8, intensity = 1) {
    super();
    this.isLight = true;
    this.type = "Light";
    this.color = new Color2(color8);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta2) {
    const data = super.toJSON(meta2);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== undefined)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== undefined)
      data.object.distance = this.distance;
    if (this.angle !== undefined)
      data.object.angle = this.angle;
    if (this.decay !== undefined)
      data.object.decay = this.decay;
    if (this.penumbra !== undefined)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== undefined)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
}
var _projScreenMatrix$1 = new Matrix4;
var _lightPositionWorld$1 = new Vector3;
var _lookTarget$1 = new Vector3;

class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum;
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    shadowMatrix.multiply(_projScreenMatrix$1);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.normalBias !== 0)
      object.normalBias = this.normalBias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    this.isDirectionalLightShadow = true;
  }
}

class DirectionalLight extends Light {
  constructor(color8, intensity) {
    super(color8, intensity);
    this.isDirectionalLight = true;
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D;
    this.shadow = new DirectionalLightShadow;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}

class AmbientLight extends Light {
  constructor(color8, intensity) {
    super(color8, intensity);
    this.isAmbientLight = true;
    this.type = "AmbientLight";
  }
}
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
var _supportedObjectNames = ["material", "materials", "bones", "map"];

class Composite {
  constructor(targetGroup, path2, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path2);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path2, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== undefined)
      binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (let i3 = this._targetGroup.nCachedObjects_, n4 = bindings.length;i3 !== n4; ++i3) {
      bindings[i3].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i3 = this._targetGroup.nCachedObjects_, n4 = bindings.length;i3 !== n4; ++i3) {
      bindings[i3].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i3 = this._targetGroup.nCachedObjects_, n4 = bindings.length;i3 !== n4; ++i3) {
      bindings[i3].unbind();
    }
  }
}

class PropertyBinding {
  constructor(rootNode, path2, parsedPath) {
    this.path = path2;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path2);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path2, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path2, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path2, parsedPath);
    }
  }
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (matches === null) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== undefined && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (nodeName === undefined || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== undefined) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i3 = 0;i3 < children.length; i3++) {
          const childNode = children[i3];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(buffer, offset) {
    buffer[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer, offset) {
    const source = this.resolvedProperty;
    for (let i3 = 0, n4 = source.length;i3 !== n4; ++i3) {
      buffer[offset++] = source[i3];
    }
  }
  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }
  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i3 = 0, n4 = dest.length;i3 !== n4; ++i3) {
      dest[i3] = buffer[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i3 = 0, n4 = dest.length;i3 !== n4; ++i3) {
      dest[i3] = buffer[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i3 = 0, n4 = dest.length;i3 !== n4; ++i3) {
      dest[i3] = buffer[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i3 = 0;i3 < targetObject.length; i3++) {
            if (targetObject[i3].name === objectIndex) {
              objectIndex = i3;
              break;
            }
          }
          break;
        case "map":
          if ("map" in targetObject) {
            targetObject = targetObject.map;
            break;
          }
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          targetObject = targetObject.material.map;
          break;
        default:
          if (targetObject[objectName] === undefined) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== undefined) {
        if (targetObject[objectIndex] === undefined) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === undefined) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn\'t found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== undefined) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== undefined) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!targetObject.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
var _controlInterpolantsResultBuffer = new Float32Array(1);
class Spherical {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  makeSafe() {
    const EPS = 0.000001;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v4) {
    return this.setFromCartesianCoords(v4.x, v4.y, v4.z);
  }
  setFromCartesianCoords(x3, y3, z3) {
    this.radius = Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x3, z3);
      this.phi = Math.acos(clamp(y3 / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D
var _changeEvent = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var _ray = new Ray2;
var _plane = new Plane2;
var TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);

class OrbitControls extends EventDispatcher {
  constructor(object, domElement) {
    super();
    this.object = object;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    this.enabled = true;
    this.target = new Vector3;
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = (-Infinity);
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.zoomToCursor = false;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this.getPolarAngle = function() {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
      return spherical.theta;
    };
    this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    };
    this.listenToKeyEvents = function(domElement2) {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.stopListenToKeyEvents = function() {
      this._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = null;
    };
    this.saveState = function() {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent);
      scope.update();
      state = STATE.NONE;
    };
    this.update = function() {
      const offset = new Vector3;
      const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3;
      const lastQuaternion = new Quaternion;
      const lastTargetPosition = new Vector3;
      const twoPI = 2 * Math.PI;
      return function update(deltaTime = null) {
        const position = scope.object.position;
        offset.copy(position).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle(deltaTime));
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min = scope.minAzimuthAngle;
        let max = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI)
            min += twoPI;
          else if (min > Math.PI)
            min -= twoPI;
          if (max < -Math.PI)
            max += twoPI;
          else if (max > Math.PI)
            max -= twoPI;
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {
          spherical.radius = clampDistance(spherical.radius);
        } else {
          spherical.radius = clampDistance(spherical.radius * scale3);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        let zoomChanged = false;
        if (scope.zoomToCursor && performCursorZoom) {
          let newRadius = null;
          if (scope.object.isPerspectiveCamera) {
            const prevRadius = offset.length();
            newRadius = clampDistance(prevRadius * scale3);
            const radiusDelta = prevRadius - newRadius;
            scope.object.position.addScaledVector(dollyDirection, radiusDelta);
            scope.object.updateMatrixWorld();
          } else if (scope.object.isOrthographicCamera) {
            const mouseBefore = new Vector3(mouse.x, mouse.y, 0);
            mouseBefore.unproject(scope.object);
            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale3));
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
            const mouseAfter = new Vector3(mouse.x, mouse.y, 0);
            mouseAfter.unproject(scope.object);
            scope.object.position.sub(mouseAfter).add(mouseBefore);
            scope.object.updateMatrixWorld();
            newRadius = offset.length();
          } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.");
            scope.zoomToCursor = false;
          }
          if (newRadius !== null) {
            if (this.screenSpacePanning) {
              scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);
            } else {
              _ray.origin.copy(scope.object.position);
              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix);
              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {
                object.lookAt(scope.target);
              } else {
                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);
                _ray.intersectPlane(_plane, scope.target);
              }
            }
          }
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale3));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        }
        scale3 = 1;
        performCursorZoom = false;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS || lastTargetPosition.distanceToSquared(scope.target) > 0) {
          scope.dispatchEvent(_changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          lastTargetPosition.copy(scope.target);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function() {
      scope.domElement.removeEventListener("contextmenu", onContextMenu);
      scope.domElement.removeEventListener("pointerdown", onPointerDown);
      scope.domElement.removeEventListener("pointercancel", onPointerUp);
      scope.domElement.removeEventListener("wheel", onMouseWheel);
      scope.domElement.removeEventListener("pointermove", onPointerMove);
      scope.domElement.removeEventListener("pointerup", onPointerUp);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
        scope._domElementKeyEvents = null;
      }
    };
    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE.NONE;
    const EPS = 0.000001;
    const spherical = new Spherical;
    const sphericalDelta = new Spherical;
    let scale3 = 1;
    const panOffset = new Vector3;
    const rotateStart = new Vector2;
    const rotateEnd = new Vector2;
    const rotateDelta = new Vector2;
    const panStart = new Vector2;
    const panEnd = new Vector2;
    const panDelta = new Vector2;
    const dollyStart = new Vector2;
    const dollyEnd = new Vector2;
    const dollyDelta = new Vector2;
    const dollyDirection = new Vector3;
    const mouse = new Vector2;
    let performCursorZoom = false;
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle(deltaTime) {
      if (deltaTime !== null) {
        return 2 * Math.PI / 60 * scope.autoRotateSpeed * deltaTime;
      } else {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
      }
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    const panLeft = function() {
      const v4 = new Vector3;
      return function panLeft(distance3, objectMatrix) {
        v4.setFromMatrixColumn(objectMatrix, 0);
        v4.multiplyScalar(-distance3);
        panOffset.add(v4);
      };
    }();
    const panUp = function() {
      const v4 = new Vector3;
      return function panUp(distance3, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v4.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v4.setFromMatrixColumn(objectMatrix, 0);
          v4.crossVectors(scope.object.up, v4);
        }
        v4.multiplyScalar(distance3);
        panOffset.add(v4);
      };
    }();
    const pan = function() {
      const offset = new Vector3;
      return function pan(deltaX, deltaY) {
        const element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          let targetDistance = offset.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) {
        scale3 /= dollyScale;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) {
        scale3 *= dollyScale;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function updateMouseParameters(event) {
      if (!scope.zoomToCursor) {
        return;
      }
      performCursorZoom = true;
      const rect = scope.domElement.getBoundingClientRect();
      const x3 = event.clientX - rect.left;
      const y3 = event.clientY - rect.top;
      const w4 = rect.width;
      const h3 = rect.height;
      mouse.x = x3 / w4 * 2 - 1;
      mouse.y = -(y3 / h3) * 2 + 1;
      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();
    }
    function clampDistance(dist) {
      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      updateMouseParameters(event);
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseWheel(event) {
      updateMouseParameters(event);
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(0, scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(0, -scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(-scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length === 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x3 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y3 = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x3, y3);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x3 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y3 = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x3, y3);
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance3 = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance3);
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enablePan)
        handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enableRotate)
        handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x3 = 0.5 * (event.pageX + position.x);
        const y3 = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x3, y3);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x3 = 0.5 * (event.pageX + position.x);
        const y3 = 0.5 * (event.pageY + position.y);
        panEnd.set(x3, y3);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance3 = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance3);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function onPointerDown(event) {
      if (scope.enabled === false)
        return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener("pointermove", onPointerMove);
        scope.domElement.addEventListener("pointerup", onPointerUp);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp(event) {
      removePointer(event);
      if (pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener("pointermove", onPointerMove);
        scope.domElement.removeEventListener("pointerup", onPointerUp);
      }
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
        return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(_endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate();
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate();
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i3 = 0;i3 < pointers.length; i3++) {
        if (pointers[i3].pointerId == event.pointerId) {
          pointers.splice(i3, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === undefined) {
        position = new Vector2;
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu);
    scope.domElement.addEventListener("pointerdown", onPointerDown);
    scope.domElement.addEventListener("pointercancel", onPointerUp);
    scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
    this.update();
  }
}

// node_modules/colord/plugins/names.mjs
class SimuloViewerTHREE {
  canvas;
  renderer;
  scene;
  camera;
  coll2gfx;
  listeners = {};
  on(event, callback) {
    if (!this.listeners[event])
      this.listeners[event] = [];
    this.listeners[event].push(callback);
  }
  off(event, callback) {
    if (!this.listeners[event])
      return;
    this.listeners[event].splice(this.listeners[event].indexOf(callback), 1);
  }
  constructor() {
    this.coll2gfx = new Map;
    this.scene = new Scene;
    this.camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    this.camera.position.z = 50;
    this.camera.position.y = 50;
    this.renderer = new WebGLRenderer({ antialias: true, alpha: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    let canvas = document.body.appendChild(this.renderer.domElement);
    this.canvas = canvas;
    window.addEventListener("resize", () => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    });
    const getCursorPos = (e3) => {
      let vec3 = new Vector3;
      let pos = new Vector3;
      vec3.set((e3.clientX - canvas.offsetLeft) / canvas.width * 2 - 1, -((e3.clientY - canvas.offsetTop) / canvas.height) * 2 + 1, 0.5);
      vec3.unproject(this.camera);
      vec3.sub(this.camera.position).normalize();
      let distance3 = -this.camera.position.z / vec3.z;
      pos.copy(this.camera.position).add(vec3.multiplyScalar(distance3));
      return pos;
    };
    let mouseCylinder = new Mesh2(new CylinderGeometry(0.1, 0.1, 3, 32), new MeshPhongMaterial({ color: 16777215 }));
    mouseCylinder.rotation.x = Math.PI / 2;
    this.scene.add(mouseCylinder);
    window.addEventListener("mousemove", (e3) => {
      let pos = getCursorPos(e3);
      if (this.listeners["pointermove"]) {
        this.listeners["pointermove"].forEach((callback) => callback({
          event: e3,
          point: { x: pos.x, y: pos.y }
        }));
      }
      mouseCylinder.position.set(pos.x, pos.y, 1.5);
    });
    window.addEventListener("mousedown", (e3) => {
      let pos = getCursorPos(e3);
      if (this.listeners["pointerdown"]) {
        this.listeners["pointerdown"].forEach((callback) => callback({
          event: e3,
          point: { x: pos.x, y: pos.y }
        }));
      }
    });
    window.addEventListener("mouseup", (e3) => {
      let pos = getCursorPos(e3);
      if (this.listeners["pointerup"]) {
        this.listeners["pointerup"].forEach((callback) => callback({
          event: e3,
          point: { x: pos.x, y: pos.y }
        }));
      }
    });
    let light = new AmbientLight(16777215, 0.5);
    this.scene.add(light);
    let directionalLight = new DirectionalLight(16777215, 2);
    this.scene.add(directionalLight);
    let controls = new OrbitControls(this.camera, this.renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.2;
    controls.mouseButtons = {
      LEFT: undefined,
      MIDDLE: MOUSE.PAN,
      RIGHT: MOUSE.ROTATE
    };
    this.renderer.setAnimationLoop(() => {
      directionalLight.position.copy(this.camera.position);
      directionalLight.rotation.copy(this.camera.rotation);
      this.renderer.render(this.scene, this.camera);
    });
  }
  lines = [];
  tempObjects = [];
  update(worldUpdate) {
    for (let key in worldUpdate.delta.shapeContent) {
      let content = worldUpdate.delta.shapeContent[key];
      this.addShape(content);
    }
    this.updatePositions(worldUpdate.delta.shapeTransforms);
    for (let line of this.lines) {
      this.scene.remove(line);
    }
    this.lines = [];
    for (let spring of worldUpdate.springs) {
      let material = new LineBasicMaterial({ color: 16777215, linewidth: 3, depthTest: false });
      const points2 = [];
      points2.push(new Vector3(spring.pointA.x, spring.pointA.y, 0));
      points2.push(new Vector3(spring.pointB.x, spring.pointB.y, 0));
      const geometry = new BufferGeometry().setFromPoints(points2);
      let line = new Line2(geometry, material);
      this.scene.add(line);
      this.lines.push(line);
    }
    for (let obj of this.tempObjects) {
      this.scene.remove(obj);
    }
    this.tempObjects = [];
    worldUpdate.overlays.shapes.forEach((shape) => {
      let mesh4 = this.renderShape(shape.content);
      let transform = shape.transform;
      mesh4.position.set(transform.x, transform.y, transform.z);
      mesh4.rotation.z = transform.angle;
      this.scene.add(mesh4);
      this.tempObjects.push(mesh4);
    });
  }
  renderShape(content) {
    let mesh4;
    let material = new MeshPhongMaterial({ color: content.color, flatShading: true, transparent: true });
    switch (content.type) {
      case "ball":
        let ball = content;
        mesh4 = new Mesh2(new SphereGeometry(ball.radius), material);
        break;
      case "polygon":
        break;
      case "cuboid":
        let cuboid = content;
        mesh4 = new Mesh2(new BoxGeometry(cuboid.width, cuboid.height, cuboid.depth), material);
        break;
      default:
        mesh4 = new Object3D;
        break;
    }
    return mesh4;
  }
  addShape(content) {
    let mesh4 = this.renderShape(content);
    this.scene.add(mesh4);
    this.coll2gfx.set(content.id, mesh4);
  }
  updatePositions(transformData) {
    Object.keys(transformData).forEach((id) => {
      let transform = transformData[id];
      let mesh4 = this.coll2gfx.get(id);
      if (!mesh4)
        return;
      mesh4.position.set(transform.x, transform.y, transform.z);
      mesh4.rotation.z = transform.angle;
    });
  }
}

// node_modules/colord/plugins/names.mjsiste
class SimuloRendererCanvas {
  canvas;
  ctx;
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
  }
  drawVertsAt(x3, y3, verts2, rotation = 0) {
    this.ctx.beginPath();
    this.ctx.translate(x3, y3);
    this.ctx.rotate(rotation);
    verts2.forEach((e3) => {
      this.ctx.lineTo(e3.x, e3.y);
    });
    this.ctx.closePath();
    this.ctx.save();
    this.ctx.clip();
    this.ctx.lineWidth *= 2;
    this.ctx.fill();
    this.ctx.stroke();
    this.ctx.restore();
    this.ctx.rotate(-rotation);
    this.ctx.translate(-x3, -y3);
  }
  drawVertsNoFillAt(x3, y3, verts2, rotation = 0) {
    this.ctx.beginPath();
    this.ctx.translate(x3, y3);
    this.ctx.rotate(rotation);
    verts2.forEach((e3) => {
      this.ctx.lineTo(e3.x, e3.y);
    });
    this.ctx.closePath();
    this.ctx.strokeStyle = "#9ac4f1";
    this.ctx.lineWidth = 0.01;
    this.ctx.stroke();
    this.ctx.strokeStyle = "transparent";
    this.ctx.rotate(-rotation);
    this.ctx.translate(-x3, -y3);
  }
  drawCircleAt(x3, y3, radius, rotation = 0, circleCake = false) {
    this.ctx.beginPath();
    this.ctx.arc(x3, y3, radius, 0, 2 * Math.PI);
    this.ctx.fill();
    this.ctx.stroke();
    if (circleCake) {
      this.ctx.fillStyle = "#00000080";
      this.ctx.strokeStyle = "transparent";
      this.ctx.beginPath();
      this.ctx.arc(x3, y3, radius, rotation, rotation + 23 * Math.PI / 180);
      this.ctx.lineTo(x3, y3);
      this.ctx.closePath();
      this.ctx.fill();
    }
  }
  drawVerts(verts2) {
    this.ctx.beginPath();
    verts2.forEach((e3) => this.ctx.lineTo(e3.x, e3.y));
    this.ctx.closePath();
    this.ctx.fill();
    this.ctx.stroke();
  }
  drawStretchedImageLine(image, x1, y1, x22, y22, useHeight, otherAxisLength) {
    if (useHeight) {
      let angle = Math.atan2(y22 - y1, x22 - x1);
      let length2 = Math.sqrt(Math.pow(x22 - x1, 2) + Math.pow(y22 - y1, 2));
      let halfOtherAxisLength = otherAxisLength / 2;
      this.ctx.save();
      this.ctx.translate(x1, y1);
      this.ctx.rotate(angle);
      this.ctx.drawImage(image, -halfOtherAxisLength, 0, otherAxisLength, length2);
      this.ctx.restore();
    } else {
      let angle = Math.atan2(y22 - y1, x22 - x1);
      let length2 = Math.sqrt(Math.pow(x22 - x1, 2) + Math.pow(y22 - y1, 2));
      let halfOtherAxisLength = otherAxisLength / 2;
      this.ctx.save();
      this.ctx.translate(x1, y1);
      this.ctx.rotate(angle);
      this.ctx.drawImage(image, 0, -halfOtherAxisLength, length2, otherAxisLength);
      this.ctx.restore();
    }
  }
  drawRect(x3, y3, width, height) {
    this.ctx.fillRect(x3, y3, width, height);
  }
  drawText(text7, x3, y3, size, color8, font = "urbanist", align = "left", baseline = "alphabetic") {
    this.ctx.fillStyle = color8;
    this.ctx.textAlign = align;
    this.ctx.textBaseline = baseline;
    this.ctx.font = `${size}px ${font}`;
    this.ctx.fillText(text7, x3, y3);
  }
  outlinedImage(img, s3, color8, x3, y3, width, height) {
    let canvas2 = document.createElement("canvas");
    let ctx2 = canvas2.getContext("2d");
    canvas2.width = width + s3 * 4;
    canvas2.height = height + s3 * 4;
    ctx2.imageSmoothingEnabled = false;
    ctx2.mozImageSmoothingEnabled = false;
    ctx2.webkitImageSmoothingEnabled = false;
    ctx2.msImageSmoothingEnabled = false;
    let dArr = [-1, -1, 0, -1, 1, -1, -1, 0, 1, 0, -1, 1, 0, 1, 1, 1], i3 = 0;
    for (;i3 < dArr.length; i3 += 2)
      ctx2.drawImage(img, 1 + dArr[i3] * s3 + s3, 1 + dArr[i3 + 1] * s3 + s3, width, height);
    ctx2.globalCompositeOperation = "source-in";
    ctx2.fillStyle = color8;
    ctx2.fillRect(0, 0, width + s3 * 4, height + s3 * 40);
    ctx2.globalCompositeOperation = "source-over";
    ctx2.drawImage(img, 1 + s3, 1 + s3, width, height);
    this.ctx.drawImage(canvas2, x3 - 1 - s3, y3 - 1 - s3);
  }
  roundRect(x3, y3, w4, h3, r4) {
    if (w4 < 2 * r4)
      r4 = w4 / 2;
    if (h3 < 2 * r4)
      r4 = h3 / 2;
    this.ctx.beginPath();
    this.ctx.moveTo(x3 + r4, y3);
    this.ctx.arcTo(x3 + w4, y3, x3 + w4, y3 + h3, r4);
    this.ctx.arcTo(x3 + w4, y3 + h3, x3, y3 + h3, r4);
    this.ctx.arcTo(x3, y3 + h3, x3, y3, r4);
    this.ctx.arcTo(x3, y3, x3 + w4, y3, r4);
    this.ctx.closePath();
    return this.ctx;
  }
  roundTri(x3, y3, w4, h3) {
    this.ctx.beginPath();
    this.ctx.moveTo(x3, y3);
    this.ctx.arcTo(x3 + w4, y3, x3 + w4, y3 + h3, 10);
    this.ctx.arcTo(x3 + w4, y3 + h3, x3, y3 + h3, 10);
    this.ctx.arcTo(x3, y3 + h3, x3, y3, 10);
    this.ctx.closePath();
    return this.ctx;
  }
  cachedImages = {};
  getImage(src) {
    if (this.cachedImages[src] != null) {
      return this.cachedImages[src];
    } else {
      let img = new Image;
      img.src = src;
      this.cachedImages[src] = img;
      return img;
    }
  }
  transformPoint(x3, y3) {
    let newX, newY;
    newX = (x3 - this.ctx.getTransform().e) / this.ctx.getTransform().a;
    newY = (y3 - this.ctx.getTransform().f) / this.ctx.getTransform().d;
    return { x: newX, y: newY };
  }
  updateTransform(zoom) {
    this.ctx.setTransform(zoom, 0, 0, zoom, 0, 0);
  }
  contentDatas = {};
  transformDatas = {};
  overlays = {
    shapes: [],
    texts: []
  };
  update(worldUpdate) {
    worldUpdate.delta.removedContents.forEach((id) => {
      delete this.contentDatas[id];
    });
    for (let id in worldUpdate.delta.shapeContent) {
      this.contentDatas[id] = {
        content: worldUpdate.delta.shapeContent[id],
        color: "#" + worldUpdate.delta.shapeContent[id].color.toString(16).padStart(6, "0") + Math.round(worldUpdate.delta.shapeContent[id].alpha * 255).toString(16).padStart(2, "0")
      };
    }
    for (let id in worldUpdate.delta.shapeTransforms) {
      this.transformDatas[id] = worldUpdate.delta.shapeTransforms[id];
    }
    this.overlays = worldUpdate.overlays;
  }
  renderWorld(cameraZoom) {
    let contentDatas = Object.assign({}, this.contentDatas);
    let transformDatas = Object.assign({}, this.transformDatas);
    let overlays = this.overlays;
    overlays.shapes.forEach((shape) => {
      contentDatas[shape.content.id] = {
        content: shape.content,
        color: "#" + shape.content.color.toString(16).padStart(6, "0") + Math.round(shape.content.alpha * 255).toString(16).padStart(2, "0")
      };
      transformDatas[shape.content.id] = shape.transform;
    });
    this.render(contentDatas, transformDatas, overlays.texts, cameraZoom);
  }
  render(contents, transforms, texts, zoom, handleZooming = false) {
    if (handleZooming) {
      this.updateTransform(zoom);
    }
    let topLeft = this.transformPoint(0, 0);
    let bottomRight = this.transformPoint(this.canvas.width, this.canvas.height);
    this.ctx.clearRect(topLeft.x, topLeft.y, this.canvas.width / zoom, this.canvas.height / zoom);
    this.ctx.fillStyle = "#a1acfa";
    this.ctx.strokeStyle = "transparent";
    let keys = Object.keys(contents);
    let keyLength = keys.length;
    for (let i3 = 0;i3 < keyLength; i3++) {
      let key = keys[i3];
      let content = contents[key];
      let transform = transforms[key];
      if (!transform)
        continue;
      let shapeHeight = 0;
      let shapeWidth = 0;
      this.ctx.fillStyle = content.color;
      if (content.content.border) {
        this.ctx.strokeStyle = "#" + content.content.border.toString(16).padStart(6, "0");
        this.ctx.lineWidth = content.content.borderWidth / (content.content.borderScaleWithZoom ? zoom : 1);
      } else {
        this.ctx.strokeStyle = "transparent";
      }
      if (content.content.type === "polygon") {
        let shapePolygon = content.content;
        shapePolygon.points.forEach(function(vert) {
          if (Math.abs(vert[0]) > shapeWidth)
            shapeWidth = Math.abs(vert[0]);
          if (Math.abs(vert[1]) > shapeHeight)
            shapeHeight = Math.abs(vert[1]);
        });
      } else if (content.content.type === "cuboid") {
        let shapeRectangle = content.content;
        shapeWidth = shapeRectangle.width;
        shapeHeight = shapeRectangle.height;
      } else if (content.content.type === "ball") {
        let shapeCircle = content.content;
        shapeWidth = shapeCircle.radius;
        shapeHeight = shapeCircle.radius;
      }
      if (content.content.image) {
        let image = this.getImage(content.content.image);
        if (image) {
          this.ctx.save();
          let imageTranslation = content.content.imageTransformations ? content.content.imageTransformations.translate : { x: 0, y: 0 };
          let imageScale = content.content.imageTransformations ? content.content.imageTransformations.scale : 1;
          let imageRotation = content.content.imageTransformations ? content.content.imageTransformations.rotate : 0;
          this.ctx.translate(transform.x + imageTranslation.x, -transform.y - imageTranslation.y);
          this.ctx.rotate(-transform.angle - imageRotation);
          this.ctx.rotate(Math.PI);
          try {
            this.ctx.drawImage(image, -shapeWidth, -shapeHeight, shapeWidth * 2, shapeHeight * 2);
          } catch (e3) {
            console.error(e3);
          }
          this.ctx.restore();
        }
      }
      if (content.content.type === "polygon") {
        let shapePolygon = content.content;
        this.drawVertsAt(transform.x, -transform.y, shapePolygon.points.map((points2) => {
          return { x: points2[0], y: -points2[1] };
        }), -transform.angle);
      } else if (content.content.type === "ball") {
        let shapeCircle = content.content;
        this.drawCircleAt(transform.x, -transform.y, shapeCircle.radius, -transform.angle, shapeCircle.cakeSlice);
      } else if (content.content.type === "cuboid") {
        let shapeRectangle = content.content;
        let verts2 = [
          { x: -shapeRectangle.width / 2, y: -shapeRectangle.height / 2 },
          { x: shapeRectangle.width / 2, y: -shapeRectangle.height / 2 },
          { x: shapeRectangle.width / 2, y: shapeRectangle.height / 2 },
          { x: -shapeRectangle.width / 2, y: shapeRectangle.height / 2 }
        ];
        this.drawVertsAt(transform.x, -transform.y, verts2, -transform.angle);
      }
      if (content.content.text) {
        this.drawText(content.content.text.text, transform.x, -transform.y, content.content.text.fontSize, "#" + content.content.text.color.toString(16).padStart(6, "0"), content.content.text.fontFamily, content.content.text.align, content.content.text.baseline);
      }
    }
    let textLength = texts.length;
    for (let i3 = 0;i3 < textLength; i3++) {
      let text7 = texts[i3];
      this.drawText(text7.text, text7.transform.x, -text7.transform.y, text7.fontSize, "#" + text7.color.toString(16).padStart(6, "0"), text7.fontFamily, text7.align, text7.baseline);
    }
  }
  reset() {
    this.contentDatas = {};
    this.transformDatas = {};
    this.overlays = {
      shapes: [],
      texts: []
    };
  }
}

// node_modules/colord/plugins/names.mjsi
var getEventLocation = function(e3) {
  if (window.TouchEvent && e3 instanceof TouchEvent) {
    if (e3.touches && e3.touches.length == 1) {
      return { x: e3.touches[0].clientX, y: e3.touches[0].clientY };
    }
  } else if (e3.clientX && e3.clientY) {
    return { x: e3.clientX, y: e3.clientY };
  }
  return { x: 0, y: 0 };
};

class SimuloViewerCanvas {
  ctx;
  canvas;
  cameraOffset = { x: 0, y: 0 };
  cameraZoom = 30;
  lastX;
  lastY;
  renderer;
  touchStartElement = null;
  isDragging = false;
  dragStart = { x: 0, y: 0 };
  dragStart2 = { x: 0, y: 0 };
  pointerDown = false;
  mouseTouchDown = 0;
  initialPinchDistance = null;
  lastZoom = this.cameraZoom;
  keysDown = {};
  previousPinchDistance = null;
  listeners = {};
  emit(event, data = null) {
    if (this.listeners[event]) {
      this.listeners[event].forEach((listener) => {
        if (data == null) {
          listener();
        } else {
          listener(data);
        }
      });
    }
  }
  on(event, listener) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(listener);
  }
  off(event, listener) {
    if (this.listeners[event]) {
      this.listeners[event] = this.listeners[event].filter((l4) => l4 != listener);
    }
  }
  resetCamera() {
    this.cameraOffset = { x: window.innerWidth / 2, y: window.innerHeight / 2 - 700 };
    this.cameraZoom = 30;
  }
  registeredListeners = {};
  addEventListener(element, event, listener) {
    if (!this.registeredListeners[event]) {
      this.registeredListeners[event] = [];
    }
    this.registeredListeners[event].push({ element, listener });
    element.addEventListener(event, listener);
  }
  clearEventListeners() {
    for (let event in this.registeredListeners) {
      for (let listener of this.registeredListeners[event]) {
        listener.element.removeEventListener(event, listener.listener);
      }
    }
  }
  transformPoint(x3, y3) {
    var newX, newY;
    newX = (x3 - this.ctx.getTransform().e) / this.ctx.getTransform().a;
    newY = (y3 - this.ctx.getTransform().f) / this.ctx.getTransform().d;
    return { x: newX, y: -newY };
  }
  inverseTransformPoint(x3, y3) {
    var newX, newY;
    newX = x3 * this.ctx.getTransform().a + this.ctx.getTransform().e;
    newY = -y3 * this.ctx.getTransform().d + this.ctx.getTransform().f;
    return { x: newX, y: newY };
  }
  lastMouseX;
  lastMouseY;
  lastTouchX = 0;
  lastTouchY = 0;
  constructor(canvas) {
    this.canvas = canvas;
    this.renderer = new SimuloRendererCanvas(canvas);
    const dpr = window.devicePixelRatio || 1;
    this.canvas.width = window.innerWidth * dpr;
    this.canvas.height = window.innerHeight * dpr;
    let context2 = this.canvas.getContext("2d");
    if (context2) {
      this.ctx = context2;
    } else {
      throw new Error("Could not get canvas context");
    }
    this.ctx.scale(dpr, dpr);
    if (this.canvas.tabIndex == -1) {
      this.canvas.tabIndex = -1;
    }
    this.resetCamera();
    this.lastX = window.innerWidth / 2;
    this.lastY = window.innerHeight / 2;
    this.lastMouseX = this.lastX;
    this.lastMouseY = this.lastY;
    this.addEventListener(this.canvas, "touchstart", (e3) => {
      this.mouseTouchDown++;
      this.touchStartElement = e3.target;
      this.lastTouchX = e3.touches[0].clientX;
      this.lastTouchY = e3.touches[0].clientY;
      this.canvas.focus();
    });
    this.addEventListener(this.canvas, "contextmenu", (e3) => {
      e3.preventDefault();
    });
    this.addEventListener(this.canvas, "mousemove", (e3) => {
      if (this.mouseTouchDown > 0) {
        return;
      }
      this.onPointerMove(e3);
    });
    this.addEventListener(this.canvas, "keydown", (e3) => {
      if (this.mouseTouchDown > 0) {
        return;
      }
      this.emit("keyDown", e3);
    });
    this.addEventListener(this.canvas, "keyup", (e3) => {
      if (this.mouseTouchDown > 0) {
        return;
      }
      this.emit("keyUp", e3);
    });
    this.addEventListener(this.canvas, "wheel", (e3) => {
      this.adjustZoom(-e3.deltaY > 0 ? 1.1 : 0.9, null, null);
    });
    this.addEventListener(this.canvas, "mousedown", (e3) => {
      this.canvas.focus();
      this.mouseTouchDown++;
      this.onPointerDown(e3);
      e3.stopPropagation();
      e3.preventDefault();
      return false;
    });
    this.addEventListener(this.canvas, "touchstart", (e3) => {
      this.handleTouch(e3, this.onPointerDown);
      e3.stopPropagation();
      e3.preventDefault();
      return false;
    });
    var documentElement = this.canvas.ownerDocument;
    this.addEventListener(documentElement, "touchend", (e3) => {
      if (this.mouseTouchDown <= 0) {
        return;
      }
      this.mouseTouchDown--;
      this.handleTouch(e3, this.onPointerUp);
    });
    this.addEventListener(documentElement, "touchmove", (e3) => {
      if (this.mouseTouchDown <= 0) {
        return;
      }
      this.lastTouchX = e3.touches[0].clientX;
      this.lastTouchY = e3.touches[0].clientY;
      this.handleTouch(e3, this.onPointerMove);
    });
    this.addEventListener(documentElement, "mousemove", (e3) => {
      if (this.mouseTouchDown <= 0) {
        let rect = this.canvas.getBoundingClientRect();
        if (e3.clientX >= rect.left && e3.clientX <= rect.right && e3.clientY >= rect.top && e3.clientY <= rect.bottom && !e3.buttons) {
          this.onPointerMove(e3);
        }
      }
      this.onPointerMove(e3);
    });
    this.addEventListener(documentElement, "mouseup", (e3) => {
      if (this.mouseTouchDown <= 0) {
        return;
      }
      this.mouseTouchDown--;
      this.onPointerUp(e3);
    });
    this.addEventListener(documentElement, "keydown", (e3) => {
      if (this.mouseTouchDown <= 0) {
        return;
      }
      this.emit("keyDown", e3);
    });
    this.addEventListener(documentElement, "keyup", (e3) => {
      if (this.mouseTouchDown <= 0) {
        return;
      }
      this.emit("keyUp", e3);
    });
    this.ctx = context2;
  }
  onPointerMove = (e3) => {
    if (!getEventLocation(e3).x && !getEventLocation(e3).y) {
      return;
    }
    if (this.isDragging) {
      this.cameraOffset.x = getEventLocation(e3).x - this.dragStart.x;
      this.cameraOffset.y = getEventLocation(e3).y - this.dragStart.y;
    }
    this.lastX = getEventLocation(e3).x;
    this.lastY = getEventLocation(e3).y;
    this.lastMouseX = getEventLocation(e3).x;
    this.lastMouseY = getEventLocation(e3).y;
    var mousePos = this.transformPoint(getEventLocation(e3).x, getEventLocation(e3).y);
    this.emit("pointermove", {
      point: {
        x: mousePos.x,
        y: mousePos.y
      },
      event: e3
    });
  };
  onPointerDown = (e3) => {
    var mousePos = this.transformPoint(getEventLocation(e3).x, getEventLocation(e3).y);
    if (window.TouchEvent && e3 instanceof TouchEvent) {
      this.emit("pointerdown", {
        point: {
          x: mousePos.x,
          y: mousePos.y
        },
        right: false,
        screenPos: getEventLocation(e3),
        event: e3
      });
      this.pointerDown = true;
    } else {
      if (e3.button == 2 || e3.button && 3) {
        this.isDragging = true;
        this.dragStart.x = getEventLocation(e3).x - this.cameraOffset.x;
        this.dragStart.y = getEventLocation(e3).y - this.cameraOffset.y;
        this.dragStart2.x = getEventLocation(e3).x;
        this.dragStart2.y = getEventLocation(e3).y;
      }
      if (e3.button == 0 || e3.button == 2) {
        this.emit("pointerdown", {
          point: {
            x: mousePos.x,
            y: mousePos.y
          },
          right: e3.button == 2,
          screenPos: getEventLocation(e3),
          event: e3
        });
        this.pointerDown = true;
      }
    }
  };
  onPointerUp = (e3) => {
    if (window.TouchEvent && e3 instanceof TouchEvent) {
      this.pointerDown = false;
      var mousePos = this.transformPoint(this.lastTouchX, this.lastTouchY);
      this.emit("pointerup", {
        point: {
          x: mousePos.x,
          y: mousePos.y
        },
        event: e3
      });
    } else {
      if (e3.button == 0) {
        this.pointerDown = false;
        var mousePos = this.transformPoint(getEventLocation(e3).x, getEventLocation(e3).y);
        this.emit("pointerup", {
          point: {
            x: mousePos.x,
            y: mousePos.y
          },
          event: e3
        });
      }
    }
    this.isDragging = false;
    this.lastZoom = this.cameraZoom;
    this.initialPinchDistance = null;
  };
  handleTouch(e3, singleTouchHandler) {
    if (this.touchStartElement != this.canvas) {
      console.log("it didnt start on canvas");
      return;
    }
    if (e3.touches.length <= 1) {
      singleTouchHandler(e3);
    } else if (e3.type == "touchmove" && e3.touches.length == 2) {
      this.isDragging = false;
      this.handlePinch(e3);
    }
  }
  handlePinch(e3) {
    e3.preventDefault();
    let touch1 = { x: e3.touches[0].clientX, y: e3.touches[0].clientY };
    let touch2 = { x: e3.touches[1].clientX, y: e3.touches[1].clientY };
    let currentDistance = (touch1.x - touch2.x) ** 2 + (touch1.y - touch2.y) ** 2;
    if (!this.previousPinchDistance)
      this.previousPinchDistance = currentDistance;
    if (this.initialPinchDistance == null) {
      this.initialPinchDistance = currentDistance;
    } else {
      this.adjustZoom(currentDistance - this.previousPinchDistance > 0 ? 1.05 : currentDistance - this.previousPinchDistance < 0 ? 0.95 : 0, null, { x: (touch1.x + touch2.x) / 2, y: (touch1.y + touch2.y) / 2 });
    }
    this.previousPinchDistance = currentDistance;
  }
  scaleAt(x3, y3, scaleBy) {
    this.cameraZoom *= scaleBy;
    this.cameraOffset.x = x3 - (x3 - this.cameraOffset.x) * scaleBy;
    this.cameraOffset.y = y3 - (y3 - this.cameraOffset.y) * scaleBy;
  }
  adjustZoom(zoomAmount, zoomFactor, center) {
    if (!this.isDragging) {
      if (center) {
        this.lastX = center.x;
        this.lastY = center.y;
      }
      if (zoomAmount) {
        this.scaleAt(this.lastX, this.lastY, zoomAmount);
      } else if (zoomFactor) {
        console.log(zoomFactor + " is zoom factor");
        this.scaleAt(this.lastX, this.lastY, zoomFactor);
      }
      console.log(zoomAmount);
      var mousePos = this.transformPoint(this.lastX, this.lastY);
      this.emit("pointermove", { point: { x: mousePos.x, y: mousePos.y } });
    }
  }
  lineBetweenPoints(x1, y1, x22, y22, center = false) {
    if (!center) {
      var angle = Math.atan2(y22 - y1, x22 - x1);
      var length2 = Math.sqrt(Math.pow(x22 - x1, 2) + Math.pow(y22 - y1, 2));
      return { x: x1, y: y1, angle, length: length2 };
    } else {
      var angle = Math.atan2(y22 - y1, x22 - x1);
      var length2 = Math.sqrt(Math.pow(x22 - x1, 2) + Math.pow(y22 - y1, 2));
      var x3 = x1 + (x22 - x1) / 2;
      var y3 = y1 + (y22 - y1) / 2;
      return { x: x3, y: y3, angle, length: length2 * 2 };
    }
  }
  update(worldUpdate) {
    this.renderer.update(worldUpdate);
  }
  render() {
    this.ctx.setTransform(this.cameraZoom, 0, 0, this.cameraZoom, this.cameraOffset.x, this.cameraOffset.y);
    this.renderer.renderWorld(this.cameraZoom);
  }
  destroy() {
    this.clearEventListeners();
  }
  reset() {
    this.resetCamera();
    this.renderer.reset();
  }
}
var SimuloViewerCanvas_default = SimuloViewerCanvas;

// node_modules/colord/plugins/names.mjsistener.mjsgle.mjs2D.mjsTextur
class SimuloPhysicsSandboxClientPlugin {
  name = "Simulo Physics Sandbox Client Plugin";
  description = "The client-side plugin for the Physics Sandbox game";
  version = "0.1.0";
  author = "Carroted";
  namespace = "carroted";
  id = "simulo-physics-sandbox-client-plugin";
  dependencies = [];
  controller;
  viewer;
  cachedImages = {};
  async fetchSVG(url3) {
    if (this.cachedImages[url3])
      return this.cachedImages[url3];
    this.cachedImages[url3] = await (await fetch(url3)).text();
    return this.cachedImages[url3];
  }
  async setColorCursor(image, fillColor, borderColor) {
    let cursorSVG = await this.fetchSVG(image);
    cursorSVG = cursorSVG.replace(/#ff0000/g, fillColor);
    if (!borderColor) {
      cursorSVG = cursorSVG.replace(/#0000ff/g, fillColor === "#000000" ? "#ffffff" : "#000000");
    } else {
      cursorSVG = cursorSVG.replace(/#0000ff/g, borderColor);
    }
    let cursorDataURL = "data:image/svg+xml;base64," + btoa(cursorSVG);
    document.body.style.setProperty("cursor", `url("${cursorDataURL}") 6 2, auto`, "important");
  }
  utilityBar;
  toolBar;
  menuBar;
  paused = false;
  pausedIndicator;
  pausePlay;
  togglePaused() {
    this.controller.emit("set_paused", !this.paused);
  }
  constructor(controller, viewer) {
    this.controller = controller;
    if (viewer === "pixi") {
      this.viewer = new SimuloViewerPIXI;
    } else if (viewer === "canvas") {
      let canvas = document.createElement("canvas");
      this.viewer = new SimuloViewerCanvas_default(canvas);
    } else if (viewer === "three") {
      this.viewer = new SimuloViewerTHREE;
    } else {
      let canvas = document.createElement("canvas");
      this.viewer = new SimuloViewerCanvas_default(canvas);
    }
    this.viewer.on("pointerdown", (e3) => {
      if (e3.event.button === 0) {
        console.log("down it goes at", e3.point);
        this.controller.emit("player_down", e3.point);
      }
    });
    this.viewer.on("pointermove", (e3) => {
      this.controller.emit("player_move", e3.point);
    });
    this.viewer.on("pointerup", (e3) => {
      if (e3.event.button === 0) {
        console.log("up it goes");
        this.controller.emit("player_up", e3.point);
      }
    });
    let pauseOverlay = document.createElement("div");
    pauseOverlay.className = "pause-overlay";
    pauseOverlay.id = "pause-overlay";
    this.fetchSVG("./icons/pause.svg").then((svg) => {
      pauseOverlay.innerHTML = svg;
    });
    this.pausedIndicator = document.body.appendChild(pauseOverlay);
    window.addEventListener("keydown", (e3) => {
      if (e3.code === "Space") {
        this.togglePaused();
      }
      if (e3.code === "Delete") {
        this.controller.emit("player_delete_selection", "");
      }
    });
    let renderLoop = () => {
      this.viewer.render();
      requestAnimationFrame(renderLoop);
    };
    requestAnimationFrame(renderLoop);
    this.setColorCursor("./assets/textures/cursor_new.svg", "#000000");
    let utilityBar = document.createElement("div");
    utilityBar.className = "panel bar utilities";
    utilityBar.style.display = "none";
    let people = document.createElement("div");
    people.className = "people item";
    this.fetchSVG("./icons/account-multiple.svg").then((svg) => {
      people.innerHTML = svg;
    });
    people.addEventListener("click", (e3) => {
      console.log("people");
    });
    utilityBar.appendChild(people);
    let addUndoEntry = document.createElement("div");
    addUndoEntry.className = "add-undo-entry item";
    this.fetchSVG("./icons/timeline-plus.svg").then((svg) => {
      addUndoEntry.innerHTML = svg;
    });
    addUndoEntry.addEventListener("click", (e3) => {
      console.log("add undo entry");
    });
    utilityBar.appendChild(addUndoEntry);
    {
      let divider = document.createElement("div");
      divider.className = "divider";
      utilityBar.appendChild(divider);
    }
    let undo = document.createElement("div");
    undo.className = "undo item";
    this.fetchSVG("./icons/arrow-u-left-top.svg").then((svg) => {
      undo.innerHTML = svg;
    });
    undo.addEventListener("click", (e3) => {
      console.log("undo");
    });
    utilityBar.appendChild(undo);
    let pausePlay = document.createElement("div");
    pausePlay.className = "pause-play item";
    let pauseDiv = document.createElement("div");
    pauseDiv.className = "pause";
    let playDiv = document.createElement("div");
    playDiv.className = "play";
    this.fetchSVG("./icons/pause.svg").then((svg) => {
      pauseDiv.innerHTML = svg;
    });
    this.fetchSVG("./icons/play.svg").then((svg) => {
      playDiv.innerHTML = svg;
    });
    pausePlay.appendChild(pauseDiv);
    pausePlay.appendChild(playDiv);
    pausePlay.addEventListener("click", (e3) => {
      this.togglePaused();
    });
    this.pausePlay = utilityBar.appendChild(pausePlay);
    let redo = document.createElement("div");
    redo.className = "redo item";
    this.fetchSVG("./icons/arrow-u-right-top.svg").then((svg) => {
      redo.innerHTML = svg;
    });
    redo.addEventListener("click", (e3) => {
      console.log("redo");
    });
    utilityBar.appendChild(redo);
    {
      let divider = document.createElement("div");
      divider.className = "divider";
      utilityBar.appendChild(divider);
    }
    let worldSettings = document.createElement("div");
    worldSettings.className = "world-settings item";
    this.fetchSVG("./icons/earth.svg").then((svg) => {
      worldSettings.innerHTML = svg;
    });
    worldSettings.addEventListener("click", (e3) => {
      console.log("world settings");
    });
    utilityBar.appendChild(worldSettings);
    let grid = document.createElement("div");
    grid.className = "grid item";
    this.fetchSVG("./icons/grid.svg").then((svg) => {
      grid.innerHTML = svg;
    });
    grid.addEventListener("click", (e3) => {
      console.log("grid");
    });
    utilityBar.appendChild(grid);
    this.utilityBar = document.body.appendChild(utilityBar);
    let toolBar = document.createElement("div");
    toolBar.className = "panel bar tools";
    toolBar.style.display = "none";
    this.toolBar = document.body.appendChild(toolBar);
    let menuBar = document.createElement("div");
    menuBar.className = "panel bar menus";
    this.menuBar = document.body.appendChild(menuBar);
    let fileMenu = document.createElement("div");
    fileMenu.className = "menu";
    fileMenu.innerHTML = "File";
    this.menuBar.appendChild(fileMenu);
    window.save = () => {
      this.controller.emit("save", "");
    };
    window.load = () => {
      this.controller.emit("load", "");
      this.viewer.reset();
    };
  }
  destroy() {
  }
  toolElements = {};
  async updateToolBar(toolsLists, toolID) {
    this.utilityBar.style.display = "flex";
    this.toolBar.style.display = "grid";
    this.toolBar.innerHTML = "";
    this.toolElements = {};
    for (let i3 = 0;i3 < toolsLists.length; i3++) {
      let tools = toolsLists[i3];
      if (i3 !== 0) {
        let divider = document.createElement("div");
        divider.className = "divider horizontal";
        divider.style.gridColumn = "span 2";
        this.toolBar.appendChild(divider);
      }
      for (let tool of tools) {
        if (!tool) {
          let div = document.createElement("div");
          div.className = "tool item";
          this.toolBar.appendChild(div);
          continue;
        }
        const toolElement = document.createElement("div");
        toolElement.className = toolID === tool.id ? "tool item active" : "tool item";
        toolElement.innerHTML = await this.fetchSVG(tool.icon);
        toolElement.addEventListener("click", (e3) => {
          this.controller.emit("player_tool", tool.id);
        });
        this.toolElements[tool.id] = this.toolBar.appendChild(toolElement);
      }
    }
  }
  handleIncomingEvent(event, data) {
    if (event === "world_update") {
      let worldUpdate = data;
      this.viewer.update(worldUpdate);
    }
    if (event === "tools") {
      let tools = data.tools;
      let tool = data.tool;
      this.updateToolBar(tools, tool);
    }
    if (event === "player_tool_success") {
      Object.keys(this.toolElements).forEach((tool) => {
        if (data !== tool) {
          this.toolElements[tool].classList.remove("active");
        } else {
          this.toolElements[tool].classList.add("active");
        }
      });
    }
    if (event === "pause_changed") {
      this.paused = data;
      if (this.paused) {
        this.pausedIndicator.style.opacity = "1";
        this.pausePlay.classList.add("paused");
      } else {
        this.pausedIndicator.style.opacity = "0";
        this.pausePlay.classList.remove("paused");
      }
    }
  }
  handleOutgoingEvent(event, data) {
  }
}

// node_modules/colord/plugins/names.mjsisten
class SimuloServerController {
  frameRate;
  plugins = [];
  addPlugin(plugin) {
    this.plugins.push(plugin);
  }
  removePlugin(plugin) {
    plugin.destroy();
    this.plugins.splice(this.plugins.indexOf(plugin), 1);
  }
  async runStarts() {
    for (let plugin of this.plugins) {
      try {
        await plugin.start().catch((e3) => {
          console.error(e3);
        });
      } catch (e3) {
      }
    }
  }
  async runUpdates() {
    for (let plugin of this.plugins) {
      try {
        await plugin.update().catch((e3) => {
          console.error(e3);
        });
      } catch (e3) {
      }
    }
  }
  async destroy() {
    for (let plugin of this.plugins) {
      try {
        await plugin.destroy().catch((e3) => {
          console.error(e3);
        });
      } catch (e3) {
      }
    }
  }
  async handleIncomingEvent(event, data, id) {
    for (let plugin of this.plugins) {
      await plugin.handleIncomingEvent(event, data, id);
    }
  }
  async handleOutgoingEvent(event, data, id) {
    for (let plugin of this.plugins) {
      await plugin.handleOutgoingEvent(event, data, id);
    }
  }
  listeners = {};
  on(event, callback) {
    if (!this.listeners[event])
      this.listeners[event] = [];
    this.listeners[event].push(callback);
  }
  off(event, callback) {
    if (!this.listeners[event])
      return;
    this.listeners[event].splice(this.listeners[event].indexOf(callback), 1);
  }
  async emit(event, data, id) {
    await this.handleOutgoingEvent(event, data, id);
    if (this.listeners[event]) {
      for (let callback of this.listeners[event]) {
        callback(data);
      }
    }
    if (this.listeners["data"]) {
      for (let callback of this.listeners["data"]) {
        callback({ event, data });
      }
    }
  }
  loopInterval = null;
  startLoop() {
    this.runStarts();
    this.loopInterval = setInterval(() => {
      this.runUpdates();
    }, 1000 / this.frameRate);
  }
  stopLoop() {
    if (this.loopInterval !== null) {
      clearInterval(this.loopInterval);
      this.loopInterval = null;
    }
  }
  constructor(frameRate = 60) {
    this.frameRate = frameRate;
  }
}

// node_modules/colord/plugins/names.mjsisten
class SimuloClientController {
  plugins = [];
  addPlugin(plugin) {
    this.plugins.push(plugin);
  }
  removePlugin(plugin) {
    plugin.destroy();
    this.plugins.splice(this.plugins.indexOf(plugin), 1);
  }
  destroy() {
    for (let plugin of this.plugins) {
      plugin.destroy();
    }
  }
  handleIncomingEvent(event, data) {
    for (let plugin of this.plugins) {
      plugin.handleIncomingEvent(event, data);
    }
  }
  handleOutgoingEvent(event, data) {
    for (let plugin of this.plugins) {
      plugin.handleOutgoingEvent(event, data);
    }
  }
  listeners = {};
  on(event, callback) {
    if (!this.listeners[event])
      this.listeners[event] = [];
    this.listeners[event].push(callback);
  }
  off(event, callback) {
    if (!this.listeners[event])
      return;
    this.listeners[event].splice(this.listeners[event].indexOf(callback), 1);
  }
  emit(event, data) {
    this.handleOutgoingEvent(event, data);
    if (this.listeners[event]) {
      for (let callback of this.listeners[event]) {
        callback(data);
      }
    }
    if (this.listeners["data"]) {
      for (let callback of this.listeners["data"]) {
        callback({ event, data });
      }
    }
  }
}

// node_modules/colord
console.log("test before doing anything");
var server = new SimuloServerController;
var physicsPlugin = new SimuloPhysicsPlugin(server, "rapier");
await physicsPlugin.init();
var physicsSandboxServerPlugin = new SimuloPhysicsSandboxServerPlugin(server, physicsPlugin);
server.addPlugin(physicsPlugin);
server.addPlugin(physicsSandboxServerPlugin);
server.handleIncomingEvent("connect", {
  id: "local"
}, "local");
var client = new SimuloClientController;
var physicsSandboxClientPlugin = new SimuloPhysicsSandboxClientPlugin(client, "pixi");
client.addPlugin(physicsSandboxClientPlugin);
server.on("data", (data) => {
  client.handleIncomingEvent(data.event, data.data);
});
client.on("data", (data) => {
  server.handleIncomingEvent(data.event, data.data, "local");
});
client.handleIncomingEvent("tools", {
  tools: physicsSandboxServerPlugin.getTools(),
  tool: "drag"
});
console.log("Starting...");
server.startLoop();
window.server = server;
window.client = client;
window.switchBackends = async (backend) => {
  server.stopLoop();
  await physicsPlugin.switchBackends(backend);
  console.log("Switched backends");
  server.startLoop();
};

//# debugId=77C1C256EBBA2D8664756e2164756e21
